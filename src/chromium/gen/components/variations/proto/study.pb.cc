// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: study.proto

#include "study.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace variations {
PROTOBUF_CONSTEXPR Study_Experiment_Param::Study_Experiment_Param(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct Study_Experiment_ParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_Experiment_ParamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_Experiment_ParamDefaultTypeInternal() {}
  union {
    Study_Experiment_Param _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_Experiment_ParamDefaultTypeInternal _Study_Experiment_Param_default_instance_;
PROTOBUF_CONSTEXPR Study_Experiment_FeatureAssociation::Study_Experiment_FeatureAssociation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enable_feature_)*/{}
  , /*decltype(_impl_.disable_feature_)*/{}
  , /*decltype(_impl_.forcing_feature_on_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.forcing_feature_off_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct Study_Experiment_FeatureAssociationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_Experiment_FeatureAssociationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_Experiment_FeatureAssociationDefaultTypeInternal() {}
  union {
    Study_Experiment_FeatureAssociation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_Experiment_FeatureAssociationDefaultTypeInternal _Study_Experiment_FeatureAssociation_default_instance_;
PROTOBUF_CONSTEXPR Study_Experiment_OverrideUIString::Study_Experiment_OverrideUIString(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_hash_)*/0u} {}
struct Study_Experiment_OverrideUIStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_Experiment_OverrideUIStringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_Experiment_OverrideUIStringDefaultTypeInternal() {}
  union {
    Study_Experiment_OverrideUIString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_Experiment_OverrideUIStringDefaultTypeInternal _Study_Experiment_OverrideUIString_default_instance_;
PROTOBUF_CONSTEXPR Study_Experiment::Study_Experiment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.param_)*/{}
  , /*decltype(_impl_.override_ui_string_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.forcing_flag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.feature_association_)*/nullptr
  , /*decltype(_impl_.google_web_experiment_id_)*/uint64_t{0u}
  , /*decltype(_impl_.probability_weight_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.google_web_trigger_experiment_id_)*/uint64_t{0u}
  , /*decltype(_impl_.google_app_experiment_id_)*/uint64_t{0u}
  , /*decltype(_impl_.google_web_visibility_)*/0} {}
struct Study_ExperimentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_ExperimentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_ExperimentDefaultTypeInternal() {}
  union {
    Study_Experiment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_ExperimentDefaultTypeInternal _Study_Experiment_default_instance_;
PROTOBUF_CONSTEXPR Study_Filter::Study_Filter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.channel_)*/{}
  , /*decltype(_impl_.platform_)*/{}
  , /*decltype(_impl_.locale_)*/{}
  , /*decltype(_impl_.form_factor_)*/{}
  , /*decltype(_impl_.hardware_class_)*/{}
  , /*decltype(_impl_.exclude_hardware_class_)*/{}
  , /*decltype(_impl_.country_)*/{}
  , /*decltype(_impl_.exclude_country_)*/{}
  , /*decltype(_impl_.exclude_locale_)*/{}
  , /*decltype(_impl_.exclude_form_factor_)*/{}
  , /*decltype(_impl_.cpu_architecture_)*/{}
  , /*decltype(_impl_.exclude_cpu_architecture_)*/{}
  , /*decltype(_impl_.google_group_)*/{}
  , /*decltype(_impl_._google_group_cached_byte_size_)*/{0}
  , /*decltype(_impl_.exclude_google_group_)*/{}
  , /*decltype(_impl_._exclude_google_group_cached_byte_size_)*/{0}
  , /*decltype(_impl_.min_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.max_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.min_os_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.max_os_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_date_)*/int64_t{0}
  , /*decltype(_impl_.end_date_)*/int64_t{0}
  , /*decltype(_impl_.is_low_end_device_)*/false
  , /*decltype(_impl_.is_enterprise_)*/false
  , /*decltype(_impl_.policy_restriction_)*/0} {}
struct Study_FilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_FilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_FilterDefaultTypeInternal() {}
  union {
    Study_Filter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_FilterDefaultTypeInternal _Study_Filter_default_instance_;
PROTOBUF_CONSTEXPR Study::Study(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.experiment_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.default_experiment_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filter_)*/nullptr
  , /*decltype(_impl_.layer_)*/nullptr
  , /*decltype(_impl_.expiry_date_)*/int64_t{0}
  , /*decltype(_impl_.consistency_)*/0
  , /*decltype(_impl_.randomization_seed_)*/0u
  , /*decltype(_impl_.activation_type_)*/0} {}
struct StudyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StudyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StudyDefaultTypeInternal() {}
  union {
    Study _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StudyDefaultTypeInternal _Study_default_instance_;
}  // namespace variations
namespace variations {
bool Study_Experiment_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Experiment_Type_strings[4] = {};

static const char Study_Experiment_Type_names[] =
  "IGNORE_CHANGE"
  "KILL_BEST_EFFORT"
  "KILL_CRITICAL"
  "NORMAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Experiment_Type_entries[] = {
  { {Study_Experiment_Type_names + 0, 13}, 1 },
  { {Study_Experiment_Type_names + 13, 16}, 2 },
  { {Study_Experiment_Type_names + 29, 13}, 3 },
  { {Study_Experiment_Type_names + 42, 6}, 0 },
};

static const int Study_Experiment_Type_entries_by_number[] = {
  3, // 0 -> NORMAL
  0, // 1 -> IGNORE_CHANGE
  1, // 2 -> KILL_BEST_EFFORT
  2, // 3 -> KILL_CRITICAL
};

const std::string& Study_Experiment_Type_Name(
    Study_Experiment_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_Experiment_Type_entries,
          Study_Experiment_Type_entries_by_number,
          4, Study_Experiment_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_Experiment_Type_entries,
      Study_Experiment_Type_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_Experiment_Type_strings[idx].get();
}
bool Study_Experiment_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Experiment_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_Experiment_Type_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Study_Experiment_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Experiment_Type Study_Experiment::NORMAL;
constexpr Study_Experiment_Type Study_Experiment::IGNORE_CHANGE;
constexpr Study_Experiment_Type Study_Experiment::KILL_BEST_EFFORT;
constexpr Study_Experiment_Type Study_Experiment::KILL_CRITICAL;
constexpr Study_Experiment_Type Study_Experiment::Type_MIN;
constexpr Study_Experiment_Type Study_Experiment::Type_MAX;
constexpr int Study_Experiment::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_Consistency_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Consistency_strings[2] = {};

static const char Study_Consistency_names[] =
  "PERMANENT"
  "SESSION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Consistency_entries[] = {
  { {Study_Consistency_names + 0, 9}, 1 },
  { {Study_Consistency_names + 9, 7}, 0 },
};

static const int Study_Consistency_entries_by_number[] = {
  1, // 0 -> SESSION
  0, // 1 -> PERMANENT
};

const std::string& Study_Consistency_Name(
    Study_Consistency value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_Consistency_entries,
          Study_Consistency_entries_by_number,
          2, Study_Consistency_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_Consistency_entries,
      Study_Consistency_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_Consistency_strings[idx].get();
}
bool Study_Consistency_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Consistency* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_Consistency_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Study_Consistency>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Consistency Study::SESSION;
constexpr Study_Consistency Study::PERMANENT;
constexpr Study_Consistency Study::Consistency_MIN;
constexpr Study_Consistency Study::Consistency_MAX;
constexpr int Study::Consistency_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_GoogleWebVisibility_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_GoogleWebVisibility_strings[2] = {};

static const char Study_GoogleWebVisibility_names[] =
  "ANY"
  "FIRST_PARTY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_GoogleWebVisibility_entries[] = {
  { {Study_GoogleWebVisibility_names + 0, 3}, 0 },
  { {Study_GoogleWebVisibility_names + 3, 11}, 1 },
};

static const int Study_GoogleWebVisibility_entries_by_number[] = {
  0, // 0 -> ANY
  1, // 1 -> FIRST_PARTY
};

const std::string& Study_GoogleWebVisibility_Name(
    Study_GoogleWebVisibility value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_GoogleWebVisibility_entries,
          Study_GoogleWebVisibility_entries_by_number,
          2, Study_GoogleWebVisibility_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_GoogleWebVisibility_entries,
      Study_GoogleWebVisibility_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_GoogleWebVisibility_strings[idx].get();
}
bool Study_GoogleWebVisibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_GoogleWebVisibility* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_GoogleWebVisibility_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Study_GoogleWebVisibility>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_GoogleWebVisibility Study::ANY;
constexpr Study_GoogleWebVisibility Study::FIRST_PARTY;
constexpr Study_GoogleWebVisibility Study::GoogleWebVisibility_MIN;
constexpr Study_GoogleWebVisibility Study::GoogleWebVisibility_MAX;
constexpr int Study::GoogleWebVisibility_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_Channel_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Channel_strings[5] = {};

static const char Study_Channel_names[] =
  "BETA"
  "CANARY"
  "DEV"
  "STABLE"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Channel_entries[] = {
  { {Study_Channel_names + 0, 4}, 2 },
  { {Study_Channel_names + 4, 6}, 0 },
  { {Study_Channel_names + 10, 3}, 1 },
  { {Study_Channel_names + 13, 6}, 3 },
  { {Study_Channel_names + 19, 7}, -1 },
};

static const int Study_Channel_entries_by_number[] = {
  4, // -1 -> UNKNOWN
  1, // 0 -> CANARY
  2, // 1 -> DEV
  0, // 2 -> BETA
  3, // 3 -> STABLE
};

const std::string& Study_Channel_Name(
    Study_Channel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_Channel_entries,
          Study_Channel_entries_by_number,
          5, Study_Channel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_Channel_entries,
      Study_Channel_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_Channel_strings[idx].get();
}
bool Study_Channel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Channel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_Channel_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Study_Channel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Channel Study::UNKNOWN;
constexpr Study_Channel Study::CANARY;
constexpr Study_Channel Study::DEV;
constexpr Study_Channel Study::BETA;
constexpr Study_Channel Study::STABLE;
constexpr Study_Channel Study::Channel_MIN;
constexpr Study_Channel Study::Channel_MAX;
constexpr int Study::Channel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_Platform_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Platform_strings[10] = {};

static const char Study_Platform_names[] =
  "PLATFORM_ANDROID"
  "PLATFORM_ANDROID_WEBLAYER"
  "PLATFORM_ANDROID_WEBVIEW"
  "PLATFORM_CHROMEOS"
  "PLATFORM_CHROMEOS_LACROS"
  "PLATFORM_FUCHSIA"
  "PLATFORM_IOS"
  "PLATFORM_LINUX"
  "PLATFORM_MAC"
  "PLATFORM_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Platform_entries[] = {
  { {Study_Platform_names + 0, 16}, 4 },
  { {Study_Platform_names + 16, 25}, 8 },
  { {Study_Platform_names + 41, 24}, 6 },
  { {Study_Platform_names + 65, 17}, 3 },
  { {Study_Platform_names + 82, 24}, 9 },
  { {Study_Platform_names + 106, 16}, 7 },
  { {Study_Platform_names + 122, 12}, 5 },
  { {Study_Platform_names + 134, 14}, 2 },
  { {Study_Platform_names + 148, 12}, 1 },
  { {Study_Platform_names + 160, 16}, 0 },
};

static const int Study_Platform_entries_by_number[] = {
  9, // 0 -> PLATFORM_WINDOWS
  8, // 1 -> PLATFORM_MAC
  7, // 2 -> PLATFORM_LINUX
  3, // 3 -> PLATFORM_CHROMEOS
  0, // 4 -> PLATFORM_ANDROID
  6, // 5 -> PLATFORM_IOS
  2, // 6 -> PLATFORM_ANDROID_WEBVIEW
  5, // 7 -> PLATFORM_FUCHSIA
  1, // 8 -> PLATFORM_ANDROID_WEBLAYER
  4, // 9 -> PLATFORM_CHROMEOS_LACROS
};

const std::string& Study_Platform_Name(
    Study_Platform value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_Platform_entries,
          Study_Platform_entries_by_number,
          10, Study_Platform_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_Platform_entries,
      Study_Platform_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_Platform_strings[idx].get();
}
bool Study_Platform_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Platform* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_Platform_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<Study_Platform>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Platform Study::PLATFORM_WINDOWS;
constexpr Study_Platform Study::PLATFORM_MAC;
constexpr Study_Platform Study::PLATFORM_LINUX;
constexpr Study_Platform Study::PLATFORM_CHROMEOS;
constexpr Study_Platform Study::PLATFORM_ANDROID;
constexpr Study_Platform Study::PLATFORM_IOS;
constexpr Study_Platform Study::PLATFORM_ANDROID_WEBVIEW;
constexpr Study_Platform Study::PLATFORM_FUCHSIA;
constexpr Study_Platform Study::PLATFORM_ANDROID_WEBLAYER;
constexpr Study_Platform Study::PLATFORM_CHROMEOS_LACROS;
constexpr Study_Platform Study::Platform_MIN;
constexpr Study_Platform Study::Platform_MAX;
constexpr int Study::Platform_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_FormFactor_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_FormFactor_strings[8] = {};

static const char Study_FormFactor_names[] =
  "AUTOMOTIVE"
  "DESKTOP"
  "FOLDABLE"
  "KIOSK"
  "MEET_DEVICE"
  "PHONE"
  "TABLET"
  "TV";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_FormFactor_entries[] = {
  { {Study_FormFactor_names + 0, 10}, 6 },
  { {Study_FormFactor_names + 10, 7}, 0 },
  { {Study_FormFactor_names + 17, 8}, 7 },
  { {Study_FormFactor_names + 25, 5}, 3 },
  { {Study_FormFactor_names + 30, 11}, 4 },
  { {Study_FormFactor_names + 41, 5}, 1 },
  { {Study_FormFactor_names + 46, 6}, 2 },
  { {Study_FormFactor_names + 52, 2}, 5 },
};

static const int Study_FormFactor_entries_by_number[] = {
  1, // 0 -> DESKTOP
  5, // 1 -> PHONE
  6, // 2 -> TABLET
  3, // 3 -> KIOSK
  4, // 4 -> MEET_DEVICE
  7, // 5 -> TV
  0, // 6 -> AUTOMOTIVE
  2, // 7 -> FOLDABLE
};

const std::string& Study_FormFactor_Name(
    Study_FormFactor value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_FormFactor_entries,
          Study_FormFactor_entries_by_number,
          8, Study_FormFactor_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_FormFactor_entries,
      Study_FormFactor_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_FormFactor_strings[idx].get();
}
bool Study_FormFactor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_FormFactor* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_FormFactor_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<Study_FormFactor>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_FormFactor Study::DESKTOP;
constexpr Study_FormFactor Study::PHONE;
constexpr Study_FormFactor Study::TABLET;
constexpr Study_FormFactor Study::KIOSK;
constexpr Study_FormFactor Study::MEET_DEVICE;
constexpr Study_FormFactor Study::TV;
constexpr Study_FormFactor Study::AUTOMOTIVE;
constexpr Study_FormFactor Study::FOLDABLE;
constexpr Study_FormFactor Study::FormFactor_MIN;
constexpr Study_FormFactor Study::FormFactor_MAX;
constexpr int Study::FormFactor_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_CpuArchitecture_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_CpuArchitecture_strings[5] = {};

static const char Study_CpuArchitecture_names[] =
  "ARM32"
  "ARM64"
  "TRANSLATED_X86_64"
  "X86_32"
  "X86_64";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_CpuArchitecture_entries[] = {
  { {Study_CpuArchitecture_names + 0, 5}, 3 },
  { {Study_CpuArchitecture_names + 5, 5}, 1 },
  { {Study_CpuArchitecture_names + 10, 17}, 4 },
  { {Study_CpuArchitecture_names + 27, 6}, 2 },
  { {Study_CpuArchitecture_names + 33, 6}, 0 },
};

static const int Study_CpuArchitecture_entries_by_number[] = {
  4, // 0 -> X86_64
  1, // 1 -> ARM64
  3, // 2 -> X86_32
  0, // 3 -> ARM32
  2, // 4 -> TRANSLATED_X86_64
};

const std::string& Study_CpuArchitecture_Name(
    Study_CpuArchitecture value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_CpuArchitecture_entries,
          Study_CpuArchitecture_entries_by_number,
          5, Study_CpuArchitecture_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_CpuArchitecture_entries,
      Study_CpuArchitecture_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_CpuArchitecture_strings[idx].get();
}
bool Study_CpuArchitecture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_CpuArchitecture* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_CpuArchitecture_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Study_CpuArchitecture>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_CpuArchitecture Study::X86_64;
constexpr Study_CpuArchitecture Study::ARM64;
constexpr Study_CpuArchitecture Study::X86_32;
constexpr Study_CpuArchitecture Study::ARM32;
constexpr Study_CpuArchitecture Study::TRANSLATED_X86_64;
constexpr Study_CpuArchitecture Study::CpuArchitecture_MIN;
constexpr Study_CpuArchitecture Study::CpuArchitecture_MAX;
constexpr int Study::CpuArchitecture_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_OptionalBool_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_OptionalBool_strings[3] = {};

static const char Study_OptionalBool_names[] =
  "OPTIONAL_BOOL_FALSE"
  "OPTIONAL_BOOL_MISSING"
  "OPTIONAL_BOOL_TRUE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_OptionalBool_entries[] = {
  { {Study_OptionalBool_names + 0, 19}, 2 },
  { {Study_OptionalBool_names + 19, 21}, 0 },
  { {Study_OptionalBool_names + 40, 18}, 1 },
};

static const int Study_OptionalBool_entries_by_number[] = {
  1, // 0 -> OPTIONAL_BOOL_MISSING
  2, // 1 -> OPTIONAL_BOOL_TRUE
  0, // 2 -> OPTIONAL_BOOL_FALSE
};

const std::string& Study_OptionalBool_Name(
    Study_OptionalBool value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_OptionalBool_entries,
          Study_OptionalBool_entries_by_number,
          3, Study_OptionalBool_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_OptionalBool_entries,
      Study_OptionalBool_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_OptionalBool_strings[idx].get();
}
bool Study_OptionalBool_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_OptionalBool* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_OptionalBool_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Study_OptionalBool>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_OptionalBool Study::OPTIONAL_BOOL_MISSING;
constexpr Study_OptionalBool Study::OPTIONAL_BOOL_TRUE;
constexpr Study_OptionalBool Study::OPTIONAL_BOOL_FALSE;
constexpr Study_OptionalBool Study::OptionalBool_MIN;
constexpr Study_OptionalBool Study::OptionalBool_MAX;
constexpr int Study::OptionalBool_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_PolicyRestriction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_PolicyRestriction_strings[3] = {};

static const char Study_PolicyRestriction_names[] =
  "CRITICAL"
  "CRITICAL_ONLY"
  "NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_PolicyRestriction_entries[] = {
  { {Study_PolicyRestriction_names + 0, 8}, 1 },
  { {Study_PolicyRestriction_names + 8, 13}, 2 },
  { {Study_PolicyRestriction_names + 21, 4}, 0 },
};

static const int Study_PolicyRestriction_entries_by_number[] = {
  2, // 0 -> NONE
  0, // 1 -> CRITICAL
  1, // 2 -> CRITICAL_ONLY
};

const std::string& Study_PolicyRestriction_Name(
    Study_PolicyRestriction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_PolicyRestriction_entries,
          Study_PolicyRestriction_entries_by_number,
          3, Study_PolicyRestriction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_PolicyRestriction_entries,
      Study_PolicyRestriction_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_PolicyRestriction_strings[idx].get();
}
bool Study_PolicyRestriction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_PolicyRestriction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_PolicyRestriction_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Study_PolicyRestriction>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_PolicyRestriction Study::NONE;
constexpr Study_PolicyRestriction Study::CRITICAL;
constexpr Study_PolicyRestriction Study::CRITICAL_ONLY;
constexpr Study_PolicyRestriction Study::PolicyRestriction_MIN;
constexpr Study_PolicyRestriction Study::PolicyRestriction_MAX;
constexpr int Study::PolicyRestriction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_ActivationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_ActivationType_strings[2] = {};

static const char Study_ActivationType_names[] =
  "ACTIVATE_ON_QUERY"
  "ACTIVATE_ON_STARTUP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_ActivationType_entries[] = {
  { {Study_ActivationType_names + 0, 17}, 0 },
  { {Study_ActivationType_names + 17, 19}, 1 },
};

static const int Study_ActivationType_entries_by_number[] = {
  0, // 0 -> ACTIVATE_ON_QUERY
  1, // 1 -> ACTIVATE_ON_STARTUP
};

const std::string& Study_ActivationType_Name(
    Study_ActivationType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_ActivationType_entries,
          Study_ActivationType_entries_by_number,
          2, Study_ActivationType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_ActivationType_entries,
      Study_ActivationType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_ActivationType_strings[idx].get();
}
bool Study_ActivationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_ActivationType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_ActivationType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Study_ActivationType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_ActivationType Study::ACTIVATE_ON_QUERY;
constexpr Study_ActivationType Study::ACTIVATE_ON_STARTUP;
constexpr Study_ActivationType Study::ActivationType_MIN;
constexpr Study_ActivationType Study::ActivationType_MAX;
constexpr int Study::ActivationType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Study_Experiment_Param::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Experiment_Param>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Study_Experiment_Param::Study_Experiment_Param(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment.Param)
}
Study_Experiment_Param::Study_Experiment_Param(const Study_Experiment_Param& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Study_Experiment_Param* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment.Param)
}

inline void Study_Experiment_Param::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment_Param::~Study_Experiment_Param() {
  // @@protoc_insertion_point(destructor:variations.Study.Experiment.Param)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Experiment_Param::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void Study_Experiment_Param::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Study_Experiment_Param::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Experiment.Param)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment_Param::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment_Param::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment.Param)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment.Param)
  return target;
}

size_t Study_Experiment_Param::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment.Param)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Experiment_Param::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Experiment_Param*>(
      &from));
}

void Study_Experiment_Param::MergeFrom(const Study_Experiment_Param& from) {
  Study_Experiment_Param* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment.Param)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment_Param::CopyFrom(const Study_Experiment_Param& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment.Param)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Experiment_Param::IsInitialized() const {
  return true;
}

void Study_Experiment_Param::InternalSwap(Study_Experiment_Param* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string Study_Experiment_Param::GetTypeName() const {
  return "variations.Study.Experiment.Param";
}


// ===================================================================

class Study_Experiment_FeatureAssociation::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Experiment_FeatureAssociation>()._impl_._has_bits_);
  static void set_has_forcing_feature_on(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_forcing_feature_off(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Study_Experiment_FeatureAssociation::Study_Experiment_FeatureAssociation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment.FeatureAssociation)
}
Study_Experiment_FeatureAssociation::Study_Experiment_FeatureAssociation(const Study_Experiment_FeatureAssociation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Study_Experiment_FeatureAssociation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_feature_){from._impl_.enable_feature_}
    , decltype(_impl_.disable_feature_){from._impl_.disable_feature_}
    , decltype(_impl_.forcing_feature_on_){}
    , decltype(_impl_.forcing_feature_off_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.forcing_feature_on_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_feature_on_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_forcing_feature_on()) {
    _this->_impl_.forcing_feature_on_.Set(from._internal_forcing_feature_on(), 
      _this->GetArenaForAllocation());
  }
  _impl_.forcing_feature_off_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_feature_off_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_forcing_feature_off()) {
    _this->_impl_.forcing_feature_off_.Set(from._internal_forcing_feature_off(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment.FeatureAssociation)
}

inline void Study_Experiment_FeatureAssociation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enable_feature_){arena}
    , decltype(_impl_.disable_feature_){arena}
    , decltype(_impl_.forcing_feature_on_){}
    , decltype(_impl_.forcing_feature_off_){}
  };
  _impl_.forcing_feature_on_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_feature_on_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.forcing_feature_off_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_feature_off_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment_FeatureAssociation::~Study_Experiment_FeatureAssociation() {
  // @@protoc_insertion_point(destructor:variations.Study.Experiment.FeatureAssociation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Experiment_FeatureAssociation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.enable_feature_.~RepeatedPtrField();
  _impl_.disable_feature_.~RepeatedPtrField();
  _impl_.forcing_feature_on_.Destroy();
  _impl_.forcing_feature_off_.Destroy();
}

void Study_Experiment_FeatureAssociation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Study_Experiment_FeatureAssociation::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Experiment.FeatureAssociation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enable_feature_.Clear();
  _impl_.disable_feature_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.forcing_feature_on_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.forcing_feature_off_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment_FeatureAssociation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string enable_feature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_enable_feature();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string disable_feature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_disable_feature();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string forcing_feature_on = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_forcing_feature_on();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string forcing_feature_off = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_forcing_feature_off();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment_FeatureAssociation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment.FeatureAssociation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string enable_feature = 1;
  for (int i = 0, n = this->_internal_enable_feature_size(); i < n; i++) {
    const auto& s = this->_internal_enable_feature(i);
    target = stream->WriteString(1, s, target);
  }

  // repeated string disable_feature = 2;
  for (int i = 0, n = this->_internal_disable_feature_size(); i < n; i++) {
    const auto& s = this->_internal_disable_feature(i);
    target = stream->WriteString(2, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string forcing_feature_on = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_forcing_feature_on(), target);
  }

  // optional string forcing_feature_off = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_forcing_feature_off(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment.FeatureAssociation)
  return target;
}

size_t Study_Experiment_FeatureAssociation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment.FeatureAssociation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string enable_feature = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.enable_feature_.size());
  for (int i = 0, n = _impl_.enable_feature_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.enable_feature_.Get(i));
  }

  // repeated string disable_feature = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.disable_feature_.size());
  for (int i = 0, n = _impl_.disable_feature_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.disable_feature_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string forcing_feature_on = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_forcing_feature_on());
    }

    // optional string forcing_feature_off = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_forcing_feature_off());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Experiment_FeatureAssociation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Experiment_FeatureAssociation*>(
      &from));
}

void Study_Experiment_FeatureAssociation::MergeFrom(const Study_Experiment_FeatureAssociation& from) {
  Study_Experiment_FeatureAssociation* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment.FeatureAssociation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.enable_feature_.MergeFrom(from._impl_.enable_feature_);
  _this->_impl_.disable_feature_.MergeFrom(from._impl_.disable_feature_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_forcing_feature_on(from._internal_forcing_feature_on());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_forcing_feature_off(from._internal_forcing_feature_off());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment_FeatureAssociation::CopyFrom(const Study_Experiment_FeatureAssociation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment.FeatureAssociation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Experiment_FeatureAssociation::IsInitialized() const {
  return true;
}

void Study_Experiment_FeatureAssociation::InternalSwap(Study_Experiment_FeatureAssociation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.enable_feature_.InternalSwap(&other->_impl_.enable_feature_);
  _impl_.disable_feature_.InternalSwap(&other->_impl_.disable_feature_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.forcing_feature_on_, lhs_arena,
      &other->_impl_.forcing_feature_on_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.forcing_feature_off_, lhs_arena,
      &other->_impl_.forcing_feature_off_, rhs_arena
  );
}

std::string Study_Experiment_FeatureAssociation::GetTypeName() const {
  return "variations.Study.Experiment.FeatureAssociation";
}


// ===================================================================

class Study_Experiment_OverrideUIString::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Experiment_OverrideUIString>()._impl_._has_bits_);
  static void set_has_name_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Study_Experiment_OverrideUIString::Study_Experiment_OverrideUIString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment.OverrideUIString)
}
Study_Experiment_OverrideUIString::Study_Experiment_OverrideUIString(const Study_Experiment_OverrideUIString& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Study_Experiment_OverrideUIString* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.name_hash_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.name_hash_ = from._impl_.name_hash_;
  // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment.OverrideUIString)
}

inline void Study_Experiment_OverrideUIString::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.name_hash_){0u}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment_OverrideUIString::~Study_Experiment_OverrideUIString() {
  // @@protoc_insertion_point(destructor:variations.Study.Experiment.OverrideUIString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Experiment_OverrideUIString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
}

void Study_Experiment_OverrideUIString::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Study_Experiment_OverrideUIString::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Experiment.OverrideUIString)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.value_.ClearNonDefaultToEmpty();
  }
  _impl_.name_hash_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment_OverrideUIString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 name_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_name_hash(&has_bits);
          _impl_.name_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment_OverrideUIString::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment.OverrideUIString)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 name_hash = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_name_hash(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment.OverrideUIString)
  return target;
}

size_t Study_Experiment_OverrideUIString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment.OverrideUIString)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional fixed32 name_hash = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Experiment_OverrideUIString::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Experiment_OverrideUIString*>(
      &from));
}

void Study_Experiment_OverrideUIString::MergeFrom(const Study_Experiment_OverrideUIString& from) {
  Study_Experiment_OverrideUIString* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment.OverrideUIString)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.name_hash_ = from._impl_.name_hash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment_OverrideUIString::CopyFrom(const Study_Experiment_OverrideUIString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment.OverrideUIString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Experiment_OverrideUIString::IsInitialized() const {
  return true;
}

void Study_Experiment_OverrideUIString::InternalSwap(Study_Experiment_OverrideUIString* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  swap(_impl_.name_hash_, other->_impl_.name_hash_);
}

std::string Study_Experiment_OverrideUIString::GetTypeName() const {
  return "variations.Study.Experiment.OverrideUIString";
}


// ===================================================================

class Study_Experiment::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Experiment>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_probability_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_google_web_experiment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_google_web_trigger_experiment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_google_web_visibility(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_google_app_experiment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::variations::Study_Experiment_FeatureAssociation& feature_association(const Study_Experiment* msg);
  static void set_has_feature_association(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_forcing_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000011) ^ 0x00000011) != 0;
  }
};

const ::variations::Study_Experiment_FeatureAssociation&
Study_Experiment::_Internal::feature_association(const Study_Experiment* msg) {
  return *msg->_impl_.feature_association_;
}
Study_Experiment::Study_Experiment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment)
}
Study_Experiment::Study_Experiment(const Study_Experiment& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Study_Experiment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.param_){from._impl_.param_}
    , decltype(_impl_.override_ui_string_){from._impl_.override_ui_string_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.forcing_flag_){}
    , decltype(_impl_.feature_association_){nullptr}
    , decltype(_impl_.google_web_experiment_id_){}
    , decltype(_impl_.probability_weight_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.google_web_trigger_experiment_id_){}
    , decltype(_impl_.google_app_experiment_id_){}
    , decltype(_impl_.google_web_visibility_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.forcing_flag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_flag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_forcing_flag()) {
    _this->_impl_.forcing_flag_.Set(from._internal_forcing_flag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_feature_association()) {
    _this->_impl_.feature_association_ = new ::variations::Study_Experiment_FeatureAssociation(*from._impl_.feature_association_);
  }
  ::memcpy(&_impl_.google_web_experiment_id_, &from._impl_.google_web_experiment_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.google_web_visibility_) -
    reinterpret_cast<char*>(&_impl_.google_web_experiment_id_)) + sizeof(_impl_.google_web_visibility_));
  // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment)
}

inline void Study_Experiment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.param_){arena}
    , decltype(_impl_.override_ui_string_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.forcing_flag_){}
    , decltype(_impl_.feature_association_){nullptr}
    , decltype(_impl_.google_web_experiment_id_){uint64_t{0u}}
    , decltype(_impl_.probability_weight_){0u}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.google_web_trigger_experiment_id_){uint64_t{0u}}
    , decltype(_impl_.google_app_experiment_id_){uint64_t{0u}}
    , decltype(_impl_.google_web_visibility_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.forcing_flag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_flag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment::~Study_Experiment() {
  // @@protoc_insertion_point(destructor:variations.Study.Experiment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Experiment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.param_.~RepeatedPtrField();
  _impl_.override_ui_string_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.forcing_flag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.feature_association_;
}

void Study_Experiment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Study_Experiment::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Experiment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.param_.Clear();
  _impl_.override_ui_string_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.forcing_flag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.feature_association_ != nullptr);
      _impl_.feature_association_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.google_web_experiment_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.google_app_experiment_id_) -
        reinterpret_cast<char*>(&_impl_.google_web_experiment_id_)) + sizeof(_impl_.google_app_experiment_id_));
  }
  _impl_.google_web_visibility_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 probability_weight = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_probability_weight(&has_bits);
          _impl_.probability_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 google_web_experiment_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_google_web_experiment_id(&has_bits);
          _impl_.google_web_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string forcing_flag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_forcing_flag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Experiment.Param param = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_param(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_Experiment_Type_IsValid(val))) {
            _internal_set_type(static_cast<::variations::Study_Experiment_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 google_web_trigger_experiment_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_google_web_trigger_experiment_id(&has_bits);
          _impl_.google_web_trigger_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_override_ui_string(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_feature_association(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 google_app_experiment_id = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_google_app_experiment_id(&has_bits);
          _impl_.google_app_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_GoogleWebVisibility_IsValid(val))) {
            _internal_set_google_web_visibility(static_cast<::variations::Study_GoogleWebVisibility>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required uint32 probability_weight = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_probability_weight(), target);
  }

  // optional uint64 google_web_experiment_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_google_web_experiment_id(), target);
  }

  // optional string forcing_flag = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_forcing_flag(), target);
  }

  // repeated .variations.Study.Experiment.Param param = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_param_size()); i < n; i++) {
    const auto& repfield = this->_internal_param(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_type(), target);
  }

  // optional uint64 google_web_trigger_experiment_id = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_google_web_trigger_experiment_id(), target);
  }

  // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_override_ui_string_size()); i < n; i++) {
    const auto& repfield = this->_internal_override_ui_string(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::feature_association(this),
        _Internal::feature_association(this).GetCachedSize(), target, stream);
  }

  // optional uint64 google_app_experiment_id = 15;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(15, this->_internal_google_app_experiment_id(), target);
  }

  // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_google_web_visibility(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment)
  return target;
}

size_t Study_Experiment::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:variations.Study.Experiment)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_probability_weight()) {
    // required uint32 probability_weight = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_probability_weight());
  }

  return total_size;
}
size_t Study_Experiment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000011) ^ 0x00000011) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required uint32 probability_weight = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_probability_weight());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .variations.Study.Experiment.Param param = 6;
  total_size += 1UL * this->_internal_param_size();
  for (const auto& msg : this->_impl_.param_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
  total_size += 1UL * this->_internal_override_ui_string_size();
  for (const auto& msg : this->_impl_.override_ui_string_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional string forcing_flag = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_forcing_flag());
    }

    // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.feature_association_);
    }

    // optional uint64 google_web_experiment_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_google_web_experiment_id());
    }

  }
  if (cached_has_bits & 0x000000e0u) {
    // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional uint64 google_web_trigger_experiment_id = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_google_web_trigger_experiment_id());
    }

    // optional uint64 google_app_experiment_id = 15;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_google_app_experiment_id());
    }

  }
  // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_google_web_visibility());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Experiment::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Experiment*>(
      &from));
}

void Study_Experiment::MergeFrom(const Study_Experiment& from) {
  Study_Experiment* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.param_.MergeFrom(from._impl_.param_);
  _this->_impl_.override_ui_string_.MergeFrom(from._impl_.override_ui_string_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_forcing_flag(from._internal_forcing_flag());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_feature_association()->::variations::Study_Experiment_FeatureAssociation::MergeFrom(
          from._internal_feature_association());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.google_web_experiment_id_ = from._impl_.google_web_experiment_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.probability_weight_ = from._impl_.probability_weight_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.google_web_trigger_experiment_id_ = from._impl_.google_web_trigger_experiment_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.google_app_experiment_id_ = from._impl_.google_app_experiment_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_google_web_visibility(from._internal_google_web_visibility());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment::CopyFrom(const Study_Experiment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Experiment::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Study_Experiment::InternalSwap(Study_Experiment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.param_.InternalSwap(&other->_impl_.param_);
  _impl_.override_ui_string_.InternalSwap(&other->_impl_.override_ui_string_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.forcing_flag_, lhs_arena,
      &other->_impl_.forcing_flag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Study_Experiment, _impl_.google_web_visibility_)
      + sizeof(Study_Experiment::_impl_.google_web_visibility_)
      - PROTOBUF_FIELD_OFFSET(Study_Experiment, _impl_.feature_association_)>(
          reinterpret_cast<char*>(&_impl_.feature_association_),
          reinterpret_cast<char*>(&other->_impl_.feature_association_));
}

std::string Study_Experiment::GetTypeName() const {
  return "variations.Study.Experiment";
}


// ===================================================================

class Study_Filter::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Filter>()._impl_._has_bits_);
  static void set_has_start_date(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_end_date(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_min_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_low_end_device(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_enterprise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_policy_restriction(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

Study_Filter::Study_Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:variations.Study.Filter)
}
Study_Filter::Study_Filter(const Study_Filter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Study_Filter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.channel_){from._impl_.channel_}
    , decltype(_impl_.platform_){from._impl_.platform_}
    , decltype(_impl_.locale_){from._impl_.locale_}
    , decltype(_impl_.form_factor_){from._impl_.form_factor_}
    , decltype(_impl_.hardware_class_){from._impl_.hardware_class_}
    , decltype(_impl_.exclude_hardware_class_){from._impl_.exclude_hardware_class_}
    , decltype(_impl_.country_){from._impl_.country_}
    , decltype(_impl_.exclude_country_){from._impl_.exclude_country_}
    , decltype(_impl_.exclude_locale_){from._impl_.exclude_locale_}
    , decltype(_impl_.exclude_form_factor_){from._impl_.exclude_form_factor_}
    , decltype(_impl_.cpu_architecture_){from._impl_.cpu_architecture_}
    , decltype(_impl_.exclude_cpu_architecture_){from._impl_.exclude_cpu_architecture_}
    , decltype(_impl_.google_group_){from._impl_.google_group_}
    , /*decltype(_impl_._google_group_cached_byte_size_)*/{0}
    , decltype(_impl_.exclude_google_group_){from._impl_.exclude_google_group_}
    , /*decltype(_impl_._exclude_google_group_cached_byte_size_)*/{0}
    , decltype(_impl_.min_version_){}
    , decltype(_impl_.max_version_){}
    , decltype(_impl_.min_os_version_){}
    , decltype(_impl_.max_os_version_){}
    , decltype(_impl_.start_date_){}
    , decltype(_impl_.end_date_){}
    , decltype(_impl_.is_low_end_device_){}
    , decltype(_impl_.is_enterprise_){}
    , decltype(_impl_.policy_restriction_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.min_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.min_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_min_version()) {
    _this->_impl_.min_version_.Set(from._internal_min_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.max_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_max_version()) {
    _this->_impl_.max_version_.Set(from._internal_max_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.min_os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.min_os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_min_os_version()) {
    _this->_impl_.min_os_version_.Set(from._internal_min_os_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.max_os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_max_os_version()) {
    _this->_impl_.max_os_version_.Set(from._internal_max_os_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.start_date_, &from._impl_.start_date_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.policy_restriction_) -
    reinterpret_cast<char*>(&_impl_.start_date_)) + sizeof(_impl_.policy_restriction_));
  // @@protoc_insertion_point(copy_constructor:variations.Study.Filter)
}

inline void Study_Filter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.channel_){arena}
    , decltype(_impl_.platform_){arena}
    , decltype(_impl_.locale_){arena}
    , decltype(_impl_.form_factor_){arena}
    , decltype(_impl_.hardware_class_){arena}
    , decltype(_impl_.exclude_hardware_class_){arena}
    , decltype(_impl_.country_){arena}
    , decltype(_impl_.exclude_country_){arena}
    , decltype(_impl_.exclude_locale_){arena}
    , decltype(_impl_.exclude_form_factor_){arena}
    , decltype(_impl_.cpu_architecture_){arena}
    , decltype(_impl_.exclude_cpu_architecture_){arena}
    , decltype(_impl_.google_group_){arena}
    , /*decltype(_impl_._google_group_cached_byte_size_)*/{0}
    , decltype(_impl_.exclude_google_group_){arena}
    , /*decltype(_impl_._exclude_google_group_cached_byte_size_)*/{0}
    , decltype(_impl_.min_version_){}
    , decltype(_impl_.max_version_){}
    , decltype(_impl_.min_os_version_){}
    , decltype(_impl_.max_os_version_){}
    , decltype(_impl_.start_date_){int64_t{0}}
    , decltype(_impl_.end_date_){int64_t{0}}
    , decltype(_impl_.is_low_end_device_){false}
    , decltype(_impl_.is_enterprise_){false}
    , decltype(_impl_.policy_restriction_){0}
  };
  _impl_.min_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.min_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.max_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.min_os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.min_os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.max_os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Filter::~Study_Filter() {
  // @@protoc_insertion_point(destructor:variations.Study.Filter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Filter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.channel_.~RepeatedField();
  _impl_.platform_.~RepeatedField();
  _impl_.locale_.~RepeatedPtrField();
  _impl_.form_factor_.~RepeatedField();
  _impl_.hardware_class_.~RepeatedPtrField();
  _impl_.exclude_hardware_class_.~RepeatedPtrField();
  _impl_.country_.~RepeatedPtrField();
  _impl_.exclude_country_.~RepeatedPtrField();
  _impl_.exclude_locale_.~RepeatedPtrField();
  _impl_.exclude_form_factor_.~RepeatedField();
  _impl_.cpu_architecture_.~RepeatedField();
  _impl_.exclude_cpu_architecture_.~RepeatedField();
  _impl_.google_group_.~RepeatedField();
  _impl_.exclude_google_group_.~RepeatedField();
  _impl_.min_version_.Destroy();
  _impl_.max_version_.Destroy();
  _impl_.min_os_version_.Destroy();
  _impl_.max_os_version_.Destroy();
}

void Study_Filter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Study_Filter::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Filter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.channel_.Clear();
  _impl_.platform_.Clear();
  _impl_.locale_.Clear();
  _impl_.form_factor_.Clear();
  _impl_.hardware_class_.Clear();
  _impl_.exclude_hardware_class_.Clear();
  _impl_.country_.Clear();
  _impl_.exclude_country_.Clear();
  _impl_.exclude_locale_.Clear();
  _impl_.exclude_form_factor_.Clear();
  _impl_.cpu_architecture_.Clear();
  _impl_.exclude_cpu_architecture_.Clear();
  _impl_.google_group_.Clear();
  _impl_.exclude_google_group_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.min_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.max_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.min_os_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.max_os_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.start_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_enterprise_) -
        reinterpret_cast<char*>(&_impl_.start_date_)) + sizeof(_impl_.is_enterprise_));
  }
  _impl_.policy_restriction_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Filter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 start_date = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_start_date(&has_bits);
          _impl_.start_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string min_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_min_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string max_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_max_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Channel channel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_Channel_IsValid(val))) {
              _internal_add_channel(static_cast<::variations::Study_Channel>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_channel(), ptr, ctx, ::variations::Study_Channel_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Platform platform = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_Platform_IsValid(val))) {
              _internal_add_platform(static_cast<::variations::Study_Platform>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_platform(), ptr, ctx, ::variations::Study_Platform_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string locale = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_locale();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.FormFactor form_factor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_FormFactor_IsValid(val))) {
              _internal_add_form_factor(static_cast<::variations::Study_FormFactor>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_form_factor(), ptr, ctx, ::variations::Study_FormFactor_IsValid, &_internal_metadata_, 7);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string hardware_class = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hardware_class();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string exclude_hardware_class = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_exclude_hardware_class();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string country = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_country();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string exclude_country = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_exclude_country();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string exclude_locale = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_exclude_locale();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 end_date = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_end_date(&has_bits);
          _impl_.end_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.FormFactor exclude_form_factor = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_FormFactor_IsValid(val))) {
              _internal_add_exclude_form_factor(static_cast<::variations::Study_FormFactor>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<112>(ptr));
        } else if (static_cast<uint8_t>(tag) == 114) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_exclude_form_factor(), ptr, ctx, ::variations::Study_FormFactor_IsValid, &_internal_metadata_, 14);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_low_end_device = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_is_low_end_device(&has_bits);
          _impl_.is_low_end_device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string min_os_version = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_min_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string max_os_version = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_max_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enterprise = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_is_enterprise(&has_bits);
          _impl_.is_enterprise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_PolicyRestriction_IsValid(val))) {
            _internal_set_policy_restriction(static_cast<::variations::Study_PolicyRestriction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_CpuArchitecture_IsValid(val))) {
              _internal_add_cpu_architecture(static_cast<::variations::Study_CpuArchitecture>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<160>(ptr));
        } else if (static_cast<uint8_t>(tag) == 162) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_cpu_architecture(), ptr, ctx, ::variations::Study_CpuArchitecture_IsValid, &_internal_metadata_, 20);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_CpuArchitecture_IsValid(val))) {
              _internal_add_exclude_cpu_architecture(static_cast<::variations::Study_CpuArchitecture>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(21, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<168>(ptr));
        } else if (static_cast<uint8_t>(tag) == 170) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_exclude_cpu_architecture(), ptr, ctx, ::variations::Study_CpuArchitecture_IsValid, &_internal_metadata_, 21);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 google_group = 22 [packed = true];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_google_group(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 176) {
          _internal_add_google_group(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 exclude_google_group = 23 [packed = true];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_exclude_google_group(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 184) {
          _internal_add_exclude_google_group(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Filter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Filter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 start_date = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_start_date(), target);
  }

  // optional string min_version = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_min_version(), target);
  }

  // optional string max_version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_max_version(), target);
  }

  // repeated .variations.Study.Channel channel = 4;
  for (int i = 0, n = this->_internal_channel_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_channel(i), target);
  }

  // repeated .variations.Study.Platform platform = 5;
  for (int i = 0, n = this->_internal_platform_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_platform(i), target);
  }

  // repeated string locale = 6;
  for (int i = 0, n = this->_internal_locale_size(); i < n; i++) {
    const auto& s = this->_internal_locale(i);
    target = stream->WriteString(6, s, target);
  }

  // repeated .variations.Study.FormFactor form_factor = 7;
  for (int i = 0, n = this->_internal_form_factor_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_form_factor(i), target);
  }

  // repeated string hardware_class = 8;
  for (int i = 0, n = this->_internal_hardware_class_size(); i < n; i++) {
    const auto& s = this->_internal_hardware_class(i);
    target = stream->WriteString(8, s, target);
  }

  // repeated string exclude_hardware_class = 9;
  for (int i = 0, n = this->_internal_exclude_hardware_class_size(); i < n; i++) {
    const auto& s = this->_internal_exclude_hardware_class(i);
    target = stream->WriteString(9, s, target);
  }

  // repeated string country = 10;
  for (int i = 0, n = this->_internal_country_size(); i < n; i++) {
    const auto& s = this->_internal_country(i);
    target = stream->WriteString(10, s, target);
  }

  // repeated string exclude_country = 11;
  for (int i = 0, n = this->_internal_exclude_country_size(); i < n; i++) {
    const auto& s = this->_internal_exclude_country(i);
    target = stream->WriteString(11, s, target);
  }

  // repeated string exclude_locale = 12;
  for (int i = 0, n = this->_internal_exclude_locale_size(); i < n; i++) {
    const auto& s = this->_internal_exclude_locale(i);
    target = stream->WriteString(12, s, target);
  }

  // optional int64 end_date = 13;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_end_date(), target);
  }

  // repeated .variations.Study.FormFactor exclude_form_factor = 14;
  for (int i = 0, n = this->_internal_exclude_form_factor_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        14, this->_internal_exclude_form_factor(i), target);
  }

  // optional bool is_low_end_device = 15;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_is_low_end_device(), target);
  }

  // optional string min_os_version = 16;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_min_os_version(), target);
  }

  // optional string max_os_version = 17;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_max_os_version(), target);
  }

  // optional bool is_enterprise = 18;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_is_enterprise(), target);
  }

  // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_policy_restriction(), target);
  }

  // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
  for (int i = 0, n = this->_internal_cpu_architecture_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        20, this->_internal_cpu_architecture(i), target);
  }

  // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
  for (int i = 0, n = this->_internal_exclude_cpu_architecture_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        21, this->_internal_exclude_cpu_architecture(i), target);
  }

  // repeated int64 google_group = 22 [packed = true];
  {
    int byte_size = _impl_._google_group_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          22, _internal_google_group(), byte_size, target);
    }
  }

  // repeated int64 exclude_google_group = 23 [packed = true];
  {
    int byte_size = _impl_._exclude_google_group_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          23, _internal_exclude_google_group(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Filter)
  return target;
}

size_t Study_Filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Filter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .variations.Study.Channel channel = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_channel_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_channel(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .variations.Study.Platform platform = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_platform_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_platform(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated string locale = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.locale_.size());
  for (int i = 0, n = _impl_.locale_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.locale_.Get(i));
  }

  // repeated .variations.Study.FormFactor form_factor = 7;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_form_factor_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_form_factor(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated string hardware_class = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hardware_class_.size());
  for (int i = 0, n = _impl_.hardware_class_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.hardware_class_.Get(i));
  }

  // repeated string exclude_hardware_class = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.exclude_hardware_class_.size());
  for (int i = 0, n = _impl_.exclude_hardware_class_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.exclude_hardware_class_.Get(i));
  }

  // repeated string country = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.country_.size());
  for (int i = 0, n = _impl_.country_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.country_.Get(i));
  }

  // repeated string exclude_country = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.exclude_country_.size());
  for (int i = 0, n = _impl_.exclude_country_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.exclude_country_.Get(i));
  }

  // repeated string exclude_locale = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.exclude_locale_.size());
  for (int i = 0, n = _impl_.exclude_locale_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.exclude_locale_.Get(i));
  }

  // repeated .variations.Study.FormFactor exclude_form_factor = 14;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_exclude_form_factor_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_exclude_form_factor(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_cpu_architecture_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_cpu_architecture(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_exclude_cpu_architecture_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_exclude_cpu_architecture(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  // repeated int64 google_group = 22 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.google_group_);
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._google_group_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 exclude_google_group = 23 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.exclude_google_group_);
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._exclude_google_group_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string min_version = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_min_version());
    }

    // optional string max_version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_max_version());
    }

    // optional string min_os_version = 16;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_min_os_version());
    }

    // optional string max_os_version = 17;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_max_os_version());
    }

    // optional int64 start_date = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_date());
    }

    // optional int64 end_date = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_date());
    }

    // optional bool is_low_end_device = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_enterprise = 18;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 1;
    }

  }
  // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_policy_restriction());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Filter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Filter*>(
      &from));
}

void Study_Filter::MergeFrom(const Study_Filter& from) {
  Study_Filter* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Filter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.channel_.MergeFrom(from._impl_.channel_);
  _this->_impl_.platform_.MergeFrom(from._impl_.platform_);
  _this->_impl_.locale_.MergeFrom(from._impl_.locale_);
  _this->_impl_.form_factor_.MergeFrom(from._impl_.form_factor_);
  _this->_impl_.hardware_class_.MergeFrom(from._impl_.hardware_class_);
  _this->_impl_.exclude_hardware_class_.MergeFrom(from._impl_.exclude_hardware_class_);
  _this->_impl_.country_.MergeFrom(from._impl_.country_);
  _this->_impl_.exclude_country_.MergeFrom(from._impl_.exclude_country_);
  _this->_impl_.exclude_locale_.MergeFrom(from._impl_.exclude_locale_);
  _this->_impl_.exclude_form_factor_.MergeFrom(from._impl_.exclude_form_factor_);
  _this->_impl_.cpu_architecture_.MergeFrom(from._impl_.cpu_architecture_);
  _this->_impl_.exclude_cpu_architecture_.MergeFrom(from._impl_.exclude_cpu_architecture_);
  _this->_impl_.google_group_.MergeFrom(from._impl_.google_group_);
  _this->_impl_.exclude_google_group_.MergeFrom(from._impl_.exclude_google_group_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_min_version(from._internal_min_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_max_version(from._internal_max_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_min_os_version(from._internal_min_os_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_max_os_version(from._internal_max_os_version());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.start_date_ = from._impl_.start_date_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.end_date_ = from._impl_.end_date_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_low_end_device_ = from._impl_.is_low_end_device_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_enterprise_ = from._impl_.is_enterprise_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_policy_restriction(from._internal_policy_restriction());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Filter::CopyFrom(const Study_Filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Filter::IsInitialized() const {
  return true;
}

void Study_Filter::InternalSwap(Study_Filter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.channel_.InternalSwap(&other->_impl_.channel_);
  _impl_.platform_.InternalSwap(&other->_impl_.platform_);
  _impl_.locale_.InternalSwap(&other->_impl_.locale_);
  _impl_.form_factor_.InternalSwap(&other->_impl_.form_factor_);
  _impl_.hardware_class_.InternalSwap(&other->_impl_.hardware_class_);
  _impl_.exclude_hardware_class_.InternalSwap(&other->_impl_.exclude_hardware_class_);
  _impl_.country_.InternalSwap(&other->_impl_.country_);
  _impl_.exclude_country_.InternalSwap(&other->_impl_.exclude_country_);
  _impl_.exclude_locale_.InternalSwap(&other->_impl_.exclude_locale_);
  _impl_.exclude_form_factor_.InternalSwap(&other->_impl_.exclude_form_factor_);
  _impl_.cpu_architecture_.InternalSwap(&other->_impl_.cpu_architecture_);
  _impl_.exclude_cpu_architecture_.InternalSwap(&other->_impl_.exclude_cpu_architecture_);
  _impl_.google_group_.InternalSwap(&other->_impl_.google_group_);
  _impl_.exclude_google_group_.InternalSwap(&other->_impl_.exclude_google_group_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.min_version_, lhs_arena,
      &other->_impl_.min_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.max_version_, lhs_arena,
      &other->_impl_.max_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.min_os_version_, lhs_arena,
      &other->_impl_.min_os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.max_os_version_, lhs_arena,
      &other->_impl_.max_os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Study_Filter, _impl_.policy_restriction_)
      + sizeof(Study_Filter::_impl_.policy_restriction_)
      - PROTOBUF_FIELD_OFFSET(Study_Filter, _impl_.start_date_)>(
          reinterpret_cast<char*>(&_impl_.start_date_),
          reinterpret_cast<char*>(&other->_impl_.start_date_));
}

std::string Study_Filter::GetTypeName() const {
  return "variations.Study.Filter";
}


// ===================================================================

class Study::_Internal {
 public:
  using HasBits = decltype(std::declval<Study>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_expiry_date(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_consistency(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::variations::LayerMemberReference& layer(const Study* msg);
  static void set_has_layer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_default_experiment_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::variations::Study_Filter& filter(const Study* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_randomization_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_activation_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::variations::LayerMemberReference&
Study::_Internal::layer(const Study* msg) {
  return *msg->_impl_.layer_;
}
const ::variations::Study_Filter&
Study::_Internal::filter(const Study* msg) {
  return *msg->_impl_.filter_;
}
void Study::clear_layer() {
  if (_impl_.layer_ != nullptr) _impl_.layer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
Study::Study(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:variations.Study)
}
Study::Study(const Study& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Study* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.experiment_){from._impl_.experiment_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.default_experiment_name_){}
    , decltype(_impl_.filter_){nullptr}
    , decltype(_impl_.layer_){nullptr}
    , decltype(_impl_.expiry_date_){}
    , decltype(_impl_.consistency_){}
    , decltype(_impl_.randomization_seed_){}
    , decltype(_impl_.activation_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.default_experiment_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_experiment_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_default_experiment_name()) {
    _this->_impl_.default_experiment_name_.Set(from._internal_default_experiment_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_filter()) {
    _this->_impl_.filter_ = new ::variations::Study_Filter(*from._impl_.filter_);
  }
  if (from._internal_has_layer()) {
    _this->_impl_.layer_ = new ::variations::LayerMemberReference(*from._impl_.layer_);
  }
  ::memcpy(&_impl_.expiry_date_, &from._impl_.expiry_date_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.activation_type_) -
    reinterpret_cast<char*>(&_impl_.expiry_date_)) + sizeof(_impl_.activation_type_));
  // @@protoc_insertion_point(copy_constructor:variations.Study)
}

inline void Study::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.experiment_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.default_experiment_name_){}
    , decltype(_impl_.filter_){nullptr}
    , decltype(_impl_.layer_){nullptr}
    , decltype(_impl_.expiry_date_){int64_t{0}}
    , decltype(_impl_.consistency_){0}
    , decltype(_impl_.randomization_seed_){0u}
    , decltype(_impl_.activation_type_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_experiment_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_experiment_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study::~Study() {
  // @@protoc_insertion_point(destructor:variations.Study)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.experiment_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.default_experiment_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.filter_;
  if (this != internal_default_instance()) delete _impl_.layer_;
}

void Study::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Study::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.experiment_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.default_experiment_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.filter_ != nullptr);
      _impl_.filter_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.layer_ != nullptr);
      _impl_.layer_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.expiry_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.activation_type_) -
        reinterpret_cast<char*>(&_impl_.expiry_date_)) + sizeof(_impl_.activation_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 expiry_date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_expiry_date(&has_bits);
          _impl_.expiry_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_Consistency_IsValid(val))) {
            _internal_set_consistency(static_cast<::variations::Study_Consistency>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string default_experiment_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_default_experiment_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Experiment experiment = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_experiment(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.Filter filter = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 randomization_seed = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_randomization_seed(&has_bits);
          _impl_.randomization_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.ActivationType activation_type = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_ActivationType_IsValid(val))) {
            _internal_set_activation_type(static_cast<::variations::Study_ActivationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .variations.LayerMemberReference layer = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_layer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int64 expiry_date = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_expiry_date(), target);
  }

  // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_consistency(), target);
  }

  // optional string default_experiment_name = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_default_experiment_name(), target);
  }

  // repeated .variations.Study.Experiment experiment = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_experiment_size()); i < n; i++) {
    const auto& repfield = this->_internal_experiment(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .variations.Study.Filter filter = 10;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::filter(this),
        _Internal::filter(this).GetCachedSize(), target, stream);
  }

  // optional uint32 randomization_seed = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_randomization_seed(), target);
  }

  // optional .variations.Study.ActivationType activation_type = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_activation_type(), target);
  }

  // optional .variations.LayerMemberReference layer = 16;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::layer(this),
        _Internal::layer(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study)
  return target;
}

size_t Study::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .variations.Study.Experiment experiment = 9;
  total_size += 1UL * this->_internal_experiment_size();
  for (const auto& msg : this->_impl_.experiment_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string default_experiment_name = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_default_experiment_name());
    }

    // optional .variations.Study.Filter filter = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filter_);
    }

    // optional .variations.LayerMemberReference layer = 16;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.layer_);
    }

    // optional int64 expiry_date = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_expiry_date());
    }

    // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
    }

    // optional uint32 randomization_seed = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_randomization_seed());
    }

    // optional .variations.Study.ActivationType activation_type = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_activation_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study*>(
      &from));
}

void Study::MergeFrom(const Study& from) {
  Study* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.experiment_.MergeFrom(from._impl_.experiment_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_default_experiment_name(from._internal_default_experiment_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_filter()->::variations::Study_Filter::MergeFrom(
          from._internal_filter());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_layer()->::variations::LayerMemberReference::MergeFrom(
          from._internal_layer());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.expiry_date_ = from._impl_.expiry_date_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.consistency_ = from._impl_.consistency_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.randomization_seed_ = from._impl_.randomization_seed_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.activation_type_ = from._impl_.activation_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study::CopyFrom(const Study& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.experiment_))
    return false;
  return true;
}

void Study::InternalSwap(Study* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.experiment_.InternalSwap(&other->_impl_.experiment_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.default_experiment_name_, lhs_arena,
      &other->_impl_.default_experiment_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Study, _impl_.activation_type_)
      + sizeof(Study::_impl_.activation_type_)
      - PROTOBUF_FIELD_OFFSET(Study, _impl_.filter_)>(
          reinterpret_cast<char*>(&_impl_.filter_),
          reinterpret_cast<char*>(&other->_impl_.filter_));
}

std::string Study::GetTypeName() const {
  return "variations.Study";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace variations
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::variations::Study_Experiment_Param*
Arena::CreateMaybeMessage< ::variations::Study_Experiment_Param >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Experiment_Param >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study_Experiment_FeatureAssociation*
Arena::CreateMaybeMessage< ::variations::Study_Experiment_FeatureAssociation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Experiment_FeatureAssociation >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study_Experiment_OverrideUIString*
Arena::CreateMaybeMessage< ::variations::Study_Experiment_OverrideUIString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Experiment_OverrideUIString >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study_Experiment*
Arena::CreateMaybeMessage< ::variations::Study_Experiment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Experiment >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study_Filter*
Arena::CreateMaybeMessage< ::variations::Study_Filter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Filter >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study*
Arena::CreateMaybeMessage< ::variations::Study >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
