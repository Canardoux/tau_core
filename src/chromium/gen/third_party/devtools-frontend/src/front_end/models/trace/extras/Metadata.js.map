{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/extras/Metadata.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport type * as CrUXManager from '../../crux-manager/crux-manager.js';\nimport * as Types from '../types/types.js';\n\nexport async function forNewRecording(\n    isCpuProfile: boolean, recordStartTime?: number, emulatedDeviceTitle?: string,\n    cruxFieldData?: CrUXManager.PageResult[]): Promise<Types.File.MetaData> {\n  try {\n    if (isCpuProfile) {\n      // For CPU profile, only specify data origin\n      return {\n        dataOrigin: Types.File.DataOrigin.CPU_PROFILE,\n      };\n    }\n    const cpuThrottlingManager = SDK.CPUThrottlingManager.CPUThrottlingManager.instance();\n\n    // If the CPU Throttling manager has yet to have its primary page target\n    // set, it will block on the call to get the current hardware concurrency\n    // until it does. At this point where the user has recorded a trace, that\n    // target should have been set. So if it doesn't have it set, we instead\n    // just bail and don't store the hardware concurrency (this is only\n    // metadata, not mission critical information).\n    // We also race this call against a 1s timeout, because sometimes this call\n    // can hang (unsure exactly why) and we do not want to block parsing for\n    // too long as a result.\n    function getConcurrencyOrTimeout(): Promise<number|undefined> {\n      return Promise.race([\n        SDK.CPUThrottlingManager.CPUThrottlingManager.instance().getHardwareConcurrency(),\n        new Promise<undefined>(resolve => {\n          setTimeout(() => resolve(undefined), 1_000);\n        }),\n      ]);\n    }\n\n    const hardwareConcurrency =\n        cpuThrottlingManager.hasPrimaryPageTargetSet() ? await getConcurrencyOrTimeout() : undefined;\n    const cpuThrottling = SDK.CPUThrottlingManager.CPUThrottlingManager.instance().cpuThrottlingRate();\n    const networkConditions = SDK.NetworkManager.MultitargetNetworkManager.instance().isThrottling() ?\n        SDK.NetworkManager.MultitargetNetworkManager.instance().networkConditions() :\n        undefined;\n\n    let networkThrottlingConditions;\n    let networkTitle;\n    if (networkConditions) {\n      networkThrottlingConditions = {\n        download: networkConditions.download,\n        upload: networkConditions.upload,\n        latency: networkConditions.latency,\n        packetLoss: networkConditions.packetLoss,\n        packetQueueLength: networkConditions.packetQueueLength,\n        packetReordering: networkConditions.packetReordering,\n        targetLatency: networkConditions.targetLatency,\n      };\n      networkTitle =\n          typeof networkConditions.title === 'function' ? networkConditions.title() : networkConditions.title;\n    }\n\n    return {\n      source: 'DevTools',\n      startTime: recordStartTime ? new Date(recordStartTime).toJSON() : undefined,  // ISO-8601 timestamp\n      emulatedDeviceTitle,\n      cpuThrottling: cpuThrottling !== 1 ? cpuThrottling : undefined,\n      networkThrottling: networkTitle,\n      networkThrottlingConditions,\n      hardwareConcurrency,\n      dataOrigin: Types.File.DataOrigin.TRACE_EVENTS,\n      cruxFieldData,\n    };\n  } catch {\n    // If anything went wrong, it does not really matter. The impact is that we\n    // will not save the metadata when we save the trace to disk, but that is\n    // not really important, so just return empty object and move on\n    return {};\n  }\n}\n"],
  "mappings": ";AAIA,YAAY,SAAS;AAErB,YAAY,WAAW;AAEvB,sBAAsB,gBAClB,cAAuB,iBAA0B,qBACjD,eAAwE;AAC1E,MAAI;AAkBF,QAASA,2BAAT,WAA8D;AAC5D,aAAO,QAAQ,KAAK;AAAA,QAClB,IAAI,qBAAqB,qBAAqB,SAAS,EAAE,uBAAuB;AAAA,QAChF,IAAI,QAAmB,aAAW;AAChC,qBAAW,MAAM,QAAQ,MAAS,GAAG,GAAK;AAAA,QAC5C,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAPS,kCAAAA;AAjBT,QAAI,cAAc;AAEhB,aAAO;AAAA,QACL,YAAY,MAAM,KAAK,WAAW;AAAA,MACpC;AAAA,IACF;AACA,UAAM,uBAAuB,IAAI,qBAAqB,qBAAqB,SAAS;AAoBpF,UAAM,sBACF,qBAAqB,wBAAwB,IAAI,MAAMA,yBAAwB,IAAI;AACvF,UAAM,gBAAgB,IAAI,qBAAqB,qBAAqB,SAAS,EAAE,kBAAkB;AACjG,UAAM,oBAAoB,IAAI,eAAe,0BAA0B,SAAS,EAAE,aAAa,IAC3F,IAAI,eAAe,0BAA0B,SAAS,EAAE,kBAAkB,IAC1E;AAEJ,QAAI;AACJ,QAAI;AACJ,QAAI,mBAAmB;AACrB,oCAA8B;AAAA,QAC5B,UAAU,kBAAkB;AAAA,QAC5B,QAAQ,kBAAkB;AAAA,QAC1B,SAAS,kBAAkB;AAAA,QAC3B,YAAY,kBAAkB;AAAA,QAC9B,mBAAmB,kBAAkB;AAAA,QACrC,kBAAkB,kBAAkB;AAAA,QACpC,eAAe,kBAAkB;AAAA,MACnC;AACA,qBACI,OAAO,kBAAkB,UAAU,aAAa,kBAAkB,MAAM,IAAI,kBAAkB;AAAA,IACpG;AAEA,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,WAAW,kBAAkB,IAAI,KAAK,eAAe,EAAE,OAAO,IAAI;AAAA;AAAA,MAClE;AAAA,MACA,eAAe,kBAAkB,IAAI,gBAAgB;AAAA,MACrD,mBAAmB;AAAA,MACnB;AAAA,MACA;AAAA,MACA,YAAY,MAAM,KAAK,WAAW;AAAA,MAClC;AAAA,IACF;AAAA,EACF,QAAQ;AAIN,WAAO,CAAC;AAAA,EACV;AACF;",
  "names": ["getConcurrencyOrTimeout"]
}
