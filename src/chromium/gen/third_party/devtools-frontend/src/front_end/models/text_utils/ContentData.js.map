{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/text_utils/ContentData.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport { contentAsDataURL, type DeferredContent } from './ContentProvider.js';\nimport {Text} from './Text.js';\n\n/**\n * This class is a small wrapper around either raw binary or text data.\n * As the binary data can actually contain textual data, we also store the\n * MIME type and if applicable, the charset.\n *\n * This information should be generally kept together, as interpreting text\n * from raw bytes requires an encoding.\n *\n * Note that we only rarely have to decode text ourselves in the frontend,\n * this is mostly handled by the backend. There are cases though (e.g. SVG,\n * or streaming response content) where we receive text data in\n * binary (base64-encoded) form.\n *\n * The class only implements decoding. We currently don't have a use-case\n * to re-encode text into base64 bytes using a specified charset.\n */\nexport class ContentData {\n  readonly mimeType: string;\n  readonly charset: string;\n\n  #contentAsBase64?: string;\n  #contentAsText?: string;\n\n  #contentAsTextObj?: Text;\n\n  constructor(data: string, isBase64: boolean, mimeType: string, charset?: string) {\n    this.charset = charset || 'utf-8';\n    if (isBase64) {\n      this.#contentAsBase64 = data;\n    } else {\n      this.#contentAsText = data;\n    }\n\n    this.mimeType = mimeType;\n    if (!this.mimeType) {\n      // Tests or broken requests might pass an empty/undefined mime type. Fallback to\n      // \"default\" mime types.\n      this.mimeType = isBase64 ? 'application/octet-stream' : 'text/plain';\n    }\n  }\n\n  /**\n   * Returns the data as base64.\n   *\n   * @throws if this `ContentData` was constructed from text content.\n   */\n  get base64(): string {\n    if (this.#contentAsBase64 === undefined) {\n      throw new Error('Encoding text content as base64 is not supported');\n    }\n    return this.#contentAsBase64;\n  }\n\n  /**\n   * Returns the content as text. If this `ContentData` was constructed with base64\n   * encoded bytes, it will use the provided charset to attempt to decode the bytes.\n   *\n   * @throws if `mimeType` is not a text type.\n   */\n  get text(): string {\n    if (this.#contentAsText !== undefined) {\n      return this.#contentAsText;\n    }\n\n    if (!this.isTextContent) {\n      throw new Error('Cannot interpret binary data as text');\n    }\n\n    const binaryString = window.atob(this.#contentAsBase64 as string);\n    const bytes = Uint8Array.from(binaryString, m => m.codePointAt(0) as number);\n    this.#contentAsText = new TextDecoder(this.charset).decode(bytes);\n    return this.#contentAsText;\n  }\n\n  /** @returns true, if this `ContentData` was constructed from text content or the mime type indicates text that can be decoded */\n  get isTextContent(): boolean {\n    return this.#createdFromText || Platform.MimeType.isTextType(this.mimeType);\n  }\n\n  get isEmpty(): boolean {\n    // Don't trigger unnecessary decoding. Only check if both of the strings are empty.\n    return !Boolean(this.#contentAsBase64) && !Boolean(this.#contentAsText);\n  }\n\n  get createdFromBase64(): boolean {\n    return this.#contentAsBase64 !== undefined;\n  }\n\n  get #createdFromText(): boolean {\n    return this.#contentAsBase64 === undefined;\n  }\n\n  /**\n   * Returns the text content as a `Text` object. The returned object is always the same to\n   * minimize the number of times we have to calculate the line endings array.\n   *\n   * @throws if `mimeType` is not a text type.\n   */\n  get textObj(): Text {\n    if (this.#contentAsTextObj === undefined) {\n      this.#contentAsTextObj = new Text(this.text);\n    }\n    return this.#contentAsTextObj;\n  }\n\n  /**\n   * @returns True, iff the contents (base64 or text) are equal.\n   * Does not compare mime type and charset, but will decode base64 data if both\n   * mime types indicate that it's text content.\n   */\n  contentEqualTo(other: ContentData): boolean {\n    if (this.#contentAsBase64 !== undefined && other.#contentAsBase64 !== undefined) {\n      return this.#contentAsBase64 === other.#contentAsBase64;\n    }\n    if (this.#contentAsText !== undefined && other.#contentAsText !== undefined) {\n      return this.#contentAsText === other.#contentAsText;\n    }\n    if (this.isTextContent && other.isTextContent) {\n      return this.text === other.text;\n    }\n    return false;\n  }\n\n  asDataUrl(): string|null {\n    // To keep with existing behavior we prefer to return the content\n    // encoded if that is how this ContentData was constructed with.\n    if (this.#contentAsBase64 !== undefined) {\n      const charset = this.isTextContent ? this.charset : null;\n      return contentAsDataURL(this.#contentAsBase64, this.mimeType ?? '', true, charset);\n    }\n    return contentAsDataURL(this.text, this.mimeType ?? '', false, 'utf-8');\n  }\n\n  /**\n   * @deprecated Used during migration from `DeferredContent` to `ContentData`.\n   */\n  asDeferedContent(): DeferredContent {\n    // To prevent encoding mistakes, we'll return text content already decoded.\n    if (this.isTextContent) {\n      return {content: this.text, isEncoded: false};\n    }\n    if (this.#contentAsText !== undefined) {\n      // Unknown text mime type, this should not really happen.\n      return {content: this.#contentAsText, isEncoded: false};\n    }\n    if (this.#contentAsBase64 !== undefined) {\n      return {content: this.#contentAsBase64, isEncoded: true};\n    }\n    throw new Error('Unreachable');\n  }\n\n  static isError(contentDataOrError: ContentDataOrError): contentDataOrError is {error: string} {\n    return 'error' in contentDataOrError;\n  }\n\n  /** @returns `value` if the passed `ContentDataOrError` is an error, or the text content otherwise */\n  static textOr<T>(contentDataOrError: ContentDataOrError, value: T): string|T {\n    if (ContentData.isError(contentDataOrError)) {\n      return value;\n    }\n    return contentDataOrError.text;\n  }\n\n  /** @returns an empty 'text/plain' content data if the passed `ContentDataOrError` is an error, or the content data itself otherwise */\n  static contentDataOrEmpty(contentDataOrError: ContentDataOrError): ContentData {\n    if (ContentData.isError(contentDataOrError)) {\n      return EMPTY_TEXT_CONTENT_DATA;\n    }\n    return contentDataOrError;\n  }\n\n  /**\n   * @deprecated Used during migration from `DeferredContent` to `ContentData`.\n   */\n  static asDeferredContent(contentDataOrError: ContentDataOrError): DeferredContent {\n    if (ContentData.isError(contentDataOrError)) {\n      return {error: contentDataOrError.error, content: null, isEncoded: false};\n    }\n    return contentDataOrError.asDeferedContent();\n  }\n}\n\nexport const EMPTY_TEXT_CONTENT_DATA = new ContentData('', /* isBase64 */ false, 'text/plain');\n\nexport type ContentDataOrError = ContentData|{error: string};\n"],
  "mappings": "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",
  "names": []
}
