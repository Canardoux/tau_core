{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/ModelImpl.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport type * as Insights from './insights/insights.js';\nimport {TraceParseProgressEvent, TraceProcessor} from './Processor.js';\nimport * as Types from './types/types.js';\n\n// Note: this model is implemented in a way that can support multiple trace\n// processors. Currently there is only one implemented, but you will see\n// references to \"processors\" plural because it can easily be extended in the future.\n\nexport interface ParseConfig {\n  metadata?: Types.File.MetaData;\n  isFreshRecording?: boolean;\n}\n\n/**\n * The Model is responsible for parsing arrays of raw trace events and storing the\n * resulting data. It can store multiple traces at once, and can return the data for\n * any of them.\n *\n * Most uses of this class should be through `createWithAllHandlers`, but\n * `createWithSubsetOfHandlers` can be used to run just some handlers.\n **/\nexport class Model extends EventTarget {\n  readonly #traces: ParsedTraceFile[] = [];\n  readonly #syntheticEventsManagerByTrace: Helpers.SyntheticEvents.SyntheticEventsManager[] = [];\n  readonly #nextNumberByDomain = new Map<string, number>();\n\n  readonly #recordingsAvailable: string[] = [];\n  #lastRecordingIndex = 0;\n  #processor: TraceProcessor;\n  #config: Types.Configuration.Configuration = Types.Configuration.defaults();\n\n  static createWithAllHandlers(config?: Types.Configuration.Configuration): Model {\n    return new Model(Handlers.ModelHandlers, config);\n  }\n\n  /**\n   * Runs only the provided handlers.\n   *\n   * Callers must ensure they are providing all dependant handlers (although Meta is included automatically),\n   * and must know that the result of `.parsedTrace` will be limited to the handlers provided, even though\n   * the type won't reflect that.\n   */\n  static createWithSubsetOfHandlers(\n      traceHandlers: Partial<Handlers.Types.Handlers>, config?: Types.Configuration.Configuration): Model {\n    return new Model(traceHandlers as Handlers.Types.Handlers, config);\n  }\n\n  constructor(handlers: Handlers.Types.Handlers, config?: Types.Configuration.Configuration) {\n    super();\n    if (config) {\n      this.#config = config;\n    }\n    this.#processor = new TraceProcessor(handlers, this.#config);\n  }\n\n  /**\n   * Parses an array of trace events into a structured object containing all the\n   * information parsed by the trace handlers.\n   * You can `await` this function to pause execution until parsing is complete,\n   * or instead rely on the `ModuleUpdateEvent` that is dispatched when the\n   * parsing is finished.\n   *\n   * Once parsed, you then have to call the `parsedTrace` method, providing an\n   * index of the trace you want to have the data for. This is because any model\n   * can store a number of traces. Each trace is given an index, which starts at 0\n   * and increments by one as a new trace is parsed.\n   *\n   * @example\n   * // Awaiting the parse method() to block until parsing complete\n   * await this.traceModel.parse(events);\n   * const data = this.traceModel.parsedTrace(0)\n   *\n   * @example\n   * // Using an event listener to be notified when tracing is complete.\n   * this.traceModel.addEventListener(Trace.ModelUpdateEvent.eventName, (event) => {\n   *   if(event.data.data === 'done') {\n   *     // trace complete\n   *     const data = this.traceModel.parsedTrace(0);\n   *   }\n   * });\n   * void this.traceModel.parse(events);\n   **/\n  async parse(traceEvents: readonly Types.Events.Event[], config?: ParseConfig): Promise<void> {\n    const metadata = config?.metadata || {};\n    const isFreshRecording = config?.isFreshRecording || false;\n    const isCPUProfile = metadata?.dataOrigin === Types.File.DataOrigin.CPU_PROFILE;\n    // During parsing, periodically update any listeners on each processors'\n    // progress (if they have any updates).\n    const onTraceUpdate = (event: Event): void => {\n      const {data} = event as TraceParseProgressEvent;\n      this.dispatchEvent(new ModelUpdateEvent({type: ModelUpdateType.PROGRESS_UPDATE, data}));\n    };\n\n    this.#processor.addEventListener(TraceParseProgressEvent.eventName, onTraceUpdate);\n\n    // Create a parsed trace file.  It will be populated with data from the processor.\n    const file: ParsedTraceFile = {\n      traceEvents,\n      metadata,\n      parsedTrace: null,\n      traceInsights: null,\n    };\n\n    try {\n      // Wait for all outstanding promises before finishing the async execution,\n      // but perform all tasks in parallel.\n      const syntheticEventsManager = Helpers.SyntheticEvents.SyntheticEventsManager.createAndActivate(traceEvents);\n      await this.#processor.parse(traceEvents, {\n        isFreshRecording,\n        isCPUProfile,\n      });\n      this.#storeParsedFileData(file, this.#processor.parsedTrace, this.#processor.insights);\n      // We only push the file onto this.#traces here once we know it's valid\n      // and there's been no errors in the parsing.\n      this.#traces.push(file);\n      this.#syntheticEventsManagerByTrace.push(syntheticEventsManager);\n    } catch (e) {\n      throw e;\n    } finally {\n      // All processors have finished parsing, no more updates are expected.\n      this.#processor.removeEventListener(TraceParseProgressEvent.eventName, onTraceUpdate);\n      // Finally, update any listeners that all processors are 'done'.\n      this.dispatchEvent(new ModelUpdateEvent({type: ModelUpdateType.COMPLETE, data: 'done'}));\n    }\n  }\n\n  #storeParsedFileData(\n      file: ParsedTraceFile, data: Handlers.Types.ParsedTrace|null,\n      insights: Insights.Types.TraceInsightSets|null): void {\n    file.parsedTrace = data;\n    file.traceInsights = insights;\n    this.#lastRecordingIndex++;\n    let recordingName = `Trace ${this.#lastRecordingIndex}`;\n    let origin: string|null = null;\n    if (file.parsedTrace) {\n      origin = Helpers.Trace.extractOriginFromTrace(file.parsedTrace.Meta.mainFrameURL);\n      if (origin) {\n        const nextSequenceForDomain = Platform.MapUtilities.getWithDefault(this.#nextNumberByDomain, origin, () => 1);\n        recordingName = `${origin} (${nextSequenceForDomain})`;\n        this.#nextNumberByDomain.set(origin, nextSequenceForDomain + 1);\n      }\n    }\n    this.#recordingsAvailable.push(recordingName);\n  }\n\n  lastTraceIndex(): number {\n    return this.size() - 1;\n  }\n\n  /**\n   * Returns the parsed trace data indexed by the order in which it was stored.\n   * If no index is given, the last stored parsed data is returned.\n   */\n  parsedTrace(index: number = this.#traces.length - 1): Handlers.Types.ParsedTrace|null {\n    return this.#traces.at(index)?.parsedTrace ?? null;\n  }\n\n  traceInsights(index: number = this.#traces.length - 1): Insights.Types.TraceInsightSets|null {\n    return this.#traces.at(index)?.traceInsights ?? null;\n  }\n\n  metadata(index: number = this.#traces.length - 1): Types.File.MetaData|null {\n    return this.#traces.at(index)?.metadata ?? null;\n  }\n\n  overrideModifications(index: number, newModifications: Types.File.Modifications): void {\n    if (this.#traces[index]) {\n      this.#traces[index].metadata.modifications = newModifications;\n    }\n  }\n\n  rawTraceEvents(index: number = this.#traces.length - 1): readonly Types.Events.Event[]|null {\n    return this.#traces.at(index)?.traceEvents ?? null;\n  }\n\n  syntheticTraceEventsManager(index: number = this.#traces.length - 1): Helpers.SyntheticEvents.SyntheticEventsManager\n      |null {\n    return this.#syntheticEventsManagerByTrace.at(index) ?? null;\n  }\n\n  size(): number {\n    return this.#traces.length;\n  }\n\n  deleteTraceByIndex(recordingIndex: number): void {\n    this.#traces.splice(recordingIndex, 1);\n    this.#recordingsAvailable.splice(recordingIndex, 1);\n  }\n\n  getRecordingsAvailable(): string[] {\n    return this.#recordingsAvailable;\n  }\n\n  resetProcessor(): void {\n    this.#processor.reset();\n  }\n}\n\n/**\n * This parsed trace file is used by the Model. It keeps multiple instances\n * of these so that the user can swap between them. The key is that it is\n * essentially the TraceFile plus whatever the model has parsed from it.\n */\nexport type ParsedTraceFile = Types.File.TraceFile&{\n  parsedTrace: Handlers.Types.ParsedTrace | null,\n  traceInsights: Insights.Types.TraceInsightSets | null,\n};\n\nexport const enum ModelUpdateType {\n  COMPLETE = 'COMPLETE',\n  PROGRESS_UPDATE = 'PROGRESS_UPDATE',\n}\n\nexport type ModelUpdateEventData = ModelUpdateEventComplete|ModelUpdateEventProgress;\n\nexport type ModelUpdateEventComplete = {\n  type: ModelUpdateType.COMPLETE,\n  data: 'done',\n};\nexport type ModelUpdateEventProgress = {\n  type: ModelUpdateType.PROGRESS_UPDATE,\n  data: TraceParseEventProgressData,\n};\n\nexport type TraceParseEventProgressData = {\n  percent: number,\n};\n\nexport class ModelUpdateEvent extends Event {\n  static readonly eventName = 'modelupdate';\n  constructor(public data: ModelUpdateEventData) {\n    super(ModelUpdateEvent.eventName);\n  }\n}\n\ndeclare global {\n  interface HTMLElementEventMap {\n    [ModelUpdateEvent.eventName]: ModelUpdateEvent;\n  }\n}\n\nexport function isModelUpdateDataComplete(eventData: ModelUpdateEventData): eventData is ModelUpdateEventComplete {\n  return eventData.type === ModelUpdateType.COMPLETE;\n}\n\nexport function isModelUpdateDataProgress(eventData: ModelUpdateEventData): eventData is ModelUpdateEventProgress {\n  return eventData.type === ModelUpdateType.PROGRESS_UPDATE;\n}\n"],
  "mappings": ";AAIA,YAAY,cAAc;AAE1B,YAAY,cAAc;AAC1B,YAAY,aAAa;AAEzB,SAAQ,yBAAyB,sBAAqB;AACtD,YAAY,WAAW;AAmBhB,aAAM,cAAc,YAAY;AAAA,EAC5B,UAA6B,CAAC;AAAA,EAC9B,iCAAmF,CAAC;AAAA,EACpF,sBAAsB,oBAAI,IAAoB;AAAA,EAE9C,uBAAiC,CAAC;AAAA,EAC3C,sBAAsB;AAAA,EACtB;AAAA,EACA,UAA6C,MAAM,cAAc,SAAS;AAAA,EAE1E,OAAO,sBAAsB,QAAmD;AAC9E,WAAO,IAAI,MAAM,SAAS,eAAe,MAAM;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,2BACH,eAAiD,QAAmD;AACtG,WAAO,IAAI,MAAM,eAA0C,MAAM;AAAA,EACnE;AAAA,EAEA,YAAY,UAAmC,QAA4C;AACzF,UAAM;AACN,QAAI,QAAQ;AACV,WAAK,UAAU;AAAA,IACjB;AACA,SAAK,aAAa,IAAI,eAAe,UAAU,KAAK,OAAO;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6BA,MAAM,MAAM,aAA4C,QAAqC;AAC3F,UAAM,WAAW,QAAQ,YAAY,CAAC;AACtC,UAAM,mBAAmB,QAAQ,oBAAoB;AACrD,UAAM,eAAe,UAAU,eAAe,MAAM,KAAK,WAAW;AAGpE,UAAM,gBAAgB,CAAC,UAAuB;AAC5C,YAAM,EAAC,KAAI,IAAI;AACf,WAAK,cAAc,IAAI,iBAAiB,EAAC,MAAM,yCAAiC,KAAI,CAAC,CAAC;AAAA,IACxF;AAEA,SAAK,WAAW,iBAAiB,wBAAwB,WAAW,aAAa;AAGjF,UAAM,OAAwB;AAAA,MAC5B;AAAA,MACA;AAAA,MACA,aAAa;AAAA,MACb,eAAe;AAAA,IACjB;AAEA,QAAI;AAGF,YAAM,yBAAyB,QAAQ,gBAAgB,uBAAuB,kBAAkB,WAAW;AAC3G,YAAM,KAAK,WAAW,MAAM,aAAa;AAAA,QACvC;AAAA,QACA;AAAA,MACF,CAAC;AACD,WAAK,qBAAqB,MAAM,KAAK,WAAW,aAAa,KAAK,WAAW,QAAQ;AAGrF,WAAK,QAAQ,KAAK,IAAI;AACtB,WAAK,+BAA+B,KAAK,sBAAsB;AAAA,IACjE,SAAS,GAAG;AACV,YAAM;AAAA,IACR,UAAE;AAEA,WAAK,WAAW,oBAAoB,wBAAwB,WAAW,aAAa;AAEpF,WAAK,cAAc,IAAI,iBAAiB,EAAC,MAAM,2BAA0B,MAAM,OAAM,CAAC,CAAC;AAAA,IACzF;AAAA,EACF;AAAA,EAEA,qBACI,MAAuB,MACvB,UAAsD;AACxD,SAAK,cAAc;AACnB,SAAK,gBAAgB;AACrB,SAAK;AACL,QAAI,gBAAgB,SAAS,KAAK,mBAAmB;AACrD,QAAI,SAAsB;AAC1B,QAAI,KAAK,aAAa;AACpB,eAAS,QAAQ,MAAM,uBAAuB,KAAK,YAAY,KAAK,YAAY;AAChF,UAAI,QAAQ;AACV,cAAM,wBAAwB,SAAS,aAAa,eAAe,KAAK,qBAAqB,QAAQ,MAAM,CAAC;AAC5G,wBAAgB,GAAG,MAAM,KAAK,qBAAqB;AACnD,aAAK,oBAAoB,IAAI,QAAQ,wBAAwB,CAAC;AAAA,MAChE;AAAA,IACF;AACA,SAAK,qBAAqB,KAAK,aAAa;AAAA,EAC9C;AAAA,EAEA,iBAAyB;AACvB,WAAO,KAAK,KAAK,IAAI;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,QAAgB,KAAK,QAAQ,SAAS,GAAoC;AACpF,WAAO,KAAK,QAAQ,GAAG,KAAK,GAAG,eAAe;AAAA,EAChD;AAAA,EAEA,cAAc,QAAgB,KAAK,QAAQ,SAAS,GAAyC;AAC3F,WAAO,KAAK,QAAQ,GAAG,KAAK,GAAG,iBAAiB;AAAA,EAClD;AAAA,EAEA,SAAS,QAAgB,KAAK,QAAQ,SAAS,GAA6B;AAC1E,WAAO,KAAK,QAAQ,GAAG,KAAK,GAAG,YAAY;AAAA,EAC7C;AAAA,EAEA,sBAAsB,OAAe,kBAAkD;AACrF,QAAI,KAAK,QAAQ,KAAK,GAAG;AACvB,WAAK,QAAQ,KAAK,EAAE,SAAS,gBAAgB;AAAA,IAC/C;AAAA,EACF;AAAA,EAEA,eAAe,QAAgB,KAAK,QAAQ,SAAS,GAAuC;AAC1F,WAAO,KAAK,QAAQ,GAAG,KAAK,GAAG,eAAe;AAAA,EAChD;AAAA,EAEA,4BAA4B,QAAgB,KAAK,QAAQ,SAAS,GACxD;AACR,WAAO,KAAK,+BAA+B,GAAG,KAAK,KAAK;AAAA,EAC1D;AAAA,EAEA,OAAe;AACb,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EAEA,mBAAmB,gBAA8B;AAC/C,SAAK,QAAQ,OAAO,gBAAgB,CAAC;AACrC,SAAK,qBAAqB,OAAO,gBAAgB,CAAC;AAAA,EACpD;AAAA,EAEA,yBAAmC;AACjC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,iBAAuB;AACrB,SAAK,WAAW,MAAM;AAAA,EACxB;AACF;AAYO,WAAW,kBAAX,kBAAWA,qBAAX;AACL,EAAAA,iBAAA,cAAW;AACX,EAAAA,iBAAA,qBAAkB;AAFF,SAAAA;AAAA,GAAA;AAoBX,aAAM,yBAAyB,MAAM;AAAA,EAE1C,YAAmB,MAA4B;AAC7C,UAAM,iBAAiB,SAAS;AADf;AAAA,EAEnB;AAAA,EAHA,OAAgB,YAAY;AAI9B;AAQO,gBAAS,0BAA0B,WAAwE;AAChH,SAAO,UAAU,SAAS;AAC5B;AAEO,gBAAS,0BAA0B,WAAwE;AAChH,SAAO,UAAU,SAAS;AAC5B;",
  "names": ["ModelUpdateType"]
}
