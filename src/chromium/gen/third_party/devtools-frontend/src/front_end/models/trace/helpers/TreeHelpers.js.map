{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/helpers/TreeHelpers.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nimport {eventIsInBounds, microSecondsToMilliseconds} from './Timing.js';\n\nlet nodeIdCount = 0;\nexport const makeTraceEntryNodeId = (): TraceEntryNodeId => (++nodeIdCount) as TraceEntryNodeId;\n\nexport const makeEmptyTraceEntryTree = (): TraceEntryTree => ({\n  roots: new Set(),\n  maxDepth: 0,\n});\n\nexport const makeEmptyTraceEntryNode = (entry: Types.Events.Event, id: TraceEntryNodeId): TraceEntryNode => ({\n  entry,\n  id,\n  parent: null,\n  children: [],\n  depth: 0,\n});\n\nexport interface TraceEntryTree {\n  roots: Set<TraceEntryNode>;\n  maxDepth: number;\n}\n\n/** Node in the graph that defines all parent/child relationships. */\nexport interface TraceEntryNode {\n  entry: Types.Events.Event;\n  depth: number;\n  selfTime?: Types.Timing.MicroSeconds;\n  id: TraceEntryNodeId;\n  parent: TraceEntryNode|null;\n  children: TraceEntryNode[];\n}\n\nexport interface AINodeSerialized {\n  name: string;\n  dur?: number;\n  self?: number;\n  children?: AINodeSerialized[];\n  url?: string;\n  selected?: boolean;\n}\n\n/**\n * Node in a graph simplified for AI Assistance processing. The graph mirrors the TraceEntryNode one.\n * Huge tip of the hat to Victor Porof for prototyping this with some great work: https://crrev.com/c/5711249\n */\nexport class AINode {\n  // event: Types.Events.Event; // Set in the constructor.\n  name: string;\n  duration?: Types.Timing.MilliSeconds;\n  selfDuration?: Types.Timing.MilliSeconds;\n  id?: TraceEntryNodeId;\n  children?: AINode[];\n  url?: string;\n  selected?: boolean;\n\n  constructor(public event: Types.Events.Event) {\n    this.name = event.name;\n    this.duration = event.dur === undefined ? undefined : microSecondsToMilliseconds(event.dur);\n\n    if (Types.Events.isProfileCall(event)) {\n      this.name = event.callFrame.functionName || '(anonymous)';\n      this.url = event.callFrame.url;\n    }\n  }\n\n  // Manually handle how nodes in this tree are serialized. We'll drop serveral properties that we don't need in the JSON string.\n  // FYI: toJSON() is invoked implicitly via JSON.stringify()\n  toJSON(): AINodeSerialized {\n    return {\n      selected: this.selected,\n      name: this.name,\n      url: this.url,\n      // Round milliseconds because we don't need the precision\n      dur: this.duration === undefined ? undefined : Math.round(this.duration * 10) / 10,\n      self: this.selfDuration === undefined ? undefined : Math.round(this.selfDuration * 10) / 10,\n      children: this.children?.length ? this.children : undefined,\n    };\n  }\n\n  static #fromTraceEvent(event: Types.Events.Event): AINode {\n    return new AINode(event);\n  }\n\n  /**\n   * Builds a TraceEntryNodeForAI tree from a node and marks the selected node. Primary entrypoint from EntriesFilter\n   */\n  static fromEntryNode(selectedNode: TraceEntryNode, entryIsVisibleInTimeline: (event: Types.Events.Event) => boolean):\n      AINode {\n    /**\n     * Builds a AINode tree from a TraceEntryNode tree and marks the selected node.\n     */\n    function fromEntryNodeAndTree(node: TraceEntryNode): AINode {\n      const aiNode = AINode.#fromTraceEvent(node.entry);\n      aiNode.id = node.id;\n      if (node === selectedNode) {\n        aiNode.selected = true;\n      }\n      aiNode.selfDuration = node.selfTime === undefined ? undefined : microSecondsToMilliseconds(node.selfTime);\n      for (const child of node.children) {\n        aiNode.children ??= [];\n        aiNode.children.push(fromEntryNodeAndTree(child));\n      }\n      return aiNode;\n    }\n\n    function findTopMostVisibleAncestor(node: TraceEntryNode): TraceEntryNode {\n      const parentNodes = [node];\n      let parent = node.parent;\n      while (parent) {\n        parentNodes.unshift(parent);\n        parent = parent.parent;\n      }\n      return parentNodes.find(node => entryIsVisibleInTimeline(node.entry)) ?? node;\n    }\n\n    const topMostVisibleRoot = findTopMostVisibleAncestor(selectedNode);\n    const aiNode = fromEntryNodeAndTree(topMostVisibleRoot);\n\n    // If our root wasn't visible, this could return an array of multiple RunTasks.\n    // But with a visible root, we safely get back the exact same root, now with its descendent tree updated.\n    // Filter to ensure our tree here only has \"visible\" entries\n    const [filteredAiNodeRoot] = AINode.#filterRecursive([aiNode], node => {\n      if (node.event.name === 'V8.CompileCode' || node.event.name === 'UpdateCounters') {\n        return false;\n      }\n      return entryIsVisibleInTimeline(node.event);\n    });\n    return filteredAiNodeRoot;\n  }\n\n  static getSelectedNodeWithinTree(node: AINode): AINode|null {\n    if (node.selected) {\n      return node;\n    }\n    if (!node.children) {\n      return null;\n    }\n    for (const child of node.children) {\n      const returnedNode = AINode.getSelectedNodeWithinTree(child);\n      if (returnedNode) {\n        return returnedNode;\n      }\n    }\n    return null;\n  }\n\n  static #filterRecursive(list: AINode[], predicate: (node: AINode) => boolean): AINode[] {\n    let done;\n    do {\n      done = true;\n      const filtered: AINode[] = [];\n      for (const node of list) {\n        if (predicate(node)) {\n          // Keep it\n          filtered.push(node);\n        } else if (node.children) {\n          filtered.push(...node.children);\n          done = false;\n        }\n      }\n      list = filtered;\n    } while (!done);\n\n    for (const node of list) {\n      if (node.children) {\n        node.children = AINode.#filterRecursive(node.children, predicate);\n      }\n    }\n    return list;\n  }\n\n  static #removeInexpensiveNodesRecursively(\n      list: AINode[],\n      options?: {minDuration?: number, minSelf?: number, minJsDuration?: number, minJsSelf?: number}): AINode[] {\n    const minDuration = options?.minDuration ?? 0;\n    const minSelf = options?.minSelf ?? 0;\n    const minJsDuration = options?.minJsDuration ?? 0;\n    const minJsSelf = options?.minJsSelf ?? 0;\n\n    const isJS = (node: AINode): boolean => Boolean(node.url);\n    const longEnough = (node: AINode): boolean =>\n        node.duration === undefined || node.duration >= (isJS(node) ? minJsDuration : minDuration);\n    const selfLongEnough = (node: AINode): boolean =>\n        node.selfDuration === undefined || node.selfDuration >= (isJS(node) ? minJsSelf : minSelf);\n\n    return AINode.#filterRecursive(list, node => longEnough(node) && selfLongEnough(node));\n  }\n\n  // Invoked from DrJonesPerformanceAgent\n  sanitize(): void {\n    if (this.children) {\n      this.children = AINode.#removeInexpensiveNodesRecursively(this.children, {\n        minDuration: Types.Timing.MilliSeconds(1),\n        minJsDuration: Types.Timing.MilliSeconds(1),\n        minJsSelf: Types.Timing.MilliSeconds(0.1),\n      });\n    }\n  }\n}\n\nclass TraceEntryNodeIdTag {\n  /* eslint-disable-next-line no-unused-private-class-members */\n  readonly #tag: (symbol|undefined);\n}\nexport type TraceEntryNodeId = number&TraceEntryNodeIdTag;\n\n/**\n * Builds a hierarchy of the entries (trace events and profile calls) in\n * a particular thread of a particular process, assuming that they're\n * sorted, by iterating through all of the events in order.\n *\n * The approach is analogous to how a parser would be implemented. A\n * stack maintains local context. A scanner peeks and pops from the data\n * stream. Various \"tokens\" (events) are treated as \"whitespace\"\n * (ignored).\n *\n * The tree starts out empty and is populated as the hierarchy is built.\n * The nodes are also assumed to be created empty, with no known parent\n * or children.\n *\n * Complexity: O(n), where n = number of events\n */\nexport function treify(entries: Types.Events.Event[], options?: {\n  filter: {has: (name: Types.Events.Name) => boolean},\n}): {tree: TraceEntryTree, entryToNode: Map<Types.Events.Event, TraceEntryNode>} {\n  // As we construct the tree, store a map of each entry to its node. This\n  // means if you are iterating over a list of RendererEntry events you can\n  // easily look up that node in the tree.\n  const entryToNode = new Map<Types.Events.Event, TraceEntryNode>();\n\n  const stack = [];\n  // Reset the node id counter for every new renderer.\n  nodeIdCount = -1;\n  const tree = makeEmptyTraceEntryTree();\n\n  for (let i = 0; i < entries.length; i++) {\n    const event = entries[i];\n    // If the current event should not be part of the tree, then simply proceed\n    // with the next event.\n    if (options && !options.filter.has(event.name as Types.Events.Name)) {\n      continue;\n    }\n\n    const duration = event.dur || 0;\n    const nodeId = makeTraceEntryNodeId();\n    const node = makeEmptyTraceEntryNode(event, nodeId);\n\n    // If the parent stack is empty, then the current event is a root. Create a\n    // node for it, mark it as a root, then proceed with the next event.\n    if (stack.length === 0) {\n      tree.roots.add(node);\n      node.selfTime = Types.Timing.MicroSeconds(duration);\n      stack.push(node);\n      tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n      entryToNode.set(event, node);\n      continue;\n    }\n\n    const parentNode = stack.at(-1);\n    if (parentNode === undefined) {\n      throw new Error('Impossible: no parent node found in the stack');\n    }\n\n    const parentEvent = parentNode.entry;\n\n    const begin = event.ts;\n    const parentBegin = parentEvent.ts;\n    const parentDuration = parentEvent.dur || 0;\n    const end = begin + duration;\n    const parentEnd = parentBegin + parentDuration;\n    // Check the relationship between the parent event at the top of the stack,\n    // and the current event being processed. There are only 4 distinct\n    // possiblities, only 2 of them actually valid, given the assumed sorting:\n    // 1. Current event starts before the parent event, ends whenever. (invalid)\n    // 2. Current event starts after the parent event, ends whenever. (valid)\n    // 3. Current event starts during the parent event, ends after. (invalid)\n    // 4. Current event starts and ends during the parent event. (valid)\n\n    // 1. If the current event starts before the parent event, then the data is\n    //    not sorted properly, messed up some way, or this logic is incomplete.\n    const startsBeforeParent = begin < parentBegin;\n    if (startsBeforeParent) {\n      throw new Error('Impossible: current event starts before the parent event');\n    }\n\n    // 2. If the current event starts after the parent event, then it's a new\n    //    parent. Pop, then handle current event again.\n    const startsAfterParent = begin >= parentEnd;\n    if (startsAfterParent) {\n      stack.pop();\n      i--;\n      // The last created node has been discarded, so discard this id.\n      nodeIdCount--;\n      continue;\n    }\n    // 3. If the current event starts during the parent event, but ends\n    //    after it, then the data is messed up some way, for example a\n    //    profile call was sampled too late after its start, ignore the\n    //    problematic event.\n    const endsAfterParent = end > parentEnd;\n    if (endsAfterParent) {\n      continue;\n    }\n\n    // 4. The only remaining case is the common case, where the current event is\n    //    contained within the parent event. Create a node for the current\n    //    event, establish the parent/child relationship, then proceed with the\n    //    next event.\n    node.depth = stack.length;\n    node.parent = parentNode;\n    parentNode.children.push(node);\n    node.selfTime = Types.Timing.MicroSeconds(duration);\n    if (parentNode.selfTime !== undefined) {\n      parentNode.selfTime = Types.Timing.MicroSeconds(parentNode.selfTime - (event.dur || 0));\n    }\n    stack.push(node);\n    tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n    entryToNode.set(event, node);\n  }\n  return {tree, entryToNode};\n}\n\n/**\n * Iterates events in a tree hierarchically, from top to bottom,\n * calling back on every event's start and end in the order\n * as it traverses down and then up the tree.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |---------------A---------------|\n *  |------B------||-------D------|\n *    |---C---|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n *\n */\nexport function walkTreeFromEntry(\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    rootEntry: Types.Events.Event,\n    onEntryStart: (entry: Types.Events.Event) => void,\n    onEntryEnd: (entry: Types.Events.Event) => void,\n    ): void {\n  const startNode = entryToNode.get(rootEntry);\n  if (!startNode) {\n    return;\n  }\n  walkTreeByNode(entryToNode, startNode, onEntryStart, onEntryEnd);\n}\n\n/**\n * Given a Helpers.TreeHelpers.RendererTree, this will iterates events in hierarchically, visiting\n * each root node and working from top to bottom, calling back on every event's\n * start and end in the order as it traverses down and then up the tree.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n * 10. Start E\n * 11. End E\n *\n */\n\nexport function walkEntireTree(\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    tree: TraceEntryTree,\n    onEntryStart: (entry: Types.Events.Event) => void,\n    onEntryEnd: (entry: Types.Events.Event) => void,\n    traceWindowToInclude?: Types.Timing.TraceWindowMicroSeconds,\n    minDuration?: Types.Timing.MicroSeconds,\n    ): void {\n  for (const rootNode of tree.roots) {\n    walkTreeByNode(entryToNode, rootNode, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration);\n  }\n}\n\nfunction walkTreeByNode(\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    rootNode: TraceEntryNode,\n    onEntryStart: (entry: Types.Events.Event) => void,\n    onEntryEnd: (entry: Types.Events.Event) => void,\n    traceWindowToInclude?: Types.Timing.TraceWindowMicroSeconds,\n    minDuration?: Types.Timing.MicroSeconds,\n    ): void {\n  if (traceWindowToInclude && !treeNodeIsInWindow(rootNode, traceWindowToInclude)) {\n    // If this node is not within the provided window, we can skip it. We also\n    // can skip all its children too, as we know they won't be in the window if\n    // their parent is not.\n    return;\n  }\n\n  if (typeof minDuration !== 'undefined') {\n    const duration = Types.Timing.MicroSeconds(\n        rootNode.entry.ts + Types.Timing.MicroSeconds(rootNode.entry.dur ?? 0),\n    );\n    if (duration < minDuration) {\n      return;\n    }\n  }\n\n  onEntryStart(rootNode.entry);\n  for (const child of rootNode.children) {\n    walkTreeByNode(entryToNode, child, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration);\n  }\n  onEntryEnd(rootNode.entry);\n}\n\n/**\n * Returns true if the provided node is partially or fully within the trace\n * window. The entire node does not have to fit inside the window, but it does\n * have to partially intersect it.\n */\nfunction treeNodeIsInWindow(node: TraceEntryNode, traceWindow: Types.Timing.TraceWindowMicroSeconds): boolean {\n  return eventIsInBounds(node.entry, traceWindow);\n}\n\n/**\n * Determines if the given events, which are assumed to be ordered can\n * be organized into tree structures.\n * This condition is met if there is *not* a pair of async events\n * e1 and e2 where:\n *\n * e1.startTime < e2.startTime && e1.endTime > e2.startTime && e1.endTime < e2.endTime.\n * or, graphically:\n * |------- e1 ------|\n *   |------- e2 --------|\n *\n * Because a parent-child relationship cannot be made from the example\n * above, a tree cannot be made from the set of events.\n *\n * Sync events from the same thread are tree-able by definition.\n *\n * Note that this will also return true if multiple trees can be\n * built, for example if none of the events overlap with each other.\n */\nexport function canBuildTreesFromEvents(events: readonly Types.Events.Event[]): boolean {\n  const stack: Types.Events.Event[] = [];\n  for (const event of events) {\n    const startTime = event.ts;\n    const endTime = event.ts + (event.dur ?? 0);\n    let parent = stack.at(-1);\n    if (parent === undefined) {\n      stack.push(event);\n      continue;\n    }\n    let parentEndTime = parent.ts + (parent.dur ?? 0);\n    // Discard events that are not parents for this event. The parent\n    // is one whose end time is after this event start time.\n    while (stack.length && startTime >= parentEndTime) {\n      stack.pop();\n      parent = stack.at(-1);\n\n      if (parent === undefined) {\n        break;\n      }\n      parentEndTime = parent.ts + (parent.dur ?? 0);\n    }\n    if (stack.length && endTime > parentEndTime) {\n      // If such an event exists but its end time is before this\n      // event's end time, then a tree cannot be made using this\n      // events.\n      return false;\n    }\n    stack.push(event);\n  }\n  return true;\n}\n"],
  "mappings": ";AAIA,YAAY,WAAW;AAEvB,SAAQ,iBAAiB,kCAAiC;AAE1D,IAAI,cAAc;AACX,aAAM,uBAAuB,MAAyB,EAAE;AAExD,aAAM,0BAA0B,OAAuB;AAAA,EAC5D,OAAO,oBAAI,IAAI;AAAA,EACf,UAAU;AACZ;AAEO,aAAM,0BAA0B,CAAC,OAA2B,QAA0C;AAAA,EAC3G;AAAA,EACA;AAAA,EACA,QAAQ;AAAA,EACR,UAAU,CAAC;AAAA,EACX,OAAO;AACT;AA8BO,aAAM,OAAO;AAAA,EAUlB,YAAmB,OAA2B;AAA3B;AACjB,SAAK,OAAO,MAAM;AAClB,SAAK,WAAW,MAAM,QAAQ,SAAY,SAAY,2BAA2B,MAAM,GAAG;AAE1F,QAAI,MAAM,OAAO,cAAc,KAAK,GAAG;AACrC,WAAK,OAAO,MAAM,UAAU,gBAAgB;AAC5C,WAAK,MAAM,MAAM,UAAU;AAAA,IAC7B;AAAA,EACF;AAAA;AAAA,EAhBA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA,EAcA,SAA2B;AACzB,WAAO;AAAA,MACL,UAAU,KAAK;AAAA,MACf,MAAM,KAAK;AAAA,MACX,KAAK,KAAK;AAAA;AAAA,MAEV,KAAK,KAAK,aAAa,SAAY,SAAY,KAAK,MAAM,KAAK,WAAW,EAAE,IAAI;AAAA,MAChF,MAAM,KAAK,iBAAiB,SAAY,SAAY,KAAK,MAAM,KAAK,eAAe,EAAE,IAAI;AAAA,MACzF,UAAU,KAAK,UAAU,SAAS,KAAK,WAAW;AAAA,IACpD;AAAA,EACF;AAAA,EAEA,OAAO,gBAAgB,OAAmC;AACxD,WAAO,IAAI,OAAO,KAAK;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,cAAc,cAA8B,0BACxC;AAIT,aAAS,qBAAqB,MAA8B;AAC1D,YAAMA,UAAS,OAAO,gBAAgB,KAAK,KAAK;AAChD,MAAAA,QAAO,KAAK,KAAK;AACjB,UAAI,SAAS,cAAc;AACzB,QAAAA,QAAO,WAAW;AAAA,MACpB;AACA,MAAAA,QAAO,eAAe,KAAK,aAAa,SAAY,SAAY,2BAA2B,KAAK,QAAQ;AACxG,iBAAW,SAAS,KAAK,UAAU;AACjC,QAAAA,QAAO,aAAa,CAAC;AACrB,QAAAA,QAAO,SAAS,KAAK,qBAAqB,KAAK,CAAC;AAAA,MAClD;AACA,aAAOA;AAAA,IACT;AAEA,aAAS,2BAA2B,MAAsC;AACxE,YAAM,cAAc,CAAC,IAAI;AACzB,UAAI,SAAS,KAAK;AAClB,aAAO,QAAQ;AACb,oBAAY,QAAQ,MAAM;AAC1B,iBAAS,OAAO;AAAA,MAClB;AACA,aAAO,YAAY,KAAK,CAAAC,UAAQ,yBAAyBA,MAAK,KAAK,CAAC,KAAK;AAAA,IAC3E;AAEA,UAAM,qBAAqB,2BAA2B,YAAY;AAClE,UAAM,SAAS,qBAAqB,kBAAkB;AAKtD,UAAM,CAAC,kBAAkB,IAAI,OAAO,iBAAiB,CAAC,MAAM,GAAG,UAAQ;AACrE,UAAI,KAAK,MAAM,SAAS,oBAAoB,KAAK,MAAM,SAAS,kBAAkB;AAChF,eAAO;AAAA,MACT;AACA,aAAO,yBAAyB,KAAK,KAAK;AAAA,IAC5C,CAAC;AACD,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,0BAA0B,MAA2B;AAC1D,QAAI,KAAK,UAAU;AACjB,aAAO;AAAA,IACT;AACA,QAAI,CAAC,KAAK,UAAU;AAClB,aAAO;AAAA,IACT;AACA,eAAW,SAAS,KAAK,UAAU;AACjC,YAAM,eAAe,OAAO,0BAA0B,KAAK;AAC3D,UAAI,cAAc;AAChB,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,iBAAiB,MAAgB,WAAgD;AACtF,QAAI;AACJ,OAAG;AACD,aAAO;AACP,YAAM,WAAqB,CAAC;AAC5B,iBAAW,QAAQ,MAAM;AACvB,YAAI,UAAU,IAAI,GAAG;AAEnB,mBAAS,KAAK,IAAI;AAAA,QACpB,WAAW,KAAK,UAAU;AACxB,mBAAS,KAAK,GAAG,KAAK,QAAQ;AAC9B,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT,SAAS,CAAC;AAEV,eAAW,QAAQ,MAAM;AACvB,UAAI,KAAK,UAAU;AACjB,aAAK,WAAW,OAAO,iBAAiB,KAAK,UAAU,SAAS;AAAA,MAClE;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,mCACH,MACA,SAA0G;AAC5G,UAAM,cAAc,SAAS,eAAe;AAC5C,UAAM,UAAU,SAAS,WAAW;AACpC,UAAM,gBAAgB,SAAS,iBAAiB;AAChD,UAAM,YAAY,SAAS,aAAa;AAExC,UAAM,OAAO,CAAC,SAA0B,QAAQ,KAAK,GAAG;AACxD,UAAM,aAAa,CAAC,SAChB,KAAK,aAAa,UAAa,KAAK,aAAa,KAAK,IAAI,IAAI,gBAAgB;AAClF,UAAM,iBAAiB,CAAC,SACpB,KAAK,iBAAiB,UAAa,KAAK,iBAAiB,KAAK,IAAI,IAAI,YAAY;AAEtF,WAAO,OAAO,iBAAiB,MAAM,UAAQ,WAAW,IAAI,KAAK,eAAe,IAAI,CAAC;AAAA,EACvF;AAAA;AAAA,EAGA,WAAiB;AACf,QAAI,KAAK,UAAU;AACjB,WAAK,WAAW,OAAO,mCAAmC,KAAK,UAAU;AAAA,QACvE,aAAa,MAAM,OAAO,aAAa,CAAC;AAAA,QACxC,eAAe,MAAM,OAAO,aAAa,CAAC;AAAA,QAC1C,WAAW,MAAM,OAAO,aAAa,GAAG;AAAA,MAC1C,CAAC;AAAA,IACH;AAAA,EACF;AACF;AAEA,MAAM,oBAAoB;AAAA;AAAA,EAEf;AACX;AAmBO,gBAAS,OAAO,SAA+B,SAE2B;AAI/E,QAAM,cAAc,oBAAI,IAAwC;AAEhE,QAAM,QAAQ,CAAC;AAEf,gBAAc;AACd,QAAM,OAAO,wBAAwB;AAErC,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,UAAM,QAAQ,QAAQ,CAAC;AAGvB,QAAI,WAAW,CAAC,QAAQ,OAAO,IAAI,MAAM,IAAyB,GAAG;AACnE;AAAA,IACF;AAEA,UAAM,WAAW,MAAM,OAAO;AAC9B,UAAM,SAAS,qBAAqB;AACpC,UAAM,OAAO,wBAAwB,OAAO,MAAM;AAIlD,QAAI,MAAM,WAAW,GAAG;AACtB,WAAK,MAAM,IAAI,IAAI;AACnB,WAAK,WAAW,MAAM,OAAO,aAAa,QAAQ;AAClD,YAAM,KAAK,IAAI;AACf,WAAK,WAAW,KAAK,IAAI,KAAK,UAAU,MAAM,MAAM;AACpD,kBAAY,IAAI,OAAO,IAAI;AAC3B;AAAA,IACF;AAEA,UAAM,aAAa,MAAM,GAAG,EAAE;AAC9B,QAAI,eAAe,QAAW;AAC5B,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,UAAM,cAAc,WAAW;AAE/B,UAAM,QAAQ,MAAM;AACpB,UAAM,cAAc,YAAY;AAChC,UAAM,iBAAiB,YAAY,OAAO;AAC1C,UAAM,MAAM,QAAQ;AACpB,UAAM,YAAY,cAAc;AAWhC,UAAM,qBAAqB,QAAQ;AACnC,QAAI,oBAAoB;AACtB,YAAM,IAAI,MAAM,0DAA0D;AAAA,IAC5E;AAIA,UAAM,oBAAoB,SAAS;AACnC,QAAI,mBAAmB;AACrB,YAAM,IAAI;AACV;AAEA;AACA;AAAA,IACF;AAKA,UAAM,kBAAkB,MAAM;AAC9B,QAAI,iBAAiB;AACnB;AAAA,IACF;AAMA,SAAK,QAAQ,MAAM;AACnB,SAAK,SAAS;AACd,eAAW,SAAS,KAAK,IAAI;AAC7B,SAAK,WAAW,MAAM,OAAO,aAAa,QAAQ;AAClD,QAAI,WAAW,aAAa,QAAW;AACrC,iBAAW,WAAW,MAAM,OAAO,aAAa,WAAW,YAAY,MAAM,OAAO,EAAE;AAAA,IACxF;AACA,UAAM,KAAK,IAAI;AACf,SAAK,WAAW,KAAK,IAAI,KAAK,UAAU,MAAM,MAAM;AACpD,gBAAY,IAAI,OAAO,IAAI;AAAA,EAC7B;AACA,SAAO,EAAC,MAAM,YAAW;AAC3B;AAuBO,gBAAS,kBACZ,aACA,WACA,cACA,YACQ;AACV,QAAM,YAAY,YAAY,IAAI,SAAS;AAC3C,MAAI,CAAC,WAAW;AACd;AAAA,EACF;AACA,iBAAe,aAAa,WAAW,cAAc,UAAU;AACjE;AA0BO,gBAAS,eACZ,aACA,MACA,cACA,YACA,sBACA,aACQ;AACV,aAAW,YAAY,KAAK,OAAO;AACjC,mBAAe,aAAa,UAAU,cAAc,YAAY,sBAAsB,WAAW;AAAA,EACnG;AACF;AAEA,SAAS,eACL,aACA,UACA,cACA,YACA,sBACA,aACQ;AACV,MAAI,wBAAwB,CAAC,mBAAmB,UAAU,oBAAoB,GAAG;AAI/E;AAAA,EACF;AAEA,MAAI,OAAO,gBAAgB,aAAa;AACtC,UAAM,WAAW,MAAM,OAAO;AAAA,MAC1B,SAAS,MAAM,KAAK,MAAM,OAAO,aAAa,SAAS,MAAM,OAAO,CAAC;AAAA,IACzE;AACA,QAAI,WAAW,aAAa;AAC1B;AAAA,IACF;AAAA,EACF;AAEA,eAAa,SAAS,KAAK;AAC3B,aAAW,SAAS,SAAS,UAAU;AACrC,mBAAe,aAAa,OAAO,cAAc,YAAY,sBAAsB,WAAW;AAAA,EAChG;AACA,aAAW,SAAS,KAAK;AAC3B;AAOA,SAAS,mBAAmB,MAAsB,aAA4D;AAC5G,SAAO,gBAAgB,KAAK,OAAO,WAAW;AAChD;AAqBO,gBAAS,wBAAwB,QAAgD;AACtF,QAAM,QAA8B,CAAC;AACrC,aAAW,SAAS,QAAQ;AAC1B,UAAM,YAAY,MAAM;AACxB,UAAM,UAAU,MAAM,MAAM,MAAM,OAAO;AACzC,QAAI,SAAS,MAAM,GAAG,EAAE;AACxB,QAAI,WAAW,QAAW;AACxB,YAAM,KAAK,KAAK;AAChB;AAAA,IACF;AACA,QAAI,gBAAgB,OAAO,MAAM,OAAO,OAAO;AAG/C,WAAO,MAAM,UAAU,aAAa,eAAe;AACjD,YAAM,IAAI;AACV,eAAS,MAAM,GAAG,EAAE;AAEpB,UAAI,WAAW,QAAW;AACxB;AAAA,MACF;AACA,sBAAgB,OAAO,MAAM,OAAO,OAAO;AAAA,IAC7C;AACA,QAAI,MAAM,UAAU,UAAU,eAAe;AAI3C,aAAO;AAAA,IACT;AACA,UAAM,KAAK,KAAK;AAAA,EAClB;AACA,SAAO;AACT;",
  "names": ["aiNode", "node"]
}
