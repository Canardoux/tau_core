{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/metrics/LargestContentfulPaint.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport type * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\nimport type * as Types from '../types/types.js';\n\nimport {FirstContentfulPaint} from './FirstContentfulPaint.js';\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\n\nclass LargestContentfulPaint extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  /**\n   * Low priority image nodes are usually offscreen and very unlikely to be the\n   * resource that is required for LCP. Our LCP graphs include everything except for these images.\n   */\n  static isNotLowPriorityImageNode(node: Graph.Node): boolean {\n    if (node.type !== 'network') {\n      return true;\n    }\n    const isImage = node.request.resourceType === 'Image';\n    const isLowPriority = node.request.priority === 'Low' || node.request.priority === 'VeryLow';\n    return !isImage || !isLowPriority;\n  }\n\n  static override getOptimisticGraph(\n      dependencyGraph: Graph.Node, processedNavigation: Types.Simulation.ProcessedNavigation): Graph.Node {\n    const lcp = processedNavigation.timestamps.largestContentfulPaint;\n    if (!lcp) {\n      throw new Core.LanternError('NO_LCP');\n    }\n\n    return FirstContentfulPaint.getFirstPaintBasedGraph(dependencyGraph, {\n      cutoffTimestamp: lcp,\n      treatNodeAsRenderBlocking: LargestContentfulPaint.isNotLowPriorityImageNode,\n    });\n  }\n\n  static override getPessimisticGraph(\n      dependencyGraph: Graph.Node, processedNavigation: Types.Simulation.ProcessedNavigation): Graph.Node {\n    const lcp = processedNavigation.timestamps.largestContentfulPaint;\n    if (!lcp) {\n      throw new Core.LanternError('NO_LCP');\n    }\n\n    return FirstContentfulPaint.getFirstPaintBasedGraph(dependencyGraph, {\n      cutoffTimestamp: lcp,\n      treatNodeAsRenderBlocking: _ => true,\n      // For pessimistic LCP we'll include *all* layout nodes\n      additionalCpuNodesToTreatAsRenderBlocking: node => node.didPerformLayout(),\n    });\n  }\n\n  static override getEstimateFromSimulation(simulationResult: Simulation.Result): Simulation.Result {\n    const nodeTimesNotOffscreenImages = Array.from(simulationResult.nodeTimings.entries())\n                                            .filter(entry => LargestContentfulPaint.isNotLowPriorityImageNode(entry[0]))\n                                            .map(entry => entry[1].endTime);\n\n    return {\n      timeInMs: Math.max(...nodeTimesNotOffscreenImages),\n      nodeTimings: simulationResult.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the LCP metric');\n    }\n\n    const metricResult = super.compute(data, extras);\n    metricResult.timing = Math.max(metricResult.timing, fcpResult.timing);\n    return metricResult;\n  }\n}\n\nexport {LargestContentfulPaint};\n"],
  "mappings": ";AAIA,YAAY,UAAU;AAKtB,SAAQ,4BAA2B;AACnC;AAAA,EAEE;AAAA,OAIK;AAEP,MAAM,+BAA+B,OAAO;AAAA,EAC1C,WAAoB,eAAmC;AACrD,WAAO;AAAA,MACL,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,aAAa;AAAA,IACf;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,0BAA0B,MAA2B;AAC1D,QAAI,KAAK,SAAS,WAAW;AAC3B,aAAO;AAAA,IACT;AACA,UAAM,UAAU,KAAK,QAAQ,iBAAiB;AAC9C,UAAM,gBAAgB,KAAK,QAAQ,aAAa,SAAS,KAAK,QAAQ,aAAa;AACnF,WAAO,CAAC,WAAW,CAAC;AAAA,EACtB;AAAA,EAEA,OAAgB,mBACZ,iBAA6B,qBAAuE;AACtG,UAAM,MAAM,oBAAoB,WAAW;AAC3C,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,KAAK,aAAa,QAAQ;AAAA,IACtC;AAEA,WAAO,qBAAqB,wBAAwB,iBAAiB;AAAA,MACnE,iBAAiB;AAAA,MACjB,2BAA2B,uBAAuB;AAAA,IACpD,CAAC;AAAA,EACH;AAAA,EAEA,OAAgB,oBACZ,iBAA6B,qBAAuE;AACtG,UAAM,MAAM,oBAAoB,WAAW;AAC3C,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,KAAK,aAAa,QAAQ;AAAA,IACtC;AAEA,WAAO,qBAAqB,wBAAwB,iBAAiB;AAAA,MACnE,iBAAiB;AAAA,MACjB,2BAA2B,OAAK;AAAA;AAAA,MAEhC,2CAA2C,UAAQ,KAAK,iBAAiB;AAAA,IAC3E,CAAC;AAAA,EACH;AAAA,EAEA,OAAgB,0BAA0B,kBAAwD;AAChG,UAAM,8BAA8B,MAAM,KAAK,iBAAiB,YAAY,QAAQ,CAAC,EAC5C,OAAO,WAAS,uBAAuB,0BAA0B,MAAM,CAAC,CAAC,CAAC,EAC1E,IAAI,WAAS,MAAM,CAAC,EAAE,OAAO;AAEtE,WAAO;AAAA,MACL,UAAU,KAAK,IAAI,GAAG,2BAA2B;AAAA,MACjD,aAAa,iBAAiB;AAAA,IAChC;AAAA,EACF;AAAA,EAEA,OAAgB,QAAQ,MAAkC,QAAmD;AAC3G,UAAM,YAAY,QAAQ;AAC1B,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,KAAK,aAAa,6CAA6C;AAAA,IAC3E;AAEA,UAAM,eAAe,MAAM,QAAQ,MAAM,MAAM;AAC/C,iBAAa,SAAS,KAAK,IAAI,aAAa,QAAQ,UAAU,MAAM;AACpE,WAAO;AAAA,EACT;AACF;AAEA,SAAQ;",
  "names": []
}
