{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/root-causes/LayoutShift.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type {ParsedTrace} from '../handlers/types.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {RootCauseProtocolInterface} from './RootCauses.js';\n\nexport type CSSDimensions = {\n  width?: string,\n  height?: string,\n  aspectRatio?: string,\n};\n\nexport interface UnsizedMedia {\n  node: Protocol.DOM.Node;\n  authoredDimensions?: CSSDimensions;\n  computedDimensions: CSSDimensions;\n}\n\nexport interface InjectedIframe {\n  iframe: Protocol.DOM.Node;\n}\n\nexport interface RootCauseRequest {\n  request: Types.Events.SyntheticNetworkRequest;\n  initiator?: Protocol.Network.Initiator;\n}\n\nexport interface FontChange extends RootCauseRequest {\n  fontFace: Protocol.CSS.FontFace;\n}\n\nexport interface RenderBlockingRequest extends RootCauseRequest {}\n\nexport interface LayoutShiftRootCausesData {\n  unsizedMedia: UnsizedMedia[];\n  iframes: InjectedIframe[];\n  fontChanges: FontChange[];\n  renderBlockingRequests: RenderBlockingRequest[];\n  scriptStackTrace: Types.Events.CallFrame[];\n}\n\nconst fontRequestsByPrePaint = new Map<Types.Events.PrePaint, FontChange[]|null>();\nconst renderBlocksByPrePaint = new Map<Types.Events.PrePaint, RenderBlockingRequest[]|null>();\n\nfunction setDefaultValue(\n    map: Map<Types.Events.LayoutShift, LayoutShiftRootCausesData>, shift: Types.Events.LayoutShift): void {\n  Platform.MapUtilities.getWithDefault(map, shift, () => {\n    return {\n      unsizedMedia: [],\n      iframes: [],\n      fontChanges: [],\n      renderBlockingRequests: [],\n      scriptStackTrace: [],\n    };\n  });\n}\n\nfunction networkRequestIsRenderBlockingInFrame(event: Types.Events.SyntheticNetworkRequest, frameId: string): boolean {\n  return event.args.data.frame === frameId && Helpers.Network.isSyntheticNetworkRequestEventRenderBlocking(event);\n}\n\ninterface Options {\n  /** Checking iframe root causes can be an expensive operation, so it is disabled by default. */\n  enableIframeRootCauses?: boolean;\n}\n\nexport class LayoutShiftRootCauses {\n  #protocolInterface: RootCauseProtocolInterface;\n  #rootCauseCacheMap = new Map<Types.Events.LayoutShift, LayoutShiftRootCausesData>();\n  #nodeDetailsCache = new Map<Protocol.DOM.NodeId, Protocol.DOM.Node|null>();\n  #iframeRootCausesEnabled: boolean;\n\n  constructor(protocolInterface: RootCauseProtocolInterface, options?: Options) {\n    this.#protocolInterface = protocolInterface;\n    this.#iframeRootCausesEnabled = options?.enableIframeRootCauses ?? false;\n  }\n\n  /**\n   * Calculates the potential root causes for a given layout shift event. Once\n   * calculated, this data is cached.\n   * Note: because you need all layout shift data at once to calculate these\n   * correctly, this function will parse the root causes for _all_ layout shift\n   * events the first time that it's called. That then populates the cache for\n   * each shift, so any subsequent calls are just a constant lookup.\n   */\n  async rootCausesForEvent(modelData: ParsedTrace, event: Types.Events.LayoutShift):\n      Promise<Readonly<LayoutShiftRootCausesData>|null> {\n    const cachedResult = this.#rootCauseCacheMap.get(event);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    const allLayoutShifts = modelData.LayoutShifts.clusters.flatMap(cluster => cluster.events);\n    // Make sure a value in the cache is set even for shifts that don't have a root cause,\n    // so that we don't have to recompute when no root causes are found. In case a cause\n    // for a shift is found, the default value is replaced.\n    allLayoutShifts.forEach(shift => setDefaultValue(this.#rootCauseCacheMap, shift));\n\n    // Populate the cache\n    await this.blameShifts(\n        allLayoutShifts,\n        modelData,\n    );\n\n    const resultForEvent = this.#rootCauseCacheMap.get(event);\n    if (!resultForEvent) {\n      // No root causes available for this layout shift.\n      return null;\n    }\n    return resultForEvent;\n  }\n\n  /**\n   * Determines potential root causes for shifts\n   */\n  async blameShifts(\n      layoutShifts: Types.Events.LayoutShift[],\n      modelData: ParsedTrace,\n      ): Promise<void> {\n    await this.linkShiftsToLayoutInvalidations(layoutShifts, modelData);\n    this.linkShiftsToLayoutEvents(layoutShifts, modelData);\n  }\n\n  /**\n   * \"LayoutInvalidations\" are a set of trace events dispatched in Blink under the name\n   * \"layoutInvalidationTracking\", which track invalidations on the \"Layout\"stage of the\n   * rendering pipeline. This function utilizes this event to flag potential root causes\n   * to layout shifts.\n   */\n  async linkShiftsToLayoutInvalidations(layoutShifts: Types.Events.LayoutShift[], modelData: ParsedTrace):\n      Promise<void> {\n    const {prePaintEvents, layoutInvalidationEvents, scheduleStyleInvalidationEvents, backendNodeIds} =\n        modelData.LayoutShifts;\n\n    // For the purposes of determining root causes of layout shifts, we\n    // consider scheduleStyleInvalidationTracking and\n    // LayoutInvalidationTracking events as events that could have been the\n    // cause of the layout shift.\n    const eventsForLayoutInvalidation:\n        Array<Types.Events.LayoutInvalidationTracking|Types.Events.ScheduleStyleInvalidationTracking> =\n            [...layoutInvalidationEvents, ...scheduleStyleInvalidationEvents];\n\n    const nodes = await this.#protocolInterface.pushNodesByBackendIdsToFrontend(backendNodeIds);\n    const nodeIdsByBackendIdMap = new Map<Protocol.DOM.BackendNodeId, Protocol.DOM.NodeId>();\n    for (let i = 0; i < backendNodeIds.length; i++) {\n      nodeIdsByBackendIdMap.set(backendNodeIds[i], nodes[i]);\n    }\n\n    // Maps from PrePaint events to LayoutShifts that occured in each one.\n    const shiftsByPrePaint = getShiftsByPrePaintEvents(layoutShifts, prePaintEvents);\n    for (const layoutInvalidation of eventsForLayoutInvalidation) {\n      // Get the first PrePaint event that happened after the current LayoutInvalidation event.\n      const nextPrePaintIndex = Platform.ArrayUtilities.nearestIndexFromBeginning(\n          prePaintEvents, prePaint => prePaint.ts > layoutInvalidation.ts);\n      if (nextPrePaintIndex === null) {\n        // No PrePaint event registered after this LayoutInvalidation. Continue.\n        continue;\n      }\n      const nextPrePaint = prePaintEvents[nextPrePaintIndex];\n      const subsequentShifts = shiftsByPrePaint.get(nextPrePaint);\n      if (!subsequentShifts) {\n        // The PrePaint after the current LayoutInvalidation doesn't contain shifts.\n        continue;\n      }\n      const fontChangeRootCause = this.getFontChangeRootCause(layoutInvalidation, nextPrePaint, modelData);\n      const renderBlockRootCause = this.getRenderBlockRootCause(layoutInvalidation, nextPrePaint, modelData);\n      const layoutInvalidationNodeId = nodeIdsByBackendIdMap.get(layoutInvalidation.args.data.nodeId);\n      let unsizedMediaRootCause: UnsizedMedia|null = null;\n      let iframeRootCause: InjectedIframe|null = null;\n      if (layoutInvalidationNodeId !== undefined && Types.Events.isLayoutInvalidationTracking(layoutInvalidation)) {\n        unsizedMediaRootCause = await this.getUnsizedMediaRootCause(layoutInvalidation, layoutInvalidationNodeId);\n        iframeRootCause = await this.getIframeRootCause(layoutInvalidation, layoutInvalidationNodeId);\n      }\n\n      if (!unsizedMediaRootCause && !iframeRootCause && !fontChangeRootCause && !renderBlockRootCause) {\n        continue;\n      }\n\n      // Add found potential root causes to all the shifts in this PrePaint and populate the cache.\n      for (const shift of subsequentShifts) {\n        const rootCausesForShift = Platform.MapUtilities.getWithDefault(this.#rootCauseCacheMap, shift, () => {\n          return {\n            unsizedMedia: [],\n            iframes: [],\n            fontChanges: [],\n            renderBlockingRequests: [],\n            scriptStackTrace: [],\n          };\n        });\n        if (unsizedMediaRootCause &&\n            !rootCausesForShift.unsizedMedia.some(media => media.node.nodeId === unsizedMediaRootCause?.node.nodeId) &&\n            shift.args.frame === layoutInvalidation.args.data.frame) {\n          rootCausesForShift.unsizedMedia.push(unsizedMediaRootCause);\n        }\n        if (iframeRootCause &&\n            !rootCausesForShift.iframes.some(\n                injectedIframe => injectedIframe.iframe.nodeId === iframeRootCause?.iframe.nodeId)) {\n          rootCausesForShift.iframes.push(iframeRootCause);\n        }\n        if (fontChangeRootCause) {\n          // Unlike other root causes, we calculate fonts causing a shift only once,\n          // which means we assign the built array instead of appending new objects\n          // to it.\n          rootCausesForShift.fontChanges = fontChangeRootCause;\n        }\n        if (renderBlockRootCause) {\n          rootCausesForShift.renderBlockingRequests = renderBlockRootCause;\n        }\n      }\n    }\n  }\n\n  /**\n   * For every shift looks up the initiator of its corresponding Layout event. This initiator\n   * is assigned by the RendererHandler and contains the stack trace of the point in a script\n   * that caused a style recalculation or a relayout. This stack trace is added to the shift's\n   * potential root causes.\n   * Note that a Layout cannot always be linked to a script, in that case, we cannot add a\n   * \"script causing reflow\" as a potential root cause to the corresponding shift.\n   */\n  linkShiftsToLayoutEvents(layoutShifts: Types.Events.LayoutShift[], modelData: ParsedTrace): void {\n    const {prePaintEvents} = modelData.LayoutShifts;\n    // Maps from PrePaint events to LayoutShifts that occured in each one.\n    const shiftsByPrePaint = getShiftsByPrePaintEvents(layoutShifts, prePaintEvents);\n\n    const eventTriggersLayout = ({name}: {name: string}): boolean => {\n      const knownName = name as Types.Events.Name;\n      return knownName === Types.Events.Name.LAYOUT;\n    };\n    const layoutEvents = modelData.Renderer.allTraceEntries.filter(eventTriggersLayout);\n    for (const layout of layoutEvents) {\n      // Get the first PrePaint event that happened after the current layout event.\n      const nextPrePaintIndex = Platform.ArrayUtilities.nearestIndexFromBeginning(\n          prePaintEvents, prePaint => prePaint.ts > layout.ts + (layout.dur || 0));\n      if (nextPrePaintIndex === null) {\n        // No PrePaint event registered after this LayoutInvalidation. Continue.\n        continue;\n      }\n      const nextPrePaint = prePaintEvents[nextPrePaintIndex];\n      const subsequentShifts = shiftsByPrePaint.get(nextPrePaint);\n      if (!subsequentShifts) {\n        // The PrePaint after the current LayoutInvalidation doesn't contain shifts.\n        continue;\n      }\n      const layoutNode = modelData.Renderer.entryToNode.get(layout);\n      const initiator = layoutNode ? modelData.Initiators.eventToInitiator.get(layoutNode.entry) : null;\n      const stackTrace = initiator?.args?.data?.stackTrace;\n      if (!stackTrace) {\n        continue;\n      }\n      // Add found potential root causes to all the shifts in this PrePaint and populate the cache.\n      for (const shift of subsequentShifts) {\n        const rootCausesForShift = Platform.MapUtilities.getWithDefault(this.#rootCauseCacheMap, shift, () => {\n          return {\n            unsizedMedia: [],\n            iframes: [],\n            fontChanges: [],\n            renderBlockingRequests: [],\n            scriptStackTrace: [],\n          };\n        });\n        if (rootCausesForShift.scriptStackTrace.length === 0) {\n          rootCausesForShift.scriptStackTrace = stackTrace;\n        }\n      }\n    }\n  }\n\n  /**\n   * Given a LayoutInvalidation trace event, determines if it was dispatched\n   * because a media element without dimensions was resized.\n   */\n  async getUnsizedMediaRootCause(\n      layoutInvalidation: Types.Events.LayoutInvalidationTracking,\n      layoutInvalidationNodeId: Protocol.DOM.NodeId): Promise<UnsizedMedia|null> {\n    // Filter events to resizes only.\n    if (layoutInvalidation.args.data.reason !== Types.Events.LayoutInvalidationReason.SIZE_CHANGED) {\n      return null;\n    }\n\n    const layoutInvalidationNode = await this.getNodeDetails(layoutInvalidationNodeId);\n    if (!layoutInvalidationNode) {\n      return null;\n    }\n\n    const computedStylesList = await this.#protocolInterface.getComputedStyleForNode(layoutInvalidationNode.nodeId);\n    const computedStyles = new Map(computedStylesList.map(item => [item.name, item.value]));\n    if (computedStyles && !(await nodeIsUnfixedMedia(layoutInvalidationNode, computedStyles))) {\n      return null;\n    }\n    const authoredDimensions = await this.getNodeAuthoredDimensions(layoutInvalidationNode);\n    if (dimensionsAreExplicit(authoredDimensions)) {\n      return null;\n    }\n    const computedDimensions = computedStyles ? getNodeComputedDimensions(computedStyles) : {};\n\n    return {node: layoutInvalidationNode, authoredDimensions, computedDimensions};\n  }\n\n  /**\n   * Given a LayoutInvalidation trace event, determines if it was dispatched\n   * because a node, which is an ancestor to an iframe, was injected.\n   */\n  async getIframeRootCause(\n      layoutInvalidation: Types.Events.LayoutInvalidationTracking,\n      layoutInvalidationNodeId: Protocol.DOM.NodeId): Promise<InjectedIframe|null> {\n    if (!this.#iframeRootCausesEnabled) {\n      return null;\n    }\n\n    if (!layoutInvalidation.args.data.nodeName?.startsWith('IFRAME') &&\n        layoutInvalidation.args.data.reason !== Types.Events.LayoutInvalidationReason.STYLE_CHANGED &&\n        layoutInvalidation.args.data.reason !== Types.Events.LayoutInvalidationReason.ADDED_TO_LAYOUT) {\n      return null;\n    }\n\n    const layoutInvalidationNode = await this.getNodeDetails(layoutInvalidationNodeId);\n    if (!layoutInvalidationNode) {\n      return null;\n    }\n\n    const iframe = firstIframeInDOMTree(layoutInvalidationNode);\n    if (!iframe) {\n      return null;\n    }\n    return {iframe};\n  }\n\n  async getNodeDetails(nodeId: Protocol.DOM.NodeId): Promise<Protocol.DOM.Node|null> {\n    let nodeDetails = this.#nodeDetailsCache.get(nodeId);\n    if (nodeDetails !== undefined) {\n      return nodeDetails;\n    }\n\n    nodeDetails = await this.#protocolInterface.getNode(nodeId);\n    this.#nodeDetailsCache.set(nodeId, nodeDetails);\n\n    return nodeDetails;\n  }\n\n  /**\n   * Given a layout invalidation event and a sorted array, returns the subset of requests that arrived within a\n   * 500ms window before the layout invalidation.\n   */\n  requestsInInvalidationWindow(\n      layoutInvalidation: Types.Events.LayoutInvalidationTracking|Types.Events.ScheduleStyleInvalidationTracking,\n      modelData: ParsedTrace): RootCauseRequest[] {\n    const requestsSortedByEndTime = modelData.NetworkRequests.byTime.sort((req1, req2) => {\n      const req1EndTime = req1.ts + req1.dur;\n      const req2EndTime = req2.ts + req2.dur;\n      return req1EndTime - req2EndTime;\n    });\n\n    const lastRequestIndex = Platform.ArrayUtilities.nearestIndexFromEnd(\n        requestsSortedByEndTime, request => request.ts + request.dur < layoutInvalidation.ts);\n    if (lastRequestIndex === null) {\n      return [];\n    }\n\n    const MAX_DELTA_FOR_FONT_REQUEST = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(0.5));\n\n    const requestsInInvalidationWindow: RootCauseRequest[] = [];\n\n    // Get all requests finished within the valid window.\n    for (let i = lastRequestIndex; i > -1; i--) {\n      const previousRequest = requestsSortedByEndTime[i];\n      const previousRequestEndTime = previousRequest.ts + previousRequest.dur;\n      if (layoutInvalidation.ts - previousRequestEndTime < MAX_DELTA_FOR_FONT_REQUEST) {\n        const requestInInvalidationWindow: RootCauseRequest = {request: previousRequest};\n\n        const initiator = this.#protocolInterface.getInitiatorForRequest(\n            previousRequest.args.data.url as Platform.DevToolsPath.UrlString);\n        requestInInvalidationWindow.initiator = initiator || undefined;\n        requestsInInvalidationWindow.push(requestInInvalidationWindow);\n      } else {\n        // No more requests fit in the time window.\n        break;\n      }\n    }\n    return requestsInInvalidationWindow;\n  }\n\n  /**\n   * Given a LayoutInvalidation trace event, determines if it was dispatched\n   * because fonts were changed and if so returns the information of all network\n   * request with which the fonts were possibly fetched, if any. The computed\n   * network requests are cached for the corresponding prepaint event, meaning\n   * that other LayoutInvalidation events that correspond to the same prepaint\n   * are not processed and the cached network requests for the prepaint is\n   * returned instead.\n   */\n  getFontChangeRootCause(\n      layoutInvalidation: Types.Events.LayoutInvalidationTracking|Types.Events.ScheduleStyleInvalidationTracking,\n      nextPrePaint: Types.Events.PrePaint, modelData: ParsedTrace): FontChange[]|null {\n    if (layoutInvalidation.args.data.reason !== Types.Events.LayoutInvalidationReason.FONTS_CHANGED) {\n      return null;\n    }\n    // Prevent computing the result of this function multiple times per PrePaint event.\n    const fontRequestsForPrepaint = fontRequestsByPrePaint.get(nextPrePaint);\n    if (fontRequestsForPrepaint !== undefined) {\n      return fontRequestsForPrepaint;\n    }\n\n    const fontRequestsInThisPrepaint =\n        this.getFontRequestsInInvalidationWindow(this.requestsInInvalidationWindow(layoutInvalidation, modelData));\n    fontRequestsByPrePaint.set(nextPrePaint, fontRequestsInThisPrepaint);\n    return fontRequestsInThisPrepaint;\n  }\n\n  /**\n   * Given the requests that arrived within a 500ms window before the layout invalidation, returns the font\n   * requests of them.\n   */\n  getFontRequestsInInvalidationWindow(requestsInInvalidationWindow: RootCauseRequest[]): FontChange[] {\n    const fontRequests: FontChange[] = [];\n\n    // Get all requests finished within the valid window.\n    for (let i = 0; i < requestsInInvalidationWindow.length; i++) {\n      const fontRequest = requestsInInvalidationWindow[i] as FontChange;\n      if (!fontRequest.request.args.data.mimeType.startsWith('font')) {\n        continue;\n      }\n\n      const fontFace = this.#protocolInterface.fontFaceForSource(fontRequest.request.args.data.url);\n      if (!fontFace || fontFace.fontDisplay === 'optional') {\n        // Setting font-display to optional is part of what the developer\n        // can do to avoid layout shifts due to FOIT/FOUT, as such we cannot\n        // suggest any actionable insight here.\n        continue;\n      }\n      fontRequest.fontFace = fontFace;\n      fontRequests.push(fontRequest);\n    }\n    return fontRequests;\n  }\n\n  /**\n   * Given a LayoutInvalidation trace event, determines if it arrived within a 500ms window before the layout\n   * invalidation and if so returns the information of all network request, if any. The computed network\n   * requests are cached for the corresponding prepaint event, meaning that other LayoutInvalidation events\n   * that correspond to the same prepaint are not processed and the cached network requests for the prepaint is\n   *  returned instead.\n   */\n  getRenderBlockRootCause(\n      layoutInvalidation: Types.Events.LayoutInvalidationTracking|Types.Events.ScheduleStyleInvalidationTracking,\n      nextPrePaint: Types.Events.PrePaint, modelData: ParsedTrace): RenderBlockingRequest[]|null {\n    // Prevent computing the result of this function multiple times per PrePaint event.\n    const renderBlocksInPrepaint = renderBlocksByPrePaint.get(nextPrePaint);\n    if (renderBlocksInPrepaint !== undefined) {\n      return renderBlocksInPrepaint;\n    }\n\n    const renderBlocksInThisPrepaint =\n        getRenderBlockRequestsInInvalidationWindow(this.requestsInInvalidationWindow(layoutInvalidation, modelData));\n    renderBlocksByPrePaint.set(nextPrePaint, renderBlocksInThisPrepaint);\n    return renderBlocksInThisPrepaint;\n  }\n\n  /**\n   * Returns a function that retrieves the active value of a given\n   * CSS property within the matched styles of the param node.\n   * The first occurence within the matched styles is returned and the\n   * value is looked up in the following order, which follows CSS\n   * specificity:\n   * 1. Inline styles.\n   * 2. CSS rules matching this node, from all applicable stylesheets.\n   * 3. Attribute defined styles.\n   */\n  async nodeMatchedStylesPropertyGetter(node: Protocol.DOM.Node): Promise<((property: string) => string | null)> {\n    const response = await this.#protocolInterface.getMatchedStylesForNode(node.nodeId);\n\n    function cssPropertyValueGetter(cssProperty: string): string|null {\n      let prop = response.inlineStyle?.cssProperties.find(prop => prop.name === cssProperty);\n      if (prop) {\n        return prop.value;\n      }\n\n      for (const {rule} of response.matchedCSSRules || []) {\n        const prop = rule.style.cssProperties.find(prop => prop.name === cssProperty);\n        if (prop) {\n          return prop.value;\n        }\n      }\n\n      prop = response.attributesStyle?.cssProperties.find(prop => prop.name === cssProperty);\n      if (prop) {\n        return prop.value;\n      }\n\n      return null;\n    }\n    return cssPropertyValueGetter;\n  }\n\n  /**\n   * Returns the CSS dimensions set to the node from its matched styles.\n   */\n  async getNodeAuthoredDimensions(node: Protocol.DOM.Node): Promise<CSSDimensions> {\n    const authoredDimensions: CSSDimensions = {};\n\n    const cssMatchedRulesGetter = await this.nodeMatchedStylesPropertyGetter(node);\n    if (!cssMatchedRulesGetter) {\n      return authoredDimensions;\n    }\n\n    const attributesFlat = node.attributes || [];\n    const attributes = [];\n    for (let i = 0; i < attributesFlat.length; i += 2) {\n      attributes.push({name: attributesFlat[i], value: attributesFlat[i + 1]});\n    }\n\n    const htmlHeight = attributes.find(attr => attr.name === 'height' && htmlAttributeIsExplicit(attr));\n    const htmlWidth = attributes.find(attr => attr.name === 'width' && htmlAttributeIsExplicit(attr));\n\n    const cssExplicitAspectRatio = cssMatchedRulesGetter('aspect-ratio') || undefined;\n\n    if (htmlHeight && htmlWidth && cssExplicitAspectRatio) {\n      return {height: htmlHeight.value, width: htmlWidth.value, aspectRatio: cssExplicitAspectRatio};\n    }\n\n    const cssHeight = cssMatchedRulesGetter('height') || undefined;\n    const cssWidth = cssMatchedRulesGetter('width') || undefined;\n    return {height: cssHeight, width: cssWidth, aspectRatio: cssExplicitAspectRatio};\n  }\n}\n\n/**\n * Given the requests that arrived within a 500ms window before the layout invalidation, returns the render\n * block requests of them.\n */\nfunction getRenderBlockRequestsInInvalidationWindow(requestsInInvalidationWindow: RootCauseRequest[]):\n    RenderBlockingRequest[] {\n  const renderBlockingRequests: RenderBlockingRequest[] = [];\n\n  // Get all requests finished within the valid window.\n  for (let i = 0; i < requestsInInvalidationWindow.length; i++) {\n    const mainFrameId = requestsInInvalidationWindow[i].request.args.data.frame;\n    if (!networkRequestIsRenderBlockingInFrame(requestsInInvalidationWindow[i].request, mainFrameId)) {\n      continue;\n    }\n    renderBlockingRequests.push(requestsInInvalidationWindow[i] as RenderBlockingRequest);\n  }\n  return renderBlockingRequests;\n}\n\nfunction firstIframeInDOMTree(root: Protocol.DOM.Node): Protocol.DOM.Node|null {\n  if (root.nodeName === 'IFRAME') {\n    return root;\n  }\n  const children = root.children;\n  if (!children) {\n    return null;\n  }\n  for (const child of children) {\n    const iFrameInChild = firstIframeInDOMTree(child);\n    if (iFrameInChild) {\n      return iFrameInChild;\n    }\n  }\n  return null;\n}\n\nfunction cssPropertyIsExplicitlySet(propertyValue: string): boolean {\n  return !['auto', 'initial', 'unset', 'inherit'].includes(propertyValue);\n}\n\nfunction htmlAttributeIsExplicit(attr: {value: string}): boolean {\n  return parseInt(attr.value, 10) >= 0;\n}\n\nfunction computedStyleHasBackroundImage(computedStyle: Map<string, string>): boolean {\n  const CSS_URL_REGEX = /^url\\(\"([^\"]+)\"\\)$/;\n  const backgroundImage = computedStyle.get('background-image');\n  if (!backgroundImage) {\n    return false;\n  }\n  return CSS_URL_REGEX.test(backgroundImage);\n}\n\nfunction computedStyleHasFixedPosition(computedStyle: Map<string, string>): boolean {\n  const position = computedStyle.get('position');\n  if (!position) {\n    return false;\n  }\n  return position === 'fixed' || position === 'absolute';\n}\n\nfunction getNodeComputedDimensions(computedStyle: Map<string, string>): CSSDimensions {\n  const computedDimensions: CSSDimensions = {};\n  computedDimensions.height = computedStyle.get('height');\n  computedDimensions.width = computedStyle.get('width');\n  computedDimensions.aspectRatio = computedStyle.get('aspect-ratio');\n  return computedDimensions;\n}\n\n/**\n * Determines if a node is a media element and is not fixed positioned\n * (i.e. \"position: fixed;\" or \"position: absolute;\")\n */\nasync function nodeIsUnfixedMedia(node: Protocol.DOM.Node, computedStyle: Map<string, string>): Promise<boolean> {\n  const localName = node.localName;\n  const isBackgroundImage = computedStyleHasBackroundImage(computedStyle);\n  if (localName !== 'img' && localName !== 'video' && !isBackgroundImage) {\n    // Not a media element.\n    return false;\n  }\n  const isFixed = computedStyleHasFixedPosition(computedStyle);\n  return !isFixed;\n}\n\n/**\n * Determines if a CSS dimensions object explicitly defines both width and height\n * (i.e. not set to auto, inherit, etc.)\n */\nfunction dimensionsAreExplicit(dimensions: CSSDimensions): boolean {\n  const {height, width, aspectRatio} = dimensions;\n\n  const explicitHeight = Boolean(height && cssPropertyIsExplicitlySet(height));\n  const explicitWidth = Boolean(width && cssPropertyIsExplicitlySet(width));\n  const explicitAspectRatio = Boolean(aspectRatio && cssPropertyIsExplicitlySet(aspectRatio));\n\n  const explicitWithAR = (explicitHeight || explicitWidth) && explicitAspectRatio;\n  return (explicitHeight && explicitWidth) || explicitWithAR;\n}\n\n/**\n * Given an array of layout shift and PrePaint events, returns a mapping from\n * PrePaint events to layout shifts dispatched within it.\n */\nfunction getShiftsByPrePaintEvents(\n    layoutShifts: Types.Events.LayoutShift[],\n    prePaintEvents: Types.Events.PrePaint[],\n    ): Map<Types.Events.PrePaint, Types.Events.LayoutShift[]> {\n  // Maps from PrePaint events to LayoutShifts that occured in each one.\n  const shiftsByPrePaint = new Map<Types.Events.PrePaint, Types.Events.LayoutShift[]>();\n\n  // Associate all shifts to their corresponding PrePaint.\n  for (const prePaintEvent of prePaintEvents) {\n    const firstShiftIndex =\n        Platform.ArrayUtilities.nearestIndexFromBeginning(layoutShifts, shift => shift.ts >= prePaintEvent.ts);\n    if (firstShiftIndex === null) {\n      // No layout shifts registered after this PrePaint start. Continue.\n      continue;\n    }\n    for (let i = firstShiftIndex; i < layoutShifts.length; i++) {\n      const shift = layoutShifts[i];\n      if (shift.ts >= prePaintEvent.ts && shift.ts <= prePaintEvent.ts + prePaintEvent.dur) {\n        const shiftsInPrePaint = Platform.MapUtilities.getWithDefault(shiftsByPrePaint, prePaintEvent, () => []);\n        shiftsInPrePaint.push(shift);\n      }\n      if (shift.ts > prePaintEvent.ts + prePaintEvent.dur) {\n        // Reached the end of this PrePaint. Continue to the next one.\n        break;\n      }\n    }\n  }\n  return shiftsByPrePaint;\n}\n"],
  "mappings": "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",
  "names": ["prop"]
}
