{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/AnimationFramesHandler.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\n\nexport interface Data {\n  animationFrames: Types.Events.SyntheticAnimationFramePair[];\n  presentationForFrame: Map<Types.Events.SyntheticAnimationFramePair, Types.Events.AnimationFramePresentation>;\n}\n\nfunction threadKey(data: Types.Events.Event): string {\n  return `${data.pid}-${data.tid}`;\n}\n// Track all the start + end events. We key them by the PID+TID so we don't\n// accidentally pair across different threads.\nconst animationFrameStarts: Map<string, Types.Events.AnimationFrameAsyncStart[]> = new Map();\nconst animationFrameEnds: Map<string, Types.Events.AnimationFrameAsyncEnd[]> = new Map();\n// Store all the AnimationFrame::Presentation events. Key them by their ID for\n// easy look-up later on when we associate one to the AnimationFrame event.\nconst animationFramePresentations: Map<string, Types.Events.AnimationFramePresentation> = new Map();\n\n// The final list of animation frames that we return.\nconst animationFrames: Types.Events.SyntheticAnimationFramePair[] = [];\n\nconst presentationForFrame: Map<Types.Events.SyntheticAnimationFramePair, Types.Events.AnimationFramePresentation> =\n    new Map();\n\nexport function reset(): void {\n  animationFrameStarts.clear();\n  animationFrameEnds.clear();\n  animationFrames.length = 0;\n  presentationForFrame.clear();\n  animationFramePresentations.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isAnimationFrameAsyncStart(event)) {\n    const key = threadKey(event);\n    const existing = animationFrameStarts.get(key) ?? [];\n    existing.push(event);\n    animationFrameStarts.set(key, existing);\n  } else if (Types.Events.isAnimationFrameAsyncEnd(event)) {\n    const key = threadKey(event);\n    const existing = animationFrameEnds.get(key) ?? [];\n    existing.push(event);\n    animationFrameEnds.set(key, existing);\n  } else if (Types.Events.isAnimationFramePresentation(event) && event.args?.id) {\n    animationFramePresentations.set(event.args.id, event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // AnimationFrames are represented with begin & end events on a stack; so we\n  // can pair them by walking through the list of start events and pairing with\n  // the same index in the list of end events, once both lists are sorted by\n  // timestamp.\n  // We walk through the set of begin/end events we gathered per pid+tid and\n  // pair those up.\n  // Unfortunately we cannot use the pairing helpers in Helpers.Trace because\n  // only the begin event has an ID; the end event does not. But because we\n  // know that AnimationFrames are sequential and do not overlap, we can pair\n  // up events easily.\n  for (const [key, startEvents] of animationFrameStarts.entries()) {\n    const endEvents = animationFrameEnds.get(key);\n    if (!endEvents) {\n      continue;\n    }\n\n    Helpers.Trace.sortTraceEventsInPlace(startEvents);\n    Helpers.Trace.sortTraceEventsInPlace(endEvents);\n\n    for (let i = 0; i < startEvents.length; i++) {\n      const endEvent = endEvents.at(i);\n      if (!endEvent) {\n        // Invalid data: break. We can't pair any other events up.\n        break;\n      }\n      const startEvent = startEvents[i];\n\n      const syntheticEvent = Helpers.SyntheticEvents.SyntheticEventsManager\n                                 .registerSyntheticEvent<Types.Events.SyntheticAnimationFramePair>({\n                                   rawSourceEvent: startEvent,\n                                   ...startEvent,\n                                   dur: Types.Timing.MicroSeconds(endEvent.ts - startEvent.ts),\n                                   args: {\n                                     data: {\n                                       beginEvent: startEvent,\n                                       endEvent,\n                                     },\n                                   },\n                                 });\n      animationFrames.push(syntheticEvent);\n\n      // AnimationFrame begin events + AnimationFrame::Presentation events share\n      // an args.id, so we can pair them up based on that.\n      const id = startEvent.args?.id;\n      if (id) {\n        const presentationEvent = animationFramePresentations.get(id);\n        if (presentationEvent) {\n          presentationForFrame.set(syntheticEvent, presentationEvent);\n        }\n      }\n    }\n  }\n}\n\nexport function data(): Data {\n  return {\n    animationFrames,\n    presentationForFrame,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n"],
  "mappings": ";AAGA,YAAY,aAAa;AACzB,YAAY,WAAW;AASvB,SAAS,UAAUA,OAAkC;AACnD,SAAO,GAAGA,MAAK,GAAG,IAAIA,MAAK,GAAG;AAChC;AAGA,MAAM,uBAA6E,oBAAI,IAAI;AAC3F,MAAM,qBAAyE,oBAAI,IAAI;AAGvF,MAAM,8BAAoF,oBAAI,IAAI;AAGlG,MAAM,kBAA8D,CAAC;AAErE,MAAM,uBACF,oBAAI,IAAI;AAEL,gBAAS,QAAc;AAC5B,uBAAqB,MAAM;AAC3B,qBAAmB,MAAM;AACzB,kBAAgB,SAAS;AACzB,uBAAqB,MAAM;AAC3B,8BAA4B,MAAM;AACpC;AAEO,gBAAS,YAAY,OAAiC;AAC3D,MAAI,MAAM,OAAO,2BAA2B,KAAK,GAAG;AAClD,UAAM,MAAM,UAAU,KAAK;AAC3B,UAAM,WAAW,qBAAqB,IAAI,GAAG,KAAK,CAAC;AACnD,aAAS,KAAK,KAAK;AACnB,yBAAqB,IAAI,KAAK,QAAQ;AAAA,EACxC,WAAW,MAAM,OAAO,yBAAyB,KAAK,GAAG;AACvD,UAAM,MAAM,UAAU,KAAK;AAC3B,UAAM,WAAW,mBAAmB,IAAI,GAAG,KAAK,CAAC;AACjD,aAAS,KAAK,KAAK;AACnB,uBAAmB,IAAI,KAAK,QAAQ;AAAA,EACtC,WAAW,MAAM,OAAO,6BAA6B,KAAK,KAAK,MAAM,MAAM,IAAI;AAC7E,gCAA4B,IAAI,MAAM,KAAK,IAAI,KAAK;AAAA,EACtD;AACF;AAEA,sBAAsB,WAA0B;AAW9C,aAAW,CAAC,KAAK,WAAW,KAAK,qBAAqB,QAAQ,GAAG;AAC/D,UAAM,YAAY,mBAAmB,IAAI,GAAG;AAC5C,QAAI,CAAC,WAAW;AACd;AAAA,IACF;AAEA,YAAQ,MAAM,uBAAuB,WAAW;AAChD,YAAQ,MAAM,uBAAuB,SAAS;AAE9C,aAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,YAAM,WAAW,UAAU,GAAG,CAAC;AAC/B,UAAI,CAAC,UAAU;AAEb;AAAA,MACF;AACA,YAAM,aAAa,YAAY,CAAC;AAEhC,YAAM,iBAAiB,QAAQ,gBAAgB,uBACnB,uBAAiE;AAAA,QAChE,gBAAgB;AAAA,QAChB,GAAG;AAAA,QACH,KAAK,MAAM,OAAO,aAAa,SAAS,KAAK,WAAW,EAAE;AAAA,QAC1D,MAAM;AAAA,UACJ,MAAM;AAAA,YACJ,YAAY;AAAA,YACZ;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAC5B,sBAAgB,KAAK,cAAc;AAInC,YAAM,KAAK,WAAW,MAAM;AAC5B,UAAI,IAAI;AACN,cAAM,oBAAoB,4BAA4B,IAAI,EAAE;AAC5D,YAAI,mBAAmB;AACrB,+BAAqB,IAAI,gBAAgB,iBAAiB;AAAA,QAC5D;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEO,gBAAS,OAAa;AAC3B,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEO,gBAAS,OAAsB;AACpC,SAAO,CAAC,MAAM;AAChB;",
  "names": ["data"]
}
