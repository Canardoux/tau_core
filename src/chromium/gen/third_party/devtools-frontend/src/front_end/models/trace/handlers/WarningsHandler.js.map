{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/WarningsHandler.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\nimport {data as userInteractionsHandlerData} from './UserInteractionsHandler.js';\n\nexport interface WarningsData {\n  // Tracks warnings keyed by the event.\n  perEvent: Map<Types.Events.Event, Warning[]>;\n  // The same data in reverse: for each type of warning, track the events.\n  // Useful if we need to enumerate events by type of issue\n  perWarning: Map<Warning, Types.Events.Event[]>;\n}\n\nexport type Warning = 'LONG_TASK'|'IDLE_CALLBACK_OVER_TIME'|'FORCED_REFLOW'|'LONG_INTERACTION';\n\nconst warningsPerEvent: WarningsData['perEvent'] = new Map();\nconst eventsPerWarning: WarningsData['perWarning'] = new Map();\n\n/**\n * Tracks the stack formed by nested trace events up to a given point\n */\nconst allEventsStack: Types.Events.Event[] = [];\n/**\n * Tracks the stack formed by JS invocation trace events up to a given point.\n * F.e. FunctionCall, EvaluateScript, V8Execute.\n * Not to be confused with ProfileCalls.\n */\nconst jsInvokeStack: Types.Events.Event[] = [];\n/**\n * Tracks reflow events in a task.\n */\nconst taskReflowEvents: Types.Events.Event[] = [];\n\nexport const FORCED_REFLOW_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(30));\n\nexport const LONG_MAIN_THREAD_TASK_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(50));\n\nexport function reset(): void {\n  warningsPerEvent.clear();\n  eventsPerWarning.clear();\n  allEventsStack.length = 0;\n  jsInvokeStack.length = 0;\n  taskReflowEvents.length = 0;\n}\n\nfunction storeWarning(event: Types.Events.Event, warning: Warning): void {\n  const existingWarnings = Platform.MapUtilities.getWithDefault(warningsPerEvent, event, () => []);\n  existingWarnings.push(warning);\n  warningsPerEvent.set(event, existingWarnings);\n\n  const existingEvents = Platform.MapUtilities.getWithDefault(eventsPerWarning, warning, () => []);\n  existingEvents.push(event);\n  eventsPerWarning.set(warning, existingEvents);\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  processForcedReflowWarning(event);\n  if (event.name === Types.Events.Name.RUN_TASK) {\n    const {duration} = Helpers.Timing.eventTimingsMicroSeconds(event);\n    if (duration > LONG_MAIN_THREAD_TASK_THRESHOLD) {\n      storeWarning(event, 'LONG_TASK');\n    }\n    return;\n  }\n\n  if (Types.Events.isFireIdleCallback(event)) {\n    const {duration} = Helpers.Timing.eventTimingsMilliSeconds(event);\n    if (duration > event.args.data.allottedMilliseconds) {\n      storeWarning(event, 'IDLE_CALLBACK_OVER_TIME');\n    }\n    return;\n  }\n}\n\n/**\n * Reflows* are added a warning to if:\n * 1. They are forced/sync, meaning they are invoked by JS and finish\n *    during the Script execution.\n * 2. Their duration exceeds a threshold.\n * - *Reflow: The style recalculation and layout steps in a render task.\n */\nfunction processForcedReflowWarning(event: Types.Events.Event): void {\n  // Update the event and the JS invocation stacks.\n  accomodateEventInStack(event, allEventsStack);\n  accomodateEventInStack(event, jsInvokeStack, /* pushEventToStack */ Types.Events.isJSInvocationEvent(event));\n  if (jsInvokeStack.length) {\n    // Current event falls inside a JS call.\n    if (event.name === Types.Events.Name.LAYOUT || event.name === Types.Events.Name.UPDATE_LAYOUT_TREE) {\n      // A forced reflow happened. However we need to check if\n      // the threshold is surpassed to add a warning. Accumulate the\n      // event to check for this after the current Task is over.\n      taskReflowEvents.push(event);\n      return;\n    }\n  }\n  if (allEventsStack.length === 1) {\n    // We hit a new task. Check if the forced reflows in the previous\n    // task exceeded the threshold and add a warning if so.\n    const totalTime = taskReflowEvents.reduce((time, event) => time + (event.dur || 0), 0);\n    if (totalTime >= FORCED_REFLOW_THRESHOLD) {\n      taskReflowEvents.forEach(reflowEvent => storeWarning(reflowEvent, 'FORCED_REFLOW'));\n    }\n    taskReflowEvents.length = 0;\n  }\n}\n\n/**\n * Updates a given trace event stack given a new event.\n */\nfunction accomodateEventInStack(event: Types.Events.Event, stack: Types.Events.Event[], pushEventToStack = true): void {\n  let nextItem = stack.at(-1);\n  while (nextItem && event.ts > nextItem.ts + (nextItem.dur || 0)) {\n    stack.pop();\n    nextItem = stack.at(-1);\n  }\n  if (!pushEventToStack) {\n    return;\n  }\n  stack.push(event);\n}\n\nexport function deps(): HandlerName[] {\n  return ['UserInteractions'];\n}\n\nexport async function finalize(): Promise<void> {\n  // These events do exist on the UserInteractionsHandler, but we also put\n  // them into the WarningsHandler so that the warnings handler can be the\n  // source of truth and the way to look up all warnings for a given event.\n  // Otherwise, we would have to look up warnings across multiple handlers for\n  // a given event, which will start to get messy very quickly.\n  const longInteractions = userInteractionsHandlerData().interactionsOverThreshold;\n  for (const interaction of longInteractions) {\n    storeWarning(interaction, 'LONG_INTERACTION');\n  }\n}\n\nexport function data(): WarningsData {\n  return {\n    perEvent: warningsPerEvent,\n    perWarning: eventsPerWarning,\n  };\n}\n"],
  "mappings": "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",
  "names": ["event"]
}
