{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/helpers/SamplesIntegrator.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\nimport {millisecondsToMicroseconds} from './Timing.js';\nimport {makeProfileCall, mergeEventsInOrder} from './Trace.js';\n\n/**\n * This is a helper that integrates CPU profiling data coming in the\n * shape of samples, with trace events. Samples indicate what the JS\n * stack trace looked at a given point in time, but they don't have\n * duration. The SamplesIntegrator task is to make an approximation\n * of what the duration of each JS call was, given the sample data and\n * given the trace events profiled during that time. At the end of its\n * execution, the SamplesIntegrator returns an array of ProfileCalls\n * (under SamplesIntegrator::buildProfileCalls()), which\n * represent JS calls, with a call frame and duration. These calls have\n * the shape of a complete trace events and can be treated as flame\n * chart entries in the timeline.\n *\n * The approach to build the profile calls consists in tracking the\n * current stack as the following events happen (in order):\n * 1. A sample was done.\n * 2. A trace event started.\n * 3. A trace event ended.\n * Depending on the event and on the data that's coming with it the\n * stack is updated by adding or removing JS calls to it and updating\n * the duration of the calls in the tracking stack.\n *\n * note: Although this approach has been implemented since long ago, and\n * is relatively efficent (adds a complexity over the trace parsing of\n * O(n) where n is the number of samples) it has proven to be faulty.\n * It might be worthwhile experimenting with improvements or with a\n * completely different approach. Improving the approach is tracked in\n * crbug.com/1417439\n */\nexport class SamplesIntegrator {\n  /**\n   * The result of runing the samples integrator. Holds the JS calls\n   * with their approximated duration after integrating samples into the\n   * trace event tree.\n   */\n  #constructedProfileCalls: Types.Events.SyntheticProfileCall[] = [];\n  /**\n   * tracks the state of the JS stack at each point in time to update\n   * the profile call durations as new events arrive. This doesn't only\n   * happen with new profile calls (in which case we would compare the\n   * stack in them) but also with trace events (in which case we would\n   * update the duration of the events we are tracking at the moment).\n   */\n  #currentJSStack: Types.Events.SyntheticProfileCall[] = [];\n  /**\n   * Process holding the CPU profile and trace events.\n   */\n  #processId: Types.Events.ProcessID;\n  /**\n   * Thread holding the CPU profile and trace events.\n   */\n  #threadId: Types.Events.ThreadID;\n  /**\n   * Tracks the depth of the JS stack at the moment a trace event starts\n   * or ends. It is assumed that for the duration of a trace event, the\n   * JS stack's depth cannot decrease, since JS calls that started\n   * before a trace event cannot end during the trace event. So as trace\n   * events arrive, we store the \"locked\" amount of JS frames that were\n   * in the stack before the event came.\n   */\n  #lockedJsStackDepth: number[] = [];\n  /**\n   * Used to keep track when samples should be integrated even if they\n   * are not children of invocation trace events. This is useful in\n   * cases where we can be missing the start of JS invocation events if\n   * we start tracing half-way through.\n   */\n  #fakeJSInvocation = false;\n  /**\n   * The parsed CPU profile, holding the tree hierarchy of JS frames and\n   * the sample data.\n   */\n  #profileModel: CPUProfile.CPUProfileDataModel.CPUProfileDataModel;\n  /**\n   * Because GC nodes don't have a stack, we artificially add a stack to\n   * them which corresponds to that of the previous sample. This map\n   * tracks which node is used for the stack of a GC call.\n   * Note that GC samples are not shown in the flamechart, however they\n   * are used during the construction of for profile calls, as we can\n   * infer information about the duration of the executed code when a\n   * GC node is sampled.\n   */\n  #nodeForGC = new Map<Types.Events.SyntheticProfileCall, CPUProfile.ProfileTreeModel.ProfileNode>();\n\n  #engineConfig: Types.Configuration.Configuration;\n  #profileId: Types.Events.ProfileID;\n\n  /**\n   * Keeps track of the individual samples from the CPU Profile.\n   * Only used with Debug Mode experiment enabled.\n   */\n  jsSampleEvents: Types.Events.SyntheticJSSample[] = [];\n\n  constructor(\n      profileModel: CPUProfile.CPUProfileDataModel.CPUProfileDataModel, profileId: Types.Events.ProfileID,\n      pid: Types.Events.ProcessID, tid: Types.Events.ThreadID, configuration?: Types.Configuration.Configuration) {\n    this.#profileModel = profileModel;\n    this.#threadId = tid;\n    this.#processId = pid;\n    this.#engineConfig = configuration || Types.Configuration.defaults();\n    this.#profileId = profileId;\n  }\n\n  buildProfileCalls(traceEvents: Types.Events.Event[]): Types.Events.SyntheticProfileCall[] {\n    const mergedEvents = mergeEventsInOrder(traceEvents, this.callsFromProfileSamples());\n    const stack = [];\n    for (let i = 0; i < mergedEvents.length; i++) {\n      const event = mergedEvents[i];\n      // Because instant trace events have no duration, they don't provide\n      // useful information for possible changes in the duration of calls\n      // in the JS stack.\n      if (event.ph === Types.Events.Phase.INSTANT) {\n        continue;\n      }\n      if (stack.length === 0) {\n        if (Types.Events.isProfileCall(event)) {\n          this.#onProfileCall(event);\n          continue;\n        }\n        stack.push(event);\n        this.#onTraceEventStart(event);\n        continue;\n      }\n\n      const parentEvent = stack.at(-1);\n      if (parentEvent === undefined) {\n        continue;\n      }\n      const begin = event.ts;\n      const parentBegin = parentEvent.ts;\n      const parentDuration = parentEvent.dur || 0;\n      const parentEnd = parentBegin + parentDuration;\n\n      const startsAfterParent = begin >= parentEnd;\n      if (startsAfterParent) {\n        this.#onTraceEventEnd(parentEvent);\n        stack.pop();\n        i--;\n        continue;\n      }\n      if (Types.Events.isProfileCall(event)) {\n        this.#onProfileCall(event, parentEvent);\n        continue;\n      }\n      this.#onTraceEventStart(event);\n      stack.push(event);\n    }\n    while (stack.length) {\n      const last = stack.pop();\n      if (last) {\n        this.#onTraceEventEnd(last);\n      }\n    }\n    return this.#constructedProfileCalls;\n  }\n\n  #onTraceEventStart(event: Types.Events.Event): void {\n    // Top level events cannot be nested into JS frames so we reset\n    // the stack when we find one.\n    if (event.name === Types.Events.Name.RUN_MICROTASKS || event.name === Types.Events.Name.RUN_TASK) {\n      this.#lockedJsStackDepth = [];\n      this.#truncateJSStack(0, event.ts);\n      this.#fakeJSInvocation = false;\n    }\n\n    if (this.#fakeJSInvocation) {\n      this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, event.ts);\n      this.#fakeJSInvocation = false;\n    }\n    this.#extractStackTrace(event);\n    // Keep track of the call frames in the stack before the event\n    // happened. For the duration of this event, these frames cannot\n    // change (none can be terminated before this event finishes).\n    //\n    // Also, every frame that is opened after this event, is considered\n    // to be a descendant of the event. So once the event finishes, the\n    // frames that were opened after it, need to be closed (see\n    // onEndEvent).\n    //\n    // TODO(crbug.com/1417439):\n    // The assumption that every frame opened after an event is a\n    // descendant of the event is incorrect. For example, a JS call that\n    // parents a trace event might have been sampled after the event was\n    // dispatched. In this case the JS call would be discarded if this\n    // event isn't an invocation event, otherwise the call will be\n    // considered a child of the event. In both cases, the result would\n    // be incorrect.\n    this.#lockedJsStackDepth.push(this.#currentJSStack.length);\n  }\n\n  #onProfileCall(event: Types.Events.SyntheticProfileCall, parent?: Types.Events.Event): void {\n    if ((parent && Types.Events.isJSInvocationEvent(parent)) || this.#fakeJSInvocation) {\n      this.#extractStackTrace(event);\n    } else if (Types.Events.isProfileCall(event) && this.#currentJSStack.length === 0) {\n      // Force JS Samples to show up even if we are not inside a JS\n      // invocation event, because we can be missing the start of JS\n      // invocation events if we start tracing half-way through. Pretend\n      // we have a top-level JS invocation event.\n      this.#fakeJSInvocation = true;\n      const stackDepthBefore = this.#currentJSStack.length;\n      this.#extractStackTrace(event);\n      this.#lockedJsStackDepth.push(stackDepthBefore);\n    }\n  }\n\n  #onTraceEventEnd(event: Types.Events.Event): void {\n    // Because the event has ended, any frames that happened after\n    // this event are terminated. Frames that are ancestors to this\n    // event are extended to cover its ending.\n    const endTime = Types.Timing.MicroSeconds(event.ts + (event.dur ?? 0));\n    this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, endTime);\n  }\n\n  /**\n   * Builds the initial calls with no duration from samples. Their\n   * purpose is to be merged with the trace event array being parsed so\n   * that they can be traversed in order with them and their duration\n   * can be updated as the SampleIntegrator callbacks are invoked.\n   */\n  callsFromProfileSamples(): Types.Events.SyntheticProfileCall[] {\n    const samples = this.#profileModel.samples;\n    const timestamps = this.#profileModel.timestamps;\n    const debugModeEnabled = this.#engineConfig.debugMode;\n    if (!samples) {\n      return [];\n    }\n    const calls: Types.Events.SyntheticProfileCall[] = [];\n    let prevNode;\n    for (let i = 0; i < samples.length; i++) {\n      const node = this.#profileModel.nodeByIndex(i);\n      const timestamp = millisecondsToMicroseconds(Types.Timing.MilliSeconds(timestamps[i]));\n      if (!node) {\n        continue;\n      }\n      const call = makeProfileCall(node, this.#profileId, i, timestamp, this.#processId, this.#threadId);\n      calls.push(call);\n\n      if (debugModeEnabled) {\n        this.jsSampleEvents.push(this.#makeJSSampleEvent(call, timestamp));\n      }\n      if (node.id === this.#profileModel.gcNode?.id && prevNode) {\n        // GC samples have no stack, so we just put GC node on top of the\n        // last recorded sample. Cache the previous sample for future\n        // reference.\n        this.#nodeForGC.set(call, prevNode);\n        continue;\n      }\n      prevNode = node;\n    }\n    return calls;\n  }\n\n  #makeProfileCallsForStack(profileCall: Types.Events.SyntheticProfileCall): Types.Events.SyntheticProfileCall[] {\n    let node = this.#profileModel.nodeById(profileCall.nodeId);\n    const isGarbageCollection = node?.id === this.#profileModel.gcNode?.id;\n    if (isGarbageCollection) {\n      // Because GC don't have a stack, we use the stack of the previous\n      // sample.\n      node = this.#nodeForGC.get(profileCall) || null;\n    }\n    if (!node) {\n      return [];\n    }\n    // `node.depth` is 0 based, so to set the size of the array we need\n    // to add 1 to its value.\n    const callFrames = new Array<Types.Events.SyntheticProfileCall>(node.depth + 1 + Number(isGarbageCollection));\n    // Add the stack trace in reverse order (bottom first).\n    let i = callFrames.length - 1;\n    if (isGarbageCollection) {\n      // Place the garbage collection call frame on top of the stack.\n      callFrames[i--] = profileCall;\n    }\n\n    // Many of these ProfileCalls will be GC'd later when we estimate the frame\n    // durations\n    while (node) {\n      callFrames[i--] = makeProfileCall(\n          node, profileCall.profileId, profileCall.sampleIndex, profileCall.ts, this.#processId, this.#threadId);\n      node = node.parent;\n    }\n    return callFrames;\n  }\n\n  /**\n   * Update tracked stack using this event's call stack.\n   */\n  #extractStackTrace(event: Types.Events.Event): void {\n    const stackTrace = Types.Events.isProfileCall(event) ? this.#makeProfileCallsForStack(event) : this.#currentJSStack;\n    SamplesIntegrator.filterStackFrames(stackTrace, this.#engineConfig);\n\n    const endTime = event.ts + (event.dur || 0);\n    const minFrames = Math.min(stackTrace.length, this.#currentJSStack.length);\n    let i;\n    // Merge a sample's stack frames with the stack frames we have\n    // so far if we detect they are equivalent.\n    // Graphically\n    // This:\n    // Current stack trace       Sample\n    // [-------A------]          [A]\n    // [-------B------]          [B]\n    // [-------C------]          [C]\n    //                ^ t = x1    ^ t = x2\n\n    // Becomes this:\n    // New stack trace after merge\n    // [--------A-------]\n    // [--------B-------]\n    // [--------C-------]\n    //                  ^ t = x2\n    for (i = this.#lockedJsStackDepth.at(-1) || 0; i < minFrames; ++i) {\n      const newFrame = stackTrace[i].callFrame;\n      const oldFrame = this.#currentJSStack[i].callFrame;\n      if (!SamplesIntegrator.framesAreEqual(newFrame, oldFrame)) {\n        break;\n      }\n      // Scoot the right edge of this callFrame to the right\n      this.#currentJSStack[i].dur =\n          Types.Timing.MicroSeconds(Math.max(this.#currentJSStack[i].dur || 0, endTime - this.#currentJSStack[i].ts));\n    }\n\n    // If there are call frames in the sample that differ with the stack\n    // we have, update the stack, but keeping the common frames in place\n    // Graphically\n    // This:\n    // Current stack trace       Sample\n    // [-------A------]          [A]\n    // [-------B------]          [B]\n    // [-------C------]          [C]\n    // [-------D------]          [E]\n    //                ^ t = x1    ^ t = x2\n    // Becomes this:\n    // New stack trace after merge\n    // [--------A-------]\n    // [--------B-------]\n    // [--------C-------]\n    //                [E]\n    //                  ^ t = x2\n    this.#truncateJSStack(i, event.ts);\n\n    for (; i < stackTrace.length; ++i) {\n      const call = stackTrace[i];\n      if (call.nodeId === this.#profileModel.programNode?.id || call.nodeId === this.#profileModel.root?.id ||\n          call.nodeId === this.#profileModel.idleNode?.id || call.nodeId === this.#profileModel.gcNode?.id) {\n        // Skip (root), (program) and (idle) frames, since this are not\n        // relevant for web profiling and we don't want to show them in\n        // the timeline.\n        continue;\n      }\n      this.#currentJSStack.push(call);\n      this.#constructedProfileCalls.push(call);\n    }\n  }\n\n  /**\n   * When a call stack that differs from the one we are tracking has\n   * been detected in the samples, the latter is \"truncated\" by\n   * setting the ending time of its call frames and removing the top\n   * call frames that aren't shared with the new call stack. This way,\n   * we can update the tracked stack with the new call frames on top.\n   * @param depth the amount of call frames from bottom to top that\n   * should be kept in the tracking stack trace. AKA amount of shared\n   * call frames between two stacks.\n   * @param time the new end of the call frames in the stack.\n   */\n  #truncateJSStack(depth: number, time: Types.Timing.MicroSeconds): void {\n    if (this.#lockedJsStackDepth.length) {\n      const lockedDepth = this.#lockedJsStackDepth.at(-1);\n      if (lockedDepth && depth < lockedDepth) {\n        console.error(`Child stack is shallower (${depth}) than the parent stack (${lockedDepth}) at ${time}`);\n        depth = lockedDepth;\n      }\n    }\n    if (this.#currentJSStack.length < depth) {\n      console.error(`Trying to truncate higher than the current stack size at ${time}`);\n      depth = this.#currentJSStack.length;\n    }\n    for (let k = 0; k < this.#currentJSStack.length; ++k) {\n      this.#currentJSStack[k].dur = Types.Timing.MicroSeconds(Math.max(time - this.#currentJSStack[k].ts, 0));\n    }\n    this.#currentJSStack.length = depth;\n  }\n\n  #makeJSSampleEvent(call: Types.Events.SyntheticProfileCall, timestamp: Types.Timing.MicroSeconds):\n      Types.Events.SyntheticJSSample {\n    const JSSampleEvent: Types.Events.SyntheticJSSample = {\n      name: Types.Events.Name.JS_SAMPLE,\n      cat: 'devtools.timeline',\n      args: {\n        data: {stackTrace: this.#makeProfileCallsForStack(call).map(e => e.callFrame)},\n      },\n      ph: Types.Events.Phase.INSTANT,\n      ts: timestamp,\n      dur: Types.Timing.MicroSeconds(0),\n      pid: this.#processId,\n      tid: this.#threadId,\n    };\n    return JSSampleEvent;\n  }\n\n  static framesAreEqual(frame1: Protocol.Runtime.CallFrame, frame2: Protocol.Runtime.CallFrame): boolean {\n    return frame1.scriptId === frame2.scriptId && frame1.functionName === frame2.functionName &&\n        frame1.lineNumber === frame2.lineNumber;\n  }\n\n  static showNativeName(name: string, runtimeCallStatsEnabled: boolean): boolean {\n    return runtimeCallStatsEnabled && Boolean(SamplesIntegrator.nativeGroup(name));\n  }\n\n  static nativeGroup(nativeName: string): 'Parse'|'Compile'|null {\n    if (nativeName.startsWith('Parse')) {\n      return 'Parse';\n    }\n    if (nativeName.startsWith('Compile') || nativeName.startsWith('Recompile')) {\n      return 'Compile';\n    }\n    return null;\n  }\n\n  static isNativeRuntimeFrame(frame: Protocol.Runtime.CallFrame): boolean {\n    return frame.url === 'native V8Runtime';\n  }\n\n  static filterStackFrames(stack: Types.Events.SyntheticProfileCall[], engineConfig: Types.Configuration.Configuration):\n      void {\n    const showAllEvents = engineConfig.showAllEvents;\n    if (showAllEvents) {\n      return;\n    }\n    let previousNativeFrameName: string|null = null;\n    let j = 0;\n    for (let i = 0; i < stack.length; ++i) {\n      const frame = stack[i].callFrame;\n      const nativeRuntimeFrame = SamplesIntegrator.isNativeRuntimeFrame(frame);\n      if (nativeRuntimeFrame &&\n          !SamplesIntegrator.showNativeName(frame.functionName, engineConfig.includeRuntimeCallStats)) {\n        continue;\n      }\n      const nativeFrameName = nativeRuntimeFrame ? SamplesIntegrator.nativeGroup(frame.functionName) : null;\n      if (previousNativeFrameName && previousNativeFrameName === nativeFrameName) {\n        continue;\n      }\n      previousNativeFrameName = nativeFrameName;\n      stack[j++] = stack[i];\n    }\n    stack.length = j;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
