{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/logs/RequestResolver.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport {Events as NetworkLogEvents, NetworkLog} from './NetworkLog.js';\n\n/**\n * A class that facilitates resolving a requestId to a network request. If the requestId does not resolve, a listener\n * is installed on the network request to wait for the request to appear. This is useful if an attempt to resolve the\n * requestId is made before the network request got reported.\n *\n * This functionality is intentionally provided in this class (instead of as part of NetworkLog) to enable clients\n * to control the duration of the wait and the lifetime of the associated promises by using the `clear` method on\n * this class.\n */\nexport class RequestResolver extends\n    Common.ResolverBase.ResolverBase<Protocol.Network.RequestId, SDK.NetworkRequest.NetworkRequest> {\n  private networkListener: Common.EventTarget.EventDescriptor|null = null;\n  private networkLog: NetworkLog;\n\n  constructor(networkLog: NetworkLog = NetworkLog.instance()) {\n    super();\n    this.networkLog = networkLog;\n  }\n\n  protected getForId(id: Protocol.Network.RequestId): SDK.NetworkRequest.NetworkRequest|null {\n    const requests = this.networkLog.requestsForId(id);\n    if (requests.length > 0) {\n      return requests[0];\n    }\n    return null;\n  }\n\n  private onRequestAdded(event: Common.EventTarget.EventTargetEvent<{request: SDK.NetworkRequest.NetworkRequest}>):\n      void {\n    const {request} = event.data;\n    const backendRequestId = request.backendRequestId();\n    if (backendRequestId) {\n      this.onResolve(backendRequestId, request);\n    }\n  }\n\n  protected override startListening(): void {\n    if (this.networkListener) {\n      return;\n    }\n    this.networkListener = this.networkLog.addEventListener(NetworkLogEvents.RequestAdded, this.onRequestAdded, this);\n  }\n\n  protected override stopListening(): void {\n    if (!this.networkListener) {\n      return;\n    }\n    Common.EventTarget.removeEventListeners([this.networkListener]);\n    this.networkListener = null;\n  }\n}\n"],
  "mappings": ";AAIA,YAAY,YAAY;AAIxB,SAAQ,UAAU,kBAAkB,kBAAiB;AAW9C,aAAM,wBACT,OAAO,aAAa,aAA4E;AAAA,EAC1F,kBAA2D;AAAA,EAC3D;AAAA,EAER,YAAY,aAAyB,WAAW,SAAS,GAAG;AAC1D,UAAM;AACN,SAAK,aAAa;AAAA,EACpB;AAAA,EAEU,SAAS,IAAwE;AACzF,UAAM,WAAW,KAAK,WAAW,cAAc,EAAE;AACjD,QAAI,SAAS,SAAS,GAAG;AACvB,aAAO,SAAS,CAAC;AAAA,IACnB;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,eAAe,OACd;AACP,UAAM,EAAC,QAAO,IAAI,MAAM;AACxB,UAAM,mBAAmB,QAAQ,iBAAiB;AAClD,QAAI,kBAAkB;AACpB,WAAK,UAAU,kBAAkB,OAAO;AAAA,IAC1C;AAAA,EACF;AAAA,EAEmB,iBAAuB;AACxC,QAAI,KAAK,iBAAiB;AACxB;AAAA,IACF;AACA,SAAK,kBAAkB,KAAK,WAAW,iBAAiB,iBAAiB,cAAc,KAAK,gBAAgB,IAAI;AAAA,EAClH;AAAA,EAEmB,gBAAsB;AACvC,QAAI,CAAC,KAAK,iBAAiB;AACzB;AAAA,IACF;AACA,WAAO,YAAY,qBAAqB,CAAC,KAAK,eAAe,CAAC;AAC9D,SAAK,kBAAkB;AAAA,EACzB;AACF;",
  "names": []
}
