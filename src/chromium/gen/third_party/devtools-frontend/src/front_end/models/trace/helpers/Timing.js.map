{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/helpers/Timing.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nimport {getNavigationForTraceEvent} from './Trace.js';\n\nexport const millisecondsToMicroseconds = (value: Types.Timing.MilliSeconds): Types.Timing.MicroSeconds =>\n    Types.Timing.MicroSeconds(value * 1000);\n\nexport const secondsToMilliseconds = (value: Types.Timing.Seconds): Types.Timing.MilliSeconds =>\n    Types.Timing.MilliSeconds(value * 1000);\n\nexport const secondsToMicroseconds = (value: Types.Timing.Seconds): Types.Timing.MicroSeconds =>\n    millisecondsToMicroseconds(secondsToMilliseconds(value));\n\nexport const microSecondsToMilliseconds = (value: Types.Timing.MicroSeconds): Types.Timing.MilliSeconds =>\n    Types.Timing.MilliSeconds(value / 1000);\n\nexport const microSecondsToSeconds = (value: Types.Timing.MicroSeconds): Types.Timing.Seconds =>\n    Types.Timing.Seconds(value / 1000 / 1000);\n\nexport function timeStampForEventAdjustedByClosestNavigation(\n    event: Types.Events.Event,\n    traceBounds: Types.Timing.TraceWindowMicroSeconds,\n    navigationsByNavigationId: Map<string, Types.Events.NavigationStart>,\n    navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>,\n    ): Types.Timing.MicroSeconds {\n  let eventTimeStamp = event.ts - traceBounds.min;\n  if (event.args?.data?.navigationId) {\n    const navigationForEvent = navigationsByNavigationId.get(event.args.data.navigationId);\n    if (navigationForEvent) {\n      eventTimeStamp = event.ts - navigationForEvent.ts;\n    }\n  } else if (event.args?.data?.frame) {\n    const navigationForEvent = getNavigationForTraceEvent(event, event.args.data.frame, navigationsByFrameId);\n    if (navigationForEvent) {\n      eventTimeStamp = event.ts - navigationForEvent.ts;\n    }\n  }\n  return Types.Timing.MicroSeconds(eventTimeStamp);\n}\n\n// Expands the trace window by a provided percentage or, if it the expanded window is smaller than 1 millisecond, expands it to 1 millisecond.\n// If the expanded window is outside of the max trace window, cut the overflowing bound to the max trace window bound.\nexport function expandWindowByPercentOrToOneMillisecond(\n    annotationWindow: Types.Timing.TraceWindowMicroSeconds, maxTraceWindow: Types.Timing.TraceWindowMicroSeconds,\n    percentage: number): Types.Timing.TraceWindowMicroSeconds {\n  // Expand min and max of the window by half of the provided percentage. That way, in total, the window will be expanded by the provided percentage.\n  let newMin = annotationWindow.min - annotationWindow.range * (percentage / 100) / 2;\n  let newMax = annotationWindow.max + annotationWindow.range * (percentage / 100) / 2;\n\n  if (newMax - newMin < 1_000) {\n    const rangeMiddle = (annotationWindow.min + annotationWindow.max) / 2;\n    newMin = rangeMiddle - 500;\n    newMax = rangeMiddle + 500;\n  }\n\n  newMin = Math.max(newMin, maxTraceWindow.min);\n  newMax = Math.min(newMax, maxTraceWindow.max);\n\n  const expandedWindow: Types.Timing.TraceWindowMicroSeconds = {\n    min: Types.Timing.MicroSeconds(newMin),\n    max: Types.Timing.MicroSeconds(newMax),\n    range: Types.Timing.MicroSeconds(newMax - newMin),\n  };\n\n  return expandedWindow;\n}\n\nexport interface EventTimingsData<\n  ValueType extends Types.Timing.MicroSeconds|Types.Timing.MilliSeconds|Types.Timing.Seconds,\n> {\n  startTime: ValueType;\n  endTime: ValueType;\n  duration: ValueType;\n}\n\nexport function eventTimingsMicroSeconds(event: Types.Events.Event): EventTimingsData<Types.Timing.MicroSeconds> {\n  return {\n    startTime: event.ts,\n    endTime: Types.Timing.MicroSeconds(event.ts + (event.dur ?? Types.Timing.MicroSeconds(0))),\n    duration: Types.Timing.MicroSeconds(event.dur || 0),\n  };\n}\nexport function eventTimingsMilliSeconds(event: Types.Events.Event): EventTimingsData<Types.Timing.MilliSeconds> {\n  const microTimes = eventTimingsMicroSeconds(event);\n  return {\n    startTime: microSecondsToMilliseconds(microTimes.startTime),\n    endTime: microSecondsToMilliseconds(microTimes.endTime),\n    duration: microSecondsToMilliseconds(microTimes.duration),\n  };\n}\nexport function eventTimingsSeconds(event: Types.Events.Event): EventTimingsData<Types.Timing.Seconds> {\n  const microTimes = eventTimingsMicroSeconds(event);\n  return {\n    startTime: microSecondsToSeconds(microTimes.startTime),\n    endTime: microSecondsToSeconds(microTimes.endTime),\n    duration: microSecondsToSeconds(microTimes.duration),\n  };\n}\n\nexport function traceWindowMilliSeconds(bounds: Types.Timing.TraceWindowMicroSeconds):\n    Types.Timing.TraceWindowMilliSeconds {\n  return {\n    min: microSecondsToMilliseconds(bounds.min),\n    max: microSecondsToMilliseconds(bounds.max),\n    range: microSecondsToMilliseconds(bounds.range),\n  };\n}\n\nexport function traceWindowMillisecondsToMicroSeconds(bounds: Types.Timing.TraceWindowMilliSeconds):\n    Types.Timing.TraceWindowMicroSeconds {\n  return {\n    min: millisecondsToMicroseconds(bounds.min),\n    max: millisecondsToMicroseconds(bounds.max),\n    range: millisecondsToMicroseconds(bounds.range),\n  };\n}\nexport function traceWindowMicroSecondsToMilliSeconds(bounds: Types.Timing.TraceWindowMicroSeconds):\n    Types.Timing.TraceWindowMilliSeconds {\n  return {\n    min: microSecondsToMilliseconds(bounds.min),\n    max: microSecondsToMilliseconds(bounds.max),\n    range: microSecondsToMilliseconds(bounds.range),\n  };\n}\n\nexport function traceWindowFromMilliSeconds(\n    min: Types.Timing.MilliSeconds, max: Types.Timing.MilliSeconds): Types.Timing.TraceWindowMicroSeconds {\n  const traceWindow: Types.Timing.TraceWindowMicroSeconds = {\n    min: millisecondsToMicroseconds(min),\n    max: millisecondsToMicroseconds(max),\n    range: Types.Timing.MicroSeconds(millisecondsToMicroseconds(max) - millisecondsToMicroseconds(min)),\n  };\n  return traceWindow;\n}\n\nexport function traceWindowFromMicroSeconds(\n    min: Types.Timing.MicroSeconds, max: Types.Timing.MicroSeconds): Types.Timing.TraceWindowMicroSeconds {\n  const traceWindow: Types.Timing.TraceWindowMicroSeconds = {\n    min,\n    max,\n    range: Types.Timing.MicroSeconds(max - min),\n  };\n  return traceWindow;\n}\n\nexport function traceWindowFromEvent(event: Types.Events.Event): Types.Timing.TraceWindowMicroSeconds {\n  return {\n    min: event.ts,\n    max: Types.Timing.MicroSeconds(event.ts + (event.dur ?? 0)),\n    range: event.dur ?? Types.Timing.MicroSeconds(0),\n  };\n}\n\nexport interface BoundsIncludeTimeRange {\n  timeRange: Types.Timing.TraceWindowMicroSeconds;\n  bounds: Types.Timing.TraceWindowMicroSeconds;\n}\n\n/**\n * Checks to see if the timeRange is within the bounds. By \"within\" we mean\n * \"has any overlap\":\n *         |------------------------|\n *      ==                                     no overlap (entirely before)\n *       =========                             overlap\n *            =========                        overlap\n *                             =========       overlap\n *                                     ====    no overlap (entirely after)\n *        ==============================       overlap (time range is larger than bounds)\n *         |------------------------|\n */\nexport function boundsIncludeTimeRange(data: BoundsIncludeTimeRange): boolean {\n  const {min: visibleMin, max: visibleMax} = data.bounds;\n  const {min: rangeMin, max: rangeMax} = data.timeRange;\n\n  return visibleMin <= rangeMax && visibleMax >= rangeMin;\n}\n\n/** Checks to see if the event is within or overlaps the bounds */\nexport function eventIsInBounds(event: Types.Events.Event, bounds: Types.Timing.TraceWindowMicroSeconds): boolean {\n  const startTime = event.ts;\n  return startTime <= bounds.max && bounds.min <= (startTime + (event.dur ?? 0));\n}\n\nexport function timestampIsInBounds(\n    bounds: Types.Timing.TraceWindowMicroSeconds, timestamp: Types.Timing.MicroSeconds): boolean {\n  return timestamp >= bounds.min && timestamp <= bounds.max;\n}\n\nexport interface WindowFitsInsideBounds {\n  window: Types.Timing.TraceWindowMicroSeconds;\n  bounds: Types.Timing.TraceWindowMicroSeconds;\n}\n\n/**\n * Returns true if the window fits entirely within the bounds.\n * Note that if the window is equivalent to the bounds, that is considered to fit\n */\nexport function windowFitsInsideBounds(data: WindowFitsInsideBounds): boolean {\n  return data.window.min >= data.bounds.min && data.window.max <= data.bounds.max;\n}\n\nexport function windowsEqual(\n    w1: Types.Timing.TraceWindowMicroSeconds, w2: Types.Timing.TraceWindowMicroSeconds): boolean {\n  return w1.min === w2.min && w1.max === w2.max;\n}\n"],
  "mappings": "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",
  "names": []
}
