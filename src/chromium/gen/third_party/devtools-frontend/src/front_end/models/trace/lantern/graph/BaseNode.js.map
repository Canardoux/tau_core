{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/graph/BaseNode.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport type * as Lantern from '../types/types.js';\n\nimport type {CPUNode} from './CPUNode.js';\nimport type {NetworkNode} from './NetworkNode.js';\n\n/**\n * A union of all types derived from BaseNode, allowing type check discrimination\n * based on `node.type`. If a new node type is created, it should be added here.\n */\nexport type Node<T = Lantern.AnyNetworkObject> = CPUNode<T>|NetworkNode<T>;\n\n/**\n * @fileoverview This class encapsulates logic for handling resources and tasks used to model the\n * execution dependency graph of the page. A node has a unique identifier and can depend on other\n * nodes/be depended on. The construction of the graph maintains some important invariants that are\n * inherent to the model:\n *\n *    1. The graph is a DAG, there are no cycles.\n *    2. There is always a root node upon which all other nodes eventually depend.\n *\n * This allows particular optimizations in this class so that we do no need to check for cycles as\n * these methods are called and we can always start traversal at the root node.\n */\n\nclass BaseNode<T = Lantern.AnyNetworkObject> {\n  static types = {\n    NETWORK: 'network',\n    CPU: 'cpu',\n  } as const;\n\n  _id: string;\n  _isMainDocument: boolean;\n  dependents: Node[];\n  dependencies: Node[];\n\n  constructor(id: string) {\n    this._id = id;\n    this._isMainDocument = false;\n    this.dependents = [];\n    this.dependencies = [];\n  }\n\n  get id(): string {\n    return this._id;\n  }\n\n  get type(): 'network'|'cpu' {\n    throw new Core.LanternError('Unimplemented');\n  }\n\n  /**\n   * In microseconds\n   */\n  get startTime(): number {\n    throw new Core.LanternError('Unimplemented');\n  }\n\n  /**\n   * In microseconds\n   */\n  get endTime(): number {\n    throw new Core.LanternError('Unimplemented');\n  }\n\n  setIsMainDocument(value: boolean): void {\n    this._isMainDocument = value;\n  }\n\n  isMainDocument(): boolean {\n    return this._isMainDocument;\n  }\n\n  getDependents(): Node[] {\n    return this.dependents.slice();\n  }\n\n  getNumberOfDependents(): number {\n    return this.dependents.length;\n  }\n\n  getDependencies(): Node[] {\n    return this.dependencies.slice();\n  }\n\n  getNumberOfDependencies(): number {\n    return this.dependencies.length;\n  }\n\n  getRootNode(): Node<T> {\n    let rootNode = this as BaseNode as Node;\n    while (rootNode.dependencies.length) {\n      rootNode = rootNode.dependencies[0];\n    }\n\n    return rootNode;\n  }\n\n  addDependent(node: Node): void {\n    node.addDependency(this as BaseNode as Node);\n  }\n\n  addDependency(node: Node): void {\n    // @ts-expect-error - in checkJs, ts doesn't know that CPUNode and NetworkNode *are* BaseNodes.\n    if (node === this) {\n      throw new Core.LanternError('Cannot add dependency on itself');\n    }\n\n    if (this.dependencies.includes(node)) {\n      return;\n    }\n\n    node.dependents.push(this as BaseNode as Node);\n    this.dependencies.push(node);\n  }\n\n  removeDependent(node: Node): void {\n    node.removeDependency(this as BaseNode as Node);\n  }\n\n  removeDependency(node: Node): void {\n    if (!this.dependencies.includes(node)) {\n      return;\n    }\n\n    const thisIndex = node.dependents.indexOf(this as BaseNode as Node);\n    node.dependents.splice(thisIndex, 1);\n    this.dependencies.splice(this.dependencies.indexOf(node), 1);\n  }\n\n  removeAllDependencies(): void {\n    for (const node of this.dependencies.slice()) {\n      this.removeDependency(node);\n    }\n  }\n\n  /**\n   * Computes whether the given node is anywhere in the dependency graph of this node.\n   * While this method can prevent cycles, it walks the graph and should be used sparingly.\n   * Nodes are always considered dependent on themselves for the purposes of cycle detection.\n   */\n  isDependentOn(node: BaseNode<T>): boolean {\n    let isDependentOnNode = false;\n    this.traverse(\n        currentNode => {\n          if (isDependentOnNode) {\n            return;\n          }\n          isDependentOnNode = currentNode === node;\n        },\n        currentNode => {\n          // If we've already found the dependency, don't traverse further.\n          if (isDependentOnNode) {\n            return [];\n          }\n          // Otherwise, traverse the dependencies.\n          return currentNode.getDependencies();\n        });\n\n    return isDependentOnNode;\n  }\n\n  /**\n   * Clones the node's information without adding any dependencies/dependents.\n   */\n  cloneWithoutRelationships(): Node<T> {\n    const node = new BaseNode(this.id) as Node<T>;\n    node.setIsMainDocument(this._isMainDocument);\n    return node;\n  }\n\n  /**\n   * Clones the entire graph connected to this node filtered by the optional predicate. If a node is\n   * included by the predicate, all nodes along the paths between the node and the root will be included. If the\n   * node this was called on is not included in the resulting filtered graph, the method will throw.\n   *\n   * This does not clone NetworkNode's `record` or `rawRecord` fields. It may be reasonable to clone the former,\n   * to assist in graph construction, but the latter should never be cloned as one contraint of Lantern is that\n   * the underlying data records are accessible for plain object reference equality checks.\n   */\n  cloneWithRelationships(predicate?: (arg0: Node) => boolean): Node {\n    const rootNode = this.getRootNode();\n\n    const idsToIncludedClones = new Map<string, Node>();\n\n    // Walk down dependents.\n    rootNode.traverse(node => {\n      if (idsToIncludedClones.has(node.id)) {\n        return;\n      }\n\n      if (predicate === undefined) {\n        // No condition for entry, so clone every node.\n        idsToIncludedClones.set(node.id, node.cloneWithoutRelationships());\n        return;\n      }\n\n      if (predicate(node)) {\n        // Node included, so walk back up dependencies, cloning nodes from here back to the root.\n        node.traverse(\n            node => idsToIncludedClones.set(node.id, node.cloneWithoutRelationships()),\n            // Dependencies already cloned have already cloned ancestors, so no need to visit again.\n            node => node.dependencies.filter(parent => !idsToIncludedClones.has(parent.id)),\n        );\n      }\n    });\n\n    // Copy dependencies between nodes.\n    rootNode.traverse(originalNode => {\n      const clonedNode = idsToIncludedClones.get(originalNode.id);\n      if (!clonedNode) {\n        return;\n      }\n\n      for (const dependency of originalNode.dependencies) {\n        const clonedDependency = idsToIncludedClones.get(dependency.id);\n        if (!clonedDependency) {\n          throw new Core.LanternError('Dependency somehow not cloned');\n        }\n        clonedNode.addDependency(clonedDependency);\n      }\n    });\n\n    const clonedThisNode = idsToIncludedClones.get(this.id);\n    if (!clonedThisNode) {\n      throw new Core.LanternError('Cloned graph missing node');\n    }\n    return clonedThisNode;\n  }\n\n  /**\n   * Traverses all connected nodes in BFS order, calling `callback` exactly once\n   * on each. `traversalPath` is the shortest (though not necessarily unique)\n   * path from `node` to the root of the iteration.\n   *\n   * The `getNextNodes` function takes a visited node and returns which nodes to\n   * visit next. It defaults to returning the node's dependents.\n   */\n  traverse(callback: (node: Node<T>, traversalPath: Node<T>[]) => void, getNextNodes?: (arg0: Node<T>) => Node<T>[]):\n      void {\n    for (const {node, traversalPath} of this.traverseGenerator(getNextNodes)) {\n      callback(node, traversalPath);\n    }\n  }\n\n  /**\n   * @see BaseNode.traverse\n   */\n  // clang-format off\n  *traverseGenerator(getNextNodes?: (arg0: Node) => Node[]):\n      Generator<{node: Node, traversalPath: Node[]}, void, unknown> {\n    // clang-format on\n    if (!getNextNodes) {\n      getNextNodes = node => node.getDependents();\n    }\n\n    // @ts-expect-error - only traverses graphs of Node, so force tsc to treat `this` as one\n    const queue: Node[][] = [[this]];\n    const visited = new Set([this.id]);\n\n    while (queue.length) {\n      // @ts-expect-error - queue has length so it's guaranteed to have an item\n      const traversalPath: Node[] = queue.shift();\n      const node = traversalPath[0];\n      yield {node, traversalPath};\n\n      for (const nextNode of getNextNodes(node)) {\n        if (visited.has(nextNode.id)) {\n          continue;\n        }\n        visited.add(nextNode.id);\n\n        queue.push([nextNode, ...traversalPath]);\n      }\n    }\n  }\n\n  /**\n   * Returns whether the given node has a cycle in its dependent graph by performing a DFS.\n   */\n  static hasCycle(node: Node, direction: 'dependents'|'dependencies'|'both' = 'both'): boolean {\n    // Checking 'both' is the default entrypoint to recursively check both directions\n    if (direction === 'both') {\n      return BaseNode.hasCycle(node, 'dependents') || BaseNode.hasCycle(node, 'dependencies');\n    }\n\n    const visited = new Set();\n    const currentPath: BaseNode[] = [];\n    const toVisit = [node];\n    const depthAdded = new Map([[node, 0]]);\n\n    // Keep going while we have nodes to visit in the stack\n    while (toVisit.length) {\n      // Get the last node in the stack (DFS uses stack, not queue)\n      // @ts-expect-error - toVisit has length so it's guaranteed to have an item\n      const currentNode: BaseNode = toVisit.pop();\n\n      // We've hit a cycle if the node we're visiting is in our current dependency path\n      if (currentPath.includes(currentNode)) {\n        return true;\n      }\n      // If we've already visited the node, no need to revisit it\n      if (visited.has(currentNode)) {\n        continue;\n      }\n\n      // Since we're visiting this node, clear out any nodes in our path that we had to backtrack\n      // @ts-expect-error\n      while (currentPath.length > depthAdded.get(currentNode)) {\n        currentPath.pop();\n      }\n\n      // Update our data structures to reflect that we're adding this node to our path\n      visited.add(currentNode);\n      currentPath.push(currentNode);\n\n      // Add all of its dependents to our toVisit stack\n      const nodesToExplore = direction === 'dependents' ? currentNode.dependents : currentNode.dependencies;\n      for (const nextNode of nodesToExplore) {\n        if (toVisit.includes(nextNode)) {\n          continue;\n        }\n        toVisit.push(nextNode);\n        depthAdded.set(nextNode, currentPath.length);\n      }\n    }\n\n    return false;\n  }\n\n  canDependOn(node: Node): boolean {\n    return node.startTime <= this.startTime;\n  }\n}\n\nexport {BaseNode};\n"],
  "mappings": "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",
  "names": ["node"]
}
