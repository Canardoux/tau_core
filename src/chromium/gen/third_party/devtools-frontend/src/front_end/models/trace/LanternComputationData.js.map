{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/LanternComputationData.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Protocol from '../../generated/protocol.js';\n\nimport * as Handlers from './handlers/handlers.js';\nimport * as Lantern from './lantern/lantern.js';\nimport type * as Types from './types/types.js';\n\ntype NetworkRequest = Lantern.Types.NetworkRequest<Types.Events.SyntheticNetworkRequest>;\n\nfunction createProcessedNavigation(parsedTrace: Handlers.Types.ParsedTrace, frameId: string, navigationId: string):\n    Lantern.Types.Simulation.ProcessedNavigation {\n  const scoresByNav = parsedTrace.PageLoadMetrics.metricScoresByFrameId.get(frameId);\n  if (!scoresByNav) {\n    throw new Lantern.Core.LanternError('missing metric scores for frame');\n  }\n\n  const scores = scoresByNav.get(navigationId);\n  if (!scores) {\n    throw new Lantern.Core.LanternError('missing metric scores for specified navigation');\n  }\n\n  const getTimestampOrUndefined =\n      (metric: Handlers.ModelHandlers.PageLoadMetrics.MetricName): Types.Timing.MicroSeconds|undefined => {\n        const metricScore = scores.get(metric);\n        if (!metricScore?.event) {\n          return;\n        }\n        return metricScore.event.ts;\n      };\n  const getTimestamp = (metric: Handlers.ModelHandlers.PageLoadMetrics.MetricName): Types.Timing.MicroSeconds => {\n    const metricScore = scores.get(metric);\n    if (!metricScore?.event) {\n      throw new Lantern.Core.LanternError(`missing metric: ${metric}`);\n    }\n    return metricScore.event.ts;\n  };\n  return {\n    timestamps: {\n      firstContentfulPaint: getTimestamp(Handlers.ModelHandlers.PageLoadMetrics.MetricName.FCP),\n      largestContentfulPaint: getTimestampOrUndefined(Handlers.ModelHandlers.PageLoadMetrics.MetricName.LCP),\n    },\n  };\n}\n\nfunction createParsedUrl(url: URL|string): Lantern.Types.ParsedURL {\n  if (typeof url === 'string') {\n    url = new URL(url);\n  }\n  return {\n    scheme: url.protocol.split(':')[0],\n    // Intentional, DevTools uses different terminology\n    host: url.hostname,\n    securityOrigin: url.origin,\n  };\n}\n\n/**\n * Returns a map of `pid` -> `tid[]`.\n */\nfunction findWorkerThreads(trace: Lantern.Types.Trace): Map<number, number[]> {\n  // TODO: WorkersHandler in Trace Engine needs to be updated to also include `pid` (only had `tid`).\n  const workerThreads = new Map();\n  const workerCreationEvents = ['ServiceWorker thread', 'DedicatedWorker thread'];\n\n  for (const event of trace.traceEvents) {\n    if (event.name !== 'thread_name' || !event.args.name) {\n      continue;\n    }\n    if (!workerCreationEvents.includes(event.args.name)) {\n      continue;\n    }\n\n    const tids = workerThreads.get(event.pid);\n    if (tids) {\n      tids.push(event.tid);\n    } else {\n      workerThreads.set(event.pid, [event.tid]);\n    }\n  }\n\n  return workerThreads;\n}\n\nfunction createLanternRequest(\n    parsedTrace: Readonly<Handlers.Types.ParsedTrace>, workerThreads: Map<number, number[]>,\n    request: Types.Events.SyntheticNetworkRequest): NetworkRequest|undefined {\n  if (request.args.data.connectionId === undefined || request.args.data.connectionReused === undefined) {\n    throw new Lantern.Core.LanternError('Trace is too old');\n  }\n\n  let url;\n  try {\n    url = new URL(request.args.data.url);\n  } catch (e) {\n    return;\n  }\n\n  const timing = request.args.data.timing ? {\n    // These two timings are not included in the trace.\n    workerFetchStart: -1,\n    workerRespondWithSettled: -1,\n    ...request.args.data.timing,\n  } :\n                                            undefined;\n\n  const networkRequestTime = timing ? timing.requestTime * 1000 : request.args.data.syntheticData.downloadStart / 1000;\n\n  let fromWorker = false;\n  const tids = workerThreads.get(request.pid);\n  if (tids?.includes(request.tid)) {\n    fromWorker = true;\n  }\n\n  // Trace Engine collects worker thread ids in a different manner than `workerThreads` does.\n  // AFAIK these should be equivalent, but in case they are not let's also check this for now.\n  if (parsedTrace.Workers.workerIdByThread.has(request.tid)) {\n    fromWorker = true;\n  }\n\n  // `initiator` in the trace does not contain the stack trace for JS-initiated\n  // requests. Instead, that is stored in the `stackTrace` property of the SyntheticNetworkRequest.\n  // There are some minor differences in the fields, accounted for here.\n  // Most importantly, there seems to be fewer frames in the trace than the equivalent\n  // events over the CDP. This results in less accuracy in determining the initiator request,\n  // which means less edges in the graph, which mean worse results.\n  // TODO: Should fix in Chromium.\n  const initiator: Lantern.Types.NetworkRequest['initiator'] =\n      request.args.data.initiator ?? {type: Protocol.Network.InitiatorType.Other};\n  if (request.args.data.stackTrace) {\n    const callFrames = request.args.data.stackTrace.map(f => {\n      return {\n        scriptId: String(f.scriptId) as Protocol.Runtime.ScriptId,\n        url: f.url,\n        lineNumber: f.lineNumber - 1,\n        columnNumber: f.columnNumber - 1,\n        functionName: f.functionName,\n      };\n    });\n    initiator.stack = {callFrames};\n    // Note: there is no `parent` to set ...\n  }\n\n  let resourceType = request.args.data.resourceType;\n  if (request.args.data.initiator?.fetchType === 'xmlhttprequest') {\n    // @ts-expect-error yes XHR is a valid ResourceType. TypeScript const enums are so unhelpful.\n    resourceType = 'XHR';\n  } else if (request.args.data.initiator?.fetchType === 'fetch') {\n    // @ts-expect-error yes Fetch is a valid ResourceType. TypeScript const enums are so unhelpful.\n    resourceType = 'Fetch';\n  }\n\n  // TODO: set decodedBodyLength for data urls in Trace Engine.\n  let resourceSize = request.args.data.decodedBodyLength ?? 0;\n  if (url.protocol === 'data:' && resourceSize === 0) {\n    const needle = 'base64,';\n    const index = url.pathname.indexOf(needle);\n    if (index !== -1) {\n      resourceSize = atob(url.pathname.substring(index + needle.length)).length;\n    }\n  }\n\n  return {\n    rawRequest: request,\n    requestId: request.args.data.requestId,\n    connectionId: request.args.data.connectionId,\n    connectionReused: request.args.data.connectionReused,\n    url: request.args.data.url,\n    protocol: request.args.data.protocol,\n    parsedURL: createParsedUrl(url),\n    documentURL: request.args.data.requestingFrameUrl,\n    rendererStartTime: request.ts / 1000,\n    networkRequestTime,\n    responseHeadersEndTime: request.args.data.syntheticData.downloadStart / 1000,\n    networkEndTime: request.args.data.syntheticData.finishTime / 1000,\n    transferSize: request.args.data.encodedDataLength,\n    resourceSize,\n    fromDiskCache: request.args.data.syntheticData.isDiskCached,\n    fromMemoryCache: request.args.data.syntheticData.isMemoryCached,\n    isLinkPreload: request.args.data.isLinkPreload,\n    finished: request.args.data.finished,\n    failed: request.args.data.failed,\n    statusCode: request.args.data.statusCode,\n    initiator,\n    timing,\n    resourceType,\n    mimeType: request.args.data.mimeType,\n    priority: request.args.data.priority,\n    frameId: request.args.data.frame,\n    fromWorker,\n    // Set later.\n    redirects: undefined,\n    redirectSource: undefined,\n    redirectDestination: undefined,\n    initiatorRequest: undefined,\n  };\n}\n\n/**\n * @param request The request to find the initiator of\n */\nfunction chooseInitiatorRequest(request: NetworkRequest, requestsByURL: Map<string, NetworkRequest[]>): NetworkRequest|\n    null {\n  if (request.redirectSource) {\n    return request.redirectSource;\n  }\n\n  const initiatorURL = Lantern.Graph.PageDependencyGraph.getNetworkInitiators(request)[0];\n  let candidates = requestsByURL.get(initiatorURL) || [];\n  // The (valid) initiator must come before the initiated request.\n  candidates = candidates.filter(c => {\n    return c.responseHeadersEndTime <= request.rendererStartTime && c.finished && !c.failed;\n  });\n  if (candidates.length > 1) {\n    // Disambiguate based on prefetch. Prefetch requests have type 'Other' and cannot\n    // initiate requests, so we drop them here.\n    const nonPrefetchCandidates =\n        candidates.filter(cand => cand.resourceType !== Lantern.Types.NetworkRequestTypes.Other);\n    if (nonPrefetchCandidates.length) {\n      candidates = nonPrefetchCandidates;\n    }\n  }\n  if (candidates.length > 1) {\n    // Disambiguate based on frame. It's likely that the initiator comes from the same frame.\n    const sameFrameCandidates = candidates.filter(cand => cand.frameId === request.frameId);\n    if (sameFrameCandidates.length) {\n      candidates = sameFrameCandidates;\n    }\n  }\n  if (candidates.length > 1 && request.initiator.type === 'parser') {\n    // Filter to just Documents when initiator type is parser.\n    const documentCandidates =\n        candidates.filter(cand => cand.resourceType === Lantern.Types.NetworkRequestTypes.Document);\n    if (documentCandidates.length) {\n      candidates = documentCandidates;\n    }\n  }\n  if (candidates.length > 1) {\n    // If all real loads came from successful preloads (url preloaded and\n    // loads came from the cache), filter to link rel=preload request(s).\n    const linkPreloadCandidates = candidates.filter(c => c.isLinkPreload);\n    if (linkPreloadCandidates.length) {\n      const nonPreloadCandidates = candidates.filter(c => !c.isLinkPreload);\n      const allPreloaded = nonPreloadCandidates.every(c => c.fromDiskCache || c.fromMemoryCache);\n      if (nonPreloadCandidates.length && allPreloaded) {\n        candidates = linkPreloadCandidates;\n      }\n    }\n  }\n\n  // Only return an initiator if the result is unambiguous.\n  return candidates.length === 1 ? candidates[0] : null;\n}\n\nfunction linkInitiators(lanternRequests: NetworkRequest[]): void {\n  const requestsByURL: Map<string, NetworkRequest[]> = new Map();\n  for (const request of lanternRequests) {\n    const requests = requestsByURL.get(request.url) || [];\n    requests.push(request);\n    requestsByURL.set(request.url, requests);\n  }\n\n  for (const request of lanternRequests) {\n    const initiatorRequest = chooseInitiatorRequest(request, requestsByURL);\n    if (initiatorRequest) {\n      request.initiatorRequest = initiatorRequest;\n    }\n  }\n}\n\nfunction createNetworkRequests(\n    trace: Lantern.Types.Trace, parsedTrace: Handlers.Types.ParsedTrace, startTime = 0,\n    endTime = Number.POSITIVE_INFINITY): NetworkRequest[] {\n  const workerThreads = findWorkerThreads(trace);\n\n  const lanternRequests: NetworkRequest[] = [];\n  for (const request of parsedTrace.NetworkRequests.byTime) {\n    if (request.ts >= startTime && request.ts < endTime) {\n      const lanternRequest = createLanternRequest(parsedTrace, workerThreads, request);\n      if (lanternRequest) {\n        lanternRequests.push(lanternRequest);\n      }\n    }\n  }\n\n  // Trace Engine consolidates all redirects into a single request object, but lantern needs\n  // an entry for each redirected request.\n  for (const request of [...lanternRequests]) {\n    if (!request.rawRequest) {\n      continue;\n    }\n\n    const redirects = request.rawRequest.args.data.redirects;\n    if (!redirects.length) {\n      continue;\n    }\n\n    const requestChain = [];\n    for (const redirect of redirects) {\n      const redirectedRequest = structuredClone(request);\n\n      redirectedRequest.networkRequestTime = redirect.ts / 1000;\n      redirectedRequest.rendererStartTime = redirectedRequest.networkRequestTime;\n\n      redirectedRequest.networkEndTime = (redirect.ts + redirect.dur) / 1000;\n      redirectedRequest.responseHeadersEndTime = redirectedRequest.networkEndTime;\n\n      redirectedRequest.timing = {\n        requestTime: redirectedRequest.networkRequestTime / 1000,\n        receiveHeadersStart: redirectedRequest.responseHeadersEndTime,\n        receiveHeadersEnd: redirectedRequest.responseHeadersEndTime,\n        proxyStart: -1,\n        proxyEnd: -1,\n        dnsStart: -1,\n        dnsEnd: -1,\n        connectStart: -1,\n        connectEnd: -1,\n        sslStart: -1,\n        sslEnd: -1,\n        sendStart: -1,\n        sendEnd: -1,\n        workerStart: -1,\n        workerReady: -1,\n        workerFetchStart: -1,\n        workerRespondWithSettled: -1,\n        pushStart: -1,\n        pushEnd: -1,\n      };\n\n      redirectedRequest.url = redirect.url;\n      redirectedRequest.parsedURL = createParsedUrl(redirect.url);\n      // TODO: Trace Engine is not retaining the actual status code.\n      redirectedRequest.statusCode = 302;\n      redirectedRequest.resourceType = undefined;\n      // TODO: Trace Engine is not retaining transfer size of redirected request.\n      redirectedRequest.transferSize = 400;\n      requestChain.push(redirectedRequest);\n      lanternRequests.push(redirectedRequest);\n    }\n    requestChain.push(request);\n\n    for (let i = 0; i < requestChain.length; i++) {\n      const request = requestChain[i];\n      if (i > 0) {\n        request.redirectSource = requestChain[i - 1];\n        request.redirects = requestChain.slice(0, i);\n      }\n      if (i !== requestChain.length - 1) {\n        request.redirectDestination = requestChain[i + 1];\n      }\n    }\n\n    // Apply the `:redirect` requestId convention: only redirects[0].requestId is the actual\n    // requestId, all the rest have n occurences of `:redirect` as a suffix.\n    for (let i = 1; i < requestChain.length; i++) {\n      requestChain[i].requestId = `${requestChain[i - 1].requestId}:redirect`;\n    }\n  }\n\n  linkInitiators(lanternRequests);\n\n  // This would already be sorted by rendererStartTime, if not for the redirect unwrapping done\n  // above.\n  return lanternRequests.sort((a, b) => a.rendererStartTime - b.rendererStartTime);\n}\n\nfunction collectMainThreadEvents(\n    trace: Lantern.Types.Trace, parsedTrace: Handlers.Types.ParsedTrace): Lantern.Types.TraceEvent[] {\n  const Meta = parsedTrace.Meta;\n  const mainFramePids = Meta.mainFrameNavigations.length ? new Set(Meta.mainFrameNavigations.map(nav => nav.pid)) :\n                                                           Meta.topLevelRendererIds;\n\n  const rendererPidToTid = new Map();\n  for (const pid of mainFramePids) {\n    const threads = Meta.threadsInProcess.get(pid) ?? [];\n\n    let found = false;\n    for (const [tid, thread] of threads) {\n      if (thread.args.name === 'CrRendererMain') {\n        rendererPidToTid.set(pid, tid);\n        found = true;\n        break;\n      }\n    }\n\n    if (found) {\n      continue;\n    }\n\n    // `CrRendererMain` can be missing if chrome is launched with the `--single-process` flag.\n    // In this case, page tasks will be run in the browser thread.\n    for (const [tid, thread] of threads) {\n      if (thread.args.name === 'CrBrowserMain') {\n        rendererPidToTid.set(pid, tid);\n        found = true;\n        break;\n      }\n    }\n  }\n\n  return trace.traceEvents.filter(e => rendererPidToTid.get(e.pid) === e.tid);\n}\n\nfunction createGraph(\n    requests: Lantern.Types.NetworkRequest[], trace: Lantern.Types.Trace, parsedTrace: Handlers.Types.ParsedTrace,\n    url?: Lantern.Types.Simulation.URL): Lantern.Graph.Node<Types.Events.SyntheticNetworkRequest> {\n  const mainThreadEvents = collectMainThreadEvents(trace, parsedTrace);\n\n  // url defines the initial request that the Lantern graph starts at (the root node) and the\n  // main document request. These are equal if there are no redirects.\n  if (!url) {\n    url = {\n      requestedUrl: requests[0].url,\n      mainDocumentUrl: '',\n    };\n\n    let request = requests[0];\n    while (request.redirectDestination) {\n      request = request.redirectDestination;\n    }\n    url.mainDocumentUrl = request.url;\n  }\n\n  return Lantern.Graph.PageDependencyGraph.createGraph(mainThreadEvents, requests, url);\n}\n\nexport {\n  createProcessedNavigation,\n  createNetworkRequests,\n  createGraph,\n};\n"],
  "mappings": "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",
  "names": ["request"]
}
