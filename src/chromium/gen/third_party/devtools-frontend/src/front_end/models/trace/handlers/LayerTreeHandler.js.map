{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/LayerTreeHandler.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\nconst paintEvents: Types.Events.Paint[] = [];\nconst snapshotEvents: Types.Events.DisplayItemListSnapshot[] = [];\nconst paintToSnapshotMap = new Map<Types.Events.Paint, Types.Events.DisplayItemListSnapshot>();\n\nlet lastPaintForLayerId: Record<number, Types.Events.Paint> = {};\n\nlet currentMainFrameLayerTreeId: number|null = null;\nconst updateLayerEvents: Types.Events.UpdateLayer[] = [];\n\ntype RelevantLayerTreeEvent =\n    Types.Events.Paint|Types.Events.DisplayItemListSnapshot|Types.Events.UpdateLayer|Types.Events.SetLayerTreeId;\n\nconst relevantEvents: RelevantLayerTreeEvent[] = [];\nexport function reset(): void {\n  paintEvents.length = 0;\n  snapshotEvents.length = 0;\n  paintToSnapshotMap.clear();\n\n  lastPaintForLayerId = {};\n  currentMainFrameLayerTreeId = null;\n  updateLayerEvents.length = 0;\n  relevantEvents.length = 0;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  // We gather up the events here but do all the processing in finalize(). This\n  // is because we need to have all the events before we process them, and we\n  // need the Meta handler to be finalized() so we can use its data as we need\n  // the mainFrameId to know which Layer(s) to care about.\n  if (Types.Events.isPaint(event) || Types.Events.isDisplayListItemListSnapshot(event) ||\n      Types.Events.isUpdateLayer(event) || Types.Events.isSetLayerId(event)) {\n    relevantEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const metaData = metaHandlerData();\n  Helpers.Trace.sortTraceEventsInPlace(relevantEvents);\n\n  for (const event of relevantEvents) {\n    if (Types.Events.isSetLayerId(event)) {\n      if (metaData.mainFrameId !== event.args.data.frame) {\n        // We only care about LayerId changes that affect the main frame.\n        continue;\n      }\n      currentMainFrameLayerTreeId = event.args.data.layerTreeId;\n    } else if (Types.Events.isUpdateLayer(event)) {\n      // We don't do anything with this event, but we need to store it because\n      // the information in it determines if we need to care about future\n      // snapshot events - we need to know what the active layer is when we see a\n      // snapshot.\n      updateLayerEvents.push(event);\n    } else if (Types.Events.isPaint(event)) {\n      if (!event.args.data.layerId) {\n        // Note that this check purposefully includes excluding an event with a layerId of 0.\n        // 0 indicates that this paint was for a subframe - we do not want these\n        // as we only care about paints for top level frames.\n        continue;\n      }\n      paintEvents.push(event);\n      lastPaintForLayerId[event.args.data.layerId] = event;\n      continue;\n    } else if (Types.Events.isDisplayListItemListSnapshot(event)) {\n      // First we figure out which layer is active for this event's thread. To\n      // do this we work backwards through the list of UpdateLayerEvents,\n      // finding the first one (i.e. the most recent one) with the same pid and\n      // tid.\n      let lastUpdateLayerEventForThread: Types.Events.UpdateLayer|null = null;\n      for (let i = updateLayerEvents.length - 1; i > -1; i--) {\n        const updateEvent = updateLayerEvents[i];\n        if (updateEvent.pid === event.pid && updateEvent.tid === event.tid) {\n          lastUpdateLayerEventForThread = updateEvent;\n          break;\n        }\n      }\n      if (!lastUpdateLayerEventForThread) {\n        // No active layer, so this snapshot is not relevant.\n        continue;\n      }\n      if (lastUpdateLayerEventForThread.args.layerTreeId !== currentMainFrameLayerTreeId) {\n        // Snapshot applies to a layer that is not the main frame, so discard.\n        continue;\n      }\n      const paintEvent = lastPaintForLayerId[lastUpdateLayerEventForThread.args.layerId];\n      if (!paintEvent) {\n        // No paint event for this layer, so discard.\n        continue;\n      }\n      snapshotEvents.push(event);\n\n      // Store the relationship between the paint and the snapshot.\n      paintToSnapshotMap.set(paintEvent, event);\n    }\n  }\n}\n\nexport interface LayerTreeData {\n  paints: Types.Events.Paint[];\n  snapshots: Types.Events.DisplayItemListSnapshot[];\n  paintsToSnapshots: Map<Types.Events.Paint, Types.Events.DisplayItemListSnapshot>;\n}\n\nexport function data(): LayerTreeData {\n  return {\n    paints: paintEvents,\n    snapshots: snapshotEvents,\n    paintsToSnapshots: paintToSnapshotMap,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n"],
  "mappings": ";AAIA,YAAY,aAAa;AACzB,YAAY,WAAW;AAEvB,SAAQ,QAAQ,uBAAsB;AAGtC,MAAM,cAAoC,CAAC;AAC3C,MAAM,iBAAyD,CAAC;AAChE,MAAM,qBAAqB,oBAAI,IAA8D;AAE7F,IAAI,sBAA0D,CAAC;AAE/D,IAAI,8BAA2C;AAC/C,MAAM,oBAAgD,CAAC;AAKvD,MAAM,iBAA2C,CAAC;AAC3C,gBAAS,QAAc;AAC5B,cAAY,SAAS;AACrB,iBAAe,SAAS;AACxB,qBAAmB,MAAM;AAEzB,wBAAsB,CAAC;AACvB,gCAA8B;AAC9B,oBAAkB,SAAS;AAC3B,iBAAe,SAAS;AAC1B;AAEO,gBAAS,YAAY,OAAiC;AAK3D,MAAI,MAAM,OAAO,QAAQ,KAAK,KAAK,MAAM,OAAO,8BAA8B,KAAK,KAC/E,MAAM,OAAO,cAAc,KAAK,KAAK,MAAM,OAAO,aAAa,KAAK,GAAG;AACzE,mBAAe,KAAK,KAAK;AAAA,EAC3B;AACF;AAEA,sBAAsB,WAA0B;AAC9C,QAAM,WAAW,gBAAgB;AACjC,UAAQ,MAAM,uBAAuB,cAAc;AAEnD,aAAW,SAAS,gBAAgB;AAClC,QAAI,MAAM,OAAO,aAAa,KAAK,GAAG;AACpC,UAAI,SAAS,gBAAgB,MAAM,KAAK,KAAK,OAAO;AAElD;AAAA,MACF;AACA,oCAA8B,MAAM,KAAK,KAAK;AAAA,IAChD,WAAW,MAAM,OAAO,cAAc,KAAK,GAAG;AAK5C,wBAAkB,KAAK,KAAK;AAAA,IAC9B,WAAW,MAAM,OAAO,QAAQ,KAAK,GAAG;AACtC,UAAI,CAAC,MAAM,KAAK,KAAK,SAAS;AAI5B;AAAA,MACF;AACA,kBAAY,KAAK,KAAK;AACtB,0BAAoB,MAAM,KAAK,KAAK,OAAO,IAAI;AAC/C;AAAA,IACF,WAAW,MAAM,OAAO,8BAA8B,KAAK,GAAG;AAK5D,UAAI,gCAA+D;AACnE,eAAS,IAAI,kBAAkB,SAAS,GAAG,IAAI,IAAI,KAAK;AACtD,cAAM,cAAc,kBAAkB,CAAC;AACvC,YAAI,YAAY,QAAQ,MAAM,OAAO,YAAY,QAAQ,MAAM,KAAK;AAClE,0CAAgC;AAChC;AAAA,QACF;AAAA,MACF;AACA,UAAI,CAAC,+BAA+B;AAElC;AAAA,MACF;AACA,UAAI,8BAA8B,KAAK,gBAAgB,6BAA6B;AAElF;AAAA,MACF;AACA,YAAM,aAAa,oBAAoB,8BAA8B,KAAK,OAAO;AACjF,UAAI,CAAC,YAAY;AAEf;AAAA,MACF;AACA,qBAAe,KAAK,KAAK;AAGzB,yBAAmB,IAAI,YAAY,KAAK;AAAA,IAC1C;AAAA,EACF;AACF;AAQO,gBAAS,OAAsB;AACpC,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,mBAAmB;AAAA,EACrB;AACF;AAEO,gBAAS,OAAsB;AACpC,SAAO,CAAC,MAAM;AAChB;",
  "names": []
}
