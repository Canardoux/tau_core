{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/simulation/Simulator.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Lantern from '../types/types.js';\n\nimport {ConnectionPool} from './ConnectionPool.js';\nimport {Constants} from './Constants.js';\nimport {DNSCache} from './DNSCache.js';\nimport {type CompleteNodeTiming, type ConnectionTiming, SimulatorTimingMap} from './SimulationTimingMap.js';\nimport {TCPConnection} from './TCPConnection.js';\n\nexport interface Result<T = Lantern.AnyNetworkObject> {\n  timeInMs: number;\n  nodeTimings: Map<Graph.Node<T>, Lantern.Simulation.NodeTiming>;\n}\n\nconst defaultThrottling = Constants.throttling.mobileSlow4G;\n\n// see https://cs.chromium.org/search/?q=kDefaultMaxNumDelayableRequestsPerClient&sq=package:chromium&type=cs\nconst DEFAULT_MAXIMUM_CONCURRENT_REQUESTS = 10;\n// layout tasks tend to be less CPU-bound and do not experience the same increase in duration\nconst DEFAULT_LAYOUT_TASK_MULTIPLIER = 0.5;\n// if a task takes more than 10 seconds it's usually a sign it isn't actually CPU bound and we're overestimating\nconst DEFAULT_MAXIMUM_CPU_TASK_DURATION = 10000;\n\nconst NodeState = {\n  NotReadyToStart: 0,\n  ReadyToStart: 1,\n  InProgress: 2,\n  Complete: 3,\n};\n\nconst PriorityStartTimePenalty: Record<Lantern.ResourcePriority, number> = {\n  VeryHigh: 0,\n  High: 0.25,\n  Medium: 0.5,\n  Low: 1,\n  VeryLow: 2,\n};\n\nconst ALL_SIMULATION_NODE_TIMINGS = new Map<string, Map<Graph.Node, CompleteNodeTiming>>();\n\nclass Simulator<T = Lantern.AnyNetworkObject> {\n  static createSimulator(settings: Lantern.Simulation.Settings): Simulator {\n    const {throttlingMethod, throttling, precomputedLanternData, networkAnalysis} = settings;\n\n    const options: Lantern.Simulation.Options = {\n      additionalRttByOrigin: networkAnalysis.additionalRttByOrigin,\n      serverResponseTimeByOrigin: networkAnalysis.serverResponseTimeByOrigin,\n      observedThroughput: networkAnalysis.throughput,\n    };\n\n    // If we have precomputed lantern data, overwrite our observed estimates and use precomputed instead\n    // for increased stability.\n    if (precomputedLanternData) {\n      options.additionalRttByOrigin = new Map(Object.entries(precomputedLanternData.additionalRttByOrigin));\n      options.serverResponseTimeByOrigin = new Map(Object.entries(precomputedLanternData.serverResponseTimeByOrigin));\n    }\n\n    switch (throttlingMethod) {\n      case 'provided':\n        options.rtt = networkAnalysis.rtt;\n        options.throughput = networkAnalysis.throughput;\n        options.cpuSlowdownMultiplier = 1;\n        options.layoutTaskMultiplier = 1;\n        break;\n      case 'devtools':\n        if (throttling) {\n          options.rtt = throttling.requestLatencyMs / Constants.throttling.DEVTOOLS_RTT_ADJUSTMENT_FACTOR;\n          options.throughput =\n              throttling.downloadThroughputKbps * 1024 / Constants.throttling.DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR;\n        }\n\n        options.cpuSlowdownMultiplier = 1;\n        options.layoutTaskMultiplier = 1;\n        break;\n      case 'simulate':\n        if (throttling) {\n          options.rtt = throttling.rttMs;\n          options.throughput = throttling.throughputKbps * 1024;\n          options.cpuSlowdownMultiplier = throttling.cpuSlowdownMultiplier;\n        }\n        break;\n      default:\n        // intentionally fallback to simulator defaults\n        break;\n    }\n\n    return new Simulator(options);\n  }\n\n  options: Required<Lantern.Simulation.Options>;\n  _rtt: number;\n  throughput: number;\n  maximumConcurrentRequests: number;\n  cpuSlowdownMultiplier: number;\n  layoutTaskMultiplier: number;\n  cachedNodeListByStartPosition: Graph.Node[];\n  nodeTimings: SimulatorTimingMap;\n  numberInProgressByType: Map<string, number>;\n  nodes: Record<number, Set<Graph.Node>>;\n  dns: DNSCache;\n  connectionPool: ConnectionPool;\n\n  constructor(options?: Lantern.Simulation.Options) {\n    this.options = Object.assign(\n        {\n          rtt: defaultThrottling.rttMs,\n          throughput: defaultThrottling.throughputKbps * 1024,\n          maximumConcurrentRequests: DEFAULT_MAXIMUM_CONCURRENT_REQUESTS,\n          cpuSlowdownMultiplier: defaultThrottling.cpuSlowdownMultiplier,\n          layoutTaskMultiplier: DEFAULT_LAYOUT_TASK_MULTIPLIER,\n          additionalRttByOrigin: new Map(),\n          serverResponseTimeByOrigin: new Map(),\n        },\n        options,\n    );\n\n    this._rtt = this.options.rtt;\n    this.throughput = this.options.throughput;\n    this.maximumConcurrentRequests = Math.max(\n        Math.min(\n            TCPConnection.maximumSaturatedConnections(this._rtt, this.throughput),\n            this.options.maximumConcurrentRequests,\n            ),\n        1);\n    this.cpuSlowdownMultiplier = this.options.cpuSlowdownMultiplier;\n    this.layoutTaskMultiplier = this.cpuSlowdownMultiplier * this.options.layoutTaskMultiplier;\n    this.cachedNodeListByStartPosition = [];\n\n    // Properties reset on every `.simulate` call but duplicated here for type checking\n    this.nodeTimings = new SimulatorTimingMap();\n    this.numberInProgressByType = new Map<string, number>();\n    this.nodes = {};\n    this.dns = new DNSCache({rtt: this._rtt});\n    // @ts-expect-error\n    this.connectionPool = null;\n\n    if (!Number.isFinite(this._rtt)) {\n      throw new Core.LanternError(`Invalid rtt ${this._rtt}`);\n    }\n    if (!Number.isFinite(this.throughput)) {\n      throw new Core.LanternError(`Invalid throughput ${this.throughput}`);\n    }\n  }\n\n  get rtt(): number {\n    return this._rtt;\n  }\n\n  initializeConnectionPool(graph: Graph.Node): void {\n    const records: Lantern.NetworkRequest[] = [];\n    graph.getRootNode().traverse(node => {\n      if (node.type === Graph.BaseNode.types.NETWORK) {\n        records.push(node.request);\n      }\n    });\n\n    this.connectionPool = new ConnectionPool(records, this.options);\n  }\n\n  /**\n   * Initializes the various state data structures such _nodeTimings and the _node Sets by state.\n   */\n  initializeAuxiliaryData(): void {\n    this.nodeTimings = new SimulatorTimingMap();\n    this.numberInProgressByType = new Map();\n\n    this.nodes = {};\n    this.cachedNodeListByStartPosition = [];\n    // NOTE: We don't actually need *all* of these sets, but the clarity that each node progresses\n    // through the system is quite nice.\n    for (const state of Object.values(NodeState)) {\n      this.nodes[state] = new Set();\n    }\n  }\n\n  numberInProgress(type: string): number {\n    return this.numberInProgressByType.get(type) || 0;\n  }\n\n  markNodeAsReadyToStart(node: Graph.Node, queuedTime: number): void {\n    const nodeStartPosition = Simulator.computeNodeStartPosition(node);\n    const firstNodeIndexWithGreaterStartPosition = this.cachedNodeListByStartPosition.findIndex(\n        candidate => Simulator.computeNodeStartPosition(candidate) > nodeStartPosition);\n    const insertionIndex = firstNodeIndexWithGreaterStartPosition === -1 ? this.cachedNodeListByStartPosition.length :\n                                                                           firstNodeIndexWithGreaterStartPosition;\n    this.cachedNodeListByStartPosition.splice(insertionIndex, 0, node);\n\n    this.nodes[NodeState.ReadyToStart].add(node);\n    this.nodes[NodeState.NotReadyToStart].delete(node);\n    this.nodeTimings.setReadyToStart(node, {queuedTime});\n  }\n\n  markNodeAsInProgress(node: Graph.Node, startTime: number): void {\n    const indexOfNodeToStart = this.cachedNodeListByStartPosition.indexOf(node);\n    this.cachedNodeListByStartPosition.splice(indexOfNodeToStart, 1);\n\n    this.nodes[NodeState.InProgress].add(node);\n    this.nodes[NodeState.ReadyToStart].delete(node);\n    this.numberInProgressByType.set(node.type, this.numberInProgress(node.type) + 1);\n    this.nodeTimings.setInProgress(node, {startTime});\n  }\n\n  markNodeAsComplete(node: Graph.Node, endTime: number, connectionTiming?: ConnectionTiming): void {\n    this.nodes[NodeState.Complete].add(node);\n    this.nodes[NodeState.InProgress].delete(node);\n    this.numberInProgressByType.set(node.type, this.numberInProgress(node.type) - 1);\n    this.nodeTimings.setCompleted(node, {endTime, connectionTiming});\n\n    // Try to add all its dependents to the queue\n    for (const dependent of node.getDependents()) {\n      // Skip dependent node if one of its dependencies hasn't finished yet\n      const dependencies = dependent.getDependencies();\n      if (dependencies.some(dep => !this.nodes[NodeState.Complete].has(dep))) {\n        continue;\n      }\n\n      // Otherwise add it to the queue\n      this.markNodeAsReadyToStart(dependent, endTime);\n    }\n  }\n\n  acquireConnection(request: Lantern.NetworkRequest): TCPConnection|null {\n    return this.connectionPool.acquire(request);\n  }\n\n  getNodesSortedByStartPosition(): Graph.Node[] {\n    // Make a copy so we don't skip nodes due to concurrent modification\n    return Array.from(this.cachedNodeListByStartPosition);\n  }\n\n  startNodeIfPossible(node: Graph.Node, totalElapsedTime: number): void {\n    if (node.type === Graph.BaseNode.types.CPU) {\n      // Start a CPU task if there's no other CPU task in process\n      if (this.numberInProgress(node.type) === 0) {\n        this.markNodeAsInProgress(node, totalElapsedTime);\n      }\n\n      return;\n    }\n\n    if (node.type !== Graph.BaseNode.types.NETWORK) {\n      throw new Core.LanternError('Unsupported');\n    }\n\n    // If a network request is connectionless, we can always start it, so skip the connection checks\n    if (!node.isConnectionless) {\n      // Start a network request if we're not at max requests and a connection is available\n      const numberOfActiveRequests = this.numberInProgress(node.type);\n      if (numberOfActiveRequests >= this.maximumConcurrentRequests) {\n        return;\n      }\n      const connection = this.acquireConnection(node.request);\n      if (!connection) {\n        return;\n      }\n    }\n\n    this.markNodeAsInProgress(node, totalElapsedTime);\n  }\n\n  /**\n   * Updates each connection in use with the available throughput based on the number of network requests\n   * currently in flight.\n   */\n  updateNetworkCapacity(): void {\n    const inFlight = this.numberInProgress(Graph.BaseNode.types.NETWORK);\n    if (inFlight === 0) {\n      return;\n    }\n\n    for (const connection of this.connectionPool.connectionsInUse()) {\n      connection.setThroughput(this.throughput / inFlight);\n    }\n  }\n\n  /**\n   * Estimates the number of milliseconds remaining given current condidtions before the node is complete.\n   */\n  estimateTimeRemaining(node: Graph.Node): number {\n    if (node.type === Graph.BaseNode.types.CPU) {\n      return this.estimateCPUTimeRemaining(node);\n    }\n    if (node.type === Graph.BaseNode.types.NETWORK) {\n      return this.estimateNetworkTimeRemaining(node);\n    }\n    throw new Core.LanternError('Unsupported');\n  }\n\n  estimateCPUTimeRemaining(cpuNode: Graph.CPUNode): number {\n    const timingData = this.nodeTimings.getCpuStarted(cpuNode);\n    const multiplier = cpuNode.didPerformLayout() ? this.layoutTaskMultiplier : this.cpuSlowdownMultiplier;\n    const totalDuration = Math.min(\n        Math.round(cpuNode.duration / 1000 * multiplier),\n        DEFAULT_MAXIMUM_CPU_TASK_DURATION,\n    );\n    const estimatedTimeElapsed = totalDuration - timingData.timeElapsed;\n    this.nodeTimings.setCpuEstimated(cpuNode, {estimatedTimeElapsed});\n    return estimatedTimeElapsed;\n  }\n\n  estimateNetworkTimeRemaining(networkNode: Graph.NetworkNode): number {\n    const request = networkNode.request;\n    const timingData = this.nodeTimings.getNetworkStarted(networkNode);\n\n    let timeElapsed = 0;\n    if (networkNode.fromDiskCache) {\n      // Rough access time for seeking to location on disk and reading sequentially.\n      // 8ms per seek + 20ms/MB\n      // @see http://norvig.com/21-days.html#answers\n      const sizeInMb = (request.resourceSize || 0) / 1024 / 1024;\n      timeElapsed = 8 + 20 * sizeInMb - timingData.timeElapsed;\n    } else if (networkNode.isNonNetworkProtocol) {\n      // Estimates for the overhead of a data URL in Chromium and the decoding time for base64-encoded data.\n      // 2ms per request + 10ms/MB\n      // @see traces on https://dopiaza.org/tools/datauri/examples/index.php\n      const sizeInMb = (request.resourceSize || 0) / 1024 / 1024;\n      timeElapsed = 2 + 10 * sizeInMb - timingData.timeElapsed;\n    } else {\n      const connection = this.connectionPool.acquireActiveConnectionFromRequest(request);\n      const dnsResolutionTime = this.dns.getTimeUntilResolution(request, {\n        requestedAt: timingData.startTime,\n        shouldUpdateCache: true,\n      });\n      const timeAlreadyElapsed = timingData.timeElapsed;\n      const calculation = connection.simulateDownloadUntil(\n          request.transferSize - timingData.bytesDownloaded,\n          {timeAlreadyElapsed, dnsResolutionTime, maximumTimeToElapse: Infinity},\n      );\n\n      timeElapsed = calculation.timeElapsed;\n    }\n\n    const estimatedTimeElapsed = timeElapsed + timingData.timeElapsedOvershoot;\n    this.nodeTimings.setNetworkEstimated(networkNode, {estimatedTimeElapsed});\n    return estimatedTimeElapsed;\n  }\n\n  /**\n   * Computes and returns the minimum estimated completion time of the nodes currently in progress.\n   */\n  findNextNodeCompletionTime(): number {\n    let minimumTime = Infinity;\n    for (const node of this.nodes[NodeState.InProgress]) {\n      minimumTime = Math.min(minimumTime, this.estimateTimeRemaining(node));\n    }\n\n    return minimumTime;\n  }\n\n  /**\n   * Given a time period, computes the progress toward completion that the node made durin that time.\n   */\n  updateProgressMadeInTimePeriod(node: Graph.Node, timePeriodLength: number, totalElapsedTime: number): void {\n    const timingData = this.nodeTimings.getInProgress(node);\n    const isFinished = timingData.estimatedTimeElapsed === timePeriodLength;\n\n    if (node.type === Graph.BaseNode.types.CPU || node.isConnectionless) {\n      if (isFinished) {\n        this.markNodeAsComplete(node, totalElapsedTime);\n      } else {\n        timingData.timeElapsed += timePeriodLength;\n      }\n      return;\n    }\n\n    if (node.type !== Graph.BaseNode.types.NETWORK) {\n      throw new Core.LanternError('Unsupported');\n    }\n    if (!('bytesDownloaded' in timingData)) {\n      throw new Core.LanternError('Invalid timing data');\n    }\n\n    const request = node.request;\n    const connection = this.connectionPool.acquireActiveConnectionFromRequest(request);\n    const dnsResolutionTime = this.dns.getTimeUntilResolution(request, {\n      requestedAt: timingData.startTime,\n      shouldUpdateCache: true,\n    });\n    const calculation = connection.simulateDownloadUntil(\n        request.transferSize - timingData.bytesDownloaded,\n        {\n          dnsResolutionTime,\n          timeAlreadyElapsed: timingData.timeElapsed,\n          maximumTimeToElapse: timePeriodLength - timingData.timeElapsedOvershoot,\n        },\n    );\n\n    connection.setCongestionWindow(calculation.congestionWindow);\n    connection.setH2OverflowBytesDownloaded(calculation.extraBytesDownloaded);\n\n    if (isFinished) {\n      connection.setWarmed(true);\n      this.connectionPool.release(request);\n      this.markNodeAsComplete(node, totalElapsedTime, calculation.connectionTiming);\n    } else {\n      timingData.timeElapsed += calculation.timeElapsed;\n      timingData.timeElapsedOvershoot += calculation.timeElapsed - timePeriodLength;\n      timingData.bytesDownloaded += calculation.bytesDownloaded;\n    }\n  }\n\n  computeFinalNodeTimings(): {\n    nodeTimings: Map<Graph.Node, Lantern.Simulation.NodeTiming>,\n    completeNodeTimings: Map<Graph.Node, CompleteNodeTiming>,\n  } {\n    const completeNodeTimingEntries: Array<[Graph.Node, CompleteNodeTiming]> = this.nodeTimings.getNodes().map(node => {\n      return [node, this.nodeTimings.getCompleted(node)];\n    });\n\n    // Most consumers will want the entries sorted by startTime, so insert them in that order\n    completeNodeTimingEntries.sort((a, b) => a[1].startTime - b[1].startTime);\n\n    // Trimmed version of type `Lantern.Simulation.NodeTiming`.\n    const nodeTimingEntries: Array<[Graph.Node, Lantern.Simulation.NodeTiming]> =\n        completeNodeTimingEntries.map(([node, timing]) => {\n          return [\n            node,\n            {\n              startTime: timing.startTime,\n              endTime: timing.endTime,\n              duration: timing.endTime - timing.startTime,\n            },\n          ];\n        });\n\n    return {\n      nodeTimings: new Map(nodeTimingEntries),\n      completeNodeTimings: new Map(completeNodeTimingEntries),\n    };\n  }\n\n  getOptions(): Required<Lantern.Simulation.Options> {\n    return this.options;\n  }\n\n  /**\n   * Estimates the time taken to process all of the graph's nodes, returns the overall time along with\n   * each node annotated by start/end times.\n   *\n   * Simulator/connection pool are allowed to deviate from what was\n   * observed in the trace/devtoolsLog and start requests as soon as they are queued (i.e. do not\n   * wait around for a warm connection to be available if the original request was fetched on a warm\n   * connection).\n   */\n  simulate(graph: Graph.Node, options?: {label?: string}): Result<T> {\n    if (Graph.BaseNode.hasCycle(graph)) {\n      throw new Core.LanternError('Cannot simulate graph with cycle');\n    }\n\n    options = Object.assign(\n        {\n          label: undefined,\n        },\n        options);\n\n    // initialize the necessary data containers\n    this.dns = new DNSCache({rtt: this._rtt});\n    this.initializeConnectionPool(graph);\n    this.initializeAuxiliaryData();\n\n    const nodesNotReadyToStart = this.nodes[NodeState.NotReadyToStart];\n    const nodesReadyToStart = this.nodes[NodeState.ReadyToStart];\n    const nodesInProgress = this.nodes[NodeState.InProgress];\n\n    const rootNode = graph.getRootNode();\n    rootNode.traverse(node => nodesNotReadyToStart.add(node));\n    let totalElapsedTime = 0;\n    let iteration = 0;\n\n    // root node is always ready to start\n    this.markNodeAsReadyToStart(rootNode, totalElapsedTime);\n\n    // loop as long as we have nodes in the queue or currently in progress\n    while (nodesReadyToStart.size || nodesInProgress.size) {\n      // move all possible queued nodes to in progress\n      for (const node of this.getNodesSortedByStartPosition()) {\n        this.startNodeIfPossible(node, totalElapsedTime);\n      }\n\n      if (!nodesInProgress.size) {\n        // Interplay between fromDiskCache and connectionReused can be incorrect,\n        // have to give up.\n        throw new Core.LanternError('Failed to start a node');\n      }\n\n      // set the available throughput for all connections based on # inflight\n      this.updateNetworkCapacity();\n\n      // find the time that the next node will finish\n      const minimumTime = this.findNextNodeCompletionTime();\n      totalElapsedTime += minimumTime;\n\n      // While this is no longer strictly necessary, it's always better than hanging\n      if (!Number.isFinite(minimumTime) || iteration > 100000) {\n        throw new Core.LanternError('Simulation failed, depth exceeded');\n      }\n\n      iteration++;\n      // update how far each node will progress until that point\n      for (const node of nodesInProgress) {\n        this.updateProgressMadeInTimePeriod(node, minimumTime, totalElapsedTime);\n      }\n    }\n\n    // `nodeTimings` are used for simulator consumers, `completeNodeTimings` kept for debugging.\n    const {nodeTimings, completeNodeTimings} = this.computeFinalNodeTimings();\n    ALL_SIMULATION_NODE_TIMINGS.set(options.label || 'unlabeled', completeNodeTimings);\n\n    return {\n      timeInMs: totalElapsedTime,\n      nodeTimings,\n    };\n  }\n\n  computeWastedMsFromWastedBytes(wastedBytes: number): number {\n    const {throughput, observedThroughput} = this.options;\n\n    // https://github.com/GoogleChrome/lighthouse/pull/13323#issuecomment-962031709\n    // 0 throughput means the no (additional) throttling is expected.\n    // This is common for desktop + devtools throttling where throttling is additive and we don't want any additional.\n    const bitsPerSecond = throughput === 0 ? observedThroughput : throughput;\n    if (bitsPerSecond === 0) {\n      return 0;\n    }\n\n    const wastedBits = wastedBytes * 8;\n    const wastedMs = wastedBits / bitsPerSecond * 1000;\n\n    // This is an estimate of wasted time, so we won't be more precise than 10ms.\n    return Math.round(wastedMs / 10) * 10;\n  }\n\n  static get allNodeTimings(): Map<string, Map<Graph.Node, CompleteNodeTiming>> {\n    return ALL_SIMULATION_NODE_TIMINGS;\n  }\n\n  /**\n   * We attempt to start nodes by their observed start time using the request priority as a tie breaker.\n   * When simulating, just because a low priority image started 5ms before a high priority image doesn't mean\n   * it would have happened like that when the network was slower.\n   */\n  static computeNodeStartPosition(node: Graph.Node): number {\n    if (node.type === 'cpu') {\n      return node.startTime;\n    }\n    return node.startTime + (PriorityStartTimePenalty[node.request.priority] * 1000 * 1000 || 0);\n  }\n}\n\nexport {Simulator};\n"],
  "mappings": "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",
  "names": []
}
