{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/metrics/MaxPotentialFID.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\n\nclass MaxPotentialFID extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  static override getOptimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getPessimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulation: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.fcpResult) {\n      throw new Core.LanternError('missing fcpResult');\n    }\n\n    // Intentionally use the opposite FCP estimate, a more pessimistic FCP means that more tasks\n    // are excluded from the FID computation, so a higher FCP means lower FID for same work.\n    const fcpTimeInMs = extras.optimistic ? extras.fcpResult.pessimisticEstimate.timeInMs :\n                                            extras.fcpResult.optimisticEstimate.timeInMs;\n\n    const timings = MaxPotentialFID.getTimingsAfterFCP(\n        simulation.nodeTimings,\n        fcpTimeInMs,\n    );\n\n    return {\n      timeInMs: Math.max(...timings.map(timing => timing.duration), 16),\n      nodeTimings: simulation.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the Max Potential FID metric');\n    }\n\n    return super.compute(data, extras);\n  }\n\n  static getTimingsAfterFCP(nodeTimings: Simulation.Result['nodeTimings'], fcpTimeInMs: number):\n      Array<{duration: number}> {\n    return Array.from(nodeTimings.entries())\n        .filter(([node, timing]) => node.type === Graph.BaseNode.types.CPU && timing.endTime > fcpTimeInMs)\n        .map(([_, timing]) => timing);\n  }\n}\n\nexport {MaxPotentialFID};\n"],
  "mappings": ";AAIA,YAAY,UAAU;AACtB,YAAY,WAAW;AAGvB;AAAA,EAEE;AAAA,OAIK;AAEP,MAAM,wBAAwB,OAAO;AAAA,EACnC,WAAoB,eAAmC;AACrD,WAAO;AAAA,MACL,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,aAAa;AAAA,IACf;AAAA,EACF;AAAA,EAEA,OAAgB,mBAAmB,iBAAyC;AAC1E,WAAO;AAAA,EACT;AAAA,EAEA,OAAgB,oBAAoB,iBAAyC;AAC3E,WAAO;AAAA,EACT;AAAA,EAEA,OAAgB,0BAA0B,YAA+B,QAAmC;AAC1G,QAAI,CAAC,OAAO,WAAW;AACrB,YAAM,IAAI,KAAK,aAAa,mBAAmB;AAAA,IACjD;AAIA,UAAM,cAAc,OAAO,aAAa,OAAO,UAAU,oBAAoB,WACrC,OAAO,UAAU,mBAAmB;AAE5E,UAAM,UAAU,gBAAgB;AAAA,MAC5B,WAAW;AAAA,MACX;AAAA,IACJ;AAEA,WAAO;AAAA,MACL,UAAU,KAAK,IAAI,GAAG,QAAQ,IAAI,YAAU,OAAO,QAAQ,GAAG,EAAE;AAAA,MAChE,aAAa,WAAW;AAAA,IAC1B;AAAA,EACF;AAAA,EAEA,OAAgB,QAAQ,MAAkC,QAAmD;AAC3G,UAAM,YAAY,QAAQ;AAC1B,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,KAAK,aAAa,2DAA2D;AAAA,IACzF;AAEA,WAAO,MAAM,QAAQ,MAAM,MAAM;AAAA,EACnC;AAAA,EAEA,OAAO,mBAAmB,aAA+C,aAC3C;AAC5B,WAAO,MAAM,KAAK,YAAY,QAAQ,CAAC,EAClC,OAAO,CAAC,CAAC,MAAM,MAAM,MAAM,KAAK,SAAS,MAAM,SAAS,MAAM,OAAO,OAAO,UAAU,WAAW,EACjG,IAAI,CAAC,CAAC,GAAG,MAAM,MAAM,MAAM;AAAA,EAClC;AACF;AAEA,SAAQ;",
  "names": []
}
