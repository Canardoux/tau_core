{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/simulation/TCPConnection.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {ConnectionTiming} from './SimulationTimingMap.js';\n\ninterface DownloadOptions {\n  dnsResolutionTime?: number;\n  timeAlreadyElapsed?: number;\n  maximumTimeToElapse?: number;\n}\n\ninterface DownloadResults {\n  roundTrips: number;\n  timeElapsed: number;\n  bytesDownloaded: number;\n  extraBytesDownloaded: number;\n  congestionWindow: number;\n  connectionTiming: ConnectionTiming;\n}\n\nconst INITIAL_CONGESTION_WINDOW = 10;\nconst TCP_SEGMENT_SIZE = 1460;\n\nclass TCPConnection {\n  warmed: boolean;\n  ssl: boolean;\n  h2: boolean;\n  rtt: number;\n  throughput: number;\n  serverLatency: number;\n  _congestionWindow: number;\n  h2OverflowBytesDownloaded: number;\n\n  constructor(rtt: number, throughput: number, serverLatency = 0, ssl = true, h2 = false) {\n    this.warmed = false;\n    this.ssl = ssl;\n    this.h2 = h2;\n    this.rtt = rtt;\n    this.throughput = throughput;\n    this.serverLatency = serverLatency;\n    this._congestionWindow = INITIAL_CONGESTION_WINDOW;\n    this.h2OverflowBytesDownloaded = 0;\n  }\n\n  static maximumSaturatedConnections(rtt: number, availableThroughput: number): number {\n    const roundTripsPerSecond = 1000 / rtt;\n    const bytesPerRoundTrip = TCP_SEGMENT_SIZE;\n    const bytesPerSecond = roundTripsPerSecond * bytesPerRoundTrip;\n    const minimumThroughputRequiredPerRequest = bytesPerSecond * 8;\n    return Math.floor(availableThroughput / minimumThroughputRequiredPerRequest);\n  }\n\n  computeMaximumCongestionWindowInSegments(): number {\n    const bytesPerSecond = this.throughput / 8;\n    const secondsPerRoundTrip = this.rtt / 1000;\n    const bytesPerRoundTrip = bytesPerSecond * secondsPerRoundTrip;\n    return Math.floor(bytesPerRoundTrip / TCP_SEGMENT_SIZE);\n  }\n\n  setThroughput(throughput: number): void {\n    this.throughput = throughput;\n  }\n\n  setCongestionWindow(congestion: number): void {\n    this._congestionWindow = congestion;\n  }\n\n  setWarmed(warmed: boolean): void {\n    this.warmed = warmed;\n  }\n\n  isWarm(): boolean {\n    return this.warmed;\n  }\n\n  isH2(): boolean {\n    return this.h2;\n  }\n\n  get congestionWindow(): number {\n    return this._congestionWindow;\n  }\n\n  /**\n   * Sets the number of excess bytes that are available to this connection on future downloads, only\n   * applies to H2 connections.\n   */\n  setH2OverflowBytesDownloaded(bytes: number): void {\n    if (!this.h2) {\n      return;\n    }\n    this.h2OverflowBytesDownloaded = bytes;\n  }\n\n  clone(): TCPConnection {\n    return Object.assign(new TCPConnection(this.rtt, this.throughput), this);\n  }\n\n  /**\n   * Simulates a network download of a particular number of bytes over an optional maximum amount of time\n   * and returns information about the ending state.\n   *\n   * See https://hpbn.co/building-blocks-of-tcp/#three-way-handshake and\n   *  https://hpbn.co/transport-layer-security-tls/#tls-handshake for details.\n   */\n  simulateDownloadUntil(bytesToDownload: number, options?: DownloadOptions): DownloadResults {\n    const {timeAlreadyElapsed = 0, maximumTimeToElapse = Infinity, dnsResolutionTime = 0} = options || {};\n\n    if (this.warmed && this.h2) {\n      bytesToDownload -= this.h2OverflowBytesDownloaded;\n    }\n    const twoWayLatency = this.rtt;\n    const oneWayLatency = twoWayLatency / 2;\n    const maximumCongestionWindow = this.computeMaximumCongestionWindowInSegments();\n\n    let handshakeAndRequest = oneWayLatency;\n    if (!this.warmed) {\n      handshakeAndRequest =\n          // DNS lookup\n          dnsResolutionTime +\n          // SYN\n          oneWayLatency +\n          // SYN ACK\n          oneWayLatency +\n          // ACK + initial request\n          oneWayLatency +\n          // ClientHello/ServerHello assuming TLS False Start is enabled (https://istlsfastyet.com/#server-performance).\n          (this.ssl ? twoWayLatency : 0);\n    }\n\n    let roundTrips = Math.ceil(handshakeAndRequest / twoWayLatency);\n    let timeToFirstByte = handshakeAndRequest + this.serverLatency + oneWayLatency;\n    if (this.warmed && this.h2) {\n      timeToFirstByte = 0;\n    }\n\n    const timeElapsedForTTFB = Math.max(timeToFirstByte - timeAlreadyElapsed, 0);\n    const maximumDownloadTimeToElapse = maximumTimeToElapse - timeElapsedForTTFB;\n\n    let congestionWindow = Math.min(this._congestionWindow, maximumCongestionWindow);\n    let totalBytesDownloaded = 0;\n    if (timeElapsedForTTFB > 0) {\n      totalBytesDownloaded = congestionWindow * TCP_SEGMENT_SIZE;\n    } else {\n      roundTrips = 0;\n    }\n\n    let downloadTimeElapsed = 0;\n    let bytesRemaining = bytesToDownload - totalBytesDownloaded;\n    while (bytesRemaining > 0 && downloadTimeElapsed <= maximumDownloadTimeToElapse) {\n      roundTrips++;\n      downloadTimeElapsed += twoWayLatency;\n      congestionWindow = Math.max(Math.min(maximumCongestionWindow, congestionWindow * 2), 1);\n\n      const bytesDownloadedInWindow = congestionWindow * TCP_SEGMENT_SIZE;\n      totalBytesDownloaded += bytesDownloadedInWindow;\n      bytesRemaining -= bytesDownloadedInWindow;\n    }\n\n    const timeElapsed = timeElapsedForTTFB + downloadTimeElapsed;\n    const extraBytesDownloaded = this.h2 ? Math.max(totalBytesDownloaded - bytesToDownload, 0) : 0;\n    const bytesDownloaded = Math.max(Math.min(totalBytesDownloaded, bytesToDownload), 0);\n\n    let connectionTiming: ConnectionTiming;\n    if (!this.warmed) {\n      connectionTiming = {\n        dnsResolutionTime,\n        connectionTime: handshakeAndRequest - dnsResolutionTime,\n        sslTime: this.ssl ? twoWayLatency : undefined,\n        timeToFirstByte,\n      };\n    } else if (this.h2) {\n      // TODO: timing information currently difficult to model for warm h2 connections.\n      connectionTiming = {\n        timeToFirstByte,\n      };\n    } else {\n      connectionTiming = {\n        connectionTime: handshakeAndRequest,\n        timeToFirstByte,\n      };\n    }\n\n    return {\n      roundTrips,\n      timeElapsed,\n      bytesDownloaded,\n      extraBytesDownloaded,\n      congestionWindow,\n      connectionTiming,\n    };\n  }\n}\n\nexport {TCPConnection};\n"],
  "mappings": "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",
  "names": []
}
