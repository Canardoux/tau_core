{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/metrics/FirstContentfulPaint.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Graph from '../graph/graph.js';\nimport type * as Types from '../types/types.js';\n\nimport {Metric, type MetricCoefficients} from './Metric.js';\n\ninterface FirstPaintBasedGraphOpts<T> {\n  /**\n   * The timestamp used to filter out tasks that occured after our paint of interest.\n   * Typically this is First Contentful Paint or First Meaningful Paint.\n   */\n  cutoffTimestamp: number;\n  /**\n   * The function that determines which resources should be considered *possibly*\n   * render-blocking.\n   */\n  treatNodeAsRenderBlocking: (node: Graph.NetworkNode<T>) => boolean;\n  /**\n   * The function that determines which CPU nodes should also be included in our\n   * blocking node IDs set, beyond what getRenderBlockingNodeData() already includes.\n   */\n  additionalCpuNodesToTreatAsRenderBlocking?: (node: Graph.CPUNode) => boolean;\n}\n\nclass FirstContentfulPaint extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  /**\n   * Computes the set of URLs that *appeared* to be render-blocking based on our filter,\n   * *but definitely were not* render-blocking based on the timing of their EvaluateScript task.\n   * It also computes the set of corresponding CPU node ids that were needed for the paint at the\n   * given timestamp.\n   */\n  static getRenderBlockingNodeData<T = unknown>(\n      graph: Graph.Node,\n      {cutoffTimestamp, treatNodeAsRenderBlocking, additionalCpuNodesToTreatAsRenderBlocking}:\n          FirstPaintBasedGraphOpts<T>,\n      ): {definitelyNotRenderBlockingScriptUrls: Set<string>, renderBlockingCpuNodeIds: Set<string>} {\n    /** A map of blocking script URLs to the earliest EvaluateScript task node that executed them. */\n    const scriptUrlToNodeMap = new Map<string, Graph.CPUNode>();\n\n    const cpuNodes: Graph.CPUNode[] = [];\n    graph.traverse(node => {\n      if (node.type === Graph.BaseNode.types.CPU) {\n        // A task is *possibly* render blocking if it *started* before cutoffTimestamp.\n        // We use startTime here because the paint event can be *inside* the task that was render blocking.\n        if (node.startTime <= cutoffTimestamp) {\n          cpuNodes.push(node);\n        }\n\n        // Build our script URL map to find the earliest EvaluateScript task node.\n        const scriptUrls = node.getEvaluateScriptURLs();\n        for (const url of scriptUrls) {\n          // Use the earliest CPU node we find.\n          const existing = scriptUrlToNodeMap.get(url) || node;\n          scriptUrlToNodeMap.set(url, node.startTime < existing.startTime ? node : existing);\n        }\n      }\n    });\n\n    cpuNodes.sort((a, b) => a.startTime - b.startTime);\n\n    // A script is *possibly* render blocking if it finished loading before cutoffTimestamp.\n    const possiblyRenderBlockingScriptUrls = Metric.getScriptUrls(graph, node => {\n      // The optimistic LCP treatNodeAsRenderBlocking fn wants to exclude some images in the graph,\n      // but here it only receives scripts to evaluate. It's a no-op in this case, but it will\n      // matter below in the getFirstPaintBasedGraph clone operation.\n      return node.endTime <= cutoffTimestamp && treatNodeAsRenderBlocking(node);\n    });\n\n    // A script is *definitely not* render blocking if its EvaluateScript task started after cutoffTimestamp.\n    const definitelyNotRenderBlockingScriptUrls = new Set<string>();\n    const renderBlockingCpuNodeIds = new Set<string>();\n    for (const url of possiblyRenderBlockingScriptUrls) {\n      // Lookup the CPU node that had the earliest EvaluateScript for this URL.\n      const cpuNodeForUrl = scriptUrlToNodeMap.get(url);\n\n      // If we can't find it at all, we can't conclude anything, so just skip it.\n      if (!cpuNodeForUrl) {\n        continue;\n      }\n\n      // If we found it and it was in our `cpuNodes` set that means it finished before cutoffTimestamp, so it really is render-blocking.\n      if (cpuNodes.includes(cpuNodeForUrl)) {\n        renderBlockingCpuNodeIds.add(cpuNodeForUrl.id);\n        continue;\n      }\n\n      // We couldn't find the evaluate script in the set of CPU nodes that ran before our paint, so\n      // it must not have been necessary for the paint.\n      definitelyNotRenderBlockingScriptUrls.add(url);\n    }\n\n    // The first layout, first paint, and first ParseHTML are almost always necessary for first paint,\n    // so we always include those CPU nodes.\n    const firstLayout = cpuNodes.find(node => node.didPerformLayout());\n    if (firstLayout) {\n      renderBlockingCpuNodeIds.add(firstLayout.id);\n    }\n    const firstPaint = cpuNodes.find(node => node.childEvents.some(e => e.name === 'Paint'));\n    if (firstPaint) {\n      renderBlockingCpuNodeIds.add(firstPaint.id);\n    }\n    const firstParse = cpuNodes.find(node => node.childEvents.some(e => e.name === 'ParseHTML'));\n    if (firstParse) {\n      renderBlockingCpuNodeIds.add(firstParse.id);\n    }\n\n    // If a CPU filter was passed in, we also want to include those extra nodes.\n    if (additionalCpuNodesToTreatAsRenderBlocking) {\n      cpuNodes.filter(additionalCpuNodesToTreatAsRenderBlocking).forEach(node => renderBlockingCpuNodeIds.add(node.id));\n    }\n\n    return {\n      definitelyNotRenderBlockingScriptUrls,\n      renderBlockingCpuNodeIds,\n    };\n  }\n\n  /**\n   * Computes the graph required for the first paint of interest.\n   */\n  static getFirstPaintBasedGraph<T>(\n      dependencyGraph: Graph.Node,\n      {cutoffTimestamp, treatNodeAsRenderBlocking, additionalCpuNodesToTreatAsRenderBlocking}:\n          FirstPaintBasedGraphOpts<T>,\n      ): Graph.Node<T> {\n    const rbData = this.getRenderBlockingNodeData(dependencyGraph, {\n      cutoffTimestamp,\n      treatNodeAsRenderBlocking,\n      additionalCpuNodesToTreatAsRenderBlocking,\n    });\n    const {definitelyNotRenderBlockingScriptUrls, renderBlockingCpuNodeIds} = rbData;\n\n    return dependencyGraph.cloneWithRelationships(node => {\n      if (node.type === Graph.BaseNode.types.NETWORK) {\n        // Exclude all nodes that ended after cutoffTimestamp (except for the main document which we always consider necessary)\n        // endTime is negative if request does not finish, make sure startTime isn't after cutoffTimestamp in this case.\n        const endedAfterPaint = node.endTime > cutoffTimestamp || node.startTime > cutoffTimestamp;\n        if (endedAfterPaint && !node.isMainDocument()) {\n          return false;\n        }\n\n        const url = node.request.url;\n        // If the URL definitely wasn't render-blocking then we filter it out.\n        if (definitelyNotRenderBlockingScriptUrls.has(url)) {\n          return false;\n        }\n\n        // Lastly, build up the FCP graph of all nodes we consider render blocking\n        return treatNodeAsRenderBlocking(node);\n      }\n      // If it's a CPU node, just check if it was blocking.\n      return renderBlockingCpuNodeIds.has(node.id);\n    });\n  }\n\n  static override getOptimisticGraph<T>(\n      dependencyGraph: Graph.Node<T>, processedNavigation: Types.Simulation.ProcessedNavigation): Graph.Node<T> {\n    return this.getFirstPaintBasedGraph(dependencyGraph, {\n      cutoffTimestamp: processedNavigation.timestamps.firstContentfulPaint,\n      // In the optimistic graph we exclude resources that appeared to be render blocking but were\n      // initiated by a script. While they typically have a very high importance and tend to have a\n      // significant impact on the page's content, these resources don't technically block rendering.\n      treatNodeAsRenderBlocking: node => node.hasRenderBlockingPriority() && node.initiatorType !== 'script',\n    });\n  }\n\n  static override getPessimisticGraph<T>(\n      dependencyGraph: Graph.Node<T>, processedNavigation: Types.Simulation.ProcessedNavigation): Graph.Node<T> {\n    return this.getFirstPaintBasedGraph(dependencyGraph, {\n      cutoffTimestamp: processedNavigation.timestamps.firstContentfulPaint,\n      treatNodeAsRenderBlocking: node => node.hasRenderBlockingPriority(),\n    });\n  }\n}\n\nexport {FirstContentfulPaint};\n"],
  "mappings": "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",
  "names": []
}
