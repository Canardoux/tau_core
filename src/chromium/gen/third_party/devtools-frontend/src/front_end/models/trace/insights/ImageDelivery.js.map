{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/insights/ImageDelivery.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport type * as Types from '../types/types.js';\n\nimport {\n  InsightCategory,\n  type InsightModel,\n  type InsightSetContext,\n  type RequiredData,\n} from './types.js';\n\nconst UIStrings = {\n  /**\n   * @description Title of an insight that recommends ways to reduce the size of images downloaded and used on the page.\n   */\n  title: 'Improve image delivery',\n  /**\n   * @description Description of an insight that recommends ways to reduce the size of images downloaded and used on the page.\n   */\n  description:\n      'Reducing the download time of images can improve the perceived load time of the page and LCP. [Learn more about optimizing image size](https://developer.chrome.com/docs/lighthouse/performance/uses-optimized-images/)',\n  /**\n   * @description Message displayed in a chip explaining that an image file size is large for the # of pixels it has and recommends possible adjustments to improve the image size.\n   * @example {50 MB} PH1\n   */\n  useCompression: 'Increasing the image compression factor could improve this image\\'s download size. (Est {PH1})',\n  /**\n   * @description Message displayed in a chip explaining that an image file size is large for the # of pixels it has and recommends possible adjustments to improve the image size.\n   * @example {50 MB} PH1\n   */\n  useModernFormat:\n      'Using a modern image format (WebP, AVIF) or increasing the image compression could improve this image\\'s download size. (Est {PH1})',\n  /**\n   * @description Message displayed in a chip advising the user to use video formats instead of GIFs because videos generally have smaller file sizes.\n   * @example {50 MB} PH1\n   */\n  useVideoFormat: 'Using video formats instead of GIFs can improve the download size of animated content. (Est {PH1})',\n  /**\n   * @description Message displayed in a chip explaining that an image was displayed on the page with dimensions much smaller than the image file dimensions.\n   * @example {50 MB} PH1\n   * @example {1000x500} PH2\n   * @example {100x50} PH3\n   */\n  useResponsiveSize:\n      'This image file is larger than it needs to be ({PH2}) for its displayed dimensions ({PH3}). Use responsive images to reduce the image download size. (Est {PH1})',\n};\n\nconst str_ = i18n.i18n.registerUIStrings('models/trace/insights/ImageDelivery.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\n/**\n * Even JPEGs with lots of detail can usually be compressed down to <1 byte per pixel\n * Using 4:2:2 subsampling already gets an uncompressed bitmap to 2 bytes per pixel.\n * The compression ratio for JPEG is usually somewhere around 10:1 depending on content, so\n * 8:1 is a reasonable expectation for web content which is 1.5MB for a 6MP image.\n *\n * WebP usually gives ~20% additional savings on top of that, so we will assume 10:1 for WebP.\n * This is quite pessimistic as their study shows a photographic compression ratio of ~29:1.\n * https://developers.google.com/speed/webp/docs/webp_lossless_alpha_study#results\n *\n * AVIF usually gives ~20% additional savings on top of WebP, so we will use 12:1 for AVIF.\n * This is quite pessimistic as Netflix study shows a photographic compression ratio of ~40:1\n * (0.4 *bits* per pixel at SSIM 0.97).\n * https://netflixtechblog.com/avif-for-next-generation-image-coding-b1d75675fe4\n */\nconst TARGET_BYTES_PER_PIXEL_AVIF = 2 * 1 / 12;\n\n/**\n * If GIFs are above this size, we'll flag them\n * See https://github.com/GoogleChrome/lighthouse/pull/4885#discussion_r178406623 and https://github.com/GoogleChrome/lighthouse/issues/4696#issuecomment-370979920\n */\nconst GIF_SIZE_THRESHOLD = 100 * 1024;\n\nconst BYTE_SAVINGS_THRESHOLD = 4096;\n\nexport function deps(): ['NetworkRequests', 'Meta', 'ImagePainting'] {\n  return ['NetworkRequests', 'Meta', 'ImagePainting'];\n}\n\nexport enum ImageOptimizationType {\n  ADJUST_COMPRESSION = 'ADJUST_COMPRESSION',\n  MODERN_FORMAT_OR_COMPRESSION = 'MODERN_FORMAT_OR_COMPRESSION',\n  VIDEO_FORMAT = 'VIDEO_FORMAT',\n  RESPONSIVE_SIZE = 'RESPONSIVE_SIZE',\n}\n\nexport type ImageOptimization = {\n  type: Exclude<ImageOptimizationType, ImageOptimizationType.RESPONSIVE_SIZE>,\n  byteSavings: number,\n}|{\n  type: ImageOptimizationType.RESPONSIVE_SIZE,\n  byteSavings: number,\n  fileDimensions: {width: number, height: number},\n  displayDimensions: {width: number, height: number},\n};\n\nexport interface OptimizableImage {\n  request: Types.Events.SyntheticNetworkRequest;\n  optimizations: ImageOptimization[];\n  /**\n   * If the an image resource has multiple `PaintImage`s, we compare its intrinsic size to the largest of the displayed sizes.\n   *\n   * It is theoretically possible for `PaintImage` events with the same URL to have different intrinsic sizes.\n   * However, this should be rare because it requires serving different images from the same URL.\n   */\n  largestImagePaint: Types.Events.PaintImage;\n}\n\nexport type ImageDeliveryInsightModel = InsightModel<{\n  optimizableImages: OptimizableImage[],\n}>;\n\nfunction getOptimizationMessage(optimization: ImageOptimization): string {\n  const byteSavingsText = i18n.ByteUtilities.bytesToString(optimization.byteSavings);\n  switch (optimization.type) {\n    case ImageOptimizationType.ADJUST_COMPRESSION:\n      return i18nString(UIStrings.useCompression, {PH1: byteSavingsText});\n    case ImageOptimizationType.MODERN_FORMAT_OR_COMPRESSION:\n      return i18nString(UIStrings.useModernFormat, {PH1: byteSavingsText});\n    case ImageOptimizationType.VIDEO_FORMAT:\n      return i18nString(UIStrings.useVideoFormat, {PH1: byteSavingsText});\n    case ImageOptimizationType.RESPONSIVE_SIZE:\n      return i18nString(UIStrings.useResponsiveSize, {\n        PH1: byteSavingsText,\n        PH2: `${optimization.fileDimensions.width}x${optimization.fileDimensions.height}`,\n        PH3: `${optimization.displayDimensions.width}x${optimization.displayDimensions.height}`,\n      });\n  }\n}\n\nfunction finalize(partialModel: Omit<ImageDeliveryInsightModel, 'title'|'description'|'category'|'shouldShow'>):\n    ImageDeliveryInsightModel {\n  return {\n    title: i18nString(UIStrings.title),\n    description: i18nString(UIStrings.description),\n    category: InsightCategory.LCP,\n    shouldShow: partialModel.optimizableImages.length > 0,\n    ...partialModel,\n    relatedEvents: new Map(\n        partialModel.optimizableImages.map(image => [image.request, image.optimizations.map(getOptimizationMessage)])),\n  };\n}\n\n/**\n * Calculate rough savings percentage based on 1000 real gifs transcoded to video\n * https://github.com/GoogleChrome/lighthouse/issues/4696#issuecomment-380296510\n */\nfunction estimateGIFPercentSavings(request: Types.Events.SyntheticNetworkRequest): number {\n  return Math.round((29.1 * Math.log10(request.args.data.decodedBodyLength) - 100.7)) / 100;\n}\n\nfunction getPixelCounts(paintImage: Types.Events.PaintImage): {displayedPixels: number, filePixels: number} {\n  return {\n    filePixels: paintImage.args.data.srcWidth * paintImage.args.data.srcHeight,\n    displayedPixels: paintImage.args.data.width * paintImage.args.data.height,\n  };\n}\n\nexport function generateInsight(\n    parsedTrace: RequiredData<typeof deps>, context: InsightSetContext): ImageDeliveryInsightModel {\n  const isWithinContext = (event: Types.Events.Event): boolean => Helpers.Timing.eventIsInBounds(event, context.bounds);\n\n  const contextRequests = parsedTrace.NetworkRequests.byTime.filter(isWithinContext);\n\n  const optimizableImages: OptimizableImage[] = [];\n  for (const request of contextRequests) {\n    if (request.args.data.resourceType !== 'Image') {\n      continue;\n    }\n\n    const imagePaints =\n        parsedTrace.ImagePainting.paintImageEventForUrl.get(request.args.data.url)?.filter(isWithinContext);\n\n    // This will filter out things like preloaded image requests where an image file is downloaded\n    // but never rendered on the page.\n    if (!imagePaints?.length) {\n      continue;\n    }\n\n    const largestImagePaint = imagePaints.reduce((prev, curr) => {\n      const prevPixels = getPixelCounts(prev).displayedPixels;\n      const currPixels = getPixelCounts(curr).displayedPixels;\n      return prevPixels > currPixels ? prev : curr;\n    });\n\n    const {\n      filePixels: imageFilePixels,\n      displayedPixels: largestImageDisplayPixels,\n    } = getPixelCounts(largestImagePaint);\n\n    // Decoded body length is almost always the right one to be using because of the below:\n    //     `encodedDataLength = decodedBodyLength + headers`.\n    // HOWEVER, there are some cases where an image is compressed again over the network and transfer size\n    // is smaller (see https://github.com/GoogleChrome/lighthouse/pull/4968).\n    // Use the min of the two numbers to be safe.\n    const imageBytes = Math.min(request.args.data.decodedBodyLength, request.args.data.encodedDataLength);\n\n    const bytesPerPixel = imageBytes / imageFilePixels;\n\n    let optimizations: ImageOptimization[] = [];\n    if (request.args.data.mimeType === 'image/gif') {\n      if (imageBytes > GIF_SIZE_THRESHOLD) {\n        const percentSavings = estimateGIFPercentSavings(request);\n        const byteSavings = Math.round(imageBytes * percentSavings);\n        optimizations.push({type: ImageOptimizationType.VIDEO_FORMAT, byteSavings});\n      }\n    } else if (bytesPerPixel > TARGET_BYTES_PER_PIXEL_AVIF) {\n      const idealAvifImageSize = Math.round(TARGET_BYTES_PER_PIXEL_AVIF * imageFilePixels);\n      const byteSavings = imageBytes - idealAvifImageSize;\n      if (request.args.data.mimeType !== 'image/webp' && request.args.data.mimeType !== 'image/avif') {\n        optimizations.push({type: ImageOptimizationType.MODERN_FORMAT_OR_COMPRESSION, byteSavings});\n      } else {\n        optimizations.push({type: ImageOptimizationType.ADJUST_COMPRESSION, byteSavings});\n      }\n    }\n\n    const wastedPixelRatio = 1 - (largestImageDisplayPixels / imageFilePixels);\n    if (wastedPixelRatio > 0) {\n      const byteSavings = Math.round(wastedPixelRatio * imageBytes);\n      optimizations.push({\n        type: ImageOptimizationType.RESPONSIVE_SIZE,\n        byteSavings,\n        fileDimensions: {\n          width: Math.round(largestImagePaint.args.data.srcWidth),\n          height: Math.round(largestImagePaint.args.data.srcHeight),\n        },\n        displayDimensions: {\n          width: Math.round(largestImagePaint.args.data.width),\n          height: Math.round(largestImagePaint.args.data.height),\n        },\n      });\n    }\n\n    optimizations = optimizations.filter(optimization => optimization.byteSavings > BYTE_SAVINGS_THRESHOLD);\n\n    if (optimizations.length > 0) {\n      optimizableImages.push({\n        request,\n        largestImagePaint,\n        optimizations,\n      });\n    }\n  }\n\n  return finalize({\n    optimizableImages,\n  });\n}\n"],
  "mappings": "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",
  "names": ["ImageOptimizationType"]
}
