{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/bindings/LiveLocation.ts"],
  "sourcesContent": ["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Workspace from '../workspace/workspace.js';\n\nexport interface LiveLocation {\n  update(): Promise<void>;\n  uiLocation(): Promise<Workspace.UISourceCode.UILocation|null>;\n  dispose(): void;\n  isDisposed(): boolean;\n  isIgnoreListed(): Promise<boolean>;\n}\n\nexport class LiveLocationWithPool implements LiveLocation {\n  #updateDelegate: ((arg0: LiveLocation) => Promise<void>)|null;\n  readonly #locationPool: LiveLocationPool;\n  #updatePromise: Promise<void>|null;\n\n  constructor(updateDelegate: (arg0: LiveLocation) => Promise<void>, locationPool: LiveLocationPool) {\n    this.#updateDelegate = updateDelegate;\n    this.#locationPool = locationPool;\n    this.#locationPool.add(this);\n\n    this.#updatePromise = null;\n  }\n\n  async update(): Promise<void> {\n    if (!this.#updateDelegate) {\n      return;\n    }\n    // The following is a basic scheduling algorithm, guaranteeing that\n    // {#updateDelegate} is always run atomically. That is, we always\n    // wait for an update to finish before we trigger the next run.\n    if (this.#updatePromise) {\n      await this.#updatePromise.then(() => this.update());\n    } else {\n      this.#updatePromise = this.#updateDelegate(this);\n      await this.#updatePromise;\n      this.#updatePromise = null;\n    }\n  }\n\n  async uiLocation(): Promise<Workspace.UISourceCode.UILocation|null> {\n    throw 'Not implemented';\n  }\n\n  dispose(): void {\n    this.#locationPool.delete(this);\n    this.#updateDelegate = null;\n  }\n\n  isDisposed(): boolean {\n    return !this.#locationPool.has(this);\n  }\n\n  async isIgnoreListed(): Promise<boolean> {\n    throw 'Not implemented';\n  }\n}\n\nexport class LiveLocationPool {\n  readonly #locations: Set<LiveLocation>;\n\n  constructor() {\n    this.#locations = new Set();\n  }\n\n  add(location: LiveLocation): void {\n    this.#locations.add(location);\n  }\n\n  delete(location: LiveLocation): void {\n    this.#locations.delete(location);\n  }\n\n  has(location: LiveLocation): boolean {\n    return this.#locations.has(location);\n  }\n\n  disposeAll(): void {\n    for (const location of this.#locations) {\n      location.dispose();\n    }\n  }\n}\n"],
  "mappings": ";AAcO,aAAM,qBAA6C;AAAA,EACxD;AAAA,EACS;AAAA,EACT;AAAA,EAEA,YAAY,gBAAuD,cAAgC;AACjG,SAAK,kBAAkB;AACvB,SAAK,gBAAgB;AACrB,SAAK,cAAc,IAAI,IAAI;AAE3B,SAAK,iBAAiB;AAAA,EACxB;AAAA,EAEA,MAAM,SAAwB;AAC5B,QAAI,CAAC,KAAK,iBAAiB;AACzB;AAAA,IACF;AAIA,QAAI,KAAK,gBAAgB;AACvB,YAAM,KAAK,eAAe,KAAK,MAAM,KAAK,OAAO,CAAC;AAAA,IACpD,OAAO;AACL,WAAK,iBAAiB,KAAK,gBAAgB,IAAI;AAC/C,YAAM,KAAK;AACX,WAAK,iBAAiB;AAAA,IACxB;AAAA,EACF;AAAA,EAEA,MAAM,aAA8D;AAClE,UAAM;AAAA,EACR;AAAA,EAEA,UAAgB;AACd,SAAK,cAAc,OAAO,IAAI;AAC9B,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,aAAsB;AACpB,WAAO,CAAC,KAAK,cAAc,IAAI,IAAI;AAAA,EACrC;AAAA,EAEA,MAAM,iBAAmC;AACvC,UAAM;AAAA,EACR;AACF;AAEO,aAAM,iBAAiB;AAAA,EACnB;AAAA,EAET,cAAc;AACZ,SAAK,aAAa,oBAAI,IAAI;AAAA,EAC5B;AAAA,EAEA,IAAI,UAA8B;AAChC,SAAK,WAAW,IAAI,QAAQ;AAAA,EAC9B;AAAA,EAEA,OAAO,UAA8B;AACnC,SAAK,WAAW,OAAO,QAAQ;AAAA,EACjC;AAAA,EAEA,IAAI,UAAiC;AACnC,WAAO,KAAK,WAAW,IAAI,QAAQ;AAAA,EACrC;AAAA,EAEA,aAAmB;AACjB,eAAW,YAAY,KAAK,YAAY;AACtC,eAAS,QAAQ;AAAA,IACnB;AAAA,EACF;AACF;",
  "names": []
}
