{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/metrics/TotalBlockingTime.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\nimport {BLOCKING_TIME_THRESHOLD, calculateSumOfBlockingTime} from './TBTUtils.js';\n\nclass TotalBlockingTime extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  static override getOptimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getPessimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulation: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.fcpResult) {\n      throw new Core.LanternError('missing fcpResult');\n    }\n    if (!extras.interactiveResult) {\n      throw new Core.LanternError('missing interactiveResult');\n    }\n\n    // Intentionally use the opposite FCP estimate. A pessimistic FCP is higher than equal to an\n    // optimistic FCP, which means potentially more tasks are excluded from the Total Blocking Time\n    // computation. So a more pessimistic FCP gives a more optimistic Total Blocking Time for the\n    // same work.\n    const fcpTimeInMs = extras.optimistic ? extras.fcpResult.pessimisticEstimate.timeInMs :\n                                            extras.fcpResult.optimisticEstimate.timeInMs;\n\n    // Similarly, we always have pessimistic TTI >= optimistic TTI. Therefore, picking optimistic\n    // TTI means our window of interest is smaller and thus potentially more tasks are excluded from\n    // Total Blocking Time computation, yielding a lower (more optimistic) Total Blocking Time value\n    // for the same work.\n    const interactiveTimeMs = extras.optimistic ? extras.interactiveResult.optimisticEstimate.timeInMs :\n                                                  extras.interactiveResult.pessimisticEstimate.timeInMs;\n\n    const minDurationMs = BLOCKING_TIME_THRESHOLD;\n\n    const events = TotalBlockingTime.getTopLevelEvents(\n        simulation.nodeTimings,\n        minDurationMs,\n    );\n\n    return {\n      timeInMs: calculateSumOfBlockingTime(\n          events,\n          fcpTimeInMs,\n          interactiveTimeMs,\n          ),\n      nodeTimings: simulation.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the TBT metric');\n    }\n\n    const interactiveResult = extras?.fcpResult;\n    if (!interactiveResult) {\n      throw new Core.LanternError('Interactive is required to calculate the TBT metric');\n    }\n\n    return super.compute(data, extras);\n  }\n\n  static getTopLevelEvents(nodeTimings: Simulation.Result['nodeTimings'], minDurationMs: number):\n      {start: number, end: number, duration: number}[] {\n    const events: Array<{start: number, end: number, duration: number}> = [];\n\n    for (const [node, timing] of nodeTimings.entries()) {\n      if (node.type !== Graph.BaseNode.types.CPU) {\n        continue;\n      }\n      // Filtering out events below minimum duration.\n      if (timing.duration < minDurationMs) {\n        continue;\n      }\n\n      events.push({\n        start: timing.startTime,\n        end: timing.endTime,\n        duration: timing.duration,\n      });\n    }\n\n    return events;\n  }\n}\n\nexport {TotalBlockingTime};\n"],
  "mappings": ";AAIA,YAAY,UAAU;AACtB,YAAY,WAAW;AAGvB;AAAA,EAEE;AAAA,OAIK;AACP,SAAQ,yBAAyB,kCAAiC;AAElE,MAAM,0BAA0B,OAAO;AAAA,EACrC,WAAoB,eAAmC;AACrD,WAAO;AAAA,MACL,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,aAAa;AAAA,IACf;AAAA,EACF;AAAA,EAEA,OAAgB,mBAAmB,iBAAyC;AAC1E,WAAO;AAAA,EACT;AAAA,EAEA,OAAgB,oBAAoB,iBAAyC;AAC3E,WAAO;AAAA,EACT;AAAA,EAEA,OAAgB,0BAA0B,YAA+B,QAAmC;AAC1G,QAAI,CAAC,OAAO,WAAW;AACrB,YAAM,IAAI,KAAK,aAAa,mBAAmB;AAAA,IACjD;AACA,QAAI,CAAC,OAAO,mBAAmB;AAC7B,YAAM,IAAI,KAAK,aAAa,2BAA2B;AAAA,IACzD;AAMA,UAAM,cAAc,OAAO,aAAa,OAAO,UAAU,oBAAoB,WACrC,OAAO,UAAU,mBAAmB;AAM5E,UAAM,oBAAoB,OAAO,aAAa,OAAO,kBAAkB,mBAAmB,WAC5C,OAAO,kBAAkB,oBAAoB;AAE3F,UAAM,gBAAgB;AAEtB,UAAM,SAAS,kBAAkB;AAAA,MAC7B,WAAW;AAAA,MACX;AAAA,IACJ;AAEA,WAAO;AAAA,MACL,UAAU;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACA;AAAA,MACJ,aAAa,WAAW;AAAA,IAC1B;AAAA,EACF;AAAA,EAEA,OAAgB,QAAQ,MAAkC,QAAmD;AAC3G,UAAM,YAAY,QAAQ;AAC1B,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,KAAK,aAAa,6CAA6C;AAAA,IAC3E;AAEA,UAAM,oBAAoB,QAAQ;AAClC,QAAI,CAAC,mBAAmB;AACtB,YAAM,IAAI,KAAK,aAAa,qDAAqD;AAAA,IACnF;AAEA,WAAO,MAAM,QAAQ,MAAM,MAAM;AAAA,EACnC;AAAA,EAEA,OAAO,kBAAkB,aAA+C,eACnB;AACnD,UAAM,SAAgE,CAAC;AAEvE,eAAW,CAAC,MAAM,MAAM,KAAK,YAAY,QAAQ,GAAG;AAClD,UAAI,KAAK,SAAS,MAAM,SAAS,MAAM,KAAK;AAC1C;AAAA,MACF;AAEA,UAAI,OAAO,WAAW,eAAe;AACnC;AAAA,MACF;AAEA,aAAO,KAAK;AAAA,QACV,OAAO,OAAO;AAAA,QACd,KAAK,OAAO;AAAA,QACZ,UAAU,OAAO;AAAA,MACnB,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AACF;AAEA,SAAQ;",
  "names": []
}
