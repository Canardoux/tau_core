{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/NetworkRequestsHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Protocol from '../../../generated/protocol.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\nconst MILLISECONDS_TO_MICROSECONDS = 1000;\nconst SECONDS_TO_MICROSECONDS = 1000000;\n\n// Network requests from traces are actually formed of 5 trace records.\n// This handler tracks all trace records based on the request ID, and\n// then creates a new synthetic trace event for those network requests.\n//\n// This interface, then, defines the shape of the object we intend to\n// keep for each request in the trace. In the finalize we will convert\n// these 5 types of trace records to a synthetic complete event that\n// represents a composite of these trace records.\ninterface TraceEventsForNetworkRequest {\n  changePriority?: Types.Events.ResourceChangePriority;\n  willSendRequests?: Types.Events.ResourceWillSendRequest[];\n  sendRequests?: Types.Events.ResourceSendRequest[];\n  receiveResponse?: Types.Events.ResourceReceiveResponse;\n  resourceFinish?: Types.Events.ResourceFinish;\n  receivedData?: Types.Events.ResourceReceivedData[];\n  resourceMarkAsCached?: Types.Events.ResourceMarkAsCached;\n}\n\nexport interface WebSocketTraceDataForFrame {\n  frame: string;\n  webSocketIdentifier: number;\n  events: Types.Events.WebSocketEvent[];\n  syntheticConnection: Types.Events.SyntheticWebSocketConnection|null;\n}\nexport interface WebSocketTraceDataForWorker {\n  workerId: string;\n  webSocketIdentifier: number;\n  events: Types.Events.WebSocketEvent[];\n  syntheticConnection: Types.Events.SyntheticWebSocketConnection|null;\n}\nexport type WebSocketTraceData = WebSocketTraceDataForFrame|WebSocketTraceDataForWorker;\n\nconst webSocketData: Map<number, WebSocketTraceData> = new Map();\ninterface NetworkRequestData {\n  byId: Map<string, Types.Events.SyntheticNetworkRequest>;\n  byOrigin: Map<string, {\n    renderBlocking: Types.Events.SyntheticNetworkRequest[],\n    nonRenderBlocking: Types.Events.SyntheticNetworkRequest[],\n    all: Types.Events.SyntheticNetworkRequest[],\n  }>;\n  byTime: Types.Events.SyntheticNetworkRequest[];\n  eventToInitiator: Map<Types.Events.SyntheticNetworkRequest, Types.Events.SyntheticNetworkRequest>;\n  webSocket: WebSocketTraceData[];\n}\n\nconst requestMap = new Map<string, TraceEventsForNetworkRequest>();\nconst requestsById = new Map<string, Types.Events.SyntheticNetworkRequest>();\nconst requestsByOrigin = new Map<string, {\n  renderBlocking: Types.Events.SyntheticNetworkRequest[],\n  nonRenderBlocking: Types.Events.SyntheticNetworkRequest[],\n  all: Types.Events.SyntheticNetworkRequest[],\n}>();\nconst requestsByTime: Types.Events.SyntheticNetworkRequest[] = [];\n\nconst networkRequestEventByInitiatorUrl = new Map<string, Types.Events.SyntheticNetworkRequest[]>();\nconst eventToInitiatorMap = new Map<Types.Events.SyntheticNetworkRequest, Types.Events.SyntheticNetworkRequest>();\n\nfunction storeTraceEventWithRequestId<K extends keyof TraceEventsForNetworkRequest>(\n    requestId: string, key: K, value: TraceEventsForNetworkRequest[K]): void {\n  if (!requestMap.has(requestId)) {\n    requestMap.set(requestId, {});\n  }\n\n  const traceEvents = requestMap.get(requestId);\n  if (!traceEvents) {\n    throw new Error(`Unable to locate trace events for request ID ${requestId}`);\n  }\n\n  if (Array.isArray(traceEvents[key])) {\n    const target = traceEvents[key] as Types.Events.Event[];\n    const values = value as Types.Events.Event[];\n    target.push(...values);\n  } else {\n    traceEvents[key] = value;\n  }\n}\n\nfunction firstPositiveValueInList(entries: number[]): number {\n  for (const entry of entries) {\n    if (entry > 0) {\n      return entry;\n    }\n  }\n\n  // In the event we don't find a positive value, we return 0 so as to\n  // be a mathematical noop. It's typically not correct to return \u2013 say \u2013\n  // a -1 here because it would affect the calculation of stats below.\n  return 0;\n}\n\nexport function reset(): void {\n  requestsById.clear();\n  requestsByOrigin.clear();\n  requestMap.clear();\n  requestsByTime.length = 0;\n  networkRequestEventByInitiatorUrl.clear();\n  eventToInitiatorMap.clear();\n  webSocketData.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isResourceChangePriority(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'changePriority', event);\n    return;\n  }\n\n  if (Types.Events.isResourceWillSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'willSendRequests', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'sendRequests', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceReceiveResponse(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receiveResponse', event);\n    return;\n  }\n\n  if (Types.Events.isResourceReceivedData(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receivedData', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceFinish(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceFinish', event);\n    return;\n  }\n\n  if (Types.Events.isResourceMarkAsCached(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceMarkAsCached', event);\n    return;\n  }\n\n  if (Types.Events.isWebSocketCreate(event) || Types.Events.isWebSocketInfo(event) ||\n      Types.Events.isWebSocketTransfer(event)) {\n    const identifier = event.args.data.identifier;\n    if (!webSocketData.has(identifier)) {\n      if (event.args.data.frame) {\n        webSocketData.set(identifier, {\n          frame: event.args.data.frame,\n          webSocketIdentifier: identifier,\n          events: [],\n          syntheticConnection: null,\n        });\n      } else if (event.args.data.workerId) {\n        webSocketData.set(identifier, {\n          workerId: event.args.data.workerId,\n          webSocketIdentifier: identifier,\n          events: [],\n          syntheticConnection: null,\n        });\n      }\n    }\n\n    webSocketData.get(identifier)?.events.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const {rendererProcessesByFrame} = metaHandlerData();\n  for (const [requestId, request] of requestMap.entries()) {\n    // If we have an incomplete set of events here, we choose to drop the network\n    // request rather than attempt to synthesize the missing data.\n    if (!request.sendRequests || !request.receiveResponse) {\n      continue;\n    }\n\n    // In the data we may get multiple willSendRequests and sendRequests, which\n    // will indicate that there are redirects for a given (sub)resource. In the\n    // case of a navigation, e.g., example.com/ we will get willSendRequests,\n    // and we should use these to calculate time spent in redirects.\n    // In the case of sub-resources, however, e.g., example.com/foo.js we will\n    // *only* get sendRequests, and we use these instead of willSendRequests\n    // to detect the time in redirects. We always use the sendRequest for the\n    // url, priority etc since it contains those values, but we use the\n    // willSendRequest (if it exists) to calculate the timestamp and durations\n    // of redirects.\n    const redirects: Types.Events.SyntheticNetworkRedirect[] = [];\n    for (let i = 0; i < request.sendRequests.length - 1; i++) {\n      const sendRequest = request.sendRequests[i];\n      const nextSendRequest = request.sendRequests[i + 1];\n\n      // Use the willSendRequests as the source for redirects if possible.\n      // We default to those of the sendRequests, however, since willSendRequest\n      // is not guaranteed to be present in the data for every request.\n      let ts = sendRequest.ts;\n      let dur = Types.Timing.MicroSeconds(nextSendRequest.ts - sendRequest.ts);\n      if (request.willSendRequests && request.willSendRequests[i] && request.willSendRequests[i + 1]) {\n        const willSendRequest = request.willSendRequests[i];\n        const nextWillSendRequest = request.willSendRequests[i + 1];\n        ts = willSendRequest.ts;\n        dur = Types.Timing.MicroSeconds(nextWillSendRequest.ts - willSendRequest.ts);\n      }\n\n      redirects.push({\n        url: sendRequest.args.data.url,\n        priority: sendRequest.args.data.priority,\n        requestMethod: sendRequest.args.data.requestMethod,\n        ts,\n        dur,\n      });\n    }\n\n    // If a ResourceFinish event with an encoded data length is received,\n    // then the resource was not cached; it was fetched before it was\n    // requested, e.g. because it was pushed in this navigation.\n    const isPushedResource = request.resourceFinish?.args.data.encodedDataLength !== 0;\n    // This works around crbug.com/998397, which reports pushed resources, and resources served by a service worker as disk cached.\n    const isDiskCached = request.receiveResponse.args.data.fromCache &&\n        !request.receiveResponse.args.data.fromServiceWorker && !isPushedResource;\n    // If the request contains a resourceMarkAsCached event, it was served from memory cache.\n    // The timing data returned is from the original (uncached) request, which\n    // means that if we leave the above network record data as-is when the\n    // request came from either the disk cache or memory cache, our calculations\n    // will be incorrect.\n    //\n    // So we use this flag so when we calculate the timestamps of the various\n    // events, we can overwrite them.\n    // These timestamps may not be perfect (indeed they don't always match\n    // the Network CDP domain exactly, which is likely an artifact of the way\n    // the data is routed on the backend), but they're the closest we have.\n    const isMemoryCached = request.resourceMarkAsCached !== undefined;\n    // If a request has `resourceMarkAsCached` field, the `timing` field is not correct.\n    // So let's discard it and override to 0 (which will be handled in later logic if timing field is undefined).\n    const timing = isMemoryCached ? undefined : request.receiveResponse.args.data.timing;\n    // If a non-cached request has no |timing| indicates data URLs, we ignore it.\n    if (!timing && !isMemoryCached) {\n      continue;\n    }\n\n    const firstSendRequest = request.sendRequests[0];\n    const finalSendRequest = request.sendRequests[request.sendRequests.length - 1];\n\n    const initialPriority = finalSendRequest.args.data.priority;\n    let finalPriority = initialPriority;\n    if (request.changePriority) {\n      finalPriority = request.changePriority.args.data.priority;\n    }\n\n    // Network timings are complicated.\n    // https://raw.githubusercontent.com/GoogleChrome/lighthouse/main/docs/Network-Timings.svg is generally correct, but.. less so for navigations/redirects/etc.\n\n    // Start time\n    // =======================\n    // The time where the request started, which is either the first willSendRequest\n    // event if there is one, or, if there is not, the sendRequest.\n    const startTime = (request.willSendRequests && request.willSendRequests.length) ?\n        Types.Timing.MicroSeconds(request.willSendRequests[0].ts) :\n        Types.Timing.MicroSeconds(firstSendRequest.ts);\n\n    // End redirect time\n    // =======================\n    // It's possible that when we start requesting data we will receive redirections.\n    // Here we note the time of the *last* willSendRequest / sendRequest event,\n    // which is used later on in the calculations for time queueing etc.\n    const endRedirectTime = (request.willSendRequests && request.willSendRequests.length) ?\n        Types.Timing.MicroSeconds(request.willSendRequests[request.willSendRequests.length - 1].ts) :\n        Types.Timing.MicroSeconds(finalSendRequest.ts);\n\n    // Finish time and end time\n    // =======================\n    // The finish time and the end time are subtly different.\n    //  - Finish time: records the point at which the network stack stopped receiving the data\n    //  - End time: the timestamp of the finish event itself (if one exists)\n    //\n    // The end time, then, will be slightly after the finish time.\n    const endTime = request.resourceFinish ? request.resourceFinish.ts : endRedirectTime;\n    const finishTime = request.resourceFinish?.args.data.finishTime ?\n        Types.Timing.MicroSeconds(request.resourceFinish.args.data.finishTime * SECONDS_TO_MICROSECONDS) :\n        Types.Timing.MicroSeconds(endTime);\n\n    // Network duration\n    // =======================\n    // Time spent on the network.\n    const networkDuration = Types.Timing.MicroSeconds(timing ? (finishTime || endRedirectTime) - endRedirectTime : 0);\n\n    // Processing duration\n    // =======================\n    // Time spent from start to end.\n    const processingDuration = Types.Timing.MicroSeconds(endTime - (finishTime || endTime));\n\n    // Redirection duration\n    // =======================\n    // Time between the first willSendRequest / sendRequest and last. This we place in *front* of the\n    // queueing, since the queueing time that we know about from the trace data is only the last request,\n    // i.e., the one that occurs after all the redirects.\n    const redirectionDuration = Types.Timing.MicroSeconds(endRedirectTime - startTime);\n\n    // Queueing\n    // =======================\n    // The amount of time queueing is the time between the request's start time to the requestTime\n    // arg recorded in the receiveResponse event. In the cases where the recorded start time is larger\n    // that the requestTime we set queueing time to zero.\n    const queueingFromTraceData = timing ? timing.requestTime * SECONDS_TO_MICROSECONDS - endRedirectTime : 0;\n    const queueing =\n        Types.Timing.MicroSeconds(Platform.NumberUtilities.clamp(queueingFromTraceData, 0, Number.MAX_VALUE));\n\n    // Stalled\n    // =======================\n    // If the request is cached, the amount of time stalled is the time between the start time and\n    // receiving a response.\n    // Otherwise it is whichever positive number comes first from the following timing info:\n    // DNS start, Connection start, Send Start, or the time duration between our start time and\n    // receiving a response.\n    const stalled = timing ? Types.Timing.MicroSeconds(firstPositiveValueInList([\n      timing.dnsStart * MILLISECONDS_TO_MICROSECONDS,\n      timing.connectStart * MILLISECONDS_TO_MICROSECONDS,\n      timing.sendStart * MILLISECONDS_TO_MICROSECONDS,\n      (request.receiveResponse.ts - endRedirectTime),\n    ])) :\n                             Types.Timing.MicroSeconds(request.receiveResponse.ts - startTime);\n\n    // Sending HTTP request\n    // =======================\n    // Time when the HTTP request is sent.\n    const sendStartTime = timing ?\n        Types.Timing.MicroSeconds(\n            timing.requestTime * SECONDS_TO_MICROSECONDS + timing.sendStart * MILLISECONDS_TO_MICROSECONDS) :\n        startTime;\n\n    // Waiting\n    // =======================\n    // Time from when the send finished going to when the headers were received.\n    const waiting = timing ?\n        Types.Timing.MicroSeconds((timing.receiveHeadersEnd - timing.sendEnd) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.MicroSeconds(0);\n\n    // Download\n    // =======================\n    // Time from receipt of headers to the finish time.\n    const downloadStart = timing ?\n        Types.Timing.MicroSeconds(\n            timing.requestTime * SECONDS_TO_MICROSECONDS + timing.receiveHeadersEnd * MILLISECONDS_TO_MICROSECONDS) :\n        startTime;\n    const download = timing ? Types.Timing.MicroSeconds(((finishTime || downloadStart) - downloadStart)) :\n                              Types.Timing.MicroSeconds(endTime - request.receiveResponse.ts);\n\n    const totalTime = Types.Timing.MicroSeconds(networkDuration + processingDuration);\n\n    // Collect a few values from the timing info.\n    // If the Network request is cached, these fields will be zero, so the minus will zero out them.\n    const dnsLookup = timing ?\n        Types.Timing.MicroSeconds((timing.dnsEnd - timing.dnsStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.MicroSeconds(0);\n    const ssl = timing ? Types.Timing.MicroSeconds((timing.sslEnd - timing.sslStart) * MILLISECONDS_TO_MICROSECONDS) :\n                         Types.Timing.MicroSeconds(0);\n    const proxyNegotiation = timing ?\n        Types.Timing.MicroSeconds((timing.proxyEnd - timing.proxyStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.MicroSeconds(0);\n    const requestSent = timing ?\n        Types.Timing.MicroSeconds((timing.sendEnd - timing.sendStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.MicroSeconds(0);\n    const initialConnection = timing ?\n        Types.Timing.MicroSeconds((timing.connectEnd - timing.connectStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.MicroSeconds(0);\n\n    // Finally get some of the general data from the trace events.\n    const {frame, url, renderBlocking} = finalSendRequest.args.data;\n    const {encodedDataLength, decodedBodyLength} =\n        request.resourceFinish ? request.resourceFinish.args.data : {encodedDataLength: 0, decodedBodyLength: 0};\n    const parsedUrl = new URL(url);\n    const isHttps = parsedUrl.protocol === 'https:';\n    const requestingFrameUrl =\n        Helpers.Trace.activeURLForFrameAtTime(frame, finalSendRequest.ts, rendererProcessesByFrame) || '';\n    // Construct a synthetic trace event for this network request.\n    const networkEvent =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticNetworkRequest>({\n          rawSourceEvent: finalSendRequest,\n          args: {\n            data: {\n              // All data we create from trace events should be added to |syntheticData|.\n              syntheticData: {\n                dnsLookup,\n                download,\n                downloadStart,\n                finishTime,\n                initialConnection,\n                isDiskCached,\n                isHttps,\n                isMemoryCached,\n                isPushedResource,\n                networkDuration,\n                processingDuration,\n                proxyNegotiation,\n                queueing,\n                redirectionDuration,\n                requestSent,\n                sendStartTime,\n                ssl,\n                stalled,\n                totalTime,\n                waiting,\n              },\n              // All fields below are from TraceEventsForNetworkRequest.\n              decodedBodyLength,\n              encodedDataLength,\n              frame,\n              fromServiceWorker: request.receiveResponse.args.data.fromServiceWorker,\n              isLinkPreload: finalSendRequest.args.data.isLinkPreload || false,\n              mimeType: request.receiveResponse.args.data.mimeType,\n              priority: finalPriority,\n              initialPriority,\n              protocol: request.receiveResponse.args.data.protocol ?? 'unknown',\n              redirects,\n              // In the event the property isn't set, assume non-blocking.\n              renderBlocking: renderBlocking ?? 'non_blocking',\n              requestId,\n              requestingFrameUrl,\n              requestMethod: finalSendRequest.args.data.requestMethod,\n              resourceType: finalSendRequest.args.data.resourceType ?? Protocol.Network.ResourceType.Other,\n              statusCode: request.receiveResponse.args.data.statusCode,\n              responseHeaders: request.receiveResponse.args.data.headers || [],\n              fetchPriorityHint: finalSendRequest.args.data.fetchPriorityHint ?? 'auto',\n              initiator: finalSendRequest.args.data.initiator,\n              stackTrace: finalSendRequest.args.data.stackTrace,\n              timing,\n              url,\n              failed: request.resourceFinish?.args.data.didFail ?? false,\n              finished: Boolean(request.resourceFinish),\n              connectionId: request.receiveResponse.args.data.connectionId,\n              connectionReused: request.receiveResponse.args.data.connectionReused,\n            },\n          },\n          cat: 'loading',\n          name: 'SyntheticNetworkRequest',\n          ph: Types.Events.Phase.COMPLETE,\n          dur: Types.Timing.MicroSeconds(endTime - startTime),\n          tdur: Types.Timing.MicroSeconds(endTime - startTime),\n          ts: Types.Timing.MicroSeconds(startTime),\n          tts: Types.Timing.MicroSeconds(startTime),\n          pid: finalSendRequest.pid,\n          tid: finalSendRequest.tid,\n        });\n\n    const requests = Platform.MapUtilities.getWithDefault(requestsByOrigin, parsedUrl.host, () => {\n      return {\n        renderBlocking: [],\n        nonRenderBlocking: [],\n        all: [],\n      };\n    });\n\n    // For ease of rendering we sometimes want to differentiate between\n    // render-blocking and non-render-blocking, so we divide the data here.\n    if (!Helpers.Network.isSyntheticNetworkRequestEventRenderBlocking(networkEvent)) {\n      requests.nonRenderBlocking.push(networkEvent);\n    } else {\n      requests.renderBlocking.push(networkEvent);\n    }\n\n    // However, there are also times where we just want to loop through all\n    // the captured requests, so here we store all of them together.\n    requests.all.push(networkEvent);\n    requestsByTime.push(networkEvent);\n    requestsById.set(networkEvent.args.data.requestId, networkEvent);\n\n    const initiatorUrl = networkEvent.args.data.initiator?.url ||\n        Helpers.Trace.getZeroIndexedStackTraceForEvent(networkEvent)?.at(0)?.url;\n    if (initiatorUrl) {\n      const events = networkRequestEventByInitiatorUrl.get(initiatorUrl) ?? [];\n      events.push(networkEvent);\n      networkRequestEventByInitiatorUrl.set(initiatorUrl, events);\n    }\n  }\n\n  for (const request of requestsByTime) {\n    const initiatedEvents = networkRequestEventByInitiatorUrl.get(request.args.data.url);\n\n    if (initiatedEvents) {\n      for (const initiatedEvent of initiatedEvents) {\n        eventToInitiatorMap.set(initiatedEvent, request);\n      }\n    }\n  }\n  finalizeWebSocketData();\n}\n\nexport function data(): NetworkRequestData {\n  return {\n    byId: requestsById,\n    byOrigin: requestsByOrigin,\n    byTime: requestsByTime,\n    eventToInitiator: eventToInitiatorMap,\n    webSocket: [...webSocketData.values()],\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\nfunction finalizeWebSocketData(): void {\n  // for each WebSocketTraceData in webSocketData map, we create a synthetic event\n  // to represent the entire WebSocket connection. This is done by finding the start and end event\n  // if they exist, and if they don't, we use the first event in the list for start, and the traceBounds.max\n  // for the end. So each WebSocketTraceData will have\n  // {\n  //    events:  the list of WebSocket events\n  //    syntheticConnection:  the synthetic event representing the entire WebSocket connection\n  // }\n  webSocketData.forEach(data => {\n    let startEvent: Types.Events.WebSocketEvent|null = null;\n    let endEvent: Types.Events.WebSocketDestroy|null = null;\n    for (const event of data.events) {\n      if (Types.Events.isWebSocketCreate(event)) {\n        startEvent = event;\n      }\n      if (Types.Events.isWebSocketDestroy(event)) {\n        endEvent = event;\n      }\n    }\n    data.syntheticConnection = createSyntheticWebSocketConnection(startEvent, endEvent, data.events[0]);\n  });\n}\n\nfunction createSyntheticWebSocketConnection(\n    startEvent: Types.Events.WebSocketCreate|null, endEvent: Types.Events.WebSocketDestroy|null,\n    firstRecordedEvent: Types.Events.WebSocketEvent): Types.Events.SyntheticWebSocketConnection {\n  const {traceBounds} = metaHandlerData();\n  const startTs = startEvent ? startEvent.ts : traceBounds.min;\n  const endTs = endEvent ? endEvent.ts : traceBounds.max;\n  const duration = endTs - startTs;\n  const mainEvent = startEvent || endEvent || firstRecordedEvent;\n  return {\n    name: 'SyntheticWebSocketConnection',\n    cat: mainEvent.cat,\n    ph: Types.Events.Phase.COMPLETE,\n    ts: startTs,\n    dur: duration as Types.Timing.MicroSeconds,\n    pid: mainEvent.pid,\n    tid: mainEvent.tid,\n    s: mainEvent.s,\n    rawSourceEvent: mainEvent,\n    _tag: 'SyntheticEntryTag',\n    args: {\n      data: {\n        identifier: mainEvent.args.data.identifier,\n        priority: Protocol.Network.ResourcePriority.Low,\n        url: mainEvent.args.data.url || '',\n      },\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["data"]
}
