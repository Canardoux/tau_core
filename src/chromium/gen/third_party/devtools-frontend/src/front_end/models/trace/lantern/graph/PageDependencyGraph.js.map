{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/graph/PageDependencyGraph.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport type * as Lantern from '../types/types.js';\n\nimport type {Node} from './BaseNode.js';\nimport {CPUNode} from './CPUNode.js';\nimport {NetworkNode} from './NetworkNode.js';\n\n// COMPAT: m71+ We added RunTask to `disabled-by-default-lighthouse`\nconst SCHEDULABLE_TASK_TITLE_LH = 'RunTask';\n// m69-70 DoWork is different and we now need RunTask, see https://bugs.chromium.org/p/chromium/issues/detail?id=871204#c11\nconst SCHEDULABLE_TASK_TITLE_ALT1 = 'ThreadControllerImpl::RunTask';\n// In m66-68 refactored to this task title, https://crrev.com/c/883346\nconst SCHEDULABLE_TASK_TITLE_ALT2 = 'ThreadControllerImpl::DoWork';\n// m65 and earlier\nconst SCHEDULABLE_TASK_TITLE_ALT3 = 'TaskQueueManager::ProcessTaskFromWorkQueue';\n\ninterface NetworkNodeOutput {\n  nodes: Array<NetworkNode>;\n  idToNodeMap: Map<string, NetworkNode>;\n  urlToNodeMap: Map<string, Array<NetworkNode>>;\n  frameIdToNodeMap: Map<string, NetworkNode|null>;\n}\n\n// Shorter tasks have negligible impact on simulation results.\nconst SIGNIFICANT_DUR_THRESHOLD_MS = 10;\n\n// TODO: video files tend to be enormous and throw off all graph traversals, move this ignore\n//    into estimation logic when we use the dependency graph for other purposes.\nconst IGNORED_MIME_TYPES_REGEX = /^video/;\n\nclass PageDependencyGraph {\n  static getNetworkInitiators(request: Lantern.NetworkRequest): string[] {\n    if (!request.initiator) {\n      return [];\n    }\n    if (request.initiator.url) {\n      return [request.initiator.url];\n    }\n    if (request.initiator.type === 'script') {\n      // Script initiators have the stack of callFrames from all functions that led to this request.\n      // If async stacks are enabled, then the stack will also have the parent functions that asynchronously\n      // led to this request chained in the `parent` property.\n      const scriptURLs = new Set<string>();\n      let stack = request.initiator.stack;\n      while (stack) {\n        const callFrames = stack.callFrames || [];\n        for (const frame of callFrames) {\n          if (frame.url) {\n            scriptURLs.add(frame.url);\n          }\n        }\n\n        stack = stack.parent;\n      }\n\n      return Array.from(scriptURLs);\n    }\n\n    return [];\n  }\n\n  static getNetworkNodeOutput(networkRequests: Lantern.NetworkRequest[]): NetworkNodeOutput {\n    const nodes: Array<NetworkNode> = [];\n    const idToNodeMap = new Map<string, NetworkNode>();\n    const urlToNodeMap = new Map<string, Array<NetworkNode>>();\n    const frameIdToNodeMap = new Map<string, NetworkNode|null>();\n\n    networkRequests.forEach(request => {\n      if (IGNORED_MIME_TYPES_REGEX.test(request.mimeType)) {\n        return;\n      }\n      if (request.fromWorker) {\n        return;\n      }\n\n      // Network requestIds can be duplicated for an unknown reason\n      // Suffix all subsequent requests with `:duplicate` until it's unique\n      // NOTE: This should never happen with modern NetworkRequest library, but old fixtures\n      // might still have this issue.\n      while (idToNodeMap.has(request.requestId)) {\n        request.requestId += ':duplicate';\n      }\n\n      const node = new NetworkNode(request);\n      nodes.push(node);\n\n      const urlList = urlToNodeMap.get(request.url) || [];\n      urlList.push(node);\n\n      idToNodeMap.set(request.requestId, node);\n      urlToNodeMap.set(request.url, urlList);\n\n      // If the request was for the root document of an iframe, save an entry in our\n      // map so we can link up the task `args.data.frame` dependencies later in graph creation.\n      if (request.frameId && request.resourceType === 'Document' && request.documentURL === request.url) {\n        // If there's ever any ambiguity, permanently set the value to `false` to avoid loops in the graph.\n        const value = frameIdToNodeMap.has(request.frameId) ? null : node;\n        frameIdToNodeMap.set(request.frameId, value);\n      }\n    });\n\n    return {nodes, idToNodeMap, urlToNodeMap, frameIdToNodeMap};\n  }\n\n  static isScheduleableTask(evt: Lantern.TraceEvent): boolean {\n    return evt.name === SCHEDULABLE_TASK_TITLE_LH || evt.name === SCHEDULABLE_TASK_TITLE_ALT1 ||\n        evt.name === SCHEDULABLE_TASK_TITLE_ALT2 || evt.name === SCHEDULABLE_TASK_TITLE_ALT3;\n  }\n\n  /**\n   * There should *always* be at least one top level event, having 0 typically means something is\n   * drastically wrong with the trace and we should just give up early and loudly.\n   */\n  static assertHasToplevelEvents(events: Lantern.TraceEvent[]): void {\n    const hasToplevelTask = events.some(this.isScheduleableTask);\n    if (!hasToplevelTask) {\n      throw new Core.LanternError('Could not find any top level events');\n    }\n  }\n\n  static getCPUNodes(mainThreadEvents: Lantern.TraceEvent[]): CPUNode[] {\n    const nodes: CPUNode[] = [];\n    let i = 0;\n\n    PageDependencyGraph.assertHasToplevelEvents(mainThreadEvents);\n\n    while (i < mainThreadEvents.length) {\n      const evt = mainThreadEvents[i];\n      i++;\n\n      // Skip all trace events that aren't schedulable tasks with sizable duration\n      if (!PageDependencyGraph.isScheduleableTask(evt) || !evt.dur) {\n        continue;\n      }\n\n      let correctedEndTs: number|undefined = undefined;\n\n      // Capture all events that occurred within the task\n      const children: Lantern.TraceEvent[] = [];\n      for (const endTime = evt.ts + evt.dur; i < mainThreadEvents.length && mainThreadEvents[i].ts < endTime; i++) {\n        const event = mainThreadEvents[i];\n\n        // Temporary fix for a Chrome bug where some RunTask events can be overlapping.\n        // We correct that here be ensuring each RunTask ends at least 1 microsecond before the next\n        // https://github.com/GoogleChrome/lighthouse/issues/15896\n        // https://issues.chromium.org/issues/329678173\n        if (PageDependencyGraph.isScheduleableTask(event) && event.dur) {\n          correctedEndTs = event.ts - 1;\n          break;\n        }\n\n        children.push(event);\n      }\n\n      nodes.push(new CPUNode(evt, children, correctedEndTs));\n    }\n\n    return nodes;\n  }\n\n  static linkNetworkNodes(rootNode: NetworkNode, networkNodeOutput: NetworkNodeOutput): void {\n    networkNodeOutput.nodes.forEach(node => {\n      const directInitiatorRequest = node.request.initiatorRequest || rootNode.request;\n      const directInitiatorNode = networkNodeOutput.idToNodeMap.get(directInitiatorRequest.requestId) || rootNode;\n      const canDependOnInitiator = !directInitiatorNode.isDependentOn(node) && node.canDependOn(directInitiatorNode);\n      const initiators = PageDependencyGraph.getNetworkInitiators(node.request);\n      if (initiators.length) {\n        initiators.forEach(initiator => {\n          const parentCandidates = networkNodeOutput.urlToNodeMap.get(initiator) || [];\n          // Only add the edge if the parent is unambiguous with valid timing and isn't circular.\n          if (parentCandidates.length === 1 && parentCandidates[0].startTime <= node.startTime &&\n              !parentCandidates[0].isDependentOn(node)) {\n            node.addDependency(parentCandidates[0]);\n          } else if (canDependOnInitiator) {\n            directInitiatorNode.addDependent(node);\n          }\n        });\n      } else if (canDependOnInitiator) {\n        directInitiatorNode.addDependent(node);\n      }\n\n      // Make sure the nodes are attached to the graph if the initiator information was invalid.\n      if (node !== rootNode && node.getDependencies().length === 0 && node.canDependOn(rootNode)) {\n        node.addDependency(rootNode);\n      }\n\n      if (!node.request.redirects) {\n        return;\n      }\n\n      const redirects = [...node.request.redirects, node.request];\n      for (let i = 1; i < redirects.length; i++) {\n        const redirectNode = networkNodeOutput.idToNodeMap.get(redirects[i - 1].requestId);\n        const actualNode = networkNodeOutput.idToNodeMap.get(redirects[i].requestId);\n        if (actualNode && redirectNode) {\n          actualNode.addDependency(redirectNode);\n        }\n      }\n    });\n  }\n\n  static linkCPUNodes(rootNode: Node, networkNodeOutput: NetworkNodeOutput, cpuNodes: CPUNode[]): void {\n    const linkableResourceTypes = new Set<Lantern.ResourceType|undefined>([\n      'XHR',\n      'Fetch',\n      'Script',\n    ]);\n\n    function addDependentNetworkRequest(cpuNode: CPUNode, reqId: string): void {\n      const networkNode = networkNodeOutput.idToNodeMap.get(reqId);\n      if (!networkNode ||\n          // Ignore all network nodes that started before this CPU task started\n          // A network request that started earlier could not possibly have been started by this task\n          networkNode.startTime <= cpuNode.startTime) {\n        return;\n      }\n      const {request} = networkNode;\n      const resourceType = request.resourceType || request.redirectDestination?.resourceType;\n      if (!linkableResourceTypes.has(resourceType)) {\n        // We only link some resources to CPU nodes because we observe LCP simulation\n        // regressions when including images, etc.\n        return;\n      }\n      cpuNode.addDependent(networkNode);\n    }\n\n    /**\n     * If the node has an associated frameId, then create a dependency on the root document request\n     * for the frame. The task obviously couldn't have started before the frame was even downloaded.\n     */\n    function addDependencyOnFrame(cpuNode: CPUNode, frameId: string|undefined): void {\n      if (!frameId) {\n        return;\n      }\n      const networkNode = networkNodeOutput.frameIdToNodeMap.get(frameId);\n      if (!networkNode) {\n        return;\n      }\n      // Ignore all network nodes that started after this CPU task started\n      // A network request that started after could not possibly be required this task\n      if (networkNode.startTime >= cpuNode.startTime) {\n        return;\n      }\n      cpuNode.addDependency(networkNode);\n    }\n\n    function addDependencyOnUrl(cpuNode: CPUNode, url: string): void {\n      if (!url) {\n        return;\n      }\n      // Allow network requests that end up to 100ms before the task started\n      // Some script evaluations can start before the script finishes downloading\n      const minimumAllowableTimeSinceNetworkNodeEnd = -100 * 1000;\n      const candidates = networkNodeOutput.urlToNodeMap.get(url) || [];\n\n      let minCandidate = null;\n      let minDistance = Infinity;\n      // Find the closest request that finished before this CPU task started\n      for (const candidate of candidates) {\n        // Explicitly ignore all requests that started after this CPU node\n        // A network request that started after this task started cannot possibly be a dependency\n        if (cpuNode.startTime <= candidate.startTime) {\n          return;\n        }\n\n        const distance = cpuNode.startTime - candidate.endTime;\n        if (distance >= minimumAllowableTimeSinceNetworkNodeEnd && distance < minDistance) {\n          minCandidate = candidate;\n          minDistance = distance;\n        }\n      }\n\n      if (!minCandidate) {\n        return;\n      }\n      cpuNode.addDependency(minCandidate);\n    }\n\n    const timers = new Map<string, CPUNode>();\n    for (const node of cpuNodes) {\n      for (const evt of node.childEvents) {\n        if (!evt.args.data) {\n          continue;\n        }\n\n        const argsUrl = evt.args.data.url;\n        const stackTraceUrls = (evt.args.data.stackTrace || []).map(l => l.url).filter(Boolean);\n\n        switch (evt.name) {\n          case 'TimerInstall':\n            // @ts-expect-error - 'TimerInstall' event means timerId exists.\n            timers.set(evt.args.data.timerId, node);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n          case 'TimerFire': {\n            // @ts-expect-error - 'TimerFire' event means timerId exists.\n            const installer = timers.get(evt.args.data.timerId);\n            if (!installer || installer.endTime > node.startTime) {\n              break;\n            }\n            installer.addDependent(node);\n            break;\n          }\n\n          case 'InvalidateLayout':\n          case 'ScheduleStyleRecalculation':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n\n          case 'EvaluateScript':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            // @ts-expect-error - 'EvaluateScript' event means argsUrl is defined.\n            addDependencyOnUrl(node, argsUrl);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n\n          case 'XHRReadyStateChange':\n            // Only create the dependency if the request was completed\n            // 'XHRReadyStateChange' event means readyState is defined.\n            if (evt.args.data.readyState !== 4) {\n              break;\n            }\n\n            // @ts-expect-error - 'XHRReadyStateChange' event means argsUrl is defined.\n            addDependencyOnUrl(node, argsUrl);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n\n          case 'FunctionCall':\n          case 'v8.compile':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            // @ts-expect-error - events mean argsUrl is defined.\n            addDependencyOnUrl(node, argsUrl);\n            break;\n\n          case 'ParseAuthorStyleSheet':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            // @ts-expect-error - 'ParseAuthorStyleSheet' event means styleSheetUrl is defined.\n            addDependencyOnUrl(node, evt.args.data.styleSheetUrl);\n            break;\n\n          case 'ResourceSendRequest':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            // @ts-expect-error - 'ResourceSendRequest' event means requestId is defined.\n            addDependentNetworkRequest(node, evt.args.data.requestId);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n        }\n      }\n\n      // Nodes starting before the root node cannot depend on it.\n      if (node.getNumberOfDependencies() === 0 && node.canDependOn(rootNode)) {\n        node.addDependency(rootNode);\n      }\n    }\n\n    // Second pass to prune the graph of short tasks.\n    const minimumEvtDur = SIGNIFICANT_DUR_THRESHOLD_MS * 1000;\n    let foundFirstLayout = false;\n    let foundFirstPaint = false;\n    let foundFirstParse = false;\n\n    for (const node of cpuNodes) {\n      // Don't prune if event is the first ParseHTML/Layout/Paint.\n      // See https://github.com/GoogleChrome/lighthouse/issues/9627#issuecomment-526699524 for more.\n      let isFirst = false;\n      if (!foundFirstLayout && node.childEvents.some(evt => evt.name === 'Layout')) {\n        isFirst = foundFirstLayout = true;\n      }\n      if (!foundFirstPaint && node.childEvents.some(evt => evt.name === 'Paint')) {\n        isFirst = foundFirstPaint = true;\n      }\n      if (!foundFirstParse && node.childEvents.some(evt => evt.name === 'ParseHTML')) {\n        isFirst = foundFirstParse = true;\n      }\n\n      if (isFirst || node.duration >= minimumEvtDur) {\n        // Don't prune this node. The task is long / important so it will impact simulation.\n        continue;\n      }\n\n      // Prune the node if it isn't highly connected to minimize graph size. Rewiring the graph\n      // here replaces O(M + N) edges with (M * N) edges, which is fine if either  M or N is at\n      // most 1.\n      if (node.getNumberOfDependencies() === 1 || node.getNumberOfDependents() <= 1) {\n        PageDependencyGraph.pruneNode(node);\n      }\n    }\n  }\n\n  /**\n   * Removes the given node from the graph, but retains all paths between its dependencies and\n   * dependents.\n   */\n  static pruneNode(node: Node): void {\n    const dependencies = node.getDependencies();\n    const dependents = node.getDependents();\n    for (const dependency of dependencies) {\n      node.removeDependency(dependency);\n      for (const dependent of dependents) {\n        dependency.addDependent(dependent);\n      }\n    }\n    for (const dependent of dependents) {\n      node.removeDependent(dependent);\n    }\n  }\n\n  /**\n   * TODO: remove when CDT backend in Lighthouse is gone. Until then, this is a useful debugging tool\n   * to find delta between using CDP or the trace to create the network requests.\n   *\n   * When a test fails using the trace backend, I enabled this debug method and copied the network\n   * requests when CDP was used, then when trace is used, and diff'd them. This method helped\n   * remove non-logical differences from the comparison (order of properties, slight rounding\n   * discrepancies, removing object cycles, etc).\n   *\n   * When using for a unit test, make sure to do `.only` so you are getting what you expect.\n   */\n  static debugNormalizeRequests(lanternRequests: Lantern.NetworkRequest[]): void {\n    for (const request of lanternRequests) {\n      request.rendererStartTime = Math.round(request.rendererStartTime * 1000) / 1000;\n      request.networkRequestTime = Math.round(request.networkRequestTime * 1000) / 1000;\n      request.responseHeadersEndTime = Math.round(request.responseHeadersEndTime * 1000) / 1000;\n      request.networkEndTime = Math.round(request.networkEndTime * 1000) / 1000;\n    }\n\n    for (const r of lanternRequests) {\n      delete r.rawRequest;\n      if (r.initiatorRequest) {\n        // @ts-expect-error\n        r.initiatorRequest = {id: r.initiatorRequest.requestId};\n      }\n      if (r.redirectDestination) {\n        // @ts-expect-error\n        r.redirectDestination = {id: r.redirectDestination.requestId};\n      }\n      if (r.redirectSource) {\n        // @ts-expect-error\n        r.redirectSource = {id: r.redirectSource.requestId};\n      }\n      if (r.redirects) {\n        // @ts-expect-error\n        r.redirects = r.redirects.map(r2 => r2.requestId);\n      }\n    }\n    const requests: Lantern.NetworkRequest[] = lanternRequests\n                                                   .map(r => ({\n                                                          requestId: r.requestId,\n                                                          connectionId: r.connectionId,\n                                                          connectionReused: r.connectionReused,\n                                                          url: r.url,\n                                                          protocol: r.protocol,\n                                                          parsedURL: r.parsedURL,\n                                                          documentURL: r.documentURL,\n                                                          rendererStartTime: r.rendererStartTime,\n                                                          networkRequestTime: r.networkRequestTime,\n                                                          responseHeadersEndTime: r.responseHeadersEndTime,\n                                                          networkEndTime: r.networkEndTime,\n                                                          transferSize: r.transferSize,\n                                                          resourceSize: r.resourceSize,\n                                                          fromDiskCache: r.fromDiskCache,\n                                                          fromMemoryCache: r.fromMemoryCache,\n                                                          finished: r.finished,\n                                                          statusCode: r.statusCode,\n                                                          redirectSource: r.redirectSource,\n                                                          redirectDestination: r.redirectDestination,\n                                                          redirects: r.redirects,\n                                                          failed: r.failed,\n                                                          initiator: r.initiator,\n                                                          timing: r.timing ? {\n                                                            requestTime: r.timing.requestTime,\n                                                            proxyStart: r.timing.proxyStart,\n                                                            proxyEnd: r.timing.proxyEnd,\n                                                            dnsStart: r.timing.dnsStart,\n                                                            dnsEnd: r.timing.dnsEnd,\n                                                            connectStart: r.timing.connectStart,\n                                                            connectEnd: r.timing.connectEnd,\n                                                            sslStart: r.timing.sslStart,\n                                                            sslEnd: r.timing.sslEnd,\n                                                            workerStart: r.timing.workerStart,\n                                                            workerReady: r.timing.workerReady,\n                                                            workerFetchStart: r.timing.workerFetchStart,\n                                                            workerRespondWithSettled: r.timing.workerRespondWithSettled,\n                                                            sendStart: r.timing.sendStart,\n                                                            sendEnd: r.timing.sendEnd,\n                                                            pushStart: r.timing.pushStart,\n                                                            pushEnd: r.timing.pushEnd,\n                                                            receiveHeadersStart: r.timing.receiveHeadersStart,\n                                                            receiveHeadersEnd: r.timing.receiveHeadersEnd,\n                                                          } :\n                                                                             r.timing,\n                                                          resourceType: r.resourceType,\n                                                          mimeType: r.mimeType,\n                                                          priority: r.priority,\n                                                          initiatorRequest: r.initiatorRequest,\n                                                          frameId: r.frameId,\n                                                          fromWorker: r.fromWorker,\n                                                          isLinkPreload: r.isLinkPreload,\n                                                          serverResponseTime: r.serverResponseTime,\n                                                        }))\n                                                   .filter(r => !r.fromWorker);\n    // eslint-disable-next-line no-unused-vars\n    const debug = requests;\n    // Set breakpoint here.\n    // Copy `debug` and compare with https://www.diffchecker.com/text-compare/\n    // eslint-disable-next-line no-console\n    console.log(debug);\n  }\n\n  static createGraph(\n      mainThreadEvents: Lantern.TraceEvent[], networkRequests: Lantern.NetworkRequest[],\n      url: Lantern.Simulation.URL): Node {\n    // This is for debugging trace/devtoolslog network records.\n    // const debug = PageDependencyGraph.debugNormalizeRequests(networkRequests);\n    const networkNodeOutput = PageDependencyGraph.getNetworkNodeOutput(networkRequests);\n    const cpuNodes = PageDependencyGraph.getCPUNodes(mainThreadEvents);\n    const {requestedUrl, mainDocumentUrl} = url;\n    if (!requestedUrl) {\n      throw new Core.LanternError('requestedUrl is required to get the root request');\n    }\n    if (!mainDocumentUrl) {\n      throw new Core.LanternError('mainDocumentUrl is required to get the main resource');\n    }\n\n    const rootRequest = Core.NetworkAnalyzer.findResourceForUrl(networkRequests, requestedUrl);\n    if (!rootRequest) {\n      throw new Core.LanternError('rootRequest not found');\n    }\n    const rootNode = networkNodeOutput.idToNodeMap.get(rootRequest.requestId);\n    if (!rootNode) {\n      throw new Core.LanternError('rootNode not found');\n    }\n    const mainDocumentRequest = Core.NetworkAnalyzer.findLastDocumentForUrl(networkRequests, mainDocumentUrl);\n    if (!mainDocumentRequest) {\n      throw new Core.LanternError('mainDocumentRequest not found');\n    }\n    const mainDocumentNode = networkNodeOutput.idToNodeMap.get(mainDocumentRequest.requestId);\n    if (!mainDocumentNode) {\n      throw new Core.LanternError('mainDocumentNode not found');\n    }\n\n    PageDependencyGraph.linkNetworkNodes(rootNode, networkNodeOutput);\n    PageDependencyGraph.linkCPUNodes(rootNode, networkNodeOutput, cpuNodes);\n    mainDocumentNode.setIsMainDocument(true);\n\n    if (NetworkNode.hasCycle(rootNode)) {\n      throw new Core.LanternError('Invalid dependency graph created, cycle detected');\n    }\n\n    return rootNode;\n  }\n\n  static printGraph(rootNode: Node, widthInCharacters = 100): void {\n    function padRight(str: string, target: number, padChar = ' '): string {\n      return str + padChar.repeat(Math.max(target - str.length, 0));\n    }\n\n    const nodes: Node[] = [];\n    rootNode.traverse(node => nodes.push(node));\n    nodes.sort((a, b) => a.startTime - b.startTime);\n\n    const min = nodes[0].startTime;\n    const max = nodes.reduce((max, node) => Math.max(max, node.endTime), 0);\n\n    const totalTime = max - min;\n    const timePerCharacter = totalTime / widthInCharacters;\n    nodes.forEach(node => {\n      const offset = Math.round((node.startTime - min) / timePerCharacter);\n      const length = Math.ceil((node.endTime - node.startTime) / timePerCharacter);\n      const bar = padRight('', offset) + padRight('', length, '=');\n\n      // @ts-expect-error -- disambiguate displayName from across possible Node types.\n      const displayName = node.request ? node.request.url : node.type;\n      // eslint-disable-next-line\n      console.log(padRight(bar, widthInCharacters), `| ${displayName.slice(0, 30)}`);\n    });\n  }\n}\n\nexport {PageDependencyGraph};\n"],
  "mappings": "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",
  "names": ["max"]
}
