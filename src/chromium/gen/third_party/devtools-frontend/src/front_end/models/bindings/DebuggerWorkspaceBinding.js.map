{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/bindings/DebuggerWorkspaceBinding.ts"],
  "sourcesContent": ["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport type * as TextUtils from '../text_utils/text_utils.js';\nimport * as Workspace from '../workspace/workspace.js';\n\nimport {CompilerScriptMapping} from './CompilerScriptMapping.js';\nimport {DebuggerLanguagePluginManager} from './DebuggerLanguagePlugins.js';\nimport {DefaultScriptMapping} from './DefaultScriptMapping.js';\nimport {IgnoreListManager} from './IgnoreListManager.js';\nimport {type LiveLocation, type LiveLocationPool, LiveLocationWithPool} from './LiveLocation.js';\nimport {NetworkProject} from './NetworkProject.js';\nimport type {ResourceMapping} from './ResourceMapping.js';\nimport {type ResourceScriptFile, ResourceScriptMapping} from './ResourceScriptMapping.js';\n\nlet debuggerWorkspaceBindingInstance: DebuggerWorkspaceBinding|undefined;\n\nexport class DebuggerWorkspaceBinding implements SDK.TargetManager.SDKModelObserver<SDK.DebuggerModel.DebuggerModel> {\n  readonly resourceMapping: ResourceMapping;\n  readonly #sourceMappings: DebuggerSourceMapping[];\n  readonly #debuggerModelToData: Map<SDK.DebuggerModel.DebuggerModel, ModelData>;\n  readonly #liveLocationPromises: Set<Promise<void|Location|StackTraceTopFrameLocation|null>>;\n  readonly pluginManager: DebuggerLanguagePluginManager;\n\n  private constructor(resourceMapping: ResourceMapping, targetManager: SDK.TargetManager.TargetManager) {\n    this.resourceMapping = resourceMapping;\n\n    this.#sourceMappings = [];\n\n    this.#debuggerModelToData = new Map();\n    targetManager.addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.GlobalObjectCleared, this.globalObjectCleared, this);\n    targetManager.addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.DebuggerResumed, this.debuggerResumed, this);\n    targetManager.observeModels(SDK.DebuggerModel.DebuggerModel, this);\n\n    this.#liveLocationPromises = new Set();\n\n    this.pluginManager = new DebuggerLanguagePluginManager(targetManager, resourceMapping.workspace, this);\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n    resourceMapping: ResourceMapping|null,\n    targetManager: SDK.TargetManager.TargetManager|null,\n  } = {forceNew: null, resourceMapping: null, targetManager: null}): DebuggerWorkspaceBinding {\n    const {forceNew, resourceMapping, targetManager} = opts;\n    if (!debuggerWorkspaceBindingInstance || forceNew) {\n      if (!resourceMapping || !targetManager) {\n        throw new Error(\n            `Unable to create DebuggerWorkspaceBinding: resourceMapping and targetManager must be provided: ${\n                new Error().stack}`);\n      }\n\n      debuggerWorkspaceBindingInstance = new DebuggerWorkspaceBinding(resourceMapping, targetManager);\n    }\n\n    return debuggerWorkspaceBindingInstance;\n  }\n\n  static removeInstance(): void {\n    debuggerWorkspaceBindingInstance = undefined;\n  }\n\n  addSourceMapping(sourceMapping: DebuggerSourceMapping): void {\n    this.#sourceMappings.push(sourceMapping);\n  }\n\n  removeSourceMapping(sourceMapping: DebuggerSourceMapping): void {\n    const index = this.#sourceMappings.indexOf(sourceMapping);\n    if (index !== -1) {\n      this.#sourceMappings.splice(index, 1);\n    }\n  }\n\n  private async computeAutoStepRanges(mode: SDK.DebuggerModel.StepMode, callFrame: SDK.DebuggerModel.CallFrame):\n      Promise<SDK.DebuggerModel.LocationRange[]> {\n    function contained(location: SDK.DebuggerModel.Location, range: SDK.DebuggerModel.LocationRange): boolean {\n      const {start, end} = range;\n      if (start.scriptId !== location.scriptId) {\n        return false;\n      }\n      if (location.lineNumber < start.lineNumber || location.lineNumber > end.lineNumber) {\n        return false;\n      }\n      if (location.lineNumber === start.lineNumber && location.columnNumber < start.columnNumber) {\n        return false;\n      }\n      if (location.lineNumber === end.lineNumber && location.columnNumber >= end.columnNumber) {\n        return false;\n      }\n      return true;\n    }\n\n    const rawLocation = callFrame.location();\n    if (!rawLocation) {\n      return [];\n    }\n    const pluginManager = this.pluginManager;\n    let ranges: SDK.DebuggerModel.LocationRange[] = [];\n    if (mode === SDK.DebuggerModel.StepMode.STEP_OUT) {\n      // Step out of inline function.\n      return await pluginManager.getInlinedFunctionRanges(rawLocation);\n    }\n    const uiLocation = await pluginManager.rawLocationToUILocation(rawLocation);\n    if (uiLocation) {\n      ranges = await pluginManager.uiLocationToRawLocationRanges(\n                   uiLocation.uiSourceCode, uiLocation.lineNumber, uiLocation.columnNumber) ||\n          [];\n      // TODO(bmeurer): Remove the {rawLocation} from the {ranges}?\n      ranges = ranges.filter(range => contained(rawLocation, range));\n      if (mode === SDK.DebuggerModel.StepMode.STEP_OVER) {\n        // Step over an inlined function.\n        ranges = ranges.concat(await pluginManager.getInlinedCalleesRanges(rawLocation));\n      }\n      return ranges;\n    }\n\n    const compilerMapping = this.#debuggerModelToData.get(rawLocation.debuggerModel)?.compilerMapping;\n    if (!compilerMapping) {\n      return [];\n    }\n    ranges = compilerMapping.getLocationRangesForSameSourceLocation(rawLocation);\n    ranges = ranges.filter(range => contained(rawLocation, range));\n    return ranges;\n  }\n\n  modelAdded(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModel.setBeforePausedCallback(this.shouldPause.bind(this));\n    this.#debuggerModelToData.set(debuggerModel, new ModelData(debuggerModel, this));\n    debuggerModel.setComputeAutoStepRangesCallback(this.computeAutoStepRanges.bind(this));\n  }\n\n  modelRemoved(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModel.setComputeAutoStepRangesCallback(null);\n    const modelData = this.#debuggerModelToData.get(debuggerModel);\n    if (modelData) {\n      modelData.dispose();\n      this.#debuggerModelToData.delete(debuggerModel);\n    }\n  }\n\n  /**\n   * The promise returned by this function is resolved once all *currently*\n   * pending LiveLocations are processed.\n   */\n  async pendingLiveLocationChangesPromise(): Promise<void|Location|StackTraceTopFrameLocation|null> {\n    await Promise.all(this.#liveLocationPromises);\n  }\n\n  private recordLiveLocationChange(promise: Promise<void|Location|StackTraceTopFrameLocation|null>): void {\n    void promise.then(() => {\n      this.#liveLocationPromises.delete(promise);\n    });\n    this.#liveLocationPromises.add(promise);\n  }\n\n  async updateLocations(script: SDK.Script.Script): Promise<void> {\n    const modelData = this.#debuggerModelToData.get(script.debuggerModel);\n    if (modelData) {\n      const updatePromise = modelData.updateLocations(script);\n      this.recordLiveLocationChange(updatePromise);\n      await updatePromise;\n    }\n  }\n\n  async createLiveLocation(\n      rawLocation: SDK.DebuggerModel.Location, updateDelegate: (arg0: LiveLocation) => Promise<void>,\n      locationPool: LiveLocationPool): Promise<Location|null> {\n    const modelData = this.#debuggerModelToData.get(rawLocation.debuggerModel);\n    if (!modelData) {\n      return null;\n    }\n    const liveLocationPromise = modelData.createLiveLocation(rawLocation, updateDelegate, locationPool);\n    this.recordLiveLocationChange(liveLocationPromise);\n    return liveLocationPromise;\n  }\n\n  async createStackTraceTopFrameLiveLocation(\n      rawLocations: SDK.DebuggerModel.Location[], updateDelegate: (arg0: LiveLocation) => Promise<void>,\n      locationPool: LiveLocationPool): Promise<LiveLocation> {\n    console.assert(rawLocations.length > 0);\n    const locationPromise =\n        StackTraceTopFrameLocation.createStackTraceTopFrameLocation(rawLocations, this, updateDelegate, locationPool);\n    this.recordLiveLocationChange(locationPromise);\n    return locationPromise;\n  }\n\n  async createCallFrameLiveLocation(\n      location: SDK.DebuggerModel.Location, updateDelegate: (arg0: LiveLocation) => Promise<void>,\n      locationPool: LiveLocationPool): Promise<Location|null> {\n    const script = location.script();\n    if (!script) {\n      return null;\n    }\n    const debuggerModel = location.debuggerModel;\n    const liveLocationPromise = this.createLiveLocation(location, updateDelegate, locationPool);\n    this.recordLiveLocationChange(liveLocationPromise);\n    const liveLocation = await liveLocationPromise;\n    if (!liveLocation) {\n      return null;\n    }\n    this.registerCallFrameLiveLocation(debuggerModel, liveLocation);\n    return liveLocation;\n  }\n\n  async rawLocationToUILocation(rawLocation: SDK.DebuggerModel.Location):\n      Promise<Workspace.UISourceCode.UILocation|null> {\n    for (const sourceMapping of this.#sourceMappings) {\n      const uiLocation = sourceMapping.rawLocationToUILocation(rawLocation);\n      if (uiLocation) {\n        return uiLocation;\n      }\n    }\n    const uiLocation = await this.pluginManager.rawLocationToUILocation(rawLocation);\n    if (uiLocation) {\n      return uiLocation;\n    }\n    const modelData = this.#debuggerModelToData.get(rawLocation.debuggerModel);\n    return modelData ? modelData.rawLocationToUILocation(rawLocation) : null;\n  }\n\n  uiSourceCodeForSourceMapSourceURL(\n      debuggerModel: SDK.DebuggerModel.DebuggerModel, url: Platform.DevToolsPath.UrlString,\n      isContentScript: boolean): Workspace.UISourceCode.UISourceCode|null {\n    const modelData = this.#debuggerModelToData.get(debuggerModel);\n    if (!modelData) {\n      return null;\n    }\n    return modelData.compilerMapping.uiSourceCodeForURL(url, isContentScript);\n  }\n\n  async uiSourceCodeForSourceMapSourceURLPromise(\n      debuggerModel: SDK.DebuggerModel.DebuggerModel, url: Platform.DevToolsPath.UrlString,\n      isContentScript: boolean): Promise<Workspace.UISourceCode.UISourceCode> {\n    const uiSourceCode = this.uiSourceCodeForSourceMapSourceURL(debuggerModel, url, isContentScript);\n    return uiSourceCode || this.waitForUISourceCodeAdded(url, debuggerModel.target());\n  }\n\n  async uiSourceCodeForDebuggerLanguagePluginSourceURLPromise(\n      debuggerModel: SDK.DebuggerModel.DebuggerModel,\n      url: Platform.DevToolsPath.UrlString): Promise<Workspace.UISourceCode.UISourceCode|null> {\n    const uiSourceCode = this.pluginManager.uiSourceCodeForURL(debuggerModel, url);\n    return uiSourceCode || this.waitForUISourceCodeAdded(url, debuggerModel.target());\n  }\n\n  uiSourceCodeForScript(script: SDK.Script.Script): Workspace.UISourceCode.UISourceCode|null {\n    const modelData = this.#debuggerModelToData.get(script.debuggerModel);\n    if (!modelData) {\n      return null;\n    }\n    return modelData.uiSourceCodeForScript(script);\n  }\n\n  waitForUISourceCodeAdded(url: Platform.DevToolsPath.UrlString, target: SDK.Target.Target):\n      Promise<Workspace.UISourceCode.UISourceCode> {\n    return new Promise(resolve => {\n      const workspace = Workspace.Workspace.WorkspaceImpl.instance();\n      const descriptor = workspace.addEventListener(Workspace.Workspace.Events.UISourceCodeAdded, event => {\n        const uiSourceCode = event.data;\n        if (uiSourceCode.url() === url && NetworkProject.targetForUISourceCode(uiSourceCode) === target) {\n          workspace.removeEventListener(Workspace.Workspace.Events.UISourceCodeAdded, descriptor.listener);\n          resolve(uiSourceCode);\n        }\n      });\n    });\n  }\n\n  async uiLocationToRawLocations(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number,\n      columnNumber?: number): Promise<SDK.DebuggerModel.Location[]> {\n    for (const sourceMapping of this.#sourceMappings) {\n      const locations = sourceMapping.uiLocationToRawLocations(uiSourceCode, lineNumber, columnNumber);\n      if (locations.length) {\n        return locations;\n      }\n    }\n    const locations = await this.pluginManager.uiLocationToRawLocations(uiSourceCode, lineNumber, columnNumber);\n    if (locations) {\n      return locations;\n    }\n    for (const modelData of this.#debuggerModelToData.values()) {\n      const locations = modelData.uiLocationToRawLocations(uiSourceCode, lineNumber, columnNumber);\n      if (locations.length) {\n        return locations;\n      }\n    }\n    return [];\n  }\n\n  /**\n   * Computes all the raw location ranges that intersect with the {@link textRange} in the given\n   * {@link uiSourceCode}. The reverse mappings of the returned ranges must not be fully contained\n   * with the {@link textRange} and it's the responsibility of the caller to appropriately filter or\n   * clamp if desired.\n   *\n   * It's important to note that for a contiguous range in the {@link uiSourceCode} there can be a\n   * variety of non-contiguous raw location ranges that intersect with the {@link textRange}. A\n   * simple example is that of an HTML document with multiple inline `<script>`s in the same line,\n   * so just asking for the raw locations in this single line will return a set of location ranges\n   * in different scripts.\n   *\n   * This method returns an empty array if this {@link uiSourceCode} is not provided by any of the\n   * mappings for this instance.\n   *\n   * @param uiSourceCode the {@link UISourceCode} to which the {@link textRange} belongs.\n   * @param textRange the text range in terms of the UI.\n   * @returns the list of raw location ranges that intersect with the text range or `[]` if\n   *          the {@link uiSourceCode} does not belong to this instance.\n   */\n  async uiLocationRangeToRawLocationRanges(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode,\n      textRange: TextUtils.TextRange.TextRange): Promise<SDK.DebuggerModel.LocationRange[]> {\n    for (const sourceMapping of this.#sourceMappings) {\n      const ranges = sourceMapping.uiLocationRangeToRawLocationRanges(uiSourceCode, textRange);\n      if (ranges) {\n        return ranges;\n      }\n    }\n    const ranges = await this.pluginManager.uiLocationRangeToRawLocationRanges(uiSourceCode, textRange);\n    if (ranges) {\n      return ranges;\n    }\n    for (const modelData of this.#debuggerModelToData.values()) {\n      const ranges = modelData.uiLocationRangeToRawLocationRanges(uiSourceCode, textRange);\n      if (ranges) {\n        return ranges;\n      }\n    }\n    return [];\n  }\n\n  uiLocationToRawLocationsForUnformattedJavaScript(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number,\n      columnNumber: number): SDK.DebuggerModel.Location[] {\n    console.assert(uiSourceCode.contentType().isScript());\n    const locations = [];\n    for (const modelData of this.#debuggerModelToData.values()) {\n      locations.push(...modelData.uiLocationToRawLocations(uiSourceCode, lineNumber, columnNumber));\n    }\n    return locations;\n  }\n\n  async normalizeUILocation(uiLocation: Workspace.UISourceCode.UILocation): Promise<Workspace.UISourceCode.UILocation> {\n    const rawLocations =\n        await this.uiLocationToRawLocations(uiLocation.uiSourceCode, uiLocation.lineNumber, uiLocation.columnNumber);\n    for (const location of rawLocations) {\n      const uiLocationCandidate = await this.rawLocationToUILocation(location);\n      if (uiLocationCandidate) {\n        return uiLocationCandidate;\n      }\n    }\n    return uiLocation;\n  }\n\n  /**\n   * Computes the set of lines in the {@link uiSourceCode} that map to scripts by either looking at\n   * the debug info (if any) or checking for inline scripts within documents. If this set cannot be\n   * computed or all the lines in the {@link uiSourceCode} correspond to lines in a script, `null`\n   * is returned here.\n   *\n   * @param uiSourceCode the source entity.\n   * @returns a set of known mapped lines for {@link uiSourceCode} or `null` if it's impossible to\n   *          determine the set or the {@link uiSourceCode} does not map to or include any scripts.\n   */\n  async getMappedLines(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<Set<number>|null> {\n    for (const modelData of this.#debuggerModelToData.values()) {\n      const mappedLines = modelData.getMappedLines(uiSourceCode);\n      if (mappedLines !== null) {\n        return mappedLines;\n      }\n    }\n    return await this.pluginManager.getMappedLines(uiSourceCode);\n  }\n\n  scriptFile(uiSourceCode: Workspace.UISourceCode.UISourceCode, debuggerModel: SDK.DebuggerModel.DebuggerModel):\n      ResourceScriptFile|null {\n    const modelData = this.#debuggerModelToData.get(debuggerModel);\n    return modelData ? modelData.getResourceScriptMapping().scriptFile(uiSourceCode) : null;\n  }\n\n  scriptsForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): SDK.Script.Script[] {\n    const scripts = new Set<SDK.Script.Script>();\n    this.pluginManager.scriptsForUISourceCode(uiSourceCode).forEach(script => scripts.add(script));\n    for (const modelData of this.#debuggerModelToData.values()) {\n      const resourceScriptFile = modelData.getResourceScriptMapping().scriptFile(uiSourceCode);\n      if (resourceScriptFile && resourceScriptFile.script) {\n        scripts.add(resourceScriptFile.script);\n      }\n      modelData.compilerMapping.scriptsForUISourceCode(uiSourceCode).forEach(script => scripts.add(script));\n    }\n    return [...scripts];\n  }\n\n  supportsConditionalBreakpoints(uiSourceCode: Workspace.UISourceCode.UISourceCode): boolean {\n    const scripts = this.pluginManager.scriptsForUISourceCode(uiSourceCode);\n    return scripts.every(script => script.isJavaScript());\n  }\n\n  private globalObjectCleared(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    this.reset(event.data);\n  }\n\n  private reset(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    const modelData = this.#debuggerModelToData.get(debuggerModel);\n    if (!modelData) {\n      return;\n    }\n    for (const location of modelData.callFrameLocations.values()) {\n      this.removeLiveLocation(location);\n    }\n    modelData.callFrameLocations.clear();\n  }\n\n  resetForTest(target: SDK.Target.Target): void {\n    const debuggerModel = (target.model(SDK.DebuggerModel.DebuggerModel) as SDK.DebuggerModel.DebuggerModel);\n    const modelData = this.#debuggerModelToData.get(debuggerModel);\n    if (modelData) {\n      modelData.getResourceScriptMapping().resetForTest();\n    }\n  }\n\n  private registerCallFrameLiveLocation(debuggerModel: SDK.DebuggerModel.DebuggerModel, location: Location): void {\n    const modelData = this.#debuggerModelToData.get(debuggerModel);\n    if (modelData) {\n      const locations = modelData.callFrameLocations;\n      locations.add(location);\n    }\n  }\n\n  removeLiveLocation(location: Location): void {\n    const modelData = this.#debuggerModelToData.get(location.rawLocation.debuggerModel);\n    if (modelData) {\n      modelData.disposeLocation(location);\n    }\n  }\n\n  private debuggerResumed(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    this.reset(event.data);\n  }\n\n  private async shouldPause(\n      debuggerPausedDetails: SDK.DebuggerModel.DebuggerPausedDetails,\n      autoSteppingContext: SDK.DebuggerModel.Location|null): Promise<boolean> {\n    // This function returns false if the debugger should continue stepping\n    const {callFrames: [frame]} = debuggerPausedDetails;\n    if (!frame) {\n      return false;\n    }\n    const functionLocation = frame.functionLocation();\n    if (!autoSteppingContext || debuggerPausedDetails.reason !== Protocol.Debugger.PausedEventReason.Step ||\n        !functionLocation || !frame.script.isWasm() || !Common.Settings.moduleSetting('wasm-auto-stepping').get() ||\n        !this.pluginManager.hasPluginForScript(frame.script)) {\n      return true;\n    }\n    const uiLocation = await this.pluginManager.rawLocationToUILocation(frame.location());\n    if (uiLocation) {\n      return true;\n    }\n\n    return autoSteppingContext.script() !== functionLocation.script() ||\n        autoSteppingContext.columnNumber !== functionLocation.columnNumber ||\n        autoSteppingContext.lineNumber !== functionLocation.lineNumber;\n  }\n}\n\nclass ModelData {\n  readonly #debuggerModel: SDK.DebuggerModel.DebuggerModel;\n  readonly #debuggerWorkspaceBinding: DebuggerWorkspaceBinding;\n  callFrameLocations: Set<Location>;\n  #defaultMapping: DefaultScriptMapping;\n  readonly #resourceMapping: ResourceMapping;\n  #resourceScriptMapping: ResourceScriptMapping;\n  readonly compilerMapping: CompilerScriptMapping;\n  readonly #locations: Platform.MapUtilities.Multimap<string, Location>;\n\n  constructor(debuggerModel: SDK.DebuggerModel.DebuggerModel, debuggerWorkspaceBinding: DebuggerWorkspaceBinding) {\n    this.#debuggerModel = debuggerModel;\n    this.#debuggerWorkspaceBinding = debuggerWorkspaceBinding;\n\n    this.callFrameLocations = new Set();\n\n    const {workspace} = debuggerWorkspaceBinding.resourceMapping;\n    this.#defaultMapping = new DefaultScriptMapping(debuggerModel, workspace, debuggerWorkspaceBinding);\n    this.#resourceMapping = debuggerWorkspaceBinding.resourceMapping;\n    this.#resourceScriptMapping = new ResourceScriptMapping(debuggerModel, workspace, debuggerWorkspaceBinding);\n    this.compilerMapping = new CompilerScriptMapping(debuggerModel, workspace, debuggerWorkspaceBinding);\n\n    this.#locations = new Platform.MapUtilities.Multimap();\n  }\n\n  async createLiveLocation(\n      rawLocation: SDK.DebuggerModel.Location, updateDelegate: (arg0: LiveLocation) => Promise<void>,\n      locationPool: LiveLocationPool): Promise<Location> {\n    console.assert(rawLocation.scriptId !== '');\n    const scriptId = rawLocation.scriptId;\n    const location = new Location(scriptId, rawLocation, this.#debuggerWorkspaceBinding, updateDelegate, locationPool);\n    this.#locations.set(scriptId, location);\n    await location.update();\n    return location;\n  }\n\n  disposeLocation(location: Location): void {\n    this.#locations.delete(location.scriptId, location);\n  }\n\n  async updateLocations(script: SDK.Script.Script): Promise<void> {\n    const promises = [];\n    for (const location of this.#locations.get(script.scriptId)) {\n      promises.push(location.update());\n    }\n    await Promise.all(promises);\n  }\n\n  rawLocationToUILocation(rawLocation: SDK.DebuggerModel.Location): Workspace.UISourceCode.UILocation|null {\n    let uiLocation = this.compilerMapping.rawLocationToUILocation(rawLocation);\n    uiLocation = uiLocation || this.#resourceScriptMapping.rawLocationToUILocation(rawLocation);\n    uiLocation = uiLocation || this.#resourceMapping.jsLocationToUILocation(rawLocation);\n    uiLocation = uiLocation || this.#defaultMapping.rawLocationToUILocation(rawLocation);\n    return uiLocation;\n  }\n\n  uiSourceCodeForScript(script: SDK.Script.Script): Workspace.UISourceCode.UISourceCode|null {\n    let uiSourceCode: Workspace.UISourceCode.UISourceCode|null = null;\n    uiSourceCode = uiSourceCode || this.#resourceScriptMapping.uiSourceCodeForScript(script);\n    uiSourceCode = uiSourceCode || this.#resourceMapping.uiSourceCodeForScript(script);\n    uiSourceCode = uiSourceCode || this.#defaultMapping.uiSourceCodeForScript(script);\n    return uiSourceCode;\n  }\n\n  uiLocationToRawLocations(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number,\n      columnNumber: number|undefined = 0): SDK.DebuggerModel.Location[] {\n    // TODO(crbug.com/1153123): Revisit the `#columnNumber = 0` and also preserve `undefined` for source maps?\n    let locations = this.compilerMapping.uiLocationToRawLocations(uiSourceCode, lineNumber, columnNumber);\n    locations = locations.length ?\n        locations :\n        this.#resourceScriptMapping.uiLocationToRawLocations(uiSourceCode, lineNumber, columnNumber);\n    locations = locations.length ?\n        locations :\n        this.#resourceMapping.uiLocationToJSLocations(uiSourceCode, lineNumber, columnNumber);\n    locations = locations.length ?\n        locations :\n        this.#defaultMapping.uiLocationToRawLocations(uiSourceCode, lineNumber, columnNumber);\n    return locations;\n  }\n\n  uiLocationRangeToRawLocationRanges(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode,\n      textRange: TextUtils.TextRange.TextRange): SDK.DebuggerModel.LocationRange[]|null {\n    let ranges = this.compilerMapping.uiLocationRangeToRawLocationRanges(uiSourceCode, textRange);\n    ranges ??= this.#resourceScriptMapping.uiLocationRangeToRawLocationRanges(uiSourceCode, textRange);\n    ranges ??= this.#resourceMapping.uiLocationRangeToJSLocationRanges(uiSourceCode, textRange);\n    ranges ??= this.#defaultMapping.uiLocationRangeToRawLocationRanges(uiSourceCode, textRange);\n    return ranges;\n  }\n\n  getMappedLines(uiSourceCode: Workspace.UISourceCode.UISourceCode): Set<number>|null {\n    const mappedLines = this.compilerMapping.getMappedLines(uiSourceCode);\n    // TODO(crbug.com/1411431): The scripts from the ResourceMapping appear over time,\n    // and there's currently no way to inform the UI to update.\n    // mappedLines = mappedLines ?? this.#resourceMapping.getMappedLines(uiSourceCode);\n    return mappedLines;\n  }\n\n  dispose(): void {\n    this.#debuggerModel.setBeforePausedCallback(null);\n    this.compilerMapping.dispose();\n    this.#resourceScriptMapping.dispose();\n    this.#defaultMapping.dispose();\n  }\n\n  getResourceScriptMapping(): ResourceScriptMapping {\n    return this.#resourceScriptMapping;\n  }\n}\n\nexport class Location extends LiveLocationWithPool {\n  readonly scriptId: string;\n  readonly rawLocation: SDK.DebuggerModel.Location;\n  readonly #binding: DebuggerWorkspaceBinding;\n\n  constructor(\n      scriptId: string, rawLocation: SDK.DebuggerModel.Location, binding: DebuggerWorkspaceBinding,\n      updateDelegate: (arg0: LiveLocation) => Promise<void>, locationPool: LiveLocationPool) {\n    super(updateDelegate, locationPool);\n    this.scriptId = scriptId;\n    this.rawLocation = rawLocation;\n    this.#binding = binding;\n  }\n\n  override async uiLocation(): Promise<Workspace.UISourceCode.UILocation|null> {\n    const debuggerModelLocation = this.rawLocation;\n    return this.#binding.rawLocationToUILocation(debuggerModelLocation);\n  }\n\n  override dispose(): void {\n    super.dispose();\n    this.#binding.removeLiveLocation(this);\n  }\n\n  override async isIgnoreListed(): Promise<boolean> {\n    const uiLocation = await this.uiLocation();\n    if (!uiLocation) {\n      return false;\n    }\n    return IgnoreListManager.instance().isUserOrSourceMapIgnoreListedUISourceCode(uiLocation.uiSourceCode);\n  }\n}\n\nclass StackTraceTopFrameLocation extends LiveLocationWithPool {\n  #updateScheduled: boolean;\n  #current: LiveLocation|null;\n  #locations: LiveLocation[]|null;\n  constructor(updateDelegate: (arg0: LiveLocation) => Promise<void>, locationPool: LiveLocationPool) {\n    super(updateDelegate, locationPool);\n    this.#updateScheduled = true;\n    this.#current = null;\n    this.#locations = null;\n  }\n\n  static async createStackTraceTopFrameLocation(\n      rawLocations: SDK.DebuggerModel.Location[], binding: DebuggerWorkspaceBinding,\n      updateDelegate: (arg0: LiveLocation) => Promise<void>,\n      locationPool: LiveLocationPool): Promise<StackTraceTopFrameLocation> {\n    const location = new StackTraceTopFrameLocation(updateDelegate, locationPool);\n    const locationsPromises = rawLocations.map(\n        rawLocation => binding.createLiveLocation(rawLocation, location.scheduleUpdate.bind(location), locationPool));\n    location.#locations = ((await Promise.all(locationsPromises)).filter(l => Boolean(l)) as Location[]);\n    await location.updateLocation();\n    return location;\n  }\n\n  override async uiLocation(): Promise<Workspace.UISourceCode.UILocation|null> {\n    return this.#current ? this.#current.uiLocation() : null;\n  }\n\n  override async isIgnoreListed(): Promise<boolean> {\n    return this.#current ? this.#current.isIgnoreListed() : false;\n  }\n\n  override dispose(): void {\n    super.dispose();\n    if (this.#locations) {\n      for (const location of this.#locations) {\n        location.dispose();\n      }\n    }\n    this.#locations = null;\n    this.#current = null;\n  }\n\n  private async scheduleUpdate(): Promise<void> {\n    if (this.#updateScheduled) {\n      return;\n    }\n    this.#updateScheduled = true;\n    queueMicrotask(() => {\n      void this.updateLocation();\n    });\n  }\n\n  private async updateLocation(): Promise<void> {\n    this.#updateScheduled = false;\n    if (!this.#locations || this.#locations.length === 0) {\n      return;\n    }\n\n    this.#current = this.#locations[0];\n    for (const location of this.#locations) {\n      if (!(await location.isIgnoreListed())) {\n        this.#current = location;\n        break;\n      }\n    }\n    void this.update();\n  }\n}\n\nexport interface DebuggerSourceMapping {\n  rawLocationToUILocation(rawLocation: SDK.DebuggerModel.Location): Workspace.UISourceCode.UILocation|null;\n\n  uiLocationToRawLocations(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number,\n      columnNumber?: number): SDK.DebuggerModel.Location[];\n\n  uiLocationRangeToRawLocationRanges(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode,\n      textRange: TextUtils.TextRange.TextRange): SDK.DebuggerModel.LocationRange[]|null;\n}\n"],
  "mappings": ";AAIA,YAAY,YAAY;AACxB,YAAY,cAAc;AAC1B,YAAY,SAAS;AACrB,YAAY,cAAc;AAE1B,YAAY,eAAe;AAE3B,SAAQ,6BAA4B;AACpC,SAAQ,qCAAoC;AAC5C,SAAQ,4BAA2B;AACnC,SAAQ,yBAAwB;AAChC,SAAkD,4BAA2B;AAC7E,SAAQ,sBAAqB;AAE7B,SAAiC,6BAA4B;AAE7D,IAAI;AAEG,aAAM,yBAAwG;AAAA,EAC1G;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAED,YAAY,iBAAkC,eAAgD;AACpG,SAAK,kBAAkB;AAEvB,SAAK,kBAAkB,CAAC;AAExB,SAAK,uBAAuB,oBAAI,IAAI;AACpC,kBAAc;AAAA,MACV,IAAI,cAAc;AAAA,MAAe,IAAI,cAAc,OAAO;AAAA,MAAqB,KAAK;AAAA,MAAqB;AAAA,IAAI;AACjH,kBAAc;AAAA,MACV,IAAI,cAAc;AAAA,MAAe,IAAI,cAAc,OAAO;AAAA,MAAiB,KAAK;AAAA,MAAiB;AAAA,IAAI;AACzG,kBAAc,cAAc,IAAI,cAAc,eAAe,IAAI;AAEjE,SAAK,wBAAwB,oBAAI,IAAI;AAErC,SAAK,gBAAgB,IAAI,8BAA8B,eAAe,gBAAgB,WAAW,IAAI;AAAA,EACvG;AAAA,EAEA,OAAO,SAAS,OAIZ,EAAC,UAAU,MAAM,iBAAiB,MAAM,eAAe,KAAI,GAA6B;AAC1F,UAAM,EAAC,UAAU,iBAAiB,cAAa,IAAI;AACnD,QAAI,CAAC,oCAAoC,UAAU;AACjD,UAAI,CAAC,mBAAmB,CAAC,eAAe;AACtC,cAAM,IAAI;AAAA,UACN,kGACI,IAAI,MAAM,EAAE,KAAK;AAAA,QAAE;AAAA,MAC7B;AAEA,yCAAmC,IAAI,yBAAyB,iBAAiB,aAAa;AAAA,IAChG;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,iBAAuB;AAC5B,uCAAmC;AAAA,EACrC;AAAA,EAEA,iBAAiB,eAA4C;AAC3D,SAAK,gBAAgB,KAAK,aAAa;AAAA,EACzC;AAAA,EAEA,oBAAoB,eAA4C;AAC9D,UAAM,QAAQ,KAAK,gBAAgB,QAAQ,aAAa;AACxD,QAAI,UAAU,IAAI;AAChB,WAAK,gBAAgB,OAAO,OAAO,CAAC;AAAA,IACtC;AAAA,EACF;AAAA,EAEA,MAAc,sBAAsB,MAAkC,WACvB;AAC7C,aAAS,UAAU,UAAsC,OAAiD;AACxG,YAAM,EAAC,OAAO,IAAG,IAAI;AACrB,UAAI,MAAM,aAAa,SAAS,UAAU;AACxC,eAAO;AAAA,MACT;AACA,UAAI,SAAS,aAAa,MAAM,cAAc,SAAS,aAAa,IAAI,YAAY;AAClF,eAAO;AAAA,MACT;AACA,UAAI,SAAS,eAAe,MAAM,cAAc,SAAS,eAAe,MAAM,cAAc;AAC1F,eAAO;AAAA,MACT;AACA,UAAI,SAAS,eAAe,IAAI,cAAc,SAAS,gBAAgB,IAAI,cAAc;AACvF,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAEA,UAAM,cAAc,UAAU,SAAS;AACvC,QAAI,CAAC,aAAa;AAChB,aAAO,CAAC;AAAA,IACV;AACA,UAAM,gBAAgB,KAAK;AAC3B,QAAI,SAA4C,CAAC;AACjD,QAAI,SAAS,IAAI,cAAc,SAAS,UAAU;AAEhD,aAAO,MAAM,cAAc,yBAAyB,WAAW;AAAA,IACjE;AACA,UAAM,aAAa,MAAM,cAAc,wBAAwB,WAAW;AAC1E,QAAI,YAAY;AACd,eAAS,MAAM,cAAc;AAAA,QAChB,WAAW;AAAA,QAAc,WAAW;AAAA,QAAY,WAAW;AAAA,MAAY,KAChF,CAAC;AAEL,eAAS,OAAO,OAAO,WAAS,UAAU,aAAa,KAAK,CAAC;AAC7D,UAAI,SAAS,IAAI,cAAc,SAAS,WAAW;AAEjD,iBAAS,OAAO,OAAO,MAAM,cAAc,wBAAwB,WAAW,CAAC;AAAA,MACjF;AACA,aAAO;AAAA,IACT;AAEA,UAAM,kBAAkB,KAAK,qBAAqB,IAAI,YAAY,aAAa,GAAG;AAClF,QAAI,CAAC,iBAAiB;AACpB,aAAO,CAAC;AAAA,IACV;AACA,aAAS,gBAAgB,uCAAuC,WAAW;AAC3E,aAAS,OAAO,OAAO,WAAS,UAAU,aAAa,KAAK,CAAC;AAC7D,WAAO;AAAA,EACT;AAAA,EAEA,WAAW,eAAsD;AAC/D,kBAAc,wBAAwB,KAAK,YAAY,KAAK,IAAI,CAAC;AACjE,SAAK,qBAAqB,IAAI,eAAe,IAAI,UAAU,eAAe,IAAI,CAAC;AAC/E,kBAAc,iCAAiC,KAAK,sBAAsB,KAAK,IAAI,CAAC;AAAA,EACtF;AAAA,EAEA,aAAa,eAAsD;AACjE,kBAAc,iCAAiC,IAAI;AACnD,UAAM,YAAY,KAAK,qBAAqB,IAAI,aAAa;AAC7D,QAAI,WAAW;AACb,gBAAU,QAAQ;AAClB,WAAK,qBAAqB,OAAO,aAAa;AAAA,IAChD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,oCAA4F;AAChG,UAAM,QAAQ,IAAI,KAAK,qBAAqB;AAAA,EAC9C;AAAA,EAEQ,yBAAyB,SAAuE;AACtG,SAAK,QAAQ,KAAK,MAAM;AACtB,WAAK,sBAAsB,OAAO,OAAO;AAAA,IAC3C,CAAC;AACD,SAAK,sBAAsB,IAAI,OAAO;AAAA,EACxC;AAAA,EAEA,MAAM,gBAAgB,QAA0C;AAC9D,UAAM,YAAY,KAAK,qBAAqB,IAAI,OAAO,aAAa;AACpE,QAAI,WAAW;AACb,YAAM,gBAAgB,UAAU,gBAAgB,MAAM;AACtD,WAAK,yBAAyB,aAAa;AAC3C,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,mBACF,aAAyC,gBACzC,cAAwD;AAC1D,UAAM,YAAY,KAAK,qBAAqB,IAAI,YAAY,aAAa;AACzE,QAAI,CAAC,WAAW;AACd,aAAO;AAAA,IACT;AACA,UAAM,sBAAsB,UAAU,mBAAmB,aAAa,gBAAgB,YAAY;AAClG,SAAK,yBAAyB,mBAAmB;AACjD,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,qCACF,cAA4C,gBAC5C,cAAuD;AACzD,YAAQ,OAAO,aAAa,SAAS,CAAC;AACtC,UAAM,kBACF,2BAA2B,iCAAiC,cAAc,MAAM,gBAAgB,YAAY;AAChH,SAAK,yBAAyB,eAAe;AAC7C,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,4BACF,UAAsC,gBACtC,cAAwD;AAC1D,UAAM,SAAS,SAAS,OAAO;AAC/B,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AACA,UAAM,gBAAgB,SAAS;AAC/B,UAAM,sBAAsB,KAAK,mBAAmB,UAAU,gBAAgB,YAAY;AAC1F,SAAK,yBAAyB,mBAAmB;AACjD,UAAM,eAAe,MAAM;AAC3B,QAAI,CAAC,cAAc;AACjB,aAAO;AAAA,IACT;AACA,SAAK,8BAA8B,eAAe,YAAY;AAC9D,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,wBAAwB,aACsB;AAClD,eAAW,iBAAiB,KAAK,iBAAiB;AAChD,YAAMA,cAAa,cAAc,wBAAwB,WAAW;AACpE,UAAIA,aAAY;AACd,eAAOA;AAAA,MACT;AAAA,IACF;AACA,UAAM,aAAa,MAAM,KAAK,cAAc,wBAAwB,WAAW;AAC/E,QAAI,YAAY;AACd,aAAO;AAAA,IACT;AACA,UAAM,YAAY,KAAK,qBAAqB,IAAI,YAAY,aAAa;AACzE,WAAO,YAAY,UAAU,wBAAwB,WAAW,IAAI;AAAA,EACtE;AAAA,EAEA,kCACI,eAAgD,KAChD,iBAAoE;AACtE,UAAM,YAAY,KAAK,qBAAqB,IAAI,aAAa;AAC7D,QAAI,CAAC,WAAW;AACd,aAAO;AAAA,IACT;AACA,WAAO,UAAU,gBAAgB,mBAAmB,KAAK,eAAe;AAAA,EAC1E;AAAA,EAEA,MAAM,yCACF,eAAgD,KAChD,iBAAwE;AAC1E,UAAM,eAAe,KAAK,kCAAkC,eAAe,KAAK,eAAe;AAC/F,WAAO,gBAAgB,KAAK,yBAAyB,KAAK,cAAc,OAAO,CAAC;AAAA,EAClF;AAAA,EAEA,MAAM,sDACF,eACA,KAAyF;AAC3F,UAAM,eAAe,KAAK,cAAc,mBAAmB,eAAe,GAAG;AAC7E,WAAO,gBAAgB,KAAK,yBAAyB,KAAK,cAAc,OAAO,CAAC;AAAA,EAClF;AAAA,EAEA,sBAAsB,QAAqE;AACzF,UAAM,YAAY,KAAK,qBAAqB,IAAI,OAAO,aAAa;AACpE,QAAI,CAAC,WAAW;AACd,aAAO;AAAA,IACT;AACA,WAAO,UAAU,sBAAsB,MAAM;AAAA,EAC/C;AAAA,EAEA,yBAAyB,KAAsC,QACd;AAC/C,WAAO,IAAI,QAAQ,aAAW;AAC5B,YAAM,YAAY,UAAU,UAAU,cAAc,SAAS;AAC7D,YAAM,aAAa,UAAU,iBAAiB,UAAU,UAAU,OAAO,mBAAmB,WAAS;AACnG,cAAM,eAAe,MAAM;AAC3B,YAAI,aAAa,IAAI,MAAM,OAAO,eAAe,sBAAsB,YAAY,MAAM,QAAQ;AAC/F,oBAAU,oBAAoB,UAAU,UAAU,OAAO,mBAAmB,WAAW,QAAQ;AAC/F,kBAAQ,YAAY;AAAA,QACtB;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,yBACF,cAAmD,YACnD,cAA8D;AAChE,eAAW,iBAAiB,KAAK,iBAAiB;AAChD,YAAMC,aAAY,cAAc,yBAAyB,cAAc,YAAY,YAAY;AAC/F,UAAIA,WAAU,QAAQ;AACpB,eAAOA;AAAA,MACT;AAAA,IACF;AACA,UAAM,YAAY,MAAM,KAAK,cAAc,yBAAyB,cAAc,YAAY,YAAY;AAC1G,QAAI,WAAW;AACb,aAAO;AAAA,IACT;AACA,eAAW,aAAa,KAAK,qBAAqB,OAAO,GAAG;AAC1D,YAAMA,aAAY,UAAU,yBAAyB,cAAc,YAAY,YAAY;AAC3F,UAAIA,WAAU,QAAQ;AACpB,eAAOA;AAAA,MACT;AAAA,IACF;AACA,WAAO,CAAC;AAAA,EACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,MAAM,mCACF,cACA,WAAsF;AACxF,eAAW,iBAAiB,KAAK,iBAAiB;AAChD,YAAMC,UAAS,cAAc,mCAAmC,cAAc,SAAS;AACvF,UAAIA,SAAQ;AACV,eAAOA;AAAA,MACT;AAAA,IACF;AACA,UAAM,SAAS,MAAM,KAAK,cAAc,mCAAmC,cAAc,SAAS;AAClG,QAAI,QAAQ;AACV,aAAO;AAAA,IACT;AACA,eAAW,aAAa,KAAK,qBAAqB,OAAO,GAAG;AAC1D,YAAMA,UAAS,UAAU,mCAAmC,cAAc,SAAS;AACnF,UAAIA,SAAQ;AACV,eAAOA;AAAA,MACT;AAAA,IACF;AACA,WAAO,CAAC;AAAA,EACV;AAAA,EAEA,iDACI,cAAmD,YACnD,cAAoD;AACtD,YAAQ,OAAO,aAAa,YAAY,EAAE,SAAS,CAAC;AACpD,UAAM,YAAY,CAAC;AACnB,eAAW,aAAa,KAAK,qBAAqB,OAAO,GAAG;AAC1D,gBAAU,KAAK,GAAG,UAAU,yBAAyB,cAAc,YAAY,YAAY,CAAC;AAAA,IAC9F;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,oBAAoB,YAA2F;AACnH,UAAM,eACF,MAAM,KAAK,yBAAyB,WAAW,cAAc,WAAW,YAAY,WAAW,YAAY;AAC/G,eAAW,YAAY,cAAc;AACnC,YAAM,sBAAsB,MAAM,KAAK,wBAAwB,QAAQ;AACvE,UAAI,qBAAqB;AACvB,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,eAAe,cAA8E;AACjG,eAAW,aAAa,KAAK,qBAAqB,OAAO,GAAG;AAC1D,YAAM,cAAc,UAAU,eAAe,YAAY;AACzD,UAAI,gBAAgB,MAAM;AACxB,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO,MAAM,KAAK,cAAc,eAAe,YAAY;AAAA,EAC7D;AAAA,EAEA,WAAW,cAAmD,eAClC;AAC1B,UAAM,YAAY,KAAK,qBAAqB,IAAI,aAAa;AAC7D,WAAO,YAAY,UAAU,yBAAyB,EAAE,WAAW,YAAY,IAAI;AAAA,EACrF;AAAA,EAEA,uBAAuB,cAAwE;AAC7F,UAAM,UAAU,oBAAI,IAAuB;AAC3C,SAAK,cAAc,uBAAuB,YAAY,EAAE,QAAQ,YAAU,QAAQ,IAAI,MAAM,CAAC;AAC7F,eAAW,aAAa,KAAK,qBAAqB,OAAO,GAAG;AAC1D,YAAM,qBAAqB,UAAU,yBAAyB,EAAE,WAAW,YAAY;AACvF,UAAI,sBAAsB,mBAAmB,QAAQ;AACnD,gBAAQ,IAAI,mBAAmB,MAAM;AAAA,MACvC;AACA,gBAAU,gBAAgB,uBAAuB,YAAY,EAAE,QAAQ,YAAU,QAAQ,IAAI,MAAM,CAAC;AAAA,IACtG;AACA,WAAO,CAAC,GAAG,OAAO;AAAA,EACpB;AAAA,EAEA,+BAA+B,cAA4D;AACzF,UAAM,UAAU,KAAK,cAAc,uBAAuB,YAAY;AACtE,WAAO,QAAQ,MAAM,YAAU,OAAO,aAAa,CAAC;AAAA,EACtD;AAAA,EAEQ,oBAAoB,OAAmF;AAC7G,SAAK,MAAM,MAAM,IAAI;AAAA,EACvB;AAAA,EAEQ,MAAM,eAAsD;AAClE,UAAM,YAAY,KAAK,qBAAqB,IAAI,aAAa;AAC7D,QAAI,CAAC,WAAW;AACd;AAAA,IACF;AACA,eAAW,YAAY,UAAU,mBAAmB,OAAO,GAAG;AAC5D,WAAK,mBAAmB,QAAQ;AAAA,IAClC;AACA,cAAU,mBAAmB,MAAM;AAAA,EACrC;AAAA,EAEA,aAAa,QAAiC;AAC5C,UAAM,gBAAiB,OAAO,MAAM,IAAI,cAAc,aAAa;AACnE,UAAM,YAAY,KAAK,qBAAqB,IAAI,aAAa;AAC7D,QAAI,WAAW;AACb,gBAAU,yBAAyB,EAAE,aAAa;AAAA,IACpD;AAAA,EACF;AAAA,EAEQ,8BAA8B,eAAgD,UAA0B;AAC9G,UAAM,YAAY,KAAK,qBAAqB,IAAI,aAAa;AAC7D,QAAI,WAAW;AACb,YAAM,YAAY,UAAU;AAC5B,gBAAU,IAAI,QAAQ;AAAA,IACxB;AAAA,EACF;AAAA,EAEA,mBAAmB,UAA0B;AAC3C,UAAM,YAAY,KAAK,qBAAqB,IAAI,SAAS,YAAY,aAAa;AAClF,QAAI,WAAW;AACb,gBAAU,gBAAgB,QAAQ;AAAA,IACpC;AAAA,EACF;AAAA,EAEQ,gBAAgB,OAAmF;AACzG,SAAK,MAAM,MAAM,IAAI;AAAA,EACvB;AAAA,EAEA,MAAc,YACV,uBACA,qBAAwE;AAE1E,UAAM,EAAC,YAAY,CAAC,KAAK,EAAC,IAAI;AAC9B,QAAI,CAAC,OAAO;AACV,aAAO;AAAA,IACT;AACA,UAAM,mBAAmB,MAAM,iBAAiB;AAChD,QAAI,CAAC,uBAAuB,sBAAsB,WAAW,SAAS,SAAS,kBAAkB,QAC7F,CAAC,oBAAoB,CAAC,MAAM,OAAO,OAAO,KAAK,CAAC,OAAO,SAAS,cAAc,oBAAoB,EAAE,IAAI,KACxG,CAAC,KAAK,cAAc,mBAAmB,MAAM,MAAM,GAAG;AACxD,aAAO;AAAA,IACT;AACA,UAAM,aAAa,MAAM,KAAK,cAAc,wBAAwB,MAAM,SAAS,CAAC;AACpF,QAAI,YAAY;AACd,aAAO;AAAA,IACT;AAEA,WAAO,oBAAoB,OAAO,MAAM,iBAAiB,OAAO,KAC5D,oBAAoB,iBAAiB,iBAAiB,gBACtD,oBAAoB,eAAe,iBAAiB;AAAA,EAC1D;AACF;AAEA,MAAM,UAAU;AAAA,EACL;AAAA,EACA;AAAA,EACT;AAAA,EACA;AAAA,EACS;AAAA,EACT;AAAA,EACS;AAAA,EACA;AAAA,EAET,YAAY,eAAgD,0BAAoD;AAC9G,SAAK,iBAAiB;AACtB,SAAK,4BAA4B;AAEjC,SAAK,qBAAqB,oBAAI,IAAI;AAElC,UAAM,EAAC,UAAS,IAAI,yBAAyB;AAC7C,SAAK,kBAAkB,IAAI,qBAAqB,eAAe,WAAW,wBAAwB;AAClG,SAAK,mBAAmB,yBAAyB;AACjD,SAAK,yBAAyB,IAAI,sBAAsB,eAAe,WAAW,wBAAwB;AAC1G,SAAK,kBAAkB,IAAI,sBAAsB,eAAe,WAAW,wBAAwB;AAEnG,SAAK,aAAa,IAAI,SAAS,aAAa,SAAS;AAAA,EACvD;AAAA,EAEA,MAAM,mBACF,aAAyC,gBACzC,cAAmD;AACrD,YAAQ,OAAO,YAAY,aAAa,EAAE;AAC1C,UAAM,WAAW,YAAY;AAC7B,UAAM,WAAW,IAAI,SAAS,UAAU,aAAa,KAAK,2BAA2B,gBAAgB,YAAY;AACjH,SAAK,WAAW,IAAI,UAAU,QAAQ;AACtC,UAAM,SAAS,OAAO;AACtB,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,UAA0B;AACxC,SAAK,WAAW,OAAO,SAAS,UAAU,QAAQ;AAAA,EACpD;AAAA,EAEA,MAAM,gBAAgB,QAA0C;AAC9D,UAAM,WAAW,CAAC;AAClB,eAAW,YAAY,KAAK,WAAW,IAAI,OAAO,QAAQ,GAAG;AAC3D,eAAS,KAAK,SAAS,OAAO,CAAC;AAAA,IACjC;AACA,UAAM,QAAQ,IAAI,QAAQ;AAAA,EAC5B;AAAA,EAEA,wBAAwB,aAAiF;AACvG,QAAI,aAAa,KAAK,gBAAgB,wBAAwB,WAAW;AACzE,iBAAa,cAAc,KAAK,uBAAuB,wBAAwB,WAAW;AAC1F,iBAAa,cAAc,KAAK,iBAAiB,uBAAuB,WAAW;AACnF,iBAAa,cAAc,KAAK,gBAAgB,wBAAwB,WAAW;AACnF,WAAO;AAAA,EACT;AAAA,EAEA,sBAAsB,QAAqE;AACzF,QAAI,eAAyD;AAC7D,mBAAe,gBAAgB,KAAK,uBAAuB,sBAAsB,MAAM;AACvF,mBAAe,gBAAgB,KAAK,iBAAiB,sBAAsB,MAAM;AACjF,mBAAe,gBAAgB,KAAK,gBAAgB,sBAAsB,MAAM;AAChF,WAAO;AAAA,EACT;AAAA,EAEA,yBACI,cAAmD,YACnD,eAAiC,GAAiC;AAEpE,QAAI,YAAY,KAAK,gBAAgB,yBAAyB,cAAc,YAAY,YAAY;AACpG,gBAAY,UAAU,SAClB,YACA,KAAK,uBAAuB,yBAAyB,cAAc,YAAY,YAAY;AAC/F,gBAAY,UAAU,SAClB,YACA,KAAK,iBAAiB,wBAAwB,cAAc,YAAY,YAAY;AACxF,gBAAY,UAAU,SAClB,YACA,KAAK,gBAAgB,yBAAyB,cAAc,YAAY,YAAY;AACxF,WAAO;AAAA,EACT;AAAA,EAEA,mCACI,cACA,WAAkF;AACpF,QAAI,SAAS,KAAK,gBAAgB,mCAAmC,cAAc,SAAS;AAC5F,eAAW,KAAK,uBAAuB,mCAAmC,cAAc,SAAS;AACjG,eAAW,KAAK,iBAAiB,kCAAkC,cAAc,SAAS;AAC1F,eAAW,KAAK,gBAAgB,mCAAmC,cAAc,SAAS;AAC1F,WAAO;AAAA,EACT;AAAA,EAEA,eAAe,cAAqE;AAClF,UAAM,cAAc,KAAK,gBAAgB,eAAe,YAAY;AAIpE,WAAO;AAAA,EACT;AAAA,EAEA,UAAgB;AACd,SAAK,eAAe,wBAAwB,IAAI;AAChD,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,uBAAuB,QAAQ;AACpC,SAAK,gBAAgB,QAAQ;AAAA,EAC/B;AAAA,EAEA,2BAAkD;AAChD,WAAO,KAAK;AAAA,EACd;AACF;AAEO,aAAM,iBAAiB,qBAAqB;AAAA,EACxC;AAAA,EACA;AAAA,EACA;AAAA,EAET,YACI,UAAkB,aAAyC,SAC3D,gBAAuD,cAAgC;AACzF,UAAM,gBAAgB,YAAY;AAClC,SAAK,WAAW;AAChB,SAAK,cAAc;AACnB,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,MAAe,aAA8D;AAC3E,UAAM,wBAAwB,KAAK;AACnC,WAAO,KAAK,SAAS,wBAAwB,qBAAqB;AAAA,EACpE;AAAA,EAES,UAAgB;AACvB,UAAM,QAAQ;AACd,SAAK,SAAS,mBAAmB,IAAI;AAAA,EACvC;AAAA,EAEA,MAAe,iBAAmC;AAChD,UAAM,aAAa,MAAM,KAAK,WAAW;AACzC,QAAI,CAAC,YAAY;AACf,aAAO;AAAA,IACT;AACA,WAAO,kBAAkB,SAAS,EAAE,0CAA0C,WAAW,YAAY;AAAA,EACvG;AACF;AAEA,MAAM,mCAAmC,qBAAqB;AAAA,EAC5D;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,gBAAuD,cAAgC;AACjG,UAAM,gBAAgB,YAAY;AAClC,SAAK,mBAAmB;AACxB,SAAK,WAAW;AAChB,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,aAAa,iCACT,cAA4C,SAC5C,gBACA,cAAqE;AACvE,UAAM,WAAW,IAAI,2BAA2B,gBAAgB,YAAY;AAC5E,UAAM,oBAAoB,aAAa;AAAA,MACnC,iBAAe,QAAQ,mBAAmB,aAAa,SAAS,eAAe,KAAK,QAAQ,GAAG,YAAY;AAAA,IAAC;AAChH,aAAS,cAAe,MAAM,QAAQ,IAAI,iBAAiB,GAAG,OAAO,OAAK,QAAQ,CAAC,CAAC;AACpF,UAAM,SAAS,eAAe;AAC9B,WAAO;AAAA,EACT;AAAA,EAEA,MAAe,aAA8D;AAC3E,WAAO,KAAK,WAAW,KAAK,SAAS,WAAW,IAAI;AAAA,EACtD;AAAA,EAEA,MAAe,iBAAmC;AAChD,WAAO,KAAK,WAAW,KAAK,SAAS,eAAe,IAAI;AAAA,EAC1D;AAAA,EAES,UAAgB;AACvB,UAAM,QAAQ;AACd,QAAI,KAAK,YAAY;AACnB,iBAAW,YAAY,KAAK,YAAY;AACtC,iBAAS,QAAQ;AAAA,MACnB;AAAA,IACF;AACA,SAAK,aAAa;AAClB,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,MAAc,iBAAgC;AAC5C,QAAI,KAAK,kBAAkB;AACzB;AAAA,IACF;AACA,SAAK,mBAAmB;AACxB,mBAAe,MAAM;AACnB,WAAK,KAAK,eAAe;AAAA,IAC3B,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,iBAAgC;AAC5C,SAAK,mBAAmB;AACxB,QAAI,CAAC,KAAK,cAAc,KAAK,WAAW,WAAW,GAAG;AACpD;AAAA,IACF;AAEA,SAAK,WAAW,KAAK,WAAW,CAAC;AACjC,eAAW,YAAY,KAAK,YAAY;AACtC,UAAI,CAAE,MAAM,SAAS,eAAe,GAAI;AACtC,aAAK,WAAW;AAChB;AAAA,MACF;AAAA,IACF;AACA,SAAK,KAAK,OAAO;AAAA,EACnB;AACF;",
  "names": ["uiLocation", "locations", "ranges"]
}
