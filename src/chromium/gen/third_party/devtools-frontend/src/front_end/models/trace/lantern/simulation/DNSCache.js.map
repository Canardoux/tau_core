{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/simulation/DNSCache.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Lantern from '../types/types.js';\n\n// A DNS lookup will usually take ~1-2 roundtrips of connection latency plus the extra DNS routing time.\n// Example: https://www.webpagetest.org/result/180703_3A_e33ec79747c002ed4d7bcbfc81462203/1/details/#waterfall_view_step1\n// Example: https://www.webpagetest.org/result/180707_1M_89673eb633b5d98386de95dfcf9b33d5/1/details/#waterfall_view_step1\n// DNS is highly variable though, many times it's a little more than 1, but can easily be 4-5x RTT.\n// We'll use 2 since it seems to give the most accurate results on average, but this can be tweaked.\nconst DNS_RESOLUTION_RTT_MULTIPLIER = 2;\n\nclass DNSCache {\n  static rttMultiplier = DNS_RESOLUTION_RTT_MULTIPLIER;\n\n  rtt: number;\n  resolvedDomainNames: Map<string, {resolvedAt: number}>;\n\n  constructor({rtt}: {rtt: number}) {\n    this.rtt = rtt;\n    this.resolvedDomainNames = new Map();\n  }\n\n  getTimeUntilResolution(request: Lantern.NetworkRequest, options?: {requestedAt: number, shouldUpdateCache: boolean}):\n      number {\n    const {requestedAt = 0, shouldUpdateCache = false} = options || {};\n\n    const domain = request.parsedURL.host;\n    const cacheEntry = this.resolvedDomainNames.get(domain);\n    let timeUntilResolved = this.rtt * DNSCache.rttMultiplier;\n    if (cacheEntry) {\n      const timeUntilCachedIsResolved = Math.max(cacheEntry.resolvedAt - requestedAt, 0);\n      timeUntilResolved = Math.min(timeUntilCachedIsResolved, timeUntilResolved);\n    }\n\n    const resolvedAt = requestedAt + timeUntilResolved;\n    if (shouldUpdateCache) {\n      this.updateCacheResolvedAtIfNeeded(request, resolvedAt);\n    }\n\n    return timeUntilResolved;\n  }\n\n  updateCacheResolvedAtIfNeeded(request: Lantern.NetworkRequest, resolvedAt: number): void {\n    const domain = request.parsedURL.host;\n    const cacheEntry = this.resolvedDomainNames.get(domain) || {resolvedAt};\n    cacheEntry.resolvedAt = Math.min(cacheEntry.resolvedAt, resolvedAt);\n    this.resolvedDomainNames.set(domain, cacheEntry);\n  }\n\n  /**\n   * Forcefully sets the DNS resolution time for a request.\n   * Useful for testing and alternate execution simulations.\n   */\n  setResolvedAt(domain: string, resolvedAt: number): void {\n    this.resolvedDomainNames.set(domain, {resolvedAt});\n  }\n}\n\nexport {DNSCache};\n"],
  "mappings": ";AAWA,MAAM,gCAAgC;AAEtC,MAAM,SAAS;AAAA,EACb,OAAO,gBAAgB;AAAA,EAEvB;AAAA,EACA;AAAA,EAEA,YAAY,EAAC,IAAG,GAAkB;AAChC,SAAK,MAAM;AACX,SAAK,sBAAsB,oBAAI,IAAI;AAAA,EACrC;AAAA,EAEA,uBAAuB,SAAiC,SAC7C;AACT,UAAM,EAAC,cAAc,GAAG,oBAAoB,MAAK,IAAI,WAAW,CAAC;AAEjE,UAAM,SAAS,QAAQ,UAAU;AACjC,UAAM,aAAa,KAAK,oBAAoB,IAAI,MAAM;AACtD,QAAI,oBAAoB,KAAK,MAAM,SAAS;AAC5C,QAAI,YAAY;AACd,YAAM,4BAA4B,KAAK,IAAI,WAAW,aAAa,aAAa,CAAC;AACjF,0BAAoB,KAAK,IAAI,2BAA2B,iBAAiB;AAAA,IAC3E;AAEA,UAAM,aAAa,cAAc;AACjC,QAAI,mBAAmB;AACrB,WAAK,8BAA8B,SAAS,UAAU;AAAA,IACxD;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,8BAA8B,SAAiC,YAA0B;AACvF,UAAM,SAAS,QAAQ,UAAU;AACjC,UAAM,aAAa,KAAK,oBAAoB,IAAI,MAAM,KAAK,EAAC,WAAU;AACtE,eAAW,aAAa,KAAK,IAAI,WAAW,YAAY,UAAU;AAClE,SAAK,oBAAoB,IAAI,QAAQ,UAAU;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,QAAgB,YAA0B;AACtD,SAAK,oBAAoB,IAAI,QAAQ,EAAC,WAAU,CAAC;AAAA,EACnD;AACF;AAEA,SAAQ;",
  "names": []
}
