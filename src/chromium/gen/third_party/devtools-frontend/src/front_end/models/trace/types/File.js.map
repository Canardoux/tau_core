{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/types/File.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CrUXManager from '../../../models/crux-manager/crux-manager.js';\n\nimport type {TraceWindowMicroSeconds} from './Timing.js';\nimport type {Event, LegacyTimelineFrame, ProcessID, SampleIndex, ThreadID} from './TraceEvents.js';\n\nexport type TraceFile = {\n  traceEvents: readonly Event[],\n  metadata: MetaData,\n};\n\nexport interface Breadcrumb {\n  window: TraceWindowMicroSeconds;\n  child: Breadcrumb|null;\n}\n\nexport const enum DataOrigin {\n  CPU_PROFILE = 'CPUProfile',\n  TRACE_EVENTS = 'TraceEvents',\n}\n\n/**\n * The Entries link can have 3 stated:\n *  1. The Link creation is not started yet, meaning only the button that needs to be clicked to start creating the link is visible.\n *  2. Pending to event - the creation is started, but the entry that the link points to has not been chosen yet\n *  3. Link connected - final state, both entries present\n */\nexport const enum EntriesLinkState {\n  CREATION_NOT_STARTED = 'creation_not_started',\n  PENDING_TO_EVENT = 'pending_to_event',\n  CONNECTED = 'connected',\n}\n\nexport const enum EventKeyType {\n  RAW_EVENT = 'r',\n  SYNTHETIC_EVENT = 's',\n  PROFILE_CALL = 'p',\n  LEGACY_TIMELINE_FRAME = 'l',\n}\n\n/**\n * Represents an object that is saved in the file when user created annotations in the timeline.\n *\n * Expected to add more annotations.\n */\nexport interface SerializedAnnotations {\n  entryLabels: EntryLabelAnnotationSerialized[];\n  labelledTimeRanges: TimeRangeAnnotationSerialized[];\n  linksBetweenEntries: EntriesLinkAnnotationSerialized[];\n}\n\n/**\n * Represents an object that is used to store the Entry Label annotation that is created when a user creates a label for an entry in the timeline.\n */\nexport interface EntryLabelAnnotation {\n  type: 'ENTRY_LABEL';\n  entry: Event|LegacyTimelineFrame;\n  label: string;\n}\n\n/**\n * Represents an object that is used to store the Labelled Time Range Annotation that is created when a user creates a Time Range Selection in the timeline.\n */\nexport interface TimeRangeAnnotation {\n  type: 'TIME_RANGE';\n  label: string;\n  bounds: TraceWindowMicroSeconds;\n}\n\nexport interface EntriesLinkAnnotation {\n  type: 'ENTRIES_LINK';\n  state: EntriesLinkState;\n  entryFrom: Event;\n  entryTo?: Event;\n}\n\n/**\n * Represents an object that is saved in the file when a user creates a label for an entry in the timeline.\n */\nexport interface EntryLabelAnnotationSerialized {\n  entry: SerializableKey;\n  label: string;\n}\n\n/**\n * Represents an object that is saved in the file when a user creates a time range with a label in the timeline.\n */\nexport interface TimeRangeAnnotationSerialized {\n  bounds: TraceWindowMicroSeconds;\n  label: string;\n}\n\n/**\n * Represents an object that is saved in the file when a user creates a link between entries in the timeline.\n */\nexport interface EntriesLinkAnnotationSerialized {\n  entryFrom: SerializableKey;\n  entryTo: SerializableKey;\n}\n\n/**\n * `Annotation` are the user-created annotations that are saved into the metadata.\n * Those annotations are rendered on the timeline by `Overlays.ts`\n *\n * TODO: Implement other OverlayAnnotations (annotated time ranges, links between entries).\n * TODO: Save/load overlay annotations to/from the trace file.\n */\nexport type Annotation = EntryLabelAnnotation|TimeRangeAnnotation|EntriesLinkAnnotation;\n\nexport function isTimeRangeAnnotation(annotation: Annotation): annotation is TimeRangeAnnotation {\n  return annotation.type === 'TIME_RANGE';\n}\n\nexport function isEntryLabelAnnotation(annotation: Annotation): annotation is EntryLabelAnnotation {\n  return annotation.type === 'ENTRY_LABEL';\n}\n\nexport function isEntriesLinkAnnotation(annotation: Annotation): annotation is EntriesLinkAnnotation {\n  return annotation.type === 'ENTRIES_LINK';\n}\n\n// Serializable keys are created for trace events to be able to save\n// references to timeline events in a trace file. These keys enable\n// user modifications that can be saved. See go/cpq:event-data-json for\n// more details on the key format.\nexport type RawEventKey = `${EventKeyType.RAW_EVENT}-${number}`;\nexport type SyntheticEventKey = `${EventKeyType.SYNTHETIC_EVENT}-${number}`;\nexport type ProfileCallKey = `${EventKeyType.PROFILE_CALL}-${ProcessID}-${ThreadID}-${SampleIndex}-${Protocol.integer}`;\nexport type LegacyTimelineFrameKey = `${EventKeyType.LEGACY_TIMELINE_FRAME}-${number}`;\nexport type SerializableKey = RawEventKey|ProfileCallKey|SyntheticEventKey|LegacyTimelineFrameKey;\n\n// Serializable keys values objects contain data that maps the keys to original Trace Events\nexport type RawEventKeyValues = {\n  type: EventKeyType.RAW_EVENT,\n  rawIndex: number,\n};\n\nexport type SyntheticEventKeyValues = {\n  type: EventKeyType.SYNTHETIC_EVENT,\n  rawIndex: number,\n};\n\nexport type ProfileCallKeyValues = {\n  type: EventKeyType.PROFILE_CALL,\n  processID: ProcessID,\n  threadID: ThreadID,\n  sampleIndex: SampleIndex,\n  protocol: Protocol.integer,\n};\n\nexport type LegacyTimelineFrameKeyValues = {\n  type: EventKeyType.LEGACY_TIMELINE_FRAME,\n  rawIndex: number,\n};\n\nexport type SerializableKeyValues =\n    RawEventKeyValues|ProfileCallKeyValues|SyntheticEventKeyValues|LegacyTimelineFrameKeyValues;\n\nexport interface Modifications {\n  entriesModifications: {\n    // Entries hidden by the user\n    hiddenEntries: SerializableKey[],\n    // Entries that parent a hiddenEntry\n    expandableEntries: SerializableKey[],\n  };\n  initialBreadcrumb: Breadcrumb;\n  annotations: SerializedAnnotations;\n}\n\n/**\n * Trace metadata that we persist to the file. This will allow us to\n * store specifics for the trace, e.g., which tracks should be visible\n * on load.\n */\nexport interface MetaData {\n  source?: 'DevTools';\n  startTime?: string;\n  emulatedDeviceTitle?: string;\n  // Only set if network throttling is active.\n  networkThrottling?: string;\n  // Only set if network throttling is active.\n  networkThrottlingConditions?: Omit<SDK.NetworkManager.Conditions, 'title'>;\n  // Only set if CPU throttling is active.\n  cpuThrottling?: number;\n  hardwareConcurrency?: number;\n  dataOrigin?: DataOrigin;\n  modifications?: Modifications;\n  enhancedTraceVersion?: number;\n  cruxFieldData?: CrUXManager.PageResult[];\n}\n\nexport type Contents = TraceFile|Event[];\n\nexport function traceEventKeyToValues(key: SerializableKey): SerializableKeyValues {\n  const parts = key.split('-');\n  const type = parts[0];\n\n  switch (type) {\n    case EventKeyType.PROFILE_CALL:\n      if (parts.length !== 5 ||\n          !(parts.every((part, i) => i === 0 || typeof part === 'number' || !isNaN(parseInt(part, 10))))) {\n        throw new Error(`Invalid ProfileCallKey: ${key}`);\n      }\n      return {\n        type: parts[0],\n        processID: parseInt(parts[1], 10),\n        threadID: parseInt(parts[2], 10),\n        sampleIndex: parseInt(parts[3], 10),\n        protocol: parseInt(parts[4], 10),\n      } as ProfileCallKeyValues;\n    case EventKeyType.RAW_EVENT:\n      if (parts.length !== 2 || !(typeof parts[1] === 'number' || !isNaN(parseInt(parts[1], 10)))) {\n        throw new Error(`Invalid RawEvent Key: ${key}`);\n      }\n      return {\n        type: parts[0],\n        rawIndex: parseInt(parts[1], 10),\n      } as RawEventKeyValues;\n    case EventKeyType.SYNTHETIC_EVENT:\n      if (parts.length !== 2 || !(typeof parts[1] === 'number' || !isNaN(parseInt(parts[1], 10)))) {\n        throw new Error(`Invalid SyntheticEvent Key: ${key}`);\n      }\n      return {\n        type: parts[0],\n        rawIndex: parseInt(parts[1], 10),\n      } as SyntheticEventKeyValues;\n    case EventKeyType.LEGACY_TIMELINE_FRAME: {\n      if (parts.length !== 2 || Number.isNaN(parseInt(parts[1], 10))) {\n        throw new Error(`Invalid LegacyTimelineFrame Key: ${key}`);\n      }\n      return {\n        type,\n        rawIndex: parseInt(parts[1], 10),\n      };\n    }\n\n    default:\n      throw new Error(`Unknown trace event key: ${key}`);\n  }\n}\n"],
  "mappings": ";AAqBO,WAAW,aAAX,kBAAWA,gBAAX;AACL,EAAAA,YAAA,iBAAc;AACd,EAAAA,YAAA,kBAAe;AAFC,SAAAA;AAAA,GAAA;AAWX,WAAW,mBAAX,kBAAWC,sBAAX;AACL,EAAAA,kBAAA,0BAAuB;AACvB,EAAAA,kBAAA,sBAAmB;AACnB,EAAAA,kBAAA,eAAY;AAHI,SAAAA;AAAA,GAAA;AAMX,WAAW,eAAX,kBAAWC,kBAAX;AACL,EAAAA,cAAA,eAAY;AACZ,EAAAA,cAAA,qBAAkB;AAClB,EAAAA,cAAA,kBAAe;AACf,EAAAA,cAAA,2BAAwB;AAJR,SAAAA;AAAA,GAAA;AA4EX,gBAAS,sBAAsB,YAA2D;AAC/F,SAAO,WAAW,SAAS;AAC7B;AAEO,gBAAS,uBAAuB,YAA4D;AACjG,SAAO,WAAW,SAAS;AAC7B;AAEO,gBAAS,wBAAwB,YAA6D;AACnG,SAAO,WAAW,SAAS;AAC7B;AA0EO,gBAAS,sBAAsB,KAA6C;AACjF,QAAM,QAAQ,IAAI,MAAM,GAAG;AAC3B,QAAM,OAAO,MAAM,CAAC;AAEpB,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,UAAI,MAAM,WAAW,KACjB,CAAE,MAAM,MAAM,CAAC,MAAM,MAAM,MAAM,KAAK,OAAO,SAAS,YAAY,CAAC,MAAM,SAAS,MAAM,EAAE,CAAC,CAAC,GAAI;AAClG,cAAM,IAAI,MAAM,2BAA2B,GAAG,EAAE;AAAA,MAClD;AACA,aAAO;AAAA,QACL,MAAM,MAAM,CAAC;AAAA,QACb,WAAW,SAAS,MAAM,CAAC,GAAG,EAAE;AAAA,QAChC,UAAU,SAAS,MAAM,CAAC,GAAG,EAAE;AAAA,QAC/B,aAAa,SAAS,MAAM,CAAC,GAAG,EAAE;AAAA,QAClC,UAAU,SAAS,MAAM,CAAC,GAAG,EAAE;AAAA,MACjC;AAAA,IACF,KAAK;AACH,UAAI,MAAM,WAAW,KAAK,EAAE,OAAO,MAAM,CAAC,MAAM,YAAY,CAAC,MAAM,SAAS,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI;AAC3F,cAAM,IAAI,MAAM,yBAAyB,GAAG,EAAE;AAAA,MAChD;AACA,aAAO;AAAA,QACL,MAAM,MAAM,CAAC;AAAA,QACb,UAAU,SAAS,MAAM,CAAC,GAAG,EAAE;AAAA,MACjC;AAAA,IACF,KAAK;AACH,UAAI,MAAM,WAAW,KAAK,EAAE,OAAO,MAAM,CAAC,MAAM,YAAY,CAAC,MAAM,SAAS,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI;AAC3F,cAAM,IAAI,MAAM,+BAA+B,GAAG,EAAE;AAAA,MACtD;AACA,aAAO;AAAA,QACL,MAAM,MAAM,CAAC;AAAA,QACb,UAAU,SAAS,MAAM,CAAC,GAAG,EAAE;AAAA,MACjC;AAAA,IACF,KAAK,iCAAoC;AACvC,UAAI,MAAM,WAAW,KAAK,OAAO,MAAM,SAAS,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG;AAC9D,cAAM,IAAI,MAAM,oCAAoC,GAAG,EAAE;AAAA,MAC3D;AACA,aAAO;AAAA,QACL;AAAA,QACA,UAAU,SAAS,MAAM,CAAC,GAAG,EAAE;AAAA,MACjC;AAAA,IACF;AAAA,IAEA;AACE,YAAM,IAAI,MAAM,4BAA4B,GAAG,EAAE;AAAA,EACrD;AACF;",
  "names": ["DataOrigin", "EntriesLinkState", "EventKeyType"]
}
