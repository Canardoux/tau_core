{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/PageLoadMetricsHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * This handler stores page load metrics, including web vitals,\n * and exports them in the shape of a map with the following shape:\n * Map(FrameId -> Map(navigationID -> metrics) )\n *\n * It also exports all markers in a trace in an array.\n *\n * Some metrics are taken directly from a page load events (AKA markers) like DCL.\n * Others require processing multiple events to be determined, like CLS and TBT.\n */\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * This represents the metric scores for all navigations, for all frames in a trace.\n * Given a frame id, the map points to another map from navigation id to metric scores.\n * The metric scores include the event related to the metric as well as the data regarding\n * the score itself.\n */\nconst metricScoresByFrameId =\n    new Map</* Frame id */ string, Map</* navigation id */ string, Map<MetricName, MetricScore>>>();\n\n/**\n * Page load events with no associated duration that happened in the\n * main frame.\n */\nlet allMarkerEvents: Types.Events.PageLoadEvent[] = [];\n\nexport function reset(): void {\n  metricScoresByFrameId.clear();\n  pageLoadEventsArray = [];\n  allMarkerEvents = [];\n  selectedLCPCandidateEvents.clear();\n}\n\nlet pageLoadEventsArray: Types.Events.PageLoadEvent[] = [];\n\n// Once we've found the LCP events in the trace we want to fetch their DOM Node\n// from the backend. We could do this by parsing through our Map of frame =>\n// navigation => metric, but it's easier to keep a set of LCP events. As we\n// parse the trace, any time we store an LCP candidate as the potential LCP\n// event, we store the event here. If we later find a new candidate in the\n// trace, we store that and delete the prior event. When we've parsed the\n// entire trace this set will contain all the LCP events that were used - e.g.\n// the candidates that were the actual LCP events.\nconst selectedLCPCandidateEvents = new Set<Types.Events.LargestContentfulPaintCandidate>();\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.eventIsPageLoadEvent(event)) {\n    return;\n  }\n  pageLoadEventsArray.push(event);\n}\n\nfunction storePageLoadMetricAgainstNavigationId(\n    navigation: Types.Events.NavigationStart, event: Types.Events.PageLoadEvent): void {\n  const navigationId = navigation.args.data?.navigationId;\n  if (!navigationId) {\n    throw new Error('Navigation event unexpectedly had no navigation ID.');\n  }\n  const frameId = getFrameIdForPageLoadEvent(event);\n  const {rendererProcessesByFrame} = metaHandlerData();\n\n  // If either of these pieces of data do not exist, the most likely\n  // explanation is that the page load metric we found is for a frame/process\n  // combo that the MetaHandler discarded. This typically happens if we get a\n  // navigation event with an empty URL. Therefore, we will silently return and\n  // drop this metric. If we didn't care about the navigation, we certainly do\n  // not need to care about metrics for that navigation.\n  const rendererProcessesInFrame = rendererProcessesByFrame.get(frameId);\n  if (!rendererProcessesInFrame) {\n    return;\n  }\n  const processData = rendererProcessesInFrame.get(event.pid);\n  if (!processData) {\n    return;\n  }\n\n  if (Types.Events.isNavigationStart(event)) {\n    return;\n  }\n\n  if (Types.Events.isFirstContentfulPaint(event)) {\n    const fcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const classification = scoreClassificationForFirstContentfulPaint(fcpTime);\n    const metricScore = {event, metricName: MetricName.FCP, classification, navigation, timing: fcpTime};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isFirstPaint(event)) {\n    const paintTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const classification = ScoreClassification.UNCLASSIFIED;\n    const metricScore = {event, metricName: MetricName.FP, classification, navigation, timing: paintTime};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isMarkDOMContent(event)) {\n    const dclTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const metricScore = {\n      event,\n      metricName: MetricName.DCL,\n      classification: scoreClassificationForDOMContentLoaded(dclTime),\n      navigation,\n      timing: dclTime,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isInteractiveTime(event)) {\n    const ttiValue = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const tti = {\n      event,\n      metricName: MetricName.TTI,\n      classification: scoreClassificationForTimeToInteractive(ttiValue),\n      navigation,\n      timing: ttiValue,\n    };\n    storeMetricScore(frameId, navigationId, tti);\n\n    const tbtValue =\n        Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(event.args.args.total_blocking_time_ms));\n    const tbt = {\n      event,\n      metricName: MetricName.TBT,\n      classification: scoreClassificationForTotalBlockingTime(tbtValue),\n      navigation,\n      timing: tbtValue,\n    };\n    storeMetricScore(frameId, navigationId, tbt);\n    return;\n  }\n\n  if (Types.Events.isMarkLoad(event)) {\n    const loadTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const metricScore = {\n      event,\n      metricName: MetricName.L,\n      classification: ScoreClassification.UNCLASSIFIED,\n      navigation,\n      timing: loadTime,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isLargestContentfulPaintCandidate(event)) {\n    const candidateIndex = event.args.data?.candidateIndex;\n    if (!candidateIndex) {\n      throw new Error('Largest Contenful Paint unexpectedly had no candidateIndex.');\n    }\n    const lcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const lcp = {\n      event,\n      metricName: MetricName.LCP,\n      classification: scoreClassificationForLargestContentfulPaint(lcpTime),\n      navigation,\n      timing: lcpTime,\n    };\n    const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n    const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n    const lastLCPCandidate = metrics.get(MetricName.LCP);\n    if (lastLCPCandidate === undefined) {\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n      return;\n    }\n    const lastLCPCandidateEvent = lastLCPCandidate.event;\n\n    if (!Types.Events.isLargestContentfulPaintCandidate(lastLCPCandidateEvent)) {\n      return;\n    }\n    const lastCandidateIndex = lastLCPCandidateEvent.args.data?.candidateIndex;\n    if (!lastCandidateIndex) {\n      // lastCandidateIndex cannot be undefined because we don't store candidates with\n      // with an undefined candidateIndex value. This check is only to make TypeScript\n      // treat the field as not undefined below.\n      return;\n    }\n    if (lastCandidateIndex < candidateIndex) {\n      selectedLCPCandidateEvents.delete(lastLCPCandidateEvent);\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n    }\n    return;\n  }\n  if (Types.Events.isLayoutShift(event)) {\n    return;\n  }\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction storeMetricScore(frameId: string, navigationId: string, metricScore: MetricScore): void {\n  const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n  const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n  // If an entry with that metric name is present, delete it so that the new entry that\n  // will replace it is added at the end of the map. This way we guarantee the map entries\n  // are ordered in ASC manner by timestamp.\n  metrics.delete(metricScore.metricName);\n  metrics.set(metricScore.metricName, metricScore);\n}\n\nexport function getFrameIdForPageLoadEvent(event: Types.Events.PageLoadEvent): string {\n  if (Types.Events.isFirstContentfulPaint(event) || Types.Events.isInteractiveTime(event) ||\n      Types.Events.isLargestContentfulPaintCandidate(event) || Types.Events.isNavigationStart(event) ||\n      Types.Events.isLayoutShift(event) || Types.Events.isFirstPaint(event)) {\n    return event.args.frame;\n  }\n  if (Types.Events.isMarkDOMContent(event) || Types.Events.isMarkLoad(event)) {\n    const frameId = event.args.data?.frame;\n    if (!frameId) {\n      throw new Error('MarkDOMContent unexpectedly had no frame ID.');\n    }\n    return frameId;\n  }\n  Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction getNavigationForPageLoadEvent(event: Types.Events.PageLoadEvent): Types.Events.NavigationStart|null {\n  if (Types.Events.isFirstContentfulPaint(event) || Types.Events.isLargestContentfulPaintCandidate(event) ||\n      Types.Events.isFirstPaint(event)) {\n    const navigationId = event.args.data?.navigationId;\n    if (!navigationId) {\n      throw new Error('Trace event unexpectedly had no navigation ID.');\n    }\n    const {navigationsByNavigationId} = metaHandlerData();\n    const navigation = navigationsByNavigationId.get(navigationId);\n\n    if (!navigation) {\n      // This event's navigation has been filtered out by the meta handler as a noise event.\n      return null;\n    }\n    return navigation;\n  }\n\n  if (Types.Events.isMarkDOMContent(event) || Types.Events.isInteractiveTime(event) ||\n      Types.Events.isLayoutShift(event) || Types.Events.isMarkLoad(event)) {\n    const frameId = getFrameIdForPageLoadEvent(event);\n    const {navigationsByFrameId} = metaHandlerData();\n    return Helpers.Trace.getNavigationForTraceEvent(event, frameId, navigationsByFrameId);\n  }\n\n  if (Types.Events.isNavigationStart(event)) {\n    // We don't want to compute metrics of the navigation relative to itself, so we'll avoid avoid all that.\n    return null;\n  }\n\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/fcp/\n */\nexport function scoreClassificationForFirstContentfulPaint(fcpScoreInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const FCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(1.8));\n  const FCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.0));\n  let scoreClassification = ScoreClassification.BAD;\n  if (fcpScoreInMicroseconds <= FCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (fcpScoreInMicroseconds <= FCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/interactive/#how-lighthouse-determines-your-tti-score\n */\n\nexport function scoreClassificationForTimeToInteractive(ttiTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const TTI_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.8));\n  const TTI_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(7.3));\n  let scoreClassification = ScoreClassification.BAD;\n  if (ttiTimeInMicroseconds <= TTI_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (ttiTimeInMicroseconds <= TTI_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lcp/#what-is-lcp\n */\n\nexport function scoreClassificationForLargestContentfulPaint(lcpTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const LCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(2.5));\n  const LCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(4));\n  let scoreClassification = ScoreClassification.BAD;\n  if (lcpTimeInMicroseconds <= LCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (lcpTimeInMicroseconds <= LCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * DCL does not have a classification.\n */\nexport function scoreClassificationForDOMContentLoaded(_dclTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  return ScoreClassification.UNCLASSIFIED;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lighthouse-total-blocking-#time/\n */\n\nexport function scoreClassificationForTotalBlockingTime(tbtTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const TBT_GOOD_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(200));\n  const TBT_MEDIUM_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(600));\n  let scoreClassification = ScoreClassification.BAD;\n  if (tbtTimeInMicroseconds <= TBT_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (tbtTimeInMicroseconds <= TBT_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Gets all the Largest Contentful Paint scores of all the frames in the\n * trace.\n */\nfunction gatherFinalLCPEvents(): Types.Events.PageLoadEvent[] {\n  const allFinalLCPEvents: Types.Events.PageLoadEvent[] = [];\n  const dataForAllFrames = [...metricScoresByFrameId.values()];\n  const dataForAllNavigations = dataForAllFrames.flatMap(frameData => [...frameData.values()]);\n  for (let i = 0; i < dataForAllNavigations.length; i++) {\n    const navigationData = dataForAllNavigations[i];\n    const lcpInNavigation = navigationData.get(MetricName.LCP);\n    if (!lcpInNavigation || !lcpInNavigation.event) {\n      continue;\n    }\n\n    allFinalLCPEvents.push(lcpInNavigation.event);\n  }\n  return allFinalLCPEvents;\n}\n\nexport async function finalize(): Promise<void> {\n  pageLoadEventsArray.sort((a, b) => a.ts - b.ts);\n\n  for (const pageLoadEvent of pageLoadEventsArray) {\n    const navigation = getNavigationForPageLoadEvent(pageLoadEvent);\n    if (navigation) {\n      // Event's navigation was not filtered out as noise.\n      storePageLoadMetricAgainstNavigationId(navigation, pageLoadEvent);\n    }\n  }\n  // NOTE: if you are looking for the TBT calculation, it has temporarily been\n  // removed. See crbug.com/1424335 for details.\n  const allFinalLCPEvents = gatherFinalLCPEvents();\n  const mainFrame = metaHandlerData().mainFrameId;\n  // Filter out LCP candidates to use only definitive LCP values\n  const allEventsButLCP = pageLoadEventsArray.filter(event => !Types.Events.isLargestContentfulPaintCandidate(event));\n  const markerEvents = [...allFinalLCPEvents, ...allEventsButLCP].filter(Types.Events.isMarkerEvent);\n  // Filter by main frame and sort.\n  allMarkerEvents =\n      markerEvents.filter(event => getFrameIdForPageLoadEvent(event) === mainFrame).sort((a, b) => a.ts - b.ts);\n}\n\nexport type PageLoadMetricsData = {\n  /**\n   * This represents the metric scores for all navigations, for all frames in a trace.\n   * Given a frame id, the map points to another map from navigation id to metric scores.\n   * The metric scores include the event related to the metric as well as the data regarding\n   * the score itself.\n   */\n  metricScoresByFrameId: Map<string, Map<string, Map<MetricName, MetricScore>>>,\n  /**\n   * Page load events with no associated duration that happened in the\n   * main frame.\n   */\n  allMarkerEvents: Types.Events.PageLoadEvent[],\n};\n\nexport function data(): PageLoadMetricsData {\n  return {\n    metricScoresByFrameId,\n    allMarkerEvents,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\nexport const enum ScoreClassification {\n  GOOD = 'good',\n  OK = 'ok',\n  BAD = 'bad',\n  // Some metrics (such as DOMContentLoaded) don't have a Good/OK/Bad classification, hence this additional entry.\n  UNCLASSIFIED = 'unclassified',\n}\n\nexport const enum MetricName {\n  // First Contentful Paint\n  FCP = 'FCP',\n  // First Paint\n  FP = 'FP',\n  // MarkLoad\n  L = 'L',\n  LCP = 'LCP',\n  // Mark DOM Content\n  DCL = 'DCL',\n  // Time To Interactive\n  TTI = 'TTI',\n  // Total Blocking Time\n  TBT = 'TBT',\n  // Cumulative Layout Shift\n  CLS = 'CLS',\n  // Navigation\n  NAV = 'Nav',\n  // Note: INP is handled in UserInteractionsHandler\n}\n\nexport interface MetricScore {\n  metricName: MetricName;\n  classification: ScoreClassification;\n  event?: Types.Events.PageLoadEvent;\n  // The last navigation that occured before this metric score.\n  navigation?: Types.Events.NavigationStart;\n  estimated?: boolean;\n  timing: Types.Timing.MicroSeconds;\n}\n"],
  "mappings": "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",
  "names": ["ScoreClassification", "MetricName"]
}
