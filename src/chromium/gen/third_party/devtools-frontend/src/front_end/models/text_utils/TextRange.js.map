{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/text_utils/TextRange.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\n\nconst MAX_SAFE_INT32 = 2 ** 31 - 1;\n\nexport interface SerializedTextRange {\n  startLine: number;\n  startColumn: number;\n  endLine: number;\n  endColumn: number;\n}\n\nexport class TextRange {\n  constructor(public startLine: number, public startColumn: number, public endLine: number, public endColumn: number) {\n  }\n\n  static createFromLocation(line: number, column: number): TextRange {\n    return new TextRange(line, column, line, column);\n  }\n\n  static createUnboundedFromLocation(line: number, column: number): TextRange {\n    return new TextRange(line, column, MAX_SAFE_INT32, MAX_SAFE_INT32);\n  }\n\n  static fromObject(serializedTextRange: SerializedTextRange): TextRange {\n    return new TextRange(\n        serializedTextRange.startLine, serializedTextRange.startColumn, serializedTextRange.endLine,\n        serializedTextRange.endColumn);\n  }\n\n  static comparator(range1: TextRange, range2: TextRange): number {\n    return range1.compareTo(range2);\n  }\n\n  static fromEdit(oldRange: TextRange, newText: string): TextRange {\n    let endLine: number = oldRange.startLine;\n    let endColumn: number = oldRange.startColumn + newText.length;\n\n    const lineEndings = Platform.StringUtilities.findLineEndingIndexes(newText);\n    if (lineEndings.length > 1) {\n      endLine = oldRange.startLine + lineEndings.length - 1;\n      const len = lineEndings.length;\n      endColumn = lineEndings[len - 1] - lineEndings[len - 2] - 1;\n    }\n    return new TextRange(oldRange.startLine, oldRange.startColumn, endLine, endColumn);\n  }\n\n  isEmpty(): boolean {\n    return this.startLine === this.endLine && this.startColumn === this.endColumn;\n  }\n\n  immediatelyPrecedes(range?: TextRange): boolean {\n    if (!range) {\n      return false;\n    }\n    return this.endLine === range.startLine && this.endColumn === range.startColumn;\n  }\n\n  immediatelyFollows(range?: TextRange): boolean {\n    if (!range) {\n      return false;\n    }\n    return range.immediatelyPrecedes(this);\n  }\n\n  follows(range: TextRange): boolean {\n    return (range.endLine === this.startLine && range.endColumn <= this.startColumn) || range.endLine < this.startLine;\n  }\n\n  get linesCount(): number {\n    return this.endLine - this.startLine;\n  }\n\n  collapseToEnd(): TextRange {\n    return new TextRange(this.endLine, this.endColumn, this.endLine, this.endColumn);\n  }\n\n  collapseToStart(): TextRange {\n    return new TextRange(this.startLine, this.startColumn, this.startLine, this.startColumn);\n  }\n\n  normalize(): TextRange {\n    if (this.startLine > this.endLine || (this.startLine === this.endLine && this.startColumn > this.endColumn)) {\n      return new TextRange(this.endLine, this.endColumn, this.startLine, this.startColumn);\n    }\n    return this.clone();\n  }\n\n  clone(): TextRange {\n    return new TextRange(this.startLine, this.startColumn, this.endLine, this.endColumn);\n  }\n\n  serializeToObject(): {\n    startLine: number,\n    startColumn: number,\n    endLine: number,\n    endColumn: number,\n  } {\n    return {\n      startLine: this.startLine,\n      startColumn: this.startColumn,\n      endLine: this.endLine,\n      endColumn: this.endColumn,\n    };\n  }\n\n  compareTo(other: TextRange): number {\n    if (this.startLine > other.startLine) {\n      return 1;\n    }\n    if (this.startLine < other.startLine) {\n      return -1;\n    }\n    if (this.startColumn > other.startColumn) {\n      return 1;\n    }\n    if (this.startColumn < other.startColumn) {\n      return -1;\n    }\n    return 0;\n  }\n\n  compareToPosition(lineNumber: number, columnNumber: number): number {\n    if (lineNumber < this.startLine || (lineNumber === this.startLine && columnNumber < this.startColumn)) {\n      return -1;\n    }\n    if (lineNumber > this.endLine || (lineNumber === this.endLine && columnNumber > this.endColumn)) {\n      return 1;\n    }\n    return 0;\n  }\n\n  equal(other: TextRange): boolean {\n    return this.startLine === other.startLine && this.endLine === other.endLine &&\n        this.startColumn === other.startColumn && this.endColumn === other.endColumn;\n  }\n\n  relativeTo(line: number, column: number): TextRange {\n    const relative = this.clone();\n\n    if (this.startLine === line) {\n      relative.startColumn -= column;\n    }\n    if (this.endLine === line) {\n      relative.endColumn -= column;\n    }\n\n    relative.startLine -= line;\n    relative.endLine -= line;\n    return relative;\n  }\n\n  relativeFrom(line: number, column: number): TextRange {\n    const relative = this.clone();\n\n    if (this.startLine === 0) {\n      relative.startColumn += column;\n    }\n    if (this.endLine === 0) {\n      relative.endColumn += column;\n    }\n\n    relative.startLine += line;\n    relative.endLine += line;\n    return relative;\n  }\n\n  rebaseAfterTextEdit(originalRange: TextRange, editedRange: TextRange): TextRange {\n    console.assert(originalRange.startLine === editedRange.startLine);\n    console.assert(originalRange.startColumn === editedRange.startColumn);\n    const rebase = this.clone();\n    if (!this.follows(originalRange)) {\n      return rebase;\n    }\n    const lineDelta = editedRange.endLine - originalRange.endLine;\n    const columnDelta = editedRange.endColumn - originalRange.endColumn;\n    rebase.startLine += lineDelta;\n    rebase.endLine += lineDelta;\n    if (rebase.startLine === editedRange.endLine) {\n      rebase.startColumn += columnDelta;\n    }\n    if (rebase.endLine === editedRange.endLine) {\n      rebase.endColumn += columnDelta;\n    }\n    return rebase;\n  }\n\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Checks whether this {@link TextRange} contains the location identified by the\n   * {@link lineNumber} and {@link columnNumber}. The beginning of the text range is\n   * considered inclusive while the end of the text range is considered exclusive\n   * for this comparison, meaning that for example a range `(0,1)-(1,4)` contains the\n   * location `(0,1)` but does not contain the location `(1,4)`.\n   *\n   * @param lineNumber the location's line offset.\n   * @param columnNumber the location's column offset.\n   * @returns `true` if the location identified by {@link lineNumber} and {@link columnNumber}\n   *          is contained within this text range.\n   */\n  containsLocation(lineNumber: number, columnNumber: number): boolean {\n    if (this.startLine === this.endLine) {\n      return this.startLine === lineNumber && this.startColumn <= columnNumber && columnNumber < this.endColumn;\n    }\n    if (this.startLine === lineNumber) {\n      return this.startColumn <= columnNumber;\n    }\n    if (this.endLine === lineNumber) {\n      return columnNumber < this.endColumn;\n    }\n    return this.startLine < lineNumber && lineNumber < this.endLine;\n  }\n\n  get start(): {lineNumber: number, columnNumber: number} {\n    return {lineNumber: this.startLine, columnNumber: this.startColumn};\n  }\n\n  get end(): {lineNumber: number, columnNumber: number} {\n    return {lineNumber: this.endLine, columnNumber: this.endColumn};\n  }\n\n  /**\n   * Checks whether this and `that` {@link TextRange} overlap and if they do, computes the\n   * intersection range. If they don't overlap an empty text range is returned instead (for\n   * which {@link #isEmpty()} yields `true`).\n   *\n   * The beginning of text ranges is considered to be includes while the end of the text\n   * ranges is considered exclusive for the intersection, meaning that for example intersecting\n   * `(0,1)-(1,4)` and `(1,4)-(1,6)` yields an empty range.\n   *\n   * @param that the other text range.\n   * @returns the intersection of this and `that` text range, which might be empty if their don't\n   *          overlap.\n   */\n  intersection(that: TextRange): TextRange {\n    let {startLine, startColumn} = this;\n    if (startLine < that.startLine) {\n      startLine = that.startLine;\n      startColumn = that.startColumn;\n    } else if (startLine === that.startLine) {\n      startColumn = Math.max(startColumn, that.startColumn);\n    }\n    let {endLine, endColumn} = this;\n    if (endLine > that.endLine) {\n      endLine = that.endLine;\n      endColumn = that.endColumn;\n    } else if (endLine === that.endLine) {\n      endColumn = Math.min(endColumn, that.endColumn);\n    }\n    if (startLine > endLine || (startLine === endLine && startColumn >= endColumn)) {\n      return new TextRange(0, 0, 0, 0);\n    }\n    return new TextRange(startLine, startColumn, endLine, endColumn);\n  }\n}\n\nexport class SourceRange {\n  constructor(public offset: number, public length: number) {\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
