{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/issues_manager/MarkdownIssueDescription.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Marked from '../../third_party/marked/marked.js';\n\n/**\n * The description that subclasses of `Issue` use define the issue appearance:\n * `file` specifies the markdown file, substitutions can be used to replace\n * placeholders with, e.g. URLs. The `links` property is used to specify the\n * links at the bottom of the issue.\n */\nexport interface MarkdownIssueDescription {\n  file: string;\n  substitutions?: Map<string, string>;\n  links: {link: string, linkTitle: string}[];\n}\n\nexport interface LazyMarkdownIssueDescription {\n  file: string;\n  substitutions?: Map<string, () => string>;\n  links: {link: string, linkTitle: () => string}[];\n}\n\n/**\n * A lazy version of the description. Allows to specify a description as a\n * constant and at the same time delays resolution of the substitutions\n * and/or link titles to allow localization.\n */\nexport function resolveLazyDescription(lazyDescription: LazyMarkdownIssueDescription): MarkdownIssueDescription {\n  function linksMap(currentLink: {link: string, linkTitle: () => string}): {link: string, linkTitle: string} {\n    return {link: currentLink.link, linkTitle: currentLink.linkTitle()};\n  }\n\n  const substitutionMap = new Map();\n  lazyDescription.substitutions?.forEach((value, key) => {\n    substitutionMap.set(key, value());\n  });\n\n  const description = {\n    file: lazyDescription.file,\n    links: lazyDescription.links.map(linksMap),\n    substitutions: substitutionMap,\n  };\n  return description;\n}\n\n/**\n * A loaded and parsed issue description. This is usually obtained by loading\n * a `MarkdownIssueDescription` via `createIssueDescriptionFromMarkdown`.\n */\nexport interface IssueDescription {\n  title: string;\n  markdown: Marked.Marked.Token[];\n  links: {link: string, linkTitle: string}[];\n}\n\nexport async function getFileContent(url: URL): Promise<string> {\n  try {\n    const response = await fetch(url.toString());\n    return response.text();\n  } catch (error) {\n    throw new Error(\n        `Markdown file ${url.toString()} not found. Make sure it is correctly listed in the relevant BUILD.gn files.`);\n  }\n}\n\nexport async function getMarkdownFileContent(filename: string): Promise<string> {\n  return getFileContent(new URL(`descriptions/${filename}`, import.meta.url));\n}\n\nexport async function createIssueDescriptionFromMarkdown(description: MarkdownIssueDescription):\n    Promise<IssueDescription> {\n  const rawMarkdown = await getMarkdownFileContent(description.file);\n  const rawMarkdownWithPlaceholdersReplaced = substitutePlaceholders(rawMarkdown, description.substitutions);\n  return createIssueDescriptionFromRawMarkdown(rawMarkdownWithPlaceholdersReplaced, description);\n}\n\n/**\n * This function is exported separately for unit testing.\n */\nexport function createIssueDescriptionFromRawMarkdown(\n    markdown: string, description: MarkdownIssueDescription): IssueDescription {\n  const markdownAst = Marked.Marked.lexer(markdown);\n  const title = findTitleFromMarkdownAst(markdownAst);\n  if (!title) {\n    throw new Error('Markdown issue descriptions must start with a heading');\n  }\n\n  return {\n    title,\n    markdown: markdownAst.slice(1),\n    links: description.links,\n  };\n}\n\nconst validPlaceholderMatchPattern = /\\{(PLACEHOLDER_[a-zA-Z][a-zA-Z0-9]*)\\}/g;\nconst validPlaceholderNamePattern = /PLACEHOLDER_[a-zA-Z][a-zA-Z0-9]*/;\n\n/**\n * Replaces placeholders in markdown text with a string provided by the\n * `substitutions` map. To keep mental overhead to a minimum, the same\n * syntax is used as for l10n placeholders. Please note that the\n * placeholders require a mandatory 'PLACEHOLDER_' prefix.\n *\n * Example:\n *   const str = \"This is markdown with `code` and two placeholders, namely {PLACEHOLDER_PH1} and {PLACEHOLDER_PH2}\".\n *   const result = substitePlaceholders(str, new Map([['PLACEHOLDER_PH1', 'foo'], ['PLACEHOLDER_PH2', 'bar']]));\n *\n * Exported only for unit testing.\n */\nexport function substitutePlaceholders(markdown: string, substitutions?: Map<string, string>): string {\n  const unusedPlaceholders = new Set(substitutions ? substitutions.keys() : []);\n  validatePlaceholders(unusedPlaceholders);\n\n  const result = markdown.replace(validPlaceholderMatchPattern, (_, placeholder) => {\n    const replacement = substitutions ? substitutions.get(placeholder) : undefined;\n    if (replacement === undefined) {\n      throw new Error(`No replacement provided for placeholder '${placeholder}'.`);\n    }\n    unusedPlaceholders.delete(placeholder);\n    return replacement;\n  });\n\n  if (unusedPlaceholders.size > 0) {\n    throw new Error(`Unused replacements provided: ${[...unusedPlaceholders]}`);\n  }\n\n  return result;\n}\n\n// Ensure that all provided placeholders match the naming pattern.\nfunction validatePlaceholders(placeholders: Set<string>): void {\n  const invalidPlaceholders = [...placeholders].filter(placeholder => !validPlaceholderNamePattern.test(placeholder));\n  if (invalidPlaceholders.length > 0) {\n    throw new Error(`Invalid placeholders provided in the substitutions map: ${invalidPlaceholders}`);\n  }\n}\n\nexport function findTitleFromMarkdownAst(markdownAst: Marked.Marked.Token[]): string|null {\n  if (markdownAst.length === 0 || markdownAst[0].type !== 'heading' || markdownAst[0].depth !== 1) {\n    return null;\n  }\n  return markdownAst[0].text;\n}\n\nexport async function getIssueTitleFromMarkdownDescription(description: MarkdownIssueDescription):\n    Promise<string|null> {\n  const rawMarkdown = await getMarkdownFileContent(description.file);\n  const markdownAst = Marked.Marked.lexer(rawMarkdown);\n  return findTitleFromMarkdownAst(markdownAst);\n}\n"],
  "mappings": ";AAIA,YAAY,YAAY;AAyBjB,gBAAS,uBAAuB,iBAAyE;AAC9G,WAAS,SAAS,aAAyF;AACzG,WAAO,EAAC,MAAM,YAAY,MAAM,WAAW,YAAY,UAAU,EAAC;AAAA,EACpE;AAEA,QAAM,kBAAkB,oBAAI,IAAI;AAChC,kBAAgB,eAAe,QAAQ,CAAC,OAAO,QAAQ;AACrD,oBAAgB,IAAI,KAAK,MAAM,CAAC;AAAA,EAClC,CAAC;AAED,QAAM,cAAc;AAAA,IAClB,MAAM,gBAAgB;AAAA,IACtB,OAAO,gBAAgB,MAAM,IAAI,QAAQ;AAAA,IACzC,eAAe;AAAA,EACjB;AACA,SAAO;AACT;AAYA,sBAAsB,eAAe,KAA2B;AAC9D,MAAI;AACF,UAAM,WAAW,MAAM,MAAM,IAAI,SAAS,CAAC;AAC3C,WAAO,SAAS,KAAK;AAAA,EACvB,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACN,iBAAiB,IAAI,SAAS,CAAC;AAAA,IAA8E;AAAA,EACnH;AACF;AAEA,sBAAsB,uBAAuB,UAAmC;AAC9E,SAAO,eAAe,IAAI,IAAI,gBAAgB,QAAQ,IAAI,YAAY,GAAG,CAAC;AAC5E;AAEA,sBAAsB,mCAAmC,aAC3B;AAC5B,QAAM,cAAc,MAAM,uBAAuB,YAAY,IAAI;AACjE,QAAM,sCAAsC,uBAAuB,aAAa,YAAY,aAAa;AACzG,SAAO,sCAAsC,qCAAqC,WAAW;AAC/F;AAKO,gBAAS,sCACZ,UAAkB,aAAyD;AAC7E,QAAM,cAAc,OAAO,OAAO,MAAM,QAAQ;AAChD,QAAM,QAAQ,yBAAyB,WAAW;AAClD,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,uDAAuD;AAAA,EACzE;AAEA,SAAO;AAAA,IACL;AAAA,IACA,UAAU,YAAY,MAAM,CAAC;AAAA,IAC7B,OAAO,YAAY;AAAA,EACrB;AACF;AAEA,MAAM,+BAA+B;AACrC,MAAM,8BAA8B;AAc7B,gBAAS,uBAAuB,UAAkB,eAA6C;AACpG,QAAM,qBAAqB,IAAI,IAAI,gBAAgB,cAAc,KAAK,IAAI,CAAC,CAAC;AAC5E,uBAAqB,kBAAkB;AAEvC,QAAM,SAAS,SAAS,QAAQ,8BAA8B,CAAC,GAAG,gBAAgB;AAChF,UAAM,cAAc,gBAAgB,cAAc,IAAI,WAAW,IAAI;AACrE,QAAI,gBAAgB,QAAW;AAC7B,YAAM,IAAI,MAAM,4CAA4C,WAAW,IAAI;AAAA,IAC7E;AACA,uBAAmB,OAAO,WAAW;AACrC,WAAO;AAAA,EACT,CAAC;AAED,MAAI,mBAAmB,OAAO,GAAG;AAC/B,UAAM,IAAI,MAAM,iCAAiC,CAAC,GAAG,kBAAkB,CAAC,EAAE;AAAA,EAC5E;AAEA,SAAO;AACT;AAGA,SAAS,qBAAqB,cAAiC;AAC7D,QAAM,sBAAsB,CAAC,GAAG,YAAY,EAAE,OAAO,iBAAe,CAAC,4BAA4B,KAAK,WAAW,CAAC;AAClH,MAAI,oBAAoB,SAAS,GAAG;AAClC,UAAM,IAAI,MAAM,2DAA2D,mBAAmB,EAAE;AAAA,EAClG;AACF;AAEO,gBAAS,yBAAyB,aAAiD;AACxF,MAAI,YAAY,WAAW,KAAK,YAAY,CAAC,EAAE,SAAS,aAAa,YAAY,CAAC,EAAE,UAAU,GAAG;AAC/F,WAAO;AAAA,EACT;AACA,SAAO,YAAY,CAAC,EAAE;AACxB;AAEA,sBAAsB,qCAAqC,aAClC;AACvB,QAAM,cAAc,MAAM,uBAAuB,YAAY,IAAI;AACjE,QAAM,cAAc,OAAO,OAAO,MAAM,WAAW;AACnD,SAAO,yBAAyB,WAAW;AAC7C;",
  "names": []
}
