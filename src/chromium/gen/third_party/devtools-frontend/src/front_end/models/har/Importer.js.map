{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/har/Importer.ts"],
  "sourcesContent": ["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport * as TextUtils from '../text_utils/text_utils.js';\n\nimport type {HAREntry, HARLog, HARPage, HARTimings} from './HARFormat.js';\n\nexport class Importer {\n  static requestsFromHARLog(log: HARLog): SDK.NetworkRequest.NetworkRequest[] {\n    const pages = new Map<string, HARPage>();\n    for (const page of log.pages) {\n      pages.set(page.id, page);\n    }\n\n    log.entries.sort((a, b) => a.startedDateTime.valueOf() - b.startedDateTime.valueOf());\n\n    const pageLoads = new Map<string, SDK.PageLoad.PageLoad>();\n    const requests: SDK.NetworkRequest.NetworkRequest[] = [];\n    for (const entry of log.entries) {\n      const pageref = entry.pageref;\n      let pageLoad: SDK.PageLoad.PageLoad|(SDK.PageLoad.PageLoad | undefined) =\n          pageref ? pageLoads.get(pageref) : undefined;\n      const documentURL = pageLoad ? pageLoad.mainRequest.url() : entry.request.url;\n\n      let initiator: Protocol.Network.Initiator|null = null;\n      const initiatorEntry = entry.customInitiator();\n      if (initiatorEntry) {\n        initiator = {\n          type: (initiatorEntry.type as Protocol.Network.InitiatorType),\n          url: initiatorEntry.url,\n          lineNumber: initiatorEntry.lineNumber,\n          requestId: initiatorEntry.requestId,\n          stack: initiatorEntry.stack,\n        };\n      }\n      const request = SDK.NetworkRequest.NetworkRequest.createWithoutBackendRequest(\n          'har-' + requests.length, entry.request.url, documentURL, initiator);\n      const page = pageref ? pages.get(pageref) : undefined;\n      if (!pageLoad && pageref && page) {\n        pageLoad = Importer.buildPageLoad(page, request);\n        pageLoads.set(pageref, pageLoad);\n      }\n      Importer.fillRequestFromHAREntry(request, entry, pageLoad);\n      if (pageLoad) {\n        pageLoad.bindRequest(request);\n      }\n      requests.push(request);\n    }\n    return requests;\n  }\n\n  static buildPageLoad(page: HARPage, mainRequest: SDK.NetworkRequest.NetworkRequest): SDK.PageLoad.PageLoad {\n    const pageLoad = new SDK.PageLoad.PageLoad(mainRequest);\n    pageLoad.startTime = page.startedDateTime.valueOf();\n    pageLoad.contentLoadTime = Number(page.pageTimings.onContentLoad) * 1000;\n    pageLoad.loadTime = Number(page.pageTimings.onLoad) * 1000;\n    return pageLoad;\n  }\n\n  static fillRequestFromHAREntry(\n      request: SDK.NetworkRequest.NetworkRequest, entry: HAREntry, pageLoad: SDK.PageLoad.PageLoad|undefined): void {\n    // Request data.\n    if (entry.request.postData) {\n      request.setRequestFormData(true, entry.request.postData.text);\n    } else {\n      request.setRequestFormData(false, null);\n    }\n    request.connectionId = entry.customAsString('connectionId') || '';\n    request.requestMethod = entry.request.method;\n    request.setRequestHeaders(entry.request.headers);\n\n    // Response data.\n    if (entry.response.content.mimeType && entry.response.content.mimeType !== 'x-unknown') {\n      request.mimeType = (entry.response.content.mimeType as Platform.MimeType.MimeType);\n    }\n    request.responseHeaders = entry.response.headers;\n    request.statusCode = entry.response.status;\n    request.statusText = entry.response.statusText;\n    let protocol = entry.response.httpVersion.toLowerCase();\n    if (protocol === 'http/2.0') {\n      protocol = 'h2';\n    }\n    request.protocol = protocol.replace(/^http\\/2\\.0?\\+quic/, 'http/2+quic');\n\n    // Timing data.\n    const issueTime = entry.startedDateTime.getTime() / 1000;\n    request.setIssueTime(issueTime, issueTime);\n\n    // Content data.\n    const contentSize = entry.response.content.size > 0 ? entry.response.content.size : 0;\n    const headersSize = entry.response.headersSize > 0 ? entry.response.headersSize : 0;\n    const bodySize = entry.response.bodySize > 0 ? entry.response.bodySize : 0;\n    request.resourceSize = contentSize || (headersSize + bodySize);\n    let transferSize = entry.response.customAsNumber('transferSize');\n    if (transferSize === undefined) {\n      transferSize = entry.response.headersSize + entry.response.bodySize;\n    }\n    request.setTransferSize(transferSize >= 0 ? transferSize : 0);\n\n    const fromCache = entry.customAsString('fromCache');\n    if (fromCache === 'memory') {\n      request.setFromMemoryCache();\n    } else if (fromCache === 'disk') {\n      request.setFromDiskCache();\n    }\n\n    const contentText = entry.response.content.text;\n    const isBase64 = entry.response.content.encoding === 'base64';\n    const {mimeType, charset} = Platform.MimeType.parseContentType(entry.response.content.mimeType);\n\n    request.setContentDataProvider(\n        async () =>\n            new TextUtils.ContentData.ContentData(contentText ?? '', isBase64, mimeType ?? '', charset ?? undefined));\n\n    // Timing data.\n    Importer.setupTiming(request, issueTime, entry.time, entry.timings);\n\n    // Meta data.\n    request.setRemoteAddress(entry.serverIPAddress || '', Number(entry.connection) || 80);\n    request.setResourceType(Importer.getResourceType(request, entry, pageLoad));\n\n    const priority = entry.customAsString('priority');\n    // @ts-expect-error This accesses the globalThis['Protocol'] where the enum is an actual JS object and not just a TS const enum.\n    if (priority && Protocol.Network.ResourcePriority.hasOwnProperty(priority)) {\n      request.setPriority((priority as Protocol.Network.ResourcePriority));\n    }\n\n    const messages = entry.customAsArray('webSocketMessages');\n    if (messages) {\n      for (const message of messages) {\n        if (message.time === undefined) {\n          continue;\n        }\n        if (!Object.values(SDK.NetworkRequest.WebSocketFrameType).includes(message.type)) {\n          continue;\n        }\n        if (message.opcode === undefined) {\n          continue;\n        }\n        if (message.data === undefined) {\n          continue;\n        }\n\n        const mask = message.type === SDK.NetworkRequest.WebSocketFrameType.Send;\n        request.addFrame({time: message.time, text: message.data, opCode: message.opcode, mask, type: message.type});\n      }\n    }\n\n    // Restore Service Worker related response.\n    request.fetchedViaServiceWorker = Boolean(entry.response.custom.get('fetchedViaServiceWorker'));\n    const serviceWorkerResponseSource = entry.response.customAsString('serviceWorkerResponseSource');\n    if (serviceWorkerResponseSource) {\n      // Should consist with the `Protocol.Network.ServiceWorkerResponseSource` enum class.\n      const sources = new Set<Protocol.Network.ServiceWorkerResponseSource>([\n        Protocol.Network.ServiceWorkerResponseSource.CacheStorage,\n        Protocol.Network.ServiceWorkerResponseSource.FallbackCode,\n        Protocol.Network.ServiceWorkerResponseSource.HttpCache,\n        Protocol.Network.ServiceWorkerResponseSource.Network,\n      ]);\n      if (sources.has(serviceWorkerResponseSource as Protocol.Network.ServiceWorkerResponseSource)) {\n        request.setServiceWorkerResponseSource(\n            serviceWorkerResponseSource as Protocol.Network.ServiceWorkerResponseSource);\n      }\n    }\n    const responseCacheStorageCacheName = entry.response.customAsString('responseCacheStorageCacheName');\n    if (responseCacheStorageCacheName) {\n      request.setResponseCacheStorageCacheName(responseCacheStorageCacheName);\n    }\n\n    request.finished = true;\n  }\n\n  static getResourceType(\n      request: SDK.NetworkRequest.NetworkRequest, entry: HAREntry,\n      pageLoad: SDK.PageLoad.PageLoad|undefined): Common.ResourceType.ResourceType {\n    const customResourceTypeName = entry.customAsString('resourceType');\n    if (customResourceTypeName) {\n      const customResourceType = Common.ResourceType.ResourceType.fromName(customResourceTypeName);\n      if (customResourceType) {\n        return customResourceType;\n      }\n    }\n\n    if (pageLoad && pageLoad.mainRequest === request) {\n      return Common.ResourceType.resourceTypes.Document;\n    }\n\n    const resourceTypeFromMime = Common.ResourceType.ResourceType.fromMimeType(entry.response.content.mimeType);\n    if (resourceTypeFromMime !== Common.ResourceType.resourceTypes.Other) {\n      return resourceTypeFromMime;\n    }\n\n    const resourceTypeFromUrl = Common.ResourceType.ResourceType.fromURL(entry.request.url);\n    if (resourceTypeFromUrl) {\n      return resourceTypeFromUrl;\n    }\n\n    return Common.ResourceType.resourceTypes.Other;\n  }\n\n  static setupTiming(\n      request: SDK.NetworkRequest.NetworkRequest, issueTime: number, entryTotalDuration: number,\n      timings: HARTimings): void {\n    function accumulateTime(timing: number|undefined): number {\n      if (timing === undefined || timing < 0) {\n        return -1;\n      }\n      lastEntry += timing;\n      return lastEntry;\n    }\n    let lastEntry = timings.blocked && (timings.blocked >= 0) ? timings.blocked : 0;\n\n    const proxy = timings.customAsNumber('blocked_proxy') || -1;\n    const queueing = timings.customAsNumber('blocked_queueing') || -1;\n\n    // `blocked_queueing` should be excluded from `lastEntry`\n    // (`timings.blocked`) here because it should be taken into account\n    // by `timing.requestTime`, and other subsequent timings are\n    // calculated based on the accumulated `lastEntry`.\n    if (lastEntry > 0 && queueing > 0) {\n      lastEntry -= queueing;\n    }\n\n    // SSL is part of connect for both HAR and Chrome's format so subtract it here.\n    const ssl = timings.ssl && (timings.ssl >= 0) ? timings.ssl : 0;\n    if (timings.connect && (timings.connect > 0)) {\n      timings.connect -= ssl;\n    }\n    const timing = {\n      proxyStart: proxy > 0 ? lastEntry - proxy : -1,\n      proxyEnd: proxy > 0 ? lastEntry : -1,\n      requestTime: issueTime + (queueing > 0 ? queueing : 0) / 1000,\n      dnsStart: timings.dns && (timings.dns >= 0) ? lastEntry : -1,\n      dnsEnd: accumulateTime(timings.dns),\n\n      // Add ssl to end time without modifying lastEntry (see comment above).\n      connectStart: timings.connect && (timings.connect >= 0) ? lastEntry : -1,\n      connectEnd: accumulateTime(timings.connect) + ssl,\n\n      // Now update lastEntry to add ssl timing back in (see comment above).\n      sslStart: timings.ssl && (timings.ssl >= 0) ? lastEntry : -1,\n      sslEnd: accumulateTime(timings.ssl),\n\n      workerStart: timings.customAsNumber('workerStart') || -1,\n      workerReady: timings.customAsNumber('workerReady') || -1,\n      workerFetchStart: timings.customAsNumber('workerFetchStart') || -1,\n      workerRespondWithSettled: timings.customAsNumber('workerRespondWithSettled') || -1,\n\n      sendStart: timings.send >= 0 ? lastEntry : -1,\n      sendEnd: accumulateTime(timings.send),\n      pushStart: 0,\n      pushEnd: 0,\n      receiveHeadersStart: timings.wait && (timings.wait >= 0) ? lastEntry : -1,\n      receiveHeadersEnd: accumulateTime(timings.wait),\n    };\n    accumulateTime(timings.receive);\n\n    request.timing = timing;\n    request.endTime = issueTime + Math.max(entryTotalDuration, lastEntry) / 1000;\n  }\n}\n"],
  "mappings": "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",
  "names": ["timing"]
}
