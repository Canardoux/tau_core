{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/extensions/HostUrlPattern.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../core/platform/platform.js';\n\nfunction parseScheme(pattern: string): {hostPattern: string, scheme: string}|undefined {\n  const SCHEME_SEPARATOR = '://';\n  const schemeEnd = pattern.indexOf(SCHEME_SEPARATOR);\n  if (schemeEnd < 0) {\n    return undefined;\n  }\n  const scheme = pattern.substr(0, schemeEnd).toLowerCase();\n\n  // Keep in sync with //extensions/common/url_pattern.cc in chromium\n  const validSchemes = [\n    '*', 'http', 'https', 'ftp', 'chrome', 'chrome-extension',\n    // Chromium additionally defines the following schemes, but these aren't relevant for host url patterns:\n    /* 'file', 'filesystem', 'ws', 'wss', 'data', 'uuid-in-package'*/\n  ];\n\n  if (!validSchemes.includes(scheme)) {\n    return undefined;\n  }\n\n  return {scheme, hostPattern: pattern.substr(schemeEnd + SCHEME_SEPARATOR.length)};\n}\n\nfunction defaultPort(scheme: string): string|undefined {\n  switch (scheme) {\n    case 'http':\n      return '80';\n    case 'https':\n      return '443';\n    case 'ftp':\n      return '25';\n  }\n  return undefined;\n}\n\nfunction parseHostAndPort(pattern: string, scheme: string): {host: string, port: string}|undefined {\n  const pathnameStart = pattern.indexOf('/');\n  if (pathnameStart >= 0) {\n    const path = pattern.substr(pathnameStart);\n    if (path !== '/*' && path !== '/') {\n      // Host patterns don't allow for paths to be specified\n      return undefined;\n    }\n    // Strip off path part\n    pattern = pattern.substr(0, pathnameStart);\n  }\n\n  const PORT_WILDCARD = ':*';\n  if (pattern.endsWith(PORT_WILDCARD)) {\n    // Strip off wildcard port to not upset url parsing\n    pattern = pattern.substr(0, pattern.length - PORT_WILDCARD.length);\n  }\n\n  if (pattern.endsWith(':')) {\n    return undefined;\n  }\n\n  const SUBDOMAIN_WILDCARD = '*.';\n  let asUrl: URL;\n  try {\n    asUrl = new URL(\n        pattern.startsWith(SUBDOMAIN_WILDCARD) ? `http://${pattern.substr(SUBDOMAIN_WILDCARD.length)}` :\n                                                 `http://${pattern}`);\n  } catch {\n    return undefined;\n  }\n  if (asUrl.pathname !== '/') {\n    return undefined;\n  }\n\n  if (asUrl.hostname.endsWith('.')) {\n    asUrl.hostname = asUrl.hostname.substr(0, asUrl.hostname.length - 1);\n  }\n\n  // The URL constructor is happy to accept '*', but it gets replaced with %2A\n  if (asUrl.hostname !== '%2A' && asUrl.hostname.includes('%2A')) {\n    return undefined;\n  }\n\n  // The URL constructor strips off the default port for the scheme, even if it was given explicitely\n  const httpPort = defaultPort('http');\n  if (!httpPort) {\n    return undefined;\n  }\n  const port = pattern.endsWith(`:${httpPort}`) ? httpPort : (asUrl.port === '' ? '*' : asUrl.port);\n  const schemesWithPort = ['http', 'https', 'ftp'];\n  if (port !== '*' && !schemesWithPort.includes(scheme)) {\n    return undefined;\n  }\n\n  const host = asUrl.hostname !== '%2A' ? (pattern.startsWith('*.') ? `*.${asUrl.hostname}` : asUrl.hostname) : '*';\n  return {\n    host,\n    port,\n  };\n}\n\n// HostUrlPatterns define permissions in for extensions in the form of `*://*.example.com:*/`. Since these aren't valid\n// URLs Common.ParsedURL can't handle them and we need a separate implementation.\nexport class HostUrlPattern {\n  static parse(pattern: string): HostUrlPattern|undefined {\n    if (pattern === '<all_urls>') {\n      return new HostUrlPattern({matchesAll: true});\n    }\n    const parsedScheme = parseScheme(pattern);\n    if (!parsedScheme) {\n      return undefined;\n    }\n    const {scheme, hostPattern} = parsedScheme;\n\n    const parsedHost = parseHostAndPort(hostPattern, scheme);\n    if (!parsedHost) {\n      return undefined;\n    }\n    const {host, port} = parsedHost;\n\n    return new HostUrlPattern({scheme, host, port, matchesAll: false});\n  }\n\n  private constructor(readonly pattern: {matchesAll: true}|\n                      {readonly scheme: string, readonly host: string, readonly port: string, matchesAll: false}) {\n  }\n\n  get scheme(): string {\n    return this.pattern.matchesAll ? '*' : this.pattern.scheme;\n  }\n  get host(): string {\n    return this.pattern.matchesAll ? '*' : this.pattern.host;\n  }\n  get port(): string {\n    return this.pattern.matchesAll ? '*' : this.pattern.port;\n  }\n\n  matchesAllUrls(): boolean {\n    return this.pattern.matchesAll;\n  }\n\n  matchesUrl(url: Platform.DevToolsPath.UrlString): boolean {\n    let parsedUrl;\n    try {\n      parsedUrl = new URL(url);\n    } catch {\n      return false;\n    }\n    // Try to parse the input url before checking for <all_urls> because <all_urls> doesn't match invalid urls\n    if (this.matchesAllUrls()) {\n      return true;\n    }\n    const scheme = parsedUrl.protocol.substr(0, parsedUrl.protocol.length - 1);\n    const port = parsedUrl.port || defaultPort(scheme);\n    return this.matchesScheme(scheme) && this.matchesHost(parsedUrl.hostname) && (!port || this.matchesPort(port));\n  }\n\n  matchesScheme(scheme: string): boolean {\n    if (this.pattern.matchesAll) {\n      return true;\n    }\n    if (this.pattern.scheme === '*') {\n      return scheme === 'http' || scheme === 'https';\n    }\n    return this.pattern.scheme === scheme;\n  }\n\n  matchesHost(host: string): boolean {\n    if (this.pattern.matchesAll) {\n      return true;\n    }\n    if (this.pattern.host === '*') {\n      return true;\n    }\n    let normalizedHost = new URL(`http://${host}`).hostname;\n    if (normalizedHost.endsWith('.')) {\n      normalizedHost = normalizedHost.substr(0, normalizedHost.length - 1);\n    }\n    if (this.pattern.host.startsWith('*.')) {\n      return normalizedHost === this.pattern.host.substr(2) || normalizedHost.endsWith(this.pattern.host.substr(1));\n    }\n    return this.pattern.host === normalizedHost;\n  }\n\n  matchesPort(port: string): boolean {\n    if (this.pattern.matchesAll) {\n      return true;\n    }\n    return this.pattern.port === '*' || this.pattern.port === port;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
