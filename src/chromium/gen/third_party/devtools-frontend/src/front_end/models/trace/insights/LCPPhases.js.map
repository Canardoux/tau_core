{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/insights/LCPPhases.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Handlers from '../handlers/handlers.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {\n  InsightCategory,\n  type InsightModel,\n  type InsightSetContext,\n  InsightWarning,\n  type RequiredData,\n} from './types.js';\n\nconst UIStrings = {\n  /**\n   *@description Title of an insight that provides details about the LCP metric, broken down by phases / parts.\n   */\n  title: 'LCP by phase',\n  /**\n   * @description Description of a DevTools insight that presents a breakdown for the LCP metric by phases.\n   * This is displayed after a user expands the section to see more. No character length limits.\n   */\n  description:\n      'Each [phase has specific improvement strategies](https://web.dev/articles/optimize-lcp#lcp-breakdown). Ideally, most of the LCP time should be spent on loading the resources, not within delays.',\n};\nconst str_ = i18n.i18n.registerUIStrings('models/trace/insights/LCPPhases.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport function deps(): ['NetworkRequests', 'PageLoadMetrics', 'LargestImagePaint', 'Meta'] {\n  return ['NetworkRequests', 'PageLoadMetrics', 'LargestImagePaint', 'Meta'];\n}\n\ninterface LCPPhases {\n  /**\n   * The time between when the user initiates loading the page until when\n   * the browser receives the first byte of the html response.\n   */\n  ttfb: Types.Timing.MilliSeconds;\n  /**\n   * The time between ttfb and the LCP request request being started.\n   * For a text LCP, this is undefined given no request is loaded.\n   */\n  loadDelay?: Types.Timing.MilliSeconds;\n  /**\n   * The time it takes to load the LCP request.\n   */\n  loadTime?: Types.Timing.MilliSeconds;\n  /**\n   * The time between when the LCP request finishes loading and when\n   * the LCP element is rendered.\n   */\n  renderDelay: Types.Timing.MilliSeconds;\n}\n\nexport type LCPPhasesInsightModel = InsightModel<{\n  lcpMs?: Types.Timing.MilliSeconds,\n  lcpTs?: Types.Timing.MilliSeconds,\n  lcpEvent?: Types.Events.LargestContentfulPaintCandidate,\n  /** The network request for the LCP image, if there was one. */\n  lcpRequest?: Types.Events.SyntheticNetworkRequest,\n  phases?: LCPPhases,\n}>;\n\nfunction anyValuesNaN(...values: number[]): boolean {\n  return values.some(v => Number.isNaN(v));\n}\n/**\n * Calculates the 4 phases of an LCP and the timings of each.\n * Will return `null` if any required values were missing. We don't ever expect\n * them to be missing on newer traces, but old trace files may lack some of the\n * data we rely on, so we want to handle that case.\n */\nfunction breakdownPhases(\n    nav: Types.Events.NavigationStart, docRequest: Types.Events.SyntheticNetworkRequest,\n    lcpMs: Types.Timing.MilliSeconds, lcpRequest: Types.Events.SyntheticNetworkRequest|undefined): LCPPhases|null {\n  const docReqTiming = docRequest.args.data.timing;\n  if (!docReqTiming) {\n    throw new Error('no timing for document request');\n  }\n  const firstDocByteTs = Helpers.Timing.secondsToMicroseconds(docReqTiming.requestTime) +\n      Helpers.Timing.millisecondsToMicroseconds(docReqTiming.receiveHeadersStart);\n\n  const firstDocByteTiming = Types.Timing.MicroSeconds(firstDocByteTs - nav.ts);\n  const ttfb = Helpers.Timing.microSecondsToMilliseconds(firstDocByteTiming);\n  let renderDelay = Types.Timing.MilliSeconds(lcpMs - ttfb);\n\n  if (!lcpRequest) {\n    if (anyValuesNaN(ttfb, renderDelay)) {\n      return null;\n    }\n    return {ttfb, renderDelay};\n  }\n\n  const lcpStartTs = Types.Timing.MicroSeconds(lcpRequest.ts - nav.ts);\n  const requestStart = Helpers.Timing.microSecondsToMilliseconds(lcpStartTs);\n\n  const lcpReqEndTs = Types.Timing.MicroSeconds(lcpRequest.args.data.syntheticData.finishTime - nav.ts);\n  const requestEnd = Helpers.Timing.microSecondsToMilliseconds(lcpReqEndTs);\n\n  const loadDelay = Types.Timing.MilliSeconds(requestStart - ttfb);\n  const loadTime = Types.Timing.MilliSeconds(requestEnd - requestStart);\n  renderDelay = Types.Timing.MilliSeconds(lcpMs - requestEnd);\n  if (anyValuesNaN(ttfb, loadDelay, loadTime, renderDelay)) {\n    return null;\n  }\n\n  return {\n    ttfb,\n    loadDelay,\n    loadTime,\n    renderDelay,\n  };\n}\n\nfunction finalize(partialModel: Omit<LCPPhasesInsightModel, 'title'|'description'|'category'|'shouldShow'>):\n    LCPPhasesInsightModel {\n  const relatedEvents = [];\n  if (partialModel.lcpEvent) {\n    relatedEvents.push(partialModel.lcpEvent);\n  }\n  if (partialModel.lcpRequest) {\n    relatedEvents.push(partialModel.lcpRequest);\n  }\n  return {\n    title: i18nString(UIStrings.title),\n    description: i18nString(UIStrings.description),\n    category: InsightCategory.LCP,\n    // TODO: should move the component's \"getPhaseData\" to model.\n    shouldShow: Boolean(partialModel.phases) && (partialModel.lcpMs ?? 0) > 0,\n    ...partialModel,\n    relatedEvents,\n  };\n}\n\nexport function generateInsight(\n    parsedTrace: RequiredData<typeof deps>, context: InsightSetContext): LCPPhasesInsightModel {\n  if (!context.navigation) {\n    return finalize({});\n  }\n\n  const networkRequests = parsedTrace.NetworkRequests;\n\n  const frameMetrics = parsedTrace.PageLoadMetrics.metricScoresByFrameId.get(context.frameId);\n  if (!frameMetrics) {\n    throw new Error('no frame metrics');\n  }\n\n  const navMetrics = frameMetrics.get(context.navigationId);\n  if (!navMetrics) {\n    throw new Error('no navigation metrics');\n  }\n  const metricScore = navMetrics.get(Handlers.ModelHandlers.PageLoadMetrics.MetricName.LCP);\n  const lcpEvent = metricScore?.event;\n  if (!lcpEvent || !Types.Events.isLargestContentfulPaintCandidate(lcpEvent)) {\n    return finalize({warnings: [InsightWarning.NO_LCP]});\n  }\n\n  // This helps calculate the phases.\n  const lcpMs = Helpers.Timing.microSecondsToMilliseconds(metricScore.timing);\n  // This helps position things on the timeline's UI accurately for a trace.\n  const lcpTs = metricScore.event?.ts ? Helpers.Timing.microSecondsToMilliseconds(metricScore.event?.ts) : undefined;\n  const lcpRequest = parsedTrace.LargestImagePaint.lcpRequestByNavigation.get(context.navigation);\n\n  const docRequest = networkRequests.byTime.find(req => req.args.data.requestId === context.navigationId);\n  if (!docRequest) {\n    return finalize({lcpMs, lcpTs, lcpEvent, lcpRequest, warnings: [InsightWarning.NO_DOCUMENT_REQUEST]});\n  }\n\n  if (!lcpRequest) {\n    return finalize({\n      lcpMs,\n      lcpTs,\n      lcpEvent,\n      lcpRequest,\n      phases: breakdownPhases(context.navigation, docRequest, lcpMs, lcpRequest) ?? undefined,\n    });\n  }\n\n  return finalize({\n    lcpMs,\n    lcpTs,\n    lcpEvent,\n    lcpRequest,\n    phases: breakdownPhases(context.navigation, docRequest, lcpMs, lcpRequest) ?? undefined,\n  });\n}\n"],
  "mappings": "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",
  "names": []
}
