{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/extras/ThirdParties.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as ThirdPartyWeb from '../../../third_party/third-party-web/third-party-web.js';\nimport type * as Handlers from '../handlers/handlers.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport * as URLForEntry from './URLForEntry.js';\n\nexport type Entity = typeof ThirdPartyWeb.ThirdPartyWeb.entities[number];\n\nexport interface Summary {\n  transferSize: number;\n  mainThreadTime: Types.Timing.MicroSeconds;\n}\n\nexport interface SummaryMaps {\n  byEntity: Map<Entity, Summary>;\n  byRequest: Map<Types.Events.SyntheticNetworkRequest, Summary>;\n  requestsByEntity: Map<Entity, Types.Events.SyntheticNetworkRequest[]>;\n}\n\n/**\n * Returns the origin portion of a Chrome extension URL.\n */\nfunction getChromeExtensionOrigin(url: URL): string {\n  return url.protocol + '//' + url.host;\n}\n\nfunction makeUpChromeExtensionEntity(entityCache: Map<string, Entity>, url: string, extensionName?: string): Entity {\n  const parsedUrl = new URL(url);\n  const origin = getChromeExtensionOrigin(parsedUrl);\n  const host = new URL(origin).host;\n  const name = extensionName || host;\n\n  const cachedEntity = entityCache.get(origin);\n  if (cachedEntity) {\n    return cachedEntity;\n  }\n\n  const chromeExtensionEntity = {\n    name,\n    company: name,\n    category: 'Chrome Extension',\n    homepage: 'https://chromewebstore.google.com/detail/' + host,\n    categories: [],\n    domains: [],\n    averageExecutionTime: 0,\n    totalExecutionTime: 0,\n    totalOccurrences: 0,\n  };\n\n  entityCache.set(origin, chromeExtensionEntity);\n  return chromeExtensionEntity;\n}\n\nexport function makeUpEntity(entityCache: Map<string, Entity>, url: string): Entity|undefined {\n  if (url.startsWith('chrome-extension:')) {\n    return makeUpChromeExtensionEntity(entityCache, url);\n  }\n\n  // Make up an entity only for valid http/https URLs.\n  if (!url.startsWith('http')) {\n    return;\n  }\n\n  // NOTE: Lighthouse uses a tld database to determine the root domain, but here\n  // we are using third party web's database. Doesn't really work for the case of classifying\n  // domains 3pweb doesn't know about, so it will just give us a guess.\n  const rootDomain = ThirdPartyWeb.ThirdPartyWeb.getRootDomain(url);\n  if (!rootDomain) {\n    return;\n  }\n\n  if (entityCache.has(rootDomain)) {\n    return entityCache.get(rootDomain);\n  }\n\n  const unrecognizedEntity = {\n    name: rootDomain,\n    company: rootDomain,\n    category: '',\n    categories: [],\n    domains: [rootDomain],\n    averageExecutionTime: 0,\n    totalExecutionTime: 0,\n    totalOccurrences: 0,\n    isUnrecognized: true,\n  };\n  entityCache.set(rootDomain, unrecognizedEntity);\n  return unrecognizedEntity;\n}\n\nfunction getSelfTimeByUrl(\n    parsedTrace: Handlers.Types.ParsedTrace, bounds: Types.Timing.TraceWindowMicroSeconds): Map<string, number> {\n  const selfTimeByUrl = new Map<string, number>();\n\n  for (const process of parsedTrace.Renderer.processes.values()) {\n    if (!process.isOnMainFrame) {\n      continue;\n    }\n\n    for (const thread of process.threads.values()) {\n      if (thread.name === 'CrRendererMain') {\n        if (!thread.tree) {\n          break;\n        }\n\n        for (const event of thread.entries) {\n          if (!Helpers.Timing.eventIsInBounds(event, bounds)) {\n            continue;\n          }\n\n          const node = parsedTrace.Renderer.entryToNode.get(event);\n          if (!node || !node.selfTime) {\n            continue;\n          }\n\n          const url = URLForEntry.getNonResolved(parsedTrace as Handlers.Types.ParsedTrace, event);\n          if (!url) {\n            continue;\n          }\n\n          selfTimeByUrl.set(url, node.selfTime + (selfTimeByUrl.get(url) ?? 0));\n        }\n      }\n    }\n  }\n\n  return selfTimeByUrl;\n}\n\nexport function getEntitiesByRequest(requests: Types.Events.SyntheticNetworkRequest[]):\n    {entityByRequest: Map<Types.Events.SyntheticNetworkRequest, Entity>, madeUpEntityCache: Map<string, Entity>} {\n  const entityByRequest = new Map<Types.Events.SyntheticNetworkRequest, Entity>();\n  const madeUpEntityCache = new Map<string, Entity>();\n  for (const request of requests) {\n    const url = request.args.data.url;\n    const entity = ThirdPartyWeb.ThirdPartyWeb.getEntity(url) ?? makeUpEntity(madeUpEntityCache, url);\n    if (entity) {\n      entityByRequest.set(request, entity);\n    }\n  }\n  return {entityByRequest, madeUpEntityCache};\n}\n\nfunction getSummaryMap(\n    requests: Types.Events.SyntheticNetworkRequest[],\n    entityByRequest: Map<Types.Events.SyntheticNetworkRequest, Entity>,\n    selfTimeByUrl: Map<string, number>): SummaryMaps {\n  const byRequest = new Map<Types.Events.SyntheticNetworkRequest, Summary>();\n  const byEntity = new Map<Entity, Summary>();\n  const defaultSummary: Summary = {transferSize: 0, mainThreadTime: Types.Timing.MicroSeconds(0)};\n\n  for (const request of requests) {\n    const urlSummary = byRequest.get(request) || {...defaultSummary};\n    urlSummary.transferSize += request.args.data.encodedDataLength;\n    urlSummary.mainThreadTime =\n        Types.Timing.MicroSeconds(urlSummary.mainThreadTime + (selfTimeByUrl.get(request.args.data.url) ?? 0));\n    byRequest.set(request, urlSummary);\n  }\n\n  // Map each request's stat to a particular entity.\n  const requestsByEntity = new Map<Entity, Types.Events.SyntheticNetworkRequest[]>();\n  for (const [request, requestSummary] of byRequest.entries()) {\n    const entity = entityByRequest.get(request);\n    if (!entity) {\n      byRequest.delete(request);\n      continue;\n    }\n\n    const entitySummary = byEntity.get(entity) || {...defaultSummary};\n    entitySummary.transferSize += requestSummary.transferSize;\n    entitySummary.mainThreadTime =\n        Types.Timing.MicroSeconds(entitySummary.mainThreadTime + requestSummary.mainThreadTime);\n    byEntity.set(entity, entitySummary);\n\n    const entityRequests = requestsByEntity.get(entity) || [];\n    entityRequests.push(request);\n    requestsByEntity.set(entity, entityRequests);\n  }\n\n  return {byEntity, byRequest, requestsByEntity};\n}\n\nexport function getSummariesAndEntitiesForTraceBounds(\n    parsedTrace: Handlers.Types.ParsedTrace, traceBounds: Types.Timing.TraceWindowMicroSeconds,\n    networkRequests: Types.Events.SyntheticNetworkRequest[]): {\n  summaries: SummaryMaps,\n  entityByRequest: Map<Types.Events.SyntheticNetworkRequest, Entity>,\n  madeUpEntityCache: Map<string, Entity>,\n} {\n  // Ensure we only handle requests that are within the given traceBounds.\n  const reqs = networkRequests.filter(event => {\n    return Helpers.Timing.eventIsInBounds(event, traceBounds);\n  });\n\n  const {entityByRequest, madeUpEntityCache} = getEntitiesByRequest(reqs);\n\n  const selfTimeByUrl = getSelfTimeByUrl(parsedTrace, traceBounds);\n  // TODO(crbug.com/352244718): re-work to still collect main thread activity if no request is present\n  const summaries = getSummaryMap(reqs, entityByRequest, selfTimeByUrl);\n\n  return {summaries, entityByRequest, madeUpEntityCache};\n}\n"],
  "mappings": "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",
  "names": []
}
