{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/helpers/Extensions.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Types from '../types/types.js';\n\nimport {sortTraceEventsInPlace} from './Trace.js';\nimport {canBuildTreesFromEvents, type TraceEntryNode, treify} from './TreeHelpers.js';\n\nexport function buildTrackDataFromExtensionEntries(\n    extensionEntries: Types.Extensions.SyntheticExtensionTrackEntry[],\n    extensionTrackData: Types.Extensions.ExtensionTrackData[],\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    ): {\n  extensionTrackData: Types.Extensions.ExtensionTrackData[],\n  entryToNode?: Map<Types.Events.Event, TraceEntryNode>,\n} {\n  const dataByTrack = new Map<string, Types.Extensions.ExtensionTrackData>();\n  for (const entry of extensionEntries) {\n    // Batch data by track group. For each batch, add the data of every\n    // track in the group. In cases where no track group is provided,\n    // we use the standalone track data, but use a fixed prefix in the\n    // batch key to prevent collisions where a track group has the\n    // same name as a standalone track.\n    const key = entry.args.trackGroup || `track-name-${entry.args.track}`;\n    const batchedData =\n        Platform.MapUtilities.getWithDefault(dataByTrack, key, () => ({\n                                                                 name: entry.args.trackGroup || entry.args.track,\n                                                                 isTrackGroup: Boolean(entry.args.trackGroup),\n                                                                 entriesByTrack: {[entry.args.track]: []},\n                                                               }));\n\n    if (!batchedData.entriesByTrack[entry.args.track]) {\n      batchedData.entriesByTrack[entry.args.track] = [];\n    }\n    const entriesInTrack = batchedData.entriesByTrack[entry.args.track];\n    entriesInTrack.push(entry);\n  }\n  // Calculate self time if possible for track entries, on a track\n  // by track basis.\n  for (const trackData of dataByTrack.values()) {\n    for (const entries of Object.values(trackData.entriesByTrack)) {\n      sortTraceEventsInPlace(entries);\n      if (canBuildTreesFromEvents(entries)) {\n        for (const [entry, node] of treify(entries).entryToNode) {\n          entryToNode.set(entry, node);\n        }\n      }\n    }\n    extensionTrackData.push(trackData);\n  }\n  return {extensionTrackData, entryToNode};\n}\n"],
  "mappings": ";AAIA,YAAY,cAAc;AAG1B,SAAQ,8BAA6B;AACrC,SAAQ,yBAA8C,cAAa;AAE5D,gBAAS,mCACZ,kBACA,oBACA,aAIF;AACA,QAAM,cAAc,oBAAI,IAAiD;AACzE,aAAW,SAAS,kBAAkB;AAMpC,UAAM,MAAM,MAAM,KAAK,cAAc,cAAc,MAAM,KAAK,KAAK;AACnE,UAAM,cACF,SAAS,aAAa,eAAe,aAAa,KAAK,OAAO;AAAA,MACL,MAAM,MAAM,KAAK,cAAc,MAAM,KAAK;AAAA,MAC1C,cAAc,QAAQ,MAAM,KAAK,UAAU;AAAA,MAC3C,gBAAgB,EAAC,CAAC,MAAM,KAAK,KAAK,GAAG,CAAC,EAAC;AAAA,IACzC,EAAE;AAE7D,QAAI,CAAC,YAAY,eAAe,MAAM,KAAK,KAAK,GAAG;AACjD,kBAAY,eAAe,MAAM,KAAK,KAAK,IAAI,CAAC;AAAA,IAClD;AACA,UAAM,iBAAiB,YAAY,eAAe,MAAM,KAAK,KAAK;AAClE,mBAAe,KAAK,KAAK;AAAA,EAC3B;AAGA,aAAW,aAAa,YAAY,OAAO,GAAG;AAC5C,eAAW,WAAW,OAAO,OAAO,UAAU,cAAc,GAAG;AAC7D,6BAAuB,OAAO;AAC9B,UAAI,wBAAwB,OAAO,GAAG;AACpC,mBAAW,CAAC,OAAO,IAAI,KAAK,OAAO,OAAO,EAAE,aAAa;AACvD,sBAAY,IAAI,OAAO,IAAI;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AACA,uBAAmB,KAAK,SAAS;AAAA,EACnC;AACA,SAAO,EAAC,oBAAoB,YAAW;AACzC;",
  "names": []
}
