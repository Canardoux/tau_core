{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/text_utils/TextUtils.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData, type ContentDataOrError} from './ContentData.js';\nimport {SearchMatch} from './ContentProvider.js';\nimport type {Text} from './Text.js';\n\nconst KEY_VALUE_FILTER_REGEXP = /(?:^|\\s)(\\-)?([\\w\\-]+):([^\\s]+)/;\nconst REGEXP_FILTER_REGEXP = /(?:^|\\s)(\\-)?\\/([^\\/\\\\]+(\\\\.[^\\/]*)*)\\//;\nconst TEXT_FILTER_REGEXP = /(?:^|\\s)(\\-)?([^\\s]+)/;\nconst SPACE_CHAR_REGEXP = /\\s/;\n\nexport const Utils = {\n  isSpaceChar: function(char: string): boolean {\n    return SPACE_CHAR_REGEXP.test(char);\n  },\n\n  lineIndent: function(line: string): string {\n    let indentation = 0;\n    while (indentation < line.length && Utils.isSpaceChar(line.charAt(indentation))) {\n      ++indentation;\n    }\n    return line.substr(0, indentation);\n  },\n\n  splitStringByRegexes(text: string, regexes: RegExp[]): {\n    value: string,\n    position: number,\n    regexIndex: number,\n    captureGroups: Array<string|undefined>,\n  }[] {\n    const matches: {\n      value: string,\n      position: number,\n      regexIndex: number,\n      captureGroups: (string|undefined)[],\n    }[] = [];\n    const globalRegexes: RegExp[] = [];\n    for (let i = 0; i < regexes.length; i++) {\n      const regex = regexes[i];\n      if (!regex.global) {\n        globalRegexes.push(new RegExp(regex.source, regex.flags ? regex.flags + 'g' : 'g'));\n      } else {\n        globalRegexes.push(regex);\n      }\n    }\n    doSplit(text, 0, 0);\n    return matches;\n\n    function doSplit(text: string, regexIndex: number, startIndex: number): void {\n      if (regexIndex >= globalRegexes.length) {\n        // Set regexIndex as -1 if text did not match with any regular expression\n        matches.push({value: text, position: startIndex, regexIndex: -1, captureGroups: []});\n        return;\n      }\n      const regex = globalRegexes[regexIndex];\n      let currentIndex = 0;\n      let result;\n      regex.lastIndex = 0;\n      while ((result = regex.exec(text)) !== null) {\n        const stringBeforeMatch = text.substring(currentIndex, result.index);\n        if (stringBeforeMatch) {\n          doSplit(stringBeforeMatch, regexIndex + 1, startIndex + currentIndex);\n        }\n        const match = result[0];\n        matches.push({\n          value: match,\n          position: startIndex + result.index,\n          regexIndex,\n          captureGroups: result.slice(1),\n        });\n        currentIndex = result.index + match.length;\n      }\n      const stringAfterMatches = text.substring(currentIndex);\n      if (stringAfterMatches) {\n        doSplit(stringAfterMatches, regexIndex + 1, startIndex + currentIndex);\n      }\n    }\n  },\n};\n\nexport class FilterParser {\n  private readonly keys: string[];\n  constructor(keys: string[]) {\n    this.keys = keys;\n  }\n\n  static cloneFilter(filter: ParsedFilter): ParsedFilter {\n    return {key: filter.key, text: filter.text, regex: filter.regex, negative: filter.negative};\n  }\n\n  parse(query: string): ParsedFilter[] {\n    const splitFilters =\n        Utils.splitStringByRegexes(query, [KEY_VALUE_FILTER_REGEXP, REGEXP_FILTER_REGEXP, TEXT_FILTER_REGEXP]);\n    const parsedFilters: ParsedFilter[] = [];\n    for (const {regexIndex, captureGroups} of splitFilters) {\n      if (regexIndex === -1) {\n        continue;\n      }\n      if (regexIndex === 0) {\n        const startsWithMinus = captureGroups[0];\n        const parsedKey = captureGroups[1];\n        const parsedValue = captureGroups[2];\n        if (this.keys.indexOf((parsedKey as string)) !== -1) {\n          parsedFilters.push({\n            key: parsedKey,\n            regex: undefined,\n            text: parsedValue,\n            negative: Boolean(startsWithMinus),\n          });\n        } else {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `${parsedKey}:${parsedValue}`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 1) {\n        const startsWithMinus = captureGroups[0];\n        const parsedRegex = captureGroups[1];\n        try {\n          parsedFilters.push({\n            key: undefined,\n            regex: new RegExp((parsedRegex as string), 'im'),\n            text: undefined,\n            negative: Boolean(startsWithMinus),\n          });\n        } catch (e) {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `/${parsedRegex}/`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 2) {\n        const startsWithMinus = captureGroups[0];\n        const parsedText = captureGroups[1];\n        parsedFilters.push({\n          key: undefined,\n          regex: undefined,\n          text: parsedText,\n          negative: Boolean(startsWithMinus),\n        });\n      }\n    }\n    return parsedFilters;\n  }\n}\n\nexport class BalancedJSONTokenizer {\n  private readonly callback: (arg0: string) => void;\n  private index: number;\n  private balance: number;\n  private buffer: string;\n  private findMultiple: boolean;\n  private closingDoubleQuoteRegex: RegExp;\n  private lastBalancedIndex?: number;\n  constructor(callback: (arg0: string) => void, findMultiple?: boolean) {\n    this.callback = callback;\n    this.index = 0;\n    this.balance = 0;\n    this.buffer = '';\n    this.findMultiple = findMultiple || false;\n    this.closingDoubleQuoteRegex = /[^\\\\](?:\\\\\\\\)*\"/g;\n  }\n\n  write(chunk: string): boolean {\n    this.buffer += chunk;\n    const lastIndex = this.buffer.length;\n    const buffer = this.buffer;\n    let index;\n    for (index = this.index; index < lastIndex; ++index) {\n      const character = buffer[index];\n      if (character === '\"') {\n        this.closingDoubleQuoteRegex.lastIndex = index;\n        if (!this.closingDoubleQuoteRegex.test(buffer)) {\n          break;\n        }\n        index = this.closingDoubleQuoteRegex.lastIndex - 1;\n      } else if (character === '{') {\n        ++this.balance;\n      } else if (character === '}') {\n        --this.balance;\n        if (this.balance < 0) {\n          this.reportBalanced();\n          return false;\n        }\n        if (!this.balance) {\n          this.lastBalancedIndex = index + 1;\n          if (!this.findMultiple) {\n            break;\n          }\n        }\n      } else if (character === ']' && !this.balance) {\n        this.reportBalanced();\n        return false;\n      }\n    }\n    this.index = index;\n    this.reportBalanced();\n    return true;\n  }\n\n  private reportBalanced(): void {\n    if (!this.lastBalancedIndex) {\n      return;\n    }\n    this.callback(this.buffer.slice(0, this.lastBalancedIndex));\n    this.buffer = this.buffer.slice(this.lastBalancedIndex);\n    this.index -= this.lastBalancedIndex;\n    this.lastBalancedIndex = 0;\n  }\n\n  remainder(): string {\n    return this.buffer;\n  }\n}\n\n/**\n * Detects the indentation used by a given text document, based on the _Comparing\n * lines_ approach suggested by Heather Arthur (and also found in Firefox DevTools).\n *\n * This implementation differs from the original proposal in that tab indentation\n * isn't detected by checking if at least 50% of the lines start with a tab, but\n * instead by comparing the number of lines that start with a tab to the frequency\n * of the other indentation patterns. This way we also detect small snippets with\n * long leading comments correctly, when tab indentation is used for the snippets\n * of code.\n *\n * @param lines The input document lines.\n * @return The indentation detected for the lines as string or `null` if it's inconclusive.\n *\n * @see https://heathermoor.medium.com/detecting-code-indentation-eff3ed0fb56b\n */\nexport const detectIndentation = function(lines: Iterable<string>): string|null {\n  const frequencies: Array<number> = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  let tabs = 0, previous = 0;\n\n  for (const line of lines) {\n    let current = 0;\n    if (line.length !== 0) {\n      let char = line.charAt(0);\n      if (char === '\\t') {\n        tabs++;\n        continue;\n      }\n      while (char === ' ') {\n        char = line.charAt(++current);\n      }\n    }\n\n    if (current === line.length) {\n      // Don't consider empty lines.\n      previous = 0;\n      continue;\n    }\n\n    const delta = Math.abs(current - previous);\n    if (delta < frequencies.length) {\n      // Don't consider deltas above 8 characters.\n      frequencies[delta] = frequencies[delta] + 1;\n    }\n    previous = current;\n  }\n\n  // Find most frequent non-zero width difference between adjacent lines.\n  let mostFrequentDelta = 0, highestFrequency = 0;\n  for (let delta = 1; delta < frequencies.length; ++delta) {\n    const frequency = frequencies[delta];\n    if (frequency > highestFrequency) {\n      highestFrequency = frequency;\n      mostFrequentDelta = delta;\n    }\n  }\n\n  if (tabs > mostFrequentDelta) {\n    // If more lines start with tabs than any other indentation,\n    // we assume that the document was written with tab indentation\n    // in mind. This differs from the original algorithm.\n    return '\\t';\n  }\n\n  if (!mostFrequentDelta) {\n    return null;\n  }\n\n  return ' '.repeat(mostFrequentDelta);\n};\n\n/**\n * Heuristic to check whether a given text was likely minified. Intended to\n * be used for HTML, CSS, and JavaScript inputs.\n *\n * A text is considered to be the result of minification if the average\n * line length for the whole text is 80 characters or more.\n *\n * @param text The input text to check.\n * @returns\n */\nexport const isMinified = function(text: string): boolean {\n  let lineCount = 0;\n  for (let lastIndex = 0; lastIndex < text.length; ++lineCount) {\n    let eolIndex = text.indexOf('\\n', lastIndex);\n    if (eolIndex < 0) {\n      eolIndex = text.length;\n    }\n    lastIndex = eolIndex + 1;\n  }\n  return (text.length - lineCount) / lineCount >= 80;\n};\n\n/**\n * Small wrapper around {@link performSearchInContent} to reduce boilerplate when searching\n * in {@link ContentDataOrError}.\n *\n * @returns empty search matches if `contentData` is an error or not text content.\n */\nexport const performSearchInContentData = function(\n    contentData: ContentDataOrError, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  if (ContentData.isError(contentData) || !contentData.isTextContent) {\n    return [];\n  }\n  return performSearchInContent(contentData.textObj, query, caseSensitive, isRegex);\n};\n\n/**\n * @returns One {@link SearchMatch} per match. Multiple matches on the same line each\n * result in their own `SearchMatchExact` instance.\n */\nexport const performSearchInContent = function(\n    text: Text, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n\n  const result = [];\n  for (let i = 0; i < text.lineCount(); ++i) {\n    const lineContent = text.lineAt(i);\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(i, lineContent, match.index as number, match[0].length));\n    }\n  }\n  return result;\n};\n\n/**\n * Similar to {@link performSearchInContent} but doesn't search in a whole text but rather\n * finds the exact matches on a prelminiary search result (i.e. lines with known matches).\n * @param matches is deliberatedly typed as an object literal so we can pass the\n *                CDP search result type.\n */\nexport const performSearchInSearchMatches = function(\n    matches: {lineNumber: number, lineContent: string}[], query: string, caseSensitive: boolean,\n    isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n  const result = [];\n\n  for (const {lineNumber, lineContent} of matches) {\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(lineNumber, lineContent, match.index as number, match[0].length));\n    }\n  }\n  return result;\n};\n\nexport interface ParsedFilter {\n  key?: string;\n  text?: string|null;\n  regex?: RegExp;\n  negative: boolean;\n}\n"],
  "mappings": "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",
  "names": ["text", "matches"]
}
