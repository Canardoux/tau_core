{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/extras/FilmStrip.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n//\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Handlers from '../handlers/handlers.js';\nimport type * as Types from '../types/types.js';\n\nexport interface Data {\n  zeroTime: Types.Timing.MicroSeconds;\n  spanTime: Types.Timing.MicroSeconds;\n  frames: readonly Frame[];\n}\n\nexport interface Frame {\n  screenshotEvent: Types.Events.SyntheticScreenshot;\n  index: number;\n}\n\nexport type HandlersWithFilmStrip = Handlers.Types.HandlersWithMeta<{\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  Screenshots: typeof Handlers.ModelHandlers.Screenshots,\n}>;\n\nexport type HandlerDataWithScreenshots = Handlers.Types.EnabledHandlerDataWithMeta<{\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  Screenshots: typeof Handlers.ModelHandlers.Screenshots,\n}>;\n\n// Cache film strips based on:\n// 1. The trace parsed data object\n// 2. The start time.\nconst filmStripCache = new WeakMap<HandlerDataWithScreenshots, Map<Types.Timing.MicroSeconds, Data>>();\n\nexport function fromParsedTrace(\n    parsedTrace: HandlerDataWithScreenshots, customZeroTime?: Types.Timing.MicroSeconds): Data {\n  const frames: Frame[] = [];\n\n  const zeroTime = typeof customZeroTime !== 'undefined' ? customZeroTime : parsedTrace.Meta.traceBounds.min;\n  const spanTime = parsedTrace.Meta.traceBounds.range;\n  const fromCache = filmStripCache.get(parsedTrace)?.get(zeroTime);\n  if (fromCache) {\n    return fromCache;\n  }\n\n  for (const screenshotEvent of parsedTrace.Screenshots.all) {\n    if (screenshotEvent.ts < zeroTime) {\n      continue;\n    }\n    const frame: Frame = {\n      index: frames.length,\n      screenshotEvent,\n    };\n    frames.push(frame);\n  }\n\n  const result: Data = {\n    zeroTime,\n    spanTime,\n    frames: Array.from(frames),\n  };\n\n  const cachedForData = Platform.MapUtilities.getWithDefault(\n      filmStripCache, parsedTrace, () => new Map<Types.Timing.MicroSeconds, Data>());\n  cachedForData.set(zeroTime, result);\n\n  return result;\n}\n\nexport function frameClosestToTimestamp(filmStrip: Data, searchTimestamp: Types.Timing.MicroSeconds): Frame|null {\n  const closestFrameIndexBeforeTimestamp = Platform.ArrayUtilities.nearestIndexFromEnd(\n      filmStrip.frames, frame => frame.screenshotEvent.ts < searchTimestamp);\n  if (closestFrameIndexBeforeTimestamp === null) {\n    return null;\n  }\n  return filmStrip.frames[closestFrameIndexBeforeTimestamp];\n}\n"],
  "mappings": ";AAIA,YAAY,cAAc;AA4B1B,MAAM,iBAAiB,oBAAI,QAA0E;AAE9F,gBAAS,gBACZ,aAAyC,gBAAkD;AAC7F,QAAM,SAAkB,CAAC;AAEzB,QAAM,WAAW,OAAO,mBAAmB,cAAc,iBAAiB,YAAY,KAAK,YAAY;AACvG,QAAM,WAAW,YAAY,KAAK,YAAY;AAC9C,QAAM,YAAY,eAAe,IAAI,WAAW,GAAG,IAAI,QAAQ;AAC/D,MAAI,WAAW;AACb,WAAO;AAAA,EACT;AAEA,aAAW,mBAAmB,YAAY,YAAY,KAAK;AACzD,QAAI,gBAAgB,KAAK,UAAU;AACjC;AAAA,IACF;AACA,UAAM,QAAe;AAAA,MACnB,OAAO,OAAO;AAAA,MACd;AAAA,IACF;AACA,WAAO,KAAK,KAAK;AAAA,EACnB;AAEA,QAAM,SAAe;AAAA,IACnB;AAAA,IACA;AAAA,IACA,QAAQ,MAAM,KAAK,MAAM;AAAA,EAC3B;AAEA,QAAM,gBAAgB,SAAS,aAAa;AAAA,IACxC;AAAA,IAAgB;AAAA,IAAa,MAAM,oBAAI,IAAqC;AAAA,EAAC;AACjF,gBAAc,IAAI,UAAU,MAAM;AAElC,SAAO;AACT;AAEO,gBAAS,wBAAwB,WAAiB,iBAAwD;AAC/G,QAAM,mCAAmC,SAAS,eAAe;AAAA,IAC7D,UAAU;AAAA,IAAQ,WAAS,MAAM,gBAAgB,KAAK;AAAA,EAAe;AACzE,MAAI,qCAAqC,MAAM;AAC7C,WAAO;AAAA,EACT;AACA,SAAO,UAAU,OAAO,gCAAgC;AAC1D;",
  "names": []
}
