{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/AsyncJSCallsHandler.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as flowsHandlerData} from './FlowsHandler.js';\nimport {data as rendererHandlerData} from './RendererHandler.js';\n\nconst schedulerToRunEntryPoints: Map<Types.Events.SyntheticProfileCall, Types.Events.Event[]> = new Map();\nconst asyncCallToScheduler:\n    Map<Types.Events.SyntheticProfileCall, {taskName: string, scheduler: Types.Events.SyntheticProfileCall}> =\n        new Map();\n\nexport function reset(): void {\n  schedulerToRunEntryPoints.clear();\n  asyncCallToScheduler.clear();\n}\n\nexport function handleEvent(_: Types.Events.Event): void {\n}\n\nexport async function finalize(): Promise<void> {\n  const {flows} = flowsHandlerData();\n  const {entryToNode} = rendererHandlerData();\n  // Process async task flows\n  for (const flow of flows) {\n    const asyncTaskScheduled = flow.at(0);\n    if (!asyncTaskScheduled || !Types.Events.isDebuggerAsyncTaskScheduled(asyncTaskScheduled)) {\n      continue;\n    }\n    const taskName = asyncTaskScheduled.args.taskName;\n    const asyncTaskRun = flow.at(1);\n    if (!asyncTaskRun || !Types.Events.isDebuggerAsyncTaskRun(asyncTaskRun)) {\n      // Unexpected flow shape, ignore.\n      continue;\n    }\n    const asyncCaller = findNearestProfileCallAncestor(asyncTaskScheduled, entryToNode);\n    if (!asyncCaller) {\n      // Unexpected async call trace data shape, ignore.\n      continue;\n    }\n    const asyncEntryPoints = findFirstJsInvocationsForAsyncTaskRun(asyncTaskRun, entryToNode);\n    if (!asyncEntryPoints) {\n      // Unexpected async call trace data shape, ignore.\n      continue;\n    }\n    // Set scheduler -> schedulee mapping.\n    // The schedulee being the JS entrypoint\n    schedulerToRunEntryPoints.set(asyncCaller, asyncEntryPoints);\n\n    // Set schedulee -> scheduler mapping.\n    // The schedulees being the JS calls (instead of the entrypoints as\n    // above, for usage ergonomics).\n    const scheduledProfileCalls = findFirstJSCallsForAsyncTaskRun(asyncTaskRun, entryToNode);\n    for (const call of scheduledProfileCalls) {\n      asyncCallToScheduler.set(call, {taskName, scheduler: asyncCaller});\n    }\n  }\n}\n/**\n * Given a DebuggerAsyncTaskScheduled event, returns its closest\n * ProfileCall ancestor, which represents the JS call that scheduled\n * the async task.\n */\nfunction findNearestProfileCallAncestor(\n    asyncTaskScheduled: Types.Events.DebuggerAsyncTaskScheduled,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.SyntheticProfileCall|null {\n  let node = entryToNode.get(asyncTaskScheduled)?.parent;\n  while (node) {\n    if (Types.Events.isProfileCall(node.entry)) {\n      return node.entry;\n    }\n    node = node.parent;\n  }\n  return null;\n}\n/**\n * Entrypoints to JS execution in the timeline. We ignore those starting\n * with 'v8' because they aren't shown in the timeline, and ultimately\n * this function's output results in \"initiated\" events, so ideally this\n * returns events that end up in the flame chart.\n */\nfunction acceptJSInvocationsPredicate(event: Types.Events.Event): event is Types.Events.Event {\n  return Types.Events.isJSInvocationEvent(event) && !event.name.startsWith('v8') && !event.name.startsWith('V8');\n}\n\n/**\n * Given a DebuggerAsyncTaskRun event, returns its closest JS entry\n * point descendants, which represent the task being scheduled.\n *\n * We return multiple entry points beacuse some of these are built\n * from samples (like `consoleTask.run()` ). Because of limitations with\n * sampling, multiple entry points can mistakenly be made from a single\n * entry point, so we return all of them to ensure the async stack is\n * in every event that applies.\n */\nfunction findFirstJsInvocationsForAsyncTaskRun(\n    asyncTaskRun: Types.Events.DebuggerAsyncTaskRun,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.Event[] {\n  // Ignore descendants of other DebuggerAsyncTaskRuns since they\n  // are part of another async task and have to be handled separately\n  return findFirstDescendantsOfType(\n      asyncTaskRun, entryToNode, acceptJSInvocationsPredicate, Types.Events.isDebuggerAsyncTaskRun);\n}\n\n/**\n * Given an async task run event, returns the top level call frames\n * (profile calls) directly called by the async task. This implies that\n * any profile calls under another async task run event are ignored.\n * These profile calls represent the JS task being scheduled, AKA\n * the other part of the async stack.\n *\n * For example, here the profile calls \"js 1\", \"js 2\" and \"js 4\" would\n * be returned:\n *\n * |------------------Async Task Run------------------|\n * |--FunctionCall--|    |--FunctionCall--|\n * |-js 1-||-js 2-|        |-js 4-|\n * |-js 3-|\n *\n * But here, only \"js 1\" and \"js 2\" would be returned:\n *\n * |------------------Async Task Run------------------|\n * |--FunctionCall--|    |------------------------|\n * |-js 1-||-js 2-|       |---Async Task Run--|\n * |-js 3-|                |--FunctionCall--|\n *                          |-js 4-|\n */\nfunction findFirstJSCallsForAsyncTaskRun(\n    asyncTaskRun: Types.Events.DebuggerAsyncTaskRun,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.SyntheticProfileCall[] {\n  // Ignore descendants of other DebuggerAsyncTaskRuns since they\n  // are part of another async task and have to be handled separately\n  return findFirstDescendantsOfType(\n      asyncTaskRun, entryToNode, Types.Events.isProfileCall, Types.Events.isDebuggerAsyncTaskRun);\n}\n\n/**\n * Given a root event returns all the top level descendants that meet a\n * predicate condition (predicateAccept) while ignoring subtrees whose\n * top event meets an ignore condition (predicateIgnore).\n */\nfunction findFirstDescendantsOfType<T extends Types.Events.Event>(\n    root: Types.Events.Event, entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>,\n    predicateAccept: (event: Types.Events.Event) => event is T,\n    predicateIgnore: (event: Types.Events.Event) => boolean): T[] {\n  const node = entryToNode.get(root);\n  if (!node) {\n    return [];\n  }\n  const childrenGroups = [[...node.children]];\n  const firstDescendants = [];\n  for (let i = 0; i < childrenGroups.length; i++) {\n    const siblings = childrenGroups[i];\n    for (let j = 0; j < siblings.length; j++) {\n      const node = siblings[j];\n      if (predicateAccept(node.entry)) {\n        firstDescendants.push(node.entry);\n      } else if (!predicateIgnore(node.entry)) {\n        childrenGroups.push([...node.children]);\n      }\n    }\n  }\n  return firstDescendants;\n}\n\nexport function data(): {\n  // Given a profile call, returns the JS entrypoints it scheduled (if any).\n  // For example, given a setTimeout call, returns the JS entry point\n  // trace event for the timeout callback run event (usually a\n  // FunctionCall event).\n  schedulerToRunEntryPoints: typeof schedulerToRunEntryPoints,\n  // Given a profile call, returns the profile call that scheduled it.\n  // For example given a timeout callback run event, returns its\n  // setTimeout call event.\n  asyncCallToScheduler: typeof asyncCallToScheduler,\n} {\n  return {\n    schedulerToRunEntryPoints,\n    asyncCallToScheduler,\n  };\n}\n\nexport function deps(): ['Renderer', 'Flows'] {\n  return ['Renderer', 'Flows'];\n}\n"],
  "mappings": "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",
  "names": ["node"]
}
