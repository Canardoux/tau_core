{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/Threads.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n//\nimport type * as Helpers from '../helpers/helpers.js';\nimport type * as Types from '../types/types.js';\n\nimport type {AuctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport type * as Renderer from './RendererHandler.js';\nimport type {ParsedTrace} from './types.js';\n\nexport interface ThreadData {\n  pid: Types.Events.ProcessID;\n  tid: Types.Events.ThreadID;\n  entries: readonly Types.Events.Event[];\n  processIsOnMainFrame: boolean;\n  tree: Helpers.TreeHelpers.TraceEntryTree;\n  type: ThreadType;\n  name: string|null;\n  entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>;\n}\n\nexport const enum ThreadType {\n  MAIN_THREAD = 'MAIN_THREAD',\n  WORKER = 'WORKER',\n  RASTERIZER = 'RASTERIZER',\n  AUCTION_WORKLET = 'AUCTION_WORKLET',\n  OTHER = 'OTHER',\n  CPU_PROFILE = 'CPU_PROFILE',\n  THREAD_POOL = 'THREAD_POOL',\n}\n\nfunction getThreadTypeForRendererThread(\n    pid: Types.Events.ProcessID, thread: Renderer.RendererThread,\n    auctionWorkletsData: AuctionWorkletsData): ThreadType {\n  let threadType = ThreadType.OTHER;\n  if (thread.name === 'CrRendererMain') {\n    threadType = ThreadType.MAIN_THREAD;\n  } else if (thread.name === 'DedicatedWorker thread') {\n    threadType = ThreadType.WORKER;\n  } else if (thread.name?.startsWith('CompositorTileWorker')) {\n    threadType = ThreadType.RASTERIZER;\n  } else if (auctionWorkletsData.worklets.has(pid)) {\n    threadType = ThreadType.AUCTION_WORKLET;\n  } else if (thread.name?.startsWith('ThreadPool')) {\n    // TODO(paulirish): perhaps exclude ThreadPoolServiceThread entirely\n    threadType = ThreadType.THREAD_POOL;\n  }\n  return threadType;\n}\n\nexport function threadsInRenderer(\n    rendererData: Renderer.RendererHandlerData, auctionWorkletsData: AuctionWorkletsData): readonly ThreadData[] {\n  const foundThreads: ThreadData[] = [];\n  // If we have Renderer threads, we prefer to use those. In the event that a\n  // trace is a CPU Profile trace, we will never have Renderer threads, so we\n  // know if there are no Renderer threads that we can fallback to using the\n  // data from the SamplesHandler.\n  if (rendererData.processes.size) {\n    for (const [pid, process] of rendererData.processes) {\n      for (const [tid, thread] of process.threads) {\n        if (!thread.tree) {\n          // Drop threads where we could not create the tree; this indicates\n          // unexpected data and we won't be able to support all the UI\n          // filtering we need.\n          continue;\n        }\n        const threadType = getThreadTypeForRendererThread(pid, thread, auctionWorkletsData);\n        foundThreads.push({\n          name: thread.name,\n          pid,\n          tid,\n          processIsOnMainFrame: process.isOnMainFrame,\n          entries: thread.entries,\n          tree: thread.tree,\n          type: threadType,\n          entryToNode: rendererData.entryToNode,\n        });\n      }\n    }\n  }\n  return foundThreads;\n}\n\n/**\n * Given trace parsed data, this helper will return a high level array of\n * ThreadData. This is useful because it allows you to get a list of threads\n * regardless of if the trace is a CPU Profile or a Tracing profile. Thus you\n * can use this helper to iterate over threads in confidence that it will work\n * for both trace types.\n */\nexport function threadsInTrace(parsedTrace: ParsedTrace): readonly ThreadData[] {\n  // If we have Renderer threads, we prefer to use those. In the event that a\n  // trace is a CPU Profile trace, we will never have Renderer threads, so we\n  // know if there are no Renderer threads that we can fallback to using the\n  // data from the SamplesHandler.\n  const threadsFromRenderer = threadsInRenderer(parsedTrace.Renderer, parsedTrace.AuctionWorklets);\n  if (threadsFromRenderer.length) {\n    return threadsFromRenderer;\n  }\n\n  const foundThreads: ThreadData[] = [];\n  if (parsedTrace.Samples.profilesInProcess.size) {\n    for (const [pid, process] of parsedTrace.Samples.profilesInProcess) {\n      for (const [tid, thread] of process) {\n        if (!thread.profileTree) {\n          // Drop threads where we could not create the tree; this indicates\n          // unexpected data and we won't be able to support all the UI\n          // filtering we need.\n          continue;\n        }\n\n        foundThreads.push({\n          pid,\n          tid,\n          // CPU Profile threads do not have a name.\n          name: null,\n          entries: thread.profileCalls,\n          // There is no concept of a \"Main Frame\" in a CPU profile.\n          processIsOnMainFrame: false,\n          tree: thread.profileTree,\n          type: ThreadType.CPU_PROFILE,\n          entryToNode: parsedTrace.Samples.entryToNode,\n        });\n      }\n    }\n  }\n\n  return foundThreads;\n}\n"],
  "mappings": ";AAsBO,WAAW,aAAX,kBAAWA,gBAAX;AACL,EAAAA,YAAA,iBAAc;AACd,EAAAA,YAAA,YAAS;AACT,EAAAA,YAAA,gBAAa;AACb,EAAAA,YAAA,qBAAkB;AAClB,EAAAA,YAAA,WAAQ;AACR,EAAAA,YAAA,iBAAc;AACd,EAAAA,YAAA,iBAAc;AAPE,SAAAA;AAAA,GAAA;AAUlB,SAAS,+BACL,KAA6B,QAC7B,qBAAsD;AACxD,MAAI,aAAa;AACjB,MAAI,OAAO,SAAS,kBAAkB;AACpC,iBAAa;AAAA,EACf,WAAW,OAAO,SAAS,0BAA0B;AACnD,iBAAa;AAAA,EACf,WAAW,OAAO,MAAM,WAAW,sBAAsB,GAAG;AAC1D,iBAAa;AAAA,EACf,WAAW,oBAAoB,SAAS,IAAI,GAAG,GAAG;AAChD,iBAAa;AAAA,EACf,WAAW,OAAO,MAAM,WAAW,YAAY,GAAG;AAEhD,iBAAa;AAAA,EACf;AACA,SAAO;AACT;AAEO,gBAAS,kBACZ,cAA4C,qBAAiE;AAC/G,QAAM,eAA6B,CAAC;AAKpC,MAAI,aAAa,UAAU,MAAM;AAC/B,eAAW,CAAC,KAAK,OAAO,KAAK,aAAa,WAAW;AACnD,iBAAW,CAAC,KAAK,MAAM,KAAK,QAAQ,SAAS;AAC3C,YAAI,CAAC,OAAO,MAAM;AAIhB;AAAA,QACF;AACA,cAAM,aAAa,+BAA+B,KAAK,QAAQ,mBAAmB;AAClF,qBAAa,KAAK;AAAA,UAChB,MAAM,OAAO;AAAA,UACb;AAAA,UACA;AAAA,UACA,sBAAsB,QAAQ;AAAA,UAC9B,SAAS,OAAO;AAAA,UAChB,MAAM,OAAO;AAAA,UACb,MAAM;AAAA,UACN,aAAa,aAAa;AAAA,QAC5B,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AASO,gBAAS,eAAe,aAAiD;AAK9E,QAAM,sBAAsB,kBAAkB,YAAY,UAAU,YAAY,eAAe;AAC/F,MAAI,oBAAoB,QAAQ;AAC9B,WAAO;AAAA,EACT;AAEA,QAAM,eAA6B,CAAC;AACpC,MAAI,YAAY,QAAQ,kBAAkB,MAAM;AAC9C,eAAW,CAAC,KAAK,OAAO,KAAK,YAAY,QAAQ,mBAAmB;AAClE,iBAAW,CAAC,KAAK,MAAM,KAAK,SAAS;AACnC,YAAI,CAAC,OAAO,aAAa;AAIvB;AAAA,QACF;AAEA,qBAAa,KAAK;AAAA,UAChB;AAAA,UACA;AAAA;AAAA,UAEA,MAAM;AAAA,UACN,SAAS,OAAO;AAAA;AAAA,UAEhB,sBAAsB;AAAA,UACtB,MAAM,OAAO;AAAA,UACb,MAAM;AAAA,UACN,aAAa,YAAY,QAAQ;AAAA,QACnC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;",
  "names": ["ThreadType"]
}
