{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/ServerTimingsHandler.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as networkData} from './NetworkRequestsHandler.js';\nimport type {HandlerName} from './types.js';\n\nconst serverTimings: Types.Events.SyntheticServerTiming[] = [];\n\nexport function reset(): void {\n  serverTimings.length = 0;\n}\n\nexport function handleEvent(_event: Types.Events.Event): void {\n  // Implementation not needed because data is sourced from NetworkRequestsHandler\n}\n\nexport async function finalize(): Promise<void> {\n  extractServerTimings();\n  Helpers.Trace.sortTraceEventsInPlace(serverTimings);\n}\n\nconst RESPONSE_START_METRIC_NAME = 'response-start';\nconst RESPONSE_END_METRIC_NAME = 'response-end';\n\n/**\n * Creates synthetic trace events based on server timings in the\n * `Server-Timing` response header. A non-standard `start` param is\n * expected on each metric that contains the start time of the timing\n * based on the server clock.\n *\n * In order to estimate the offset between the server and client clocks,\n * we look for the non-standard `response-start` and `response-end`\n * metrics in the response header, which contain the start and end\n * timestamps of the network request processing in the server. We\n * compare these with the times the request was sent and received in the\n * client to estimate the offset between the client and the server\n * clocks.\n *\n * With this offset estimation at hand, we can map timestamps from the\n * server clock to the tracing clock and locate the timings in the\n * performance timeline.\n */\nfunction extractServerTimings(): void {\n  for (const networkEvent of networkData().byTime) {\n    let timingsInRequest: Platform.ServerTiming.ServerTiming[]|null = null;\n    for (const header of networkEvent.args.data.responseHeaders) {\n      const headerName = header.name.toLocaleLowerCase();\n      // Some popular hosting providers like vercel or render get rid of\n      // Server-Timing headers added by users, so as a workaround we\n      // also support server timing headers with the `-test` suffix\n      // while this feature is experimental, to enable easier trials.\n      if (headerName === 'server-timing' || headerName === 'server-timing-test') {\n        header.name = 'server-timing';\n        timingsInRequest = Platform.ServerTiming.ServerTiming.parseHeaders([header]);\n        continue;\n      }\n    }\n    const serverStart = timingsInRequest?.find(timing => timing.metric === RESPONSE_START_METRIC_NAME)?.start;\n    const serverEnd = timingsInRequest?.find(timing => timing.metric === RESPONSE_END_METRIC_NAME)?.start;\n    if (!serverStart || !serverEnd || !timingsInRequest) {\n      continue;\n    }\n\n    const serverStartInMicro = serverStart * 1_000;\n    const serverEndInMicro = serverEnd * 1_000;\n    serverTimings.push(\n        ...createSyntheticServerTiming(networkEvent, serverStartInMicro, serverEndInMicro, timingsInRequest));\n  }\n}\nfunction createSyntheticServerTiming(\n    request: Types.Events.SyntheticNetworkRequest, serverStart: number, serverEnd: number,\n    timingsInRequest: Platform.ServerTiming.ServerTiming[]): Types.Events.SyntheticServerTiming[] {\n  const clientStart = request.args.data.syntheticData.sendStartTime;\n  const clientEndTime = request.args.data.syntheticData.sendStartTime + request.args.data.syntheticData.waiting;\n  const offset = Types.Timing.MicroSeconds((serverStart - clientStart + serverEnd - clientEndTime) / 2);\n  const convertedServerTimings: Types.Events.SyntheticServerTiming[] = [];\n  for (const timing of timingsInRequest) {\n    if (timing.metric === RESPONSE_START_METRIC_NAME || timing.metric === RESPONSE_END_METRIC_NAME) {\n      continue;\n    }\n    if (timing.start === null) {\n      continue;\n    }\n    const convertedTimestamp =\n        Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(timing.start)) - offset;\n    const parsedUrl = new URL(request.args.data.url);\n    const origin = parsedUrl.origin;\n\n    const serverTiming = Helpers.SyntheticEvents.SyntheticEventsManager.registerServerTiming({\n      rawSourceEvent: request.rawSourceEvent,\n      name: timing.metric,\n      ph: Types.Events.Phase.COMPLETE,\n      pid: Types.Events.ProcessID(0),\n      tid: Types.Events.ThreadID(0),\n      ts: Types.Timing.MicroSeconds(convertedTimestamp),\n      dur: Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(timing.value)),\n      cat: 'devtools.server-timing',\n      args: {data: {desc: timing.description || undefined, origin}},\n    });\n\n    if (!request.args.data.syntheticServerTimings) {\n      request.args.data.syntheticServerTimings = [];\n    }\n    request.args.data.syntheticServerTimings.push(serverTiming);\n    convertedServerTimings.push(serverTiming);\n  }\n  return convertedServerTimings;\n}\n\nexport function data(): {serverTimings: Types.Events.SyntheticServerTiming[]} {\n  return {\n    serverTimings,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['NetworkRequests'];\n}\n"],
  "mappings": ";AAIA,YAAY,cAAc;AAC1B,YAAY,aAAa;AACzB,YAAY,WAAW;AAEvB,SAAQ,QAAQ,mBAAkB;AAGlC,MAAM,gBAAsD,CAAC;AAEtD,gBAAS,QAAc;AAC5B,gBAAc,SAAS;AACzB;AAEO,gBAAS,YAAY,QAAkC;AAE9D;AAEA,sBAAsB,WAA0B;AAC9C,uBAAqB;AACrB,UAAQ,MAAM,uBAAuB,aAAa;AACpD;AAEA,MAAM,6BAA6B;AACnC,MAAM,2BAA2B;AAoBjC,SAAS,uBAA6B;AACpC,aAAW,gBAAgB,YAAY,EAAE,QAAQ;AAC/C,QAAI,mBAA8D;AAClE,eAAW,UAAU,aAAa,KAAK,KAAK,iBAAiB;AAC3D,YAAM,aAAa,OAAO,KAAK,kBAAkB;AAKjD,UAAI,eAAe,mBAAmB,eAAe,sBAAsB;AACzE,eAAO,OAAO;AACd,2BAAmB,SAAS,aAAa,aAAa,aAAa,CAAC,MAAM,CAAC;AAC3E;AAAA,MACF;AAAA,IACF;AACA,UAAM,cAAc,kBAAkB,KAAK,YAAU,OAAO,WAAW,0BAA0B,GAAG;AACpG,UAAM,YAAY,kBAAkB,KAAK,YAAU,OAAO,WAAW,wBAAwB,GAAG;AAChG,QAAI,CAAC,eAAe,CAAC,aAAa,CAAC,kBAAkB;AACnD;AAAA,IACF;AAEA,UAAM,qBAAqB,cAAc;AACzC,UAAM,mBAAmB,YAAY;AACrC,kBAAc;AAAA,MACV,GAAG,4BAA4B,cAAc,oBAAoB,kBAAkB,gBAAgB;AAAA,IAAC;AAAA,EAC1G;AACF;AACA,SAAS,4BACL,SAA+C,aAAqB,WACpE,kBAA8F;AAChG,QAAM,cAAc,QAAQ,KAAK,KAAK,cAAc;AACpD,QAAM,gBAAgB,QAAQ,KAAK,KAAK,cAAc,gBAAgB,QAAQ,KAAK,KAAK,cAAc;AACtG,QAAM,SAAS,MAAM,OAAO,cAAc,cAAc,cAAc,YAAY,iBAAiB,CAAC;AACpG,QAAM,yBAA+D,CAAC;AACtE,aAAW,UAAU,kBAAkB;AACrC,QAAI,OAAO,WAAW,8BAA8B,OAAO,WAAW,0BAA0B;AAC9F;AAAA,IACF;AACA,QAAI,OAAO,UAAU,MAAM;AACzB;AAAA,IACF;AACA,UAAM,qBACF,QAAQ,OAAO,2BAA2B,MAAM,OAAO,aAAa,OAAO,KAAK,CAAC,IAAI;AACzF,UAAM,YAAY,IAAI,IAAI,QAAQ,KAAK,KAAK,GAAG;AAC/C,UAAM,SAAS,UAAU;AAEzB,UAAM,eAAe,QAAQ,gBAAgB,uBAAuB,qBAAqB;AAAA,MACvF,gBAAgB,QAAQ;AAAA,MACxB,MAAM,OAAO;AAAA,MACb,IAAI,MAAM,OAAO,MAAM;AAAA,MACvB,KAAK,MAAM,OAAO,UAAU,CAAC;AAAA,MAC7B,KAAK,MAAM,OAAO,SAAS,CAAC;AAAA,MAC5B,IAAI,MAAM,OAAO,aAAa,kBAAkB;AAAA,MAChD,KAAK,QAAQ,OAAO,2BAA2B,MAAM,OAAO,aAAa,OAAO,KAAK,CAAC;AAAA,MACtF,KAAK;AAAA,MACL,MAAM,EAAC,MAAM,EAAC,MAAM,OAAO,eAAe,QAAW,OAAM,EAAC;AAAA,IAC9D,CAAC;AAED,QAAI,CAAC,QAAQ,KAAK,KAAK,wBAAwB;AAC7C,cAAQ,KAAK,KAAK,yBAAyB,CAAC;AAAA,IAC9C;AACA,YAAQ,KAAK,KAAK,uBAAuB,KAAK,YAAY;AAC1D,2BAAuB,KAAK,YAAY;AAAA,EAC1C;AACA,SAAO;AACT;AAEO,gBAAS,OAA8D;AAC5E,SAAO;AAAA,IACL;AAAA,EACF;AACF;AAEO,gBAAS,OAAsB;AACpC,SAAO,CAAC,iBAAiB;AAC3B;",
  "names": []
}
