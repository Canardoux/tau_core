{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/ScreenshotsHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\n\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nconst unpairedAsyncEvents: Types.Events.PipelineReporter[] = [];\n\nconst snapshotEvents: Types.Events.Screenshot[] = [];\nconst syntheticScreenshots: Types.Events.SyntheticScreenshot[] = [];\nlet frameSequenceToTs: Record<string, Types.Timing.MicroSeconds> = {};\n\nexport function reset(): void {\n  unpairedAsyncEvents.length = 0;\n  snapshotEvents.length = 0;\n  syntheticScreenshots.length = 0;\n  frameSequenceToTs = {};\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isScreenshot(event)) {\n    snapshotEvents.push(event);\n  } else if (Types.Events.isPipelineReporter(event)) {\n    unpairedAsyncEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const pipelineReporterEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(unpairedAsyncEvents);\n\n  frameSequenceToTs = Object.fromEntries(pipelineReporterEvents.map(evt => {\n    const frameSequenceId = evt.args.data.beginEvent.args.chrome_frame_reporter.frame_sequence;\n    const presentationTs = Types.Timing.MicroSeconds(evt.ts + evt.dur);\n    return [frameSequenceId, presentationTs];\n  }));\n\n  for (const snapshotEvent of snapshotEvents) {\n    const {cat, name, ph, pid, tid} = snapshotEvent;\n    const syntheticEvent = Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<\n        Types.Events.SyntheticScreenshot>({\n      rawSourceEvent: snapshotEvent,\n      cat,\n      name,\n      ph,\n      pid,\n      tid,\n      // TODO(paulirish, crbug.com/41363012): investigate why getPresentationTimestamp(snapshotEvent) seems less accurate. Resolve screenshot timing innaccuracy.\n      // `getPresentationTimestamp(snapshotEvent) - snapshotEvent.ts` is how many microsec the screenshot should be adjusted to the right/later\n      ts: snapshotEvent.ts,\n      args: {\n        dataUri: `data:image/jpg;base64,${snapshotEvent.args.snapshot}`,\n      },\n    });\n    syntheticScreenshots.push(syntheticEvent);\n  }\n}\n\n/**\n * Correct the screenshot timestamps\n * The screenshot 'snapshot object' trace event has the \"frame sequence number\" attached as an ID.\n * We match that up with the \"PipelineReporter\" trace events as they terminate at presentation.\n * Presentation == when the pixels hit the screen. AKA Swap on the GPU\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getPresentationTimestamp(screenshotEvent: Types.Events.Screenshot): Types.Timing.MicroSeconds {\n  const frameSequence = parseInt(screenshotEvent.id, 16);\n  // If it's 1, then it's an old trace (before https://crrev.com/c/4957973) and cannot be corrected.\n  if (frameSequence === 1) {\n    return screenshotEvent.ts;\n  }\n  // The screenshot trace event's `ts` reflects the \"expected display time\" which is ESTIMATE.\n  // It is set by the compositor frame sink from the `expected_display_time`, which is based on a previously known\n  // frame start PLUS the vsync interval (eg 16.6ms)\n  const updatedTs = frameSequenceToTs[frameSequence];\n  // Do we always find a match? No...\n  // We generally don't match the very first screenshot and, sometimes, the last\n  // The very first screenshot is requested immediately (even if nothing is painting). As a result there's no compositor\n  // instrumentation running alongside.\n  // The last one is sometimes missing as because the trace terminates right before the associated PipelineReporter is emitted.\n  return updatedTs ?? screenshotEvent.ts;\n}\n\n// TODO(crbug/41484172): should be readonly\nexport function data(): ({all: Types.Events.SyntheticScreenshot[]}) {\n  return {all: syntheticScreenshots};\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n"],
  "mappings": ";AAIA,YAAY,aAAa;AACzB,YAAY,WAAW;AAMvB,MAAM,sBAAuD,CAAC;AAE9D,MAAM,iBAA4C,CAAC;AACnD,MAAM,uBAA2D,CAAC;AAClE,IAAI,oBAA+D,CAAC;AAE7D,gBAAS,QAAc;AAC5B,sBAAoB,SAAS;AAC7B,iBAAe,SAAS;AACxB,uBAAqB,SAAS;AAC9B,sBAAoB,CAAC;AACvB;AAEO,gBAAS,YAAY,OAAiC;AAC3D,MAAI,MAAM,OAAO,aAAa,KAAK,GAAG;AACpC,mBAAe,KAAK,KAAK;AAAA,EAC3B,WAAW,MAAM,OAAO,mBAAmB,KAAK,GAAG;AACjD,wBAAoB,KAAK,KAAK;AAAA,EAChC;AACF;AAEA,sBAAsB,WAA0B;AAC9C,QAAM,yBAAyB,QAAQ,MAAM,mCAAmC,mBAAmB;AAEnG,sBAAoB,OAAO,YAAY,uBAAuB,IAAI,SAAO;AACvE,UAAM,kBAAkB,IAAI,KAAK,KAAK,WAAW,KAAK,sBAAsB;AAC5E,UAAM,iBAAiB,MAAM,OAAO,aAAa,IAAI,KAAK,IAAI,GAAG;AACjE,WAAO,CAAC,iBAAiB,cAAc;AAAA,EACzC,CAAC,CAAC;AAEF,aAAW,iBAAiB,gBAAgB;AAC1C,UAAM,EAAC,KAAK,MAAM,IAAI,KAAK,IAAG,IAAI;AAClC,UAAM,iBAAiB,QAAQ,gBAAgB,uBAAuB,uBAChC;AAAA,MACpC,gBAAgB;AAAA,MAChB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAAA,MAGA,IAAI,cAAc;AAAA,MAClB,MAAM;AAAA,QACJ,SAAS,yBAAyB,cAAc,KAAK,QAAQ;AAAA,MAC/D;AAAA,IACF,CAAC;AACD,yBAAqB,KAAK,cAAc;AAAA,EAC1C;AACF;AASA,SAAS,yBAAyB,iBAAqE;AACrG,QAAM,gBAAgB,SAAS,gBAAgB,IAAI,EAAE;AAErD,MAAI,kBAAkB,GAAG;AACvB,WAAO,gBAAgB;AAAA,EACzB;AAIA,QAAM,YAAY,kBAAkB,aAAa;AAMjD,SAAO,aAAa,gBAAgB;AACtC;AAGO,gBAAS,OAAoD;AAClE,SAAO,EAAC,KAAK,qBAAoB;AACnC;AAEO,gBAAS,OAAsB;AACpC,SAAO,CAAC,MAAM;AAChB;",
  "names": []
}
