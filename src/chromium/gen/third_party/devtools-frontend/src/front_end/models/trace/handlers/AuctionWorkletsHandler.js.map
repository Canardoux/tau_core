{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/AuctionWorkletsHandler.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\n/**\n * There are two metadata events that we care about.\n * => AuctionWorkletRunningInProcess tells us which process the Auction Worklet\n *    has taken to run in.\n * => AuctionWorkletDoneWithProcess tells us when the worklet is done with that\n *    process. This is less useful - but in the future we might want to surface\n *    this information so we still parse and return the event.\n *\n * It is important to note that the top level PID on these events is NOT the\n * PID that the worklet is running on; instead we have to look at its\n * args.data.pid property, which is the PID of the process that it is running\n * on.\n *\n * For any given RunningInProcess event, we would typically expect to see a\n * DoneWithProcess event, however this is not guaranteed, especially as users\n * can record any chunk of time in DevTools.\n *\n * Similarly, it is also possible to see a DoneWithProcess event without a\n * RunningInProcess event, if the user started recording after the auction\n * worklets started. Therefore we are happy to create\n * SyntheticAuctionWorklets as long as we see just one of these events.\n *\n * If we do get two events and need to pair them, we can use the\n * args.data.target property, which is a string ID shared by both\n * events.\n */\nconst runningInProcessEvents: Map<Types.Events.ProcessID, Types.Events.AuctionWorkletRunningInProcess> = new Map();\nconst doneWithProcessEvents: Map<Types.Events.ProcessID, Types.Events.AuctionWorkletDoneWithProcess> = new Map();\n\n// Keyed by the PID defined in  `args.data.pid` on AuctionWorklet trace events..\nconst createdSyntheticEvents: Map<Types.Events.ProcessID, Types.Events.SyntheticAuctionWorklet> = new Map();\n\n// Each AuctonWorklet takes over a process and has 2 threads (that we care\n// about and want to show as tracks):\n// 1. A CrUtilityMain thread which is known as the \"control process\".\n// 2. A AuctionV8HelperThread which is the actual auction worklet and will be\n//    either a \"Seller\" or a \"Bidder\"\n// To detect these we look for the metadata thread_name events. We key these by\n// PID so that we can easily look them up later without having to loop through.\nconst utilityThreads: Map<Types.Events.ProcessID, Types.Events.ThreadName> = new Map();\nconst v8HelperThreads: Map<Types.Events.ProcessID, Types.Events.ThreadName> = new Map();\n\nexport function reset(): void {\n  runningInProcessEvents.clear();\n  doneWithProcessEvents.clear();\n  createdSyntheticEvents.clear();\n  utilityThreads.clear();\n  v8HelperThreads.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isAuctionWorkletRunningInProcess(event)) {\n    runningInProcessEvents.set(event.args.data.pid, event);\n    return;\n  }\n\n  if (Types.Events.isAuctionWorkletDoneWithProcess(event)) {\n    doneWithProcessEvents.set(event.args.data.pid, event);\n    return;\n  }\n\n  if (Types.Events.isThreadName(event)) {\n    if (event.args.name === 'auction_worklet.CrUtilityMain') {\n      utilityThreads.set(event.pid, event);\n      return;\n    }\n    if (event.args.name === 'AuctionV8HelperThread') {\n      v8HelperThreads.set(event.pid, event);\n    }\n  }\n}\n\nfunction workletType(input: string): Types.Events.AuctionWorkletType {\n  switch (input) {\n    case 'seller':\n      return Types.Events.AuctionWorkletType.SELLER;\n    case 'bidder':\n      return Types.Events.AuctionWorkletType.BIDDER;\n    default:\n      return Types.Events.AuctionWorkletType.UNKNOWN;\n  }\n}\n\n/**\n * We cannot make the full event without knowing the type of event, but we can\n * create everything other than the `args` field, as those are identical\n * regardless of the type of event.\n */\nfunction makeSyntheticEventBase(event: Types.Events.AuctionWorkletDoneWithProcess|\n                                Types.Events.AuctionWorkletRunningInProcess):\n    Omit<Types.Events.SyntheticAuctionWorklet, 'args'> {\n  return Helpers.SyntheticEvents.SyntheticEventsManager\n      .registerSyntheticEvent<Omit<Types.Events.SyntheticAuctionWorklet, 'args'>>({\n        rawSourceEvent: event,\n        name: 'SyntheticAuctionWorklet',\n        s: Types.Events.Scope.THREAD,\n        cat: event.cat,\n        tid: event.tid,\n        ts: event.ts,\n        ph: Types.Events.Phase.INSTANT,\n        pid: event.args.data.pid,\n        host: event.args.data.host,\n        target: event.args.data.target,\n        type: workletType(event.args.data.type),\n      });\n}\n\nexport async function finalize(): Promise<void> {\n  // Loop through the utility threads we found to create the worklet events. We\n  // expect each worklet to have a utility thread, so we can use them as the\n  // root of our list of worklets.\n  for (const [pid, utilityThreadNameEvent] of utilityThreads) {\n    const v8HelperEvent = v8HelperThreads.get(pid);\n    if (!v8HelperEvent) {\n      // Bad trace data - AuctionWorklets are expected to always have both threads.\n      continue;\n    }\n\n    const runningEvent = runningInProcessEvents.get(pid);\n    const doneWithEvent = doneWithProcessEvents.get(pid);\n\n    // We can create a worklet from either the runningEvent or doneWithEvent -\n    // we do not need both. We cannot express that to TypeScript with an early\n    // return here, so instead we set the event initially to null, and then\n    // create it from either the running event or the doneWith event. If it is\n    // still null after this, that means neither event was found, and we drop\n    // the worklet as we do not have enough information to create the synthetic\n    // event.\n\n    let syntheticEvent: Types.Events.SyntheticAuctionWorklet|null = null;\n\n    if (runningEvent) {\n      syntheticEvent = {\n        ...makeSyntheticEventBase(runningEvent),\n        args: {\n          data: {\n            runningInProcessEvent: runningEvent,\n            utilityThread: utilityThreadNameEvent,\n            v8HelperThread: v8HelperEvent,\n          },\n        },\n      };\n      if (doneWithEvent) {\n        syntheticEvent.args.data.doneWithProcessEvent = doneWithEvent;\n      }\n    } else if (doneWithEvent) {\n      syntheticEvent = {\n        ...makeSyntheticEventBase(doneWithEvent),\n        args: {\n          data: {\n            doneWithProcessEvent: doneWithEvent,\n            utilityThread: utilityThreadNameEvent,\n            v8HelperThread: v8HelperEvent,\n          },\n        },\n      };\n      if (runningEvent) {\n        syntheticEvent.args.data.runningInProcessEvent = runningEvent;\n      }\n    }\n    if (syntheticEvent === null) {\n      continue;\n    }\n    createdSyntheticEvents.set(pid, syntheticEvent);\n  }\n}\n\nexport interface AuctionWorkletsData {\n  worklets: Map<Types.Events.ProcessID, Types.Events.SyntheticAuctionWorklet>;\n}\n\nexport function data(): AuctionWorkletsData {\n  return {\n    worklets: new Map(createdSyntheticEvents),\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
