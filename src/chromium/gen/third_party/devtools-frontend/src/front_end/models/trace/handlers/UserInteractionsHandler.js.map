{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/UserInteractionsHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\nimport type {HandlerName} from './types.js';\n\n// This handler serves two purposes. It generates a list of events that are\n// used to show user clicks in the timeline. It is also used to gather\n// EventTimings into Interactions, which we use to show interactions and\n// highlight long interactions to the user, along with INP.\n\n// We don't need to know which process / thread these events occurred in,\n// because they are effectively global, so we just track all that we find.\nconst allEvents: Types.Events.EventTimingBeginOrEnd[] = [];\n\nconst beginCommitCompositorFrameEvents: Types.Events.BeginCommitCompositorFrame[] = [];\nconst parseMetaViewportEvents: Types.Events.ParseMetaViewport[] = [];\n\nexport const LONG_INTERACTION_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(200));\n\nconst INP_GOOD_TIMING = LONG_INTERACTION_THRESHOLD;\nconst INP_MEDIUM_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(500));\n\nexport interface UserInteractionsData {\n  /** All the user events we found in the trace */\n  allEvents: readonly Types.Events.EventTimingBeginOrEnd[];\n  /** All the BeginCommitCompositorFrame events we found in the trace */\n  beginCommitCompositorFrameEvents: readonly Types.Events.BeginCommitCompositorFrame[];\n  /** All the ParseMetaViewport events we found in the trace */\n  parseMetaViewportEvents: readonly Types.Events.ParseMetaViewport[];\n  /** All the interaction events we found in the trace that had an\n   * interactionId and a duration > 0\n   **/\n  interactionEvents: readonly Types.Events.SyntheticInteractionPair[];\n  /** If the user rapidly generates interaction events (think typing into a\n   * text box), in the UI we only really want to show the user the longest\n   * interaction in that set.\n   * For example picture interactions like this:\n   * ===[interaction A]==========\n   *       =[interaction B]======\n   *            =[interaction C]=\n   *\n   * These events all end at the same time, and so in this instance we only want\n   * to show the first interaction A on the timeline, as that is the longest one\n   * and the one the developer should be focusing on. So this array of events is\n   * all the interaction events filtered down, removing any nested interactions\n   * entirely.\n   **/\n  interactionEventsWithNoNesting: readonly Types.Events.SyntheticInteractionPair[];\n  // The longest duration interaction event. Can be null if the trace has no interaction events.\n  longestInteractionEvent: Readonly<Types.Events.SyntheticInteractionPair>|null;\n  // All interactions that went over the interaction threshold (200ms, see https://web.dev/inp/)\n  interactionsOverThreshold: Readonly<Set<Types.Events.SyntheticInteractionPair>>;\n}\n\nlet longestInteractionEvent: Types.Events.SyntheticInteractionPair|null = null;\n\nconst interactionEvents: Types.Events.SyntheticInteractionPair[] = [];\nconst interactionEventsWithNoNesting: Types.Events.SyntheticInteractionPair[] = [];\nconst eventTimingEndEventsById = new Map<string, Types.Events.EventTimingEnd>();\nconst eventTimingStartEventsForInteractions: Types.Events.EventTimingBegin[] = [];\n\nexport function reset(): void {\n  allEvents.length = 0;\n  beginCommitCompositorFrameEvents.length = 0;\n  parseMetaViewportEvents.length = 0;\n  interactionEvents.length = 0;\n  eventTimingStartEventsForInteractions.length = 0;\n  eventTimingEndEventsById.clear();\n  interactionEventsWithNoNesting.length = 0;\n  longestInteractionEvent = null;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isBeginCommitCompositorFrame(event)) {\n    beginCommitCompositorFrameEvents.push(event);\n    return;\n  }\n\n  if (Types.Events.isParseMetaViewport(event)) {\n    parseMetaViewportEvents.push(event);\n    return;\n  }\n\n  if (!Types.Events.isEventTiming(event)) {\n    return;\n  }\n\n  if (Types.Events.isEventTimingEnd(event)) {\n    // Store the end event; for each start event that is an interaction, we need the matching end event to calculate the duration correctly.\n    eventTimingEndEventsById.set(event.id, event);\n  }\n\n  allEvents.push(event);\n\n  // From this point on we want to find events that represent interactions.\n  // These events are always start events - those are the ones that contain all\n  // the metadata about the interaction.\n  if (!event.args.data || !Types.Events.isEventTimingStart(event)) {\n    return;\n  }\n  const {duration, interactionId} = event.args.data;\n  // We exclude events for the sake of interactions if:\n  // 1. They have no duration.\n  // 2. They have no interactionId\n  // 3. They have an interactionId of 0: this indicates that it's not an\n  //    interaction that we care about because it hasn't had its own interactionId\n  //    set (0 is the default on the backend).\n  // See: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/responsiveness_metrics.cc;l=133;drc=40c209a9c365ebb9f16fb99dfe78c7fe768b9594\n\n  if (duration < 1 || interactionId === undefined || interactionId === 0) {\n    return;\n  }\n\n  // Store the start event. In the finalize() function we will pair this with\n  // its end event and create the synthetic interaction event.\n  eventTimingStartEventsForInteractions.push(event);\n}\n\n/**\n * See https://web.dev/better-responsiveness-metric/#interaction-types for the\n * table that defines these sets.\n **/\nconst pointerEventTypes = new Set([\n  'pointerdown',\n  'touchstart',\n  'pointerup',\n  'touchend',\n  'mousedown',\n  'mouseup',\n  'click',\n]);\n\nconst keyboardEventTypes = new Set([\n  'keydown',\n  'keypress',\n  'keyup',\n]);\n\nexport type InteractionCategory = 'KEYBOARD'|'POINTER'|'OTHER';\nexport function categoryOfInteraction(interaction: Types.Events.SyntheticInteractionPair): InteractionCategory {\n  if (pointerEventTypes.has(interaction.type)) {\n    return 'POINTER';\n  }\n  if (keyboardEventTypes.has(interaction.type)) {\n    return 'KEYBOARD';\n  }\n\n  return 'OTHER';\n}\n\n/**\n * We define a set of interactions as nested where:\n * 1. Their end times align.\n * 2. The longest interaction's start time is earlier than all other\n * interactions with the same end time.\n * 3. The interactions are of the same category [each interaction is either\n * categorised as keyboard, or pointer.]\n *\n * =============A=[pointerup]=\n *        ====B=[pointerdown]=\n *        ===C=[pointerdown]==\n *         ===D=[pointerup]===\n *\n * In this example, B, C and D are all nested and therefore should not be\n * returned from this function.\n *\n * However, in this example we would only consider B nested (under A) and D\n * nested (under C). A and C both stay because they are of different types.\n * ========A=[keydown]====\n *   =======B=[keyup]=====\n *    ====C=[pointerdown]=\n *         =D=[pointerup]=\n **/\nexport function removeNestedInteractions(interactions: readonly Types.Events.SyntheticInteractionPair[]):\n    readonly Types.Events.SyntheticInteractionPair[] {\n  /**\n   * Because we nest events only that are in the same category, we store the\n   * longest event for a given end time by category.\n   **/\n  const earliestEventForEndTimePerCategory:\n      Record<InteractionCategory, Map<Types.Timing.MicroSeconds, Types.Events.SyntheticInteractionPair>> = {\n        POINTER: new Map(),\n        KEYBOARD: new Map(),\n        OTHER: new Map(),\n      };\n\n  function storeEventIfEarliestForCategoryAndEndTime(interaction: Types.Events.SyntheticInteractionPair): void {\n    const category = categoryOfInteraction(interaction);\n    const earliestEventForEndTime = earliestEventForEndTimePerCategory[category];\n    const endTime = Types.Timing.MicroSeconds(interaction.ts + interaction.dur);\n\n    const earliestCurrentEvent = earliestEventForEndTime.get(endTime);\n    if (!earliestCurrentEvent) {\n      earliestEventForEndTime.set(endTime, interaction);\n      return;\n    }\n    if (interaction.ts < earliestCurrentEvent.ts) {\n      earliestEventForEndTime.set(endTime, interaction);\n    } else if (\n        interaction.ts === earliestCurrentEvent.ts &&\n        interaction.interactionId === earliestCurrentEvent.interactionId) {\n      // We have seen in traces that the same interaction can have multiple\n      // events (e.g. a 'click' and a 'pointerdown'). Often only one of these\n      // events will have an event handler bound to it which caused delay on\n      // the main thread, and the others will not. This leads to a situation\n      // where if we pick one of the events that had no event handler, its\n      // processing duration (processingEnd - processingStart) will be 0, but if we\n      // had picked the event that had the slow event handler, we would show\n      // correctly the main thread delay due to the event handler.\n      // So, if we find events with the same interactionId and the same\n      // begin/end times, we pick the one with the largest (processingEnd -\n      // processingStart) time in order to make sure we find the event with the\n      // worst main thread delay, as that is the one the user should care\n      // about.\n      const currentProcessingDuration = earliestCurrentEvent.processingEnd - earliestCurrentEvent.processingStart;\n      const newProcessingDuration = interaction.processingEnd - interaction.processingStart;\n\n      // Use the new interaction if it has a longer processing duration than the existing one.\n      if (newProcessingDuration > currentProcessingDuration) {\n        earliestEventForEndTime.set(endTime, interaction);\n      }\n    }\n\n    // Maximize the processing duration based on the \"children\" interactions.\n    // We pick the earliest start processing duration, and the latest end\n    // processing duration to avoid under-reporting.\n    if (interaction.processingStart < earliestCurrentEvent.processingStart) {\n      earliestCurrentEvent.processingStart = interaction.processingStart;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n    if (interaction.processingEnd > earliestCurrentEvent.processingEnd) {\n      earliestCurrentEvent.processingEnd = interaction.processingEnd;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n  }\n\n  for (const interaction of interactions) {\n    storeEventIfEarliestForCategoryAndEndTime(interaction);\n  }\n\n  // Combine all the events that we have kept from all the per-category event\n  // maps back into an array and sort them by timestamp.\n  const keptEvents = Object.values(earliestEventForEndTimePerCategory)\n                         .flatMap(eventsByEndTime => Array.from(eventsByEndTime.values()));\n  keptEvents.sort((eventA, eventB) => {\n    return eventA.ts - eventB.ts;\n  });\n  return keptEvents;\n}\n\nfunction writeSyntheticTimespans(event: Types.Events.SyntheticInteractionPair): void {\n  const startEvent = event.args.data.beginEvent;\n  const endEvent = event.args.data.endEvent;\n\n  event.inputDelay = Types.Timing.MicroSeconds(event.processingStart - startEvent.ts);\n  event.mainThreadHandling = Types.Timing.MicroSeconds(event.processingEnd - event.processingStart);\n  event.presentationDelay = Types.Timing.MicroSeconds(endEvent.ts - event.processingEnd);\n}\n\nexport async function finalize(): Promise<void> {\n  const {navigationsByFrameId} = metaHandlerData();\n\n  // For each interaction start event, find the async end event by the ID, and then create the Synthetic Interaction event.\n  for (const interactionStartEvent of eventTimingStartEventsForInteractions) {\n    const endEvent = eventTimingEndEventsById.get(interactionStartEvent.id);\n    if (!endEvent) {\n      // If we cannot find an end event, bail and drop this event.\n      continue;\n    }\n    const {type, interactionId, timeStamp, processingStart, processingEnd} = interactionStartEvent.args.data;\n    if (!type || !interactionId || !timeStamp || !processingStart || !processingEnd) {\n      // A valid interaction event that we care about has to have a type (e.g. pointerdown, keyup).\n      // We also need to ensure it has an interactionId and various timings. There are edge cases where these aren't included in the trace event.\n      continue;\n    }\n\n    // In the future we will add microsecond timestamps to the trace events\u2026\n    // (See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/window_performance.cc;l=900-901;drc=b503c262e425eae59ced4a80d59d176ed07152c7 )\n    // \u2026but until then we can use the millisecond precision values that are in\n    // the trace event. To adjust them to be relative to the event.ts and the\n    // trace timestamps, for both processingStart and processingEnd we subtract\n    // the event timestamp (NOT event.ts, but the timeStamp millisecond value\n    // emitted in args.data), and then add that value to the event.ts. This\n    // will give us a processingStart and processingEnd time in microseconds\n    // that is relative to event.ts, and can be used when drawing boxes.\n    // There is some inaccuracy here as we are converting milliseconds to microseconds, but it is good enough until the backend emits more accurate numbers.\n    const processingStartRelativeToTraceTime = Types.Timing.MicroSeconds(\n        Helpers.Timing.millisecondsToMicroseconds(processingStart) -\n            Helpers.Timing.millisecondsToMicroseconds(timeStamp) + interactionStartEvent.ts,\n    );\n\n    const processingEndRelativeToTraceTime = Types.Timing.MicroSeconds(\n        (Helpers.Timing.millisecondsToMicroseconds(processingEnd) -\n         Helpers.Timing.millisecondsToMicroseconds(timeStamp)) +\n        interactionStartEvent.ts);\n\n    // Ultimate frameId fallback only needed for TSC, see comments in the type.\n    const frameId = interactionStartEvent.args.frame ?? interactionStartEvent.args.data.frame ?? '';\n    const navigation = Helpers.Trace.getNavigationForTraceEvent(interactionStartEvent, frameId, navigationsByFrameId);\n    const navigationId = navigation?.args.data?.navigationId;\n    const interactionEvent =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticInteractionPair>({\n          // Use the start event to define the common fields.\n          rawSourceEvent: interactionStartEvent,\n          cat: interactionStartEvent.cat,\n          name: interactionStartEvent.name,\n          pid: interactionStartEvent.pid,\n          tid: interactionStartEvent.tid,\n          ph: interactionStartEvent.ph,\n          processingStart: processingStartRelativeToTraceTime,\n          processingEnd: processingEndRelativeToTraceTime,\n          // These will be set in writeSyntheticTimespans()\n          inputDelay: Types.Timing.MicroSeconds(-1),\n          mainThreadHandling: Types.Timing.MicroSeconds(-1),\n          presentationDelay: Types.Timing.MicroSeconds(-1),\n          args: {\n            data: {\n              beginEvent: interactionStartEvent,\n              endEvent,\n              frame: frameId,\n              navigationId,\n            },\n          },\n          ts: interactionStartEvent.ts,\n          dur: Types.Timing.MicroSeconds(endEvent.ts - interactionStartEvent.ts),\n          type: interactionStartEvent.args.data.type,\n          interactionId: interactionStartEvent.args.data.interactionId,\n        });\n    writeSyntheticTimespans(interactionEvent);\n\n    interactionEvents.push(interactionEvent);\n  }\n\n  interactionEventsWithNoNesting.push(...removeNestedInteractions(interactionEvents));\n\n  // Pick the longest interactions from the set that were not nested, as we\n  // know those are the set of the largest interactions.\n  for (const interactionEvent of interactionEventsWithNoNesting) {\n    if (!longestInteractionEvent || longestInteractionEvent.dur < interactionEvent.dur) {\n      longestInteractionEvent = interactionEvent;\n    }\n  }\n}\n\nexport function data(): UserInteractionsData {\n  return {\n    allEvents,\n    beginCommitCompositorFrameEvents,\n    parseMetaViewportEvents,\n    interactionEvents,\n    interactionEventsWithNoNesting,\n    longestInteractionEvent,\n    interactionsOverThreshold: new Set(interactionEvents.filter(event => {\n      return event.dur > LONG_INTERACTION_THRESHOLD;\n    })),\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/articles/inp#good-score\n */\nexport function scoreClassificationForInteractionToNextPaint(timing: Types.Timing.MicroSeconds): ScoreClassification {\n  if (timing <= INP_GOOD_TIMING) {\n    return ScoreClassification.GOOD;\n  }\n\n  if (timing <= INP_MEDIUM_TIMING) {\n    return ScoreClassification.OK;\n  }\n\n  return ScoreClassification.BAD;\n}\n"],
  "mappings": "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",
  "names": []
}
