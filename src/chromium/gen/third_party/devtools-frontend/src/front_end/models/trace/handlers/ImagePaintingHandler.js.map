{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/ImagePaintingHandler.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\n/**\n * This handler is responsible for the relationships between:\n * DecodeImage/ResizeImage, PaintImage and DrawLazyPixelRef events.\n *\n * When we get a DecodeImage event, we want to associate it to a PaintImage\n * event, primarily so we can determine the NodeID of the image that was\n * decoded.\n * We can do this in two ways:\n *\n * 1. If there is a PaintImage event on the same thread, use that\n *    (if there are multiple, use the latest one).\n *\n * 2. If not, we can find the DecodeLazyPixelRef event on the same thread, and\n *    use the PaintImage event associated with it via the `LazyPixelRef` key.\n */\n\n// Track paintImageEvents across threads.\nconst paintImageEvents: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.PaintImage[]>> = new Map();\nconst decodeLazyPixelRefEvents:\n    Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.DecodeLazyPixelRef[]>> = new Map();\n\n// A DrawLazyPixelRef event will contain a numerical reference in\n// args.LazyPixelRef. As we parse each DrawLazyPixelRef, we can assign it to a\n// paint event. Later we want to look up paint events by this reference, so we\n// store them in this map.\nconst paintImageByLazyPixelRef: Map<number, Types.Events.PaintImage> = new Map();\n\n// When we find events that we want to tie to a particular PaintImage event, we add them to this map.\n// These are currently only DecodeImage and ResizeImage events, but the type is\n// deliberately generic as in the future we might want to add more events that\n// have a relationship to a individual PaintImage event.\nconst eventToPaintImage: Map<Types.Events.Event, Types.Events.PaintImage> = new Map();\n\nconst urlToPaintImage: Map<string, Types.Events.PaintImage[]> = new Map();\n\nexport function reset(): void {\n  paintImageEvents.clear();\n  decodeLazyPixelRefEvents.clear();\n  paintImageByLazyPixelRef.clear();\n  eventToPaintImage.clear();\n  urlToPaintImage.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isPaintImage(event)) {\n    const forProcess = paintImageEvents.get(event.pid) || new Map<Types.Events.ThreadID, Types.Events.PaintImage[]>();\n    const forThread = forProcess.get(event.tid) || [];\n    forThread.push(event);\n    forProcess.set(event.tid, forThread);\n    paintImageEvents.set(event.pid, forProcess);\n\n    if (event.args.data.url) {\n      const paintsForUrl = Platform.MapUtilities.getWithDefault(urlToPaintImage, event.args.data.url, () => []);\n      paintsForUrl.push(event);\n    }\n\n    return;\n  }\n\n  if (Types.Events.isDecodeLazyPixelRef(event) && typeof event.args?.LazyPixelRef !== 'undefined') {\n    // Store these because we use them to tie DecodeImage to a PaintEvent.\n    const forProcess =\n        decodeLazyPixelRefEvents.get(event.pid) || new Map<Types.Events.ThreadID, Types.Events.DecodeLazyPixelRef[]>();\n    const forThread = forProcess.get(event.tid) || [];\n    forThread.push(event);\n    forProcess.set(event.tid, forThread);\n    decodeLazyPixelRefEvents.set(event.pid, forProcess);\n  }\n\n  // If we see a DrawLazyPixelRef event, we need to find the last PaintImage\n  // event on the thread and associate it to the LazyPixelRef that is supplied\n  // in the DrawLazyPixelRef event.\n  // This means that later on if we see a DecodeLazyPixelRef event with the\n  // same LazyPixelRef key, we can find its associated PaintImage event by\n  // looking it up.\n  if (Types.Events.isDrawLazyPixelRef(event) && typeof event.args?.LazyPixelRef !== 'undefined') {\n    const lastPaintEvent = paintImageEvents.get(event.pid)?.get(event.tid)?.at(-1);\n    if (!lastPaintEvent) {\n      return;\n    }\n    paintImageByLazyPixelRef.set(event.args.LazyPixelRef, lastPaintEvent);\n    return;\n  }\n\n  if (Types.Events.isDecodeImage(event)) {\n    // When we see a DecodeImage, we want to associate it to a PaintImage\n    // event. We try two approaches:\n    //\n    // 1. If the thread of the DecodeImage event has a previous PaintImage\n    // event, that is the associated event.\n    //\n    // 2. If that is false, we then look on the thread for a DecodeLazyPixelRef\n    // event. If we find that, we then look for its associated PaintImage\n    // event, which we associate via DrawLazyPixelRef events (the code block\n    // above this one)\n    //\n    // 1. Find a PaintImage event on the same thread. If we find it, that's our association done.\n    const lastPaintImageEventOnThread = paintImageEvents.get(event.pid)?.get(event.tid)?.at(-1);\n    if (lastPaintImageEventOnThread) {\n      eventToPaintImage.set(event, lastPaintImageEventOnThread);\n      return;\n    }\n\n    // 2. Find the last DecodeLazyPixelRef event and, if we find it, find its associated PaintImage event.\n    const lastDecodeLazyPixelRef = decodeLazyPixelRefEvents.get(event.pid)?.get(event.tid)?.at(-1);\n    if (!lastDecodeLazyPixelRef || typeof lastDecodeLazyPixelRef.args?.LazyPixelRef === 'undefined') {\n      return;\n    }\n\n    const paintEvent = paintImageByLazyPixelRef.get(lastDecodeLazyPixelRef.args.LazyPixelRef);\n    if (!paintEvent) {\n      return;\n    }\n    eventToPaintImage.set(event, paintEvent);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport interface ImagePaintData {\n  paintImageByDrawLazyPixelRef: Map<number, Types.Events.PaintImage>;\n  paintImageForEvent: Map<Types.Events.Event, Types.Events.PaintImage>;\n  paintImageEventForUrl: Map<string, Types.Events.PaintImage[]>;\n}\n\nexport function data(): ImagePaintData {\n  return {\n    paintImageByDrawLazyPixelRef: paintImageByLazyPixelRef,\n    paintImageForEvent: eventToPaintImage,\n    paintImageEventForUrl: urlToPaintImage,\n  };\n}\n"],
  "mappings": ";AAIA,YAAY,cAAc;AAC1B,YAAY,WAAW;AAmBvB,MAAM,mBAAuG,oBAAI,IAAI;AACrH,MAAM,2BAC2F,oBAAI,IAAI;AAMzG,MAAM,2BAAiE,oBAAI,IAAI;AAM/E,MAAM,oBAAsE,oBAAI,IAAI;AAEpF,MAAM,kBAA0D,oBAAI,IAAI;AAEjE,gBAAS,QAAc;AAC5B,mBAAiB,MAAM;AACvB,2BAAyB,MAAM;AAC/B,2BAAyB,MAAM;AAC/B,oBAAkB,MAAM;AACxB,kBAAgB,MAAM;AACxB;AAEO,gBAAS,YAAY,OAAiC;AAC3D,MAAI,MAAM,OAAO,aAAa,KAAK,GAAG;AACpC,UAAM,aAAa,iBAAiB,IAAI,MAAM,GAAG,KAAK,oBAAI,IAAsD;AAChH,UAAM,YAAY,WAAW,IAAI,MAAM,GAAG,KAAK,CAAC;AAChD,cAAU,KAAK,KAAK;AACpB,eAAW,IAAI,MAAM,KAAK,SAAS;AACnC,qBAAiB,IAAI,MAAM,KAAK,UAAU;AAE1C,QAAI,MAAM,KAAK,KAAK,KAAK;AACvB,YAAM,eAAe,SAAS,aAAa,eAAe,iBAAiB,MAAM,KAAK,KAAK,KAAK,MAAM,CAAC,CAAC;AACxG,mBAAa,KAAK,KAAK;AAAA,IACzB;AAEA;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,qBAAqB,KAAK,KAAK,OAAO,MAAM,MAAM,iBAAiB,aAAa;AAE/F,UAAM,aACF,yBAAyB,IAAI,MAAM,GAAG,KAAK,oBAAI,IAA8D;AACjH,UAAM,YAAY,WAAW,IAAI,MAAM,GAAG,KAAK,CAAC;AAChD,cAAU,KAAK,KAAK;AACpB,eAAW,IAAI,MAAM,KAAK,SAAS;AACnC,6BAAyB,IAAI,MAAM,KAAK,UAAU;AAAA,EACpD;AAQA,MAAI,MAAM,OAAO,mBAAmB,KAAK,KAAK,OAAO,MAAM,MAAM,iBAAiB,aAAa;AAC7F,UAAM,iBAAiB,iBAAiB,IAAI,MAAM,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,GAAG,EAAE;AAC7E,QAAI,CAAC,gBAAgB;AACnB;AAAA,IACF;AACA,6BAAyB,IAAI,MAAM,KAAK,cAAc,cAAc;AACpE;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,cAAc,KAAK,GAAG;AAarC,UAAM,8BAA8B,iBAAiB,IAAI,MAAM,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,GAAG,EAAE;AAC1F,QAAI,6BAA6B;AAC/B,wBAAkB,IAAI,OAAO,2BAA2B;AACxD;AAAA,IACF;AAGA,UAAM,yBAAyB,yBAAyB,IAAI,MAAM,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,GAAG,EAAE;AAC7F,QAAI,CAAC,0BAA0B,OAAO,uBAAuB,MAAM,iBAAiB,aAAa;AAC/F;AAAA,IACF;AAEA,UAAM,aAAa,yBAAyB,IAAI,uBAAuB,KAAK,YAAY;AACxF,QAAI,CAAC,YAAY;AACf;AAAA,IACF;AACA,sBAAkB,IAAI,OAAO,UAAU;AAAA,EACzC;AACF;AAEA,sBAAsB,WAA0B;AAChD;AAQO,gBAAS,OAAuB;AACrC,SAAO;AAAA,IACL,8BAA8B;AAAA,IAC9B,oBAAoB;AAAA,IACpB,uBAAuB;AAAA,EACzB;AACF;",
  "names": []
}
