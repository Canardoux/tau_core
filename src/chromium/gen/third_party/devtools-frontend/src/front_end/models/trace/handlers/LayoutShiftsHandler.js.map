{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/LayoutShiftsHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\nimport {data as screenshotsHandlerData} from './ScreenshotsHandler.js';\nimport type {HandlerName} from './types.js';\n\n// We start with a score of zero and step through all Layout Shift records from\n// all renderers. Each record not only tells us which renderer it is, but also\n// the unweighted and weighted scores. The unweighted score is the score we would\n// get if the renderer were the only one in the viewport. The weighted score, on\n// the other hand, accounts for how much of the viewport that particular render\n// takes up when the shift happened. An ad frame in the corner of the viewport\n// that shifts is considered less disruptive, therefore, than if it were taking\n// up the whole viewport.\n//\n// Next, we step through all the records from all renderers and add the weighted\n// score to a running total across all of the renderers. We create a new \"cluster\"\n// and reset the running total when:\n//\n// 1. We observe a outermost frame navigation, or\n// 2. When there's a gap between records of > 1s, or\n// 3. When there's more than 5 seconds of continuous layout shifting.\n//\n// Note that for it to be Cumulative Layout Shift in the sense described in the\n// documentation we would need to guarantee that we are tracking from navigation\n// to unload. However, we don't make any such guarantees here (since a developer\n// can record and stop when they please), so we support the cluster approach,\n// and we can give them a score, but it is effectively a \"session\" score, a\n// score for the given recording, and almost certainly not the\n// navigation-to-unload CLS score.\n\ninterface LayoutShifts {\n  clusters: readonly Types.Events.SyntheticLayoutShiftCluster[];\n  clustersByNavigationId: Map<Types.Events.NavigationId, Types.Events.SyntheticLayoutShiftCluster[]>;\n  sessionMaxScore: number;\n  // The session window which contains the SessionMaxScore\n  clsWindowID: number;\n  // We use these to calculate root causes for a given LayoutShift\n  // TODO(crbug/41484172): should be readonly\n  prePaintEvents: Types.Events.PrePaint[];\n  paintImageEvents: Types.Events.PaintImage[];\n  layoutInvalidationEvents: readonly Types.Events.LayoutInvalidationTracking[];\n  scheduleStyleInvalidationEvents: readonly Types.Events.ScheduleStyleInvalidationTracking[];\n  styleRecalcInvalidationEvents: readonly Types.Events.StyleRecalcInvalidationTracking[];\n  renderFrameImplCreateChildFrameEvents: readonly Types.Events.RenderFrameImplCreateChildFrame[];\n  domLoadingEvents: readonly Types.Events.DomLoading[];\n  layoutImageUnsizedEvents: readonly Types.Events.LayoutImageUnsized[];\n  beginRemoteFontLoadEvents: readonly Types.Events.BeginRemoteFontLoad[];\n  scoreRecords: readonly ScoreRecord[];\n  // TODO(crbug/41484172): should be readonly\n  backendNodeIds: Protocol.DOM.BackendNodeId[];\n}\n\n// This represents the maximum #time we will allow a cluster to go before we\n// reset it.\nexport const MAX_CLUSTER_DURATION = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(5000));\n\n// This represents the maximum #time we will allow between layout shift events\n// before considering it to be the start of a new cluster.\nexport const MAX_SHIFT_TIME_DELTA = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(1000));\n\n// Layout shifts are reported globally to the developer, irrespective of which\n// frame they originated in. However, each process does have its own individual\n// CLS score, so we need to segment by process. This means Layout Shifts from\n// sites with one process (no subframes, or subframes from the same origin)\n// will be reported together. In the case of multiple renderers (frames across\n// different origins), we offer the developer the ability to switch renderer in\n// the UI.\nconst layoutShiftEvents: Types.Events.LayoutShift[] = [];\n\n// These events denote potential node resizings. We store them to link captured\n// layout shifts to the resizing of unsized elements.\nconst layoutInvalidationEvents: Types.Events.LayoutInvalidationTracking[] = [];\nconst scheduleStyleInvalidationEvents: Types.Events.ScheduleStyleInvalidationTracking[] = [];\nconst styleRecalcInvalidationEvents: Types.Events.StyleRecalcInvalidationTracking[] = [];\nconst renderFrameImplCreateChildFrameEvents: Types.Events.RenderFrameImplCreateChildFrame[] = [];\nconst domLoadingEvents: Types.Events.DomLoading[] = [];\nconst layoutImageUnsizedEvents: Types.Events.LayoutImageUnsized[] = [];\nconst beginRemoteFontLoadEvents: Types.Events.BeginRemoteFontLoad[] = [];\n\nconst backendNodeIds = new Set<Protocol.DOM.BackendNodeId>();\n\n// Layout shifts happen during PrePaint as part of the rendering lifecycle.\n// We determine if a LayoutInvalidation event is a potential root cause of a layout\n// shift if the next PrePaint after the LayoutInvalidation is the parent\n// node of such shift.\nconst prePaintEvents: Types.Events.PrePaint[] = [];\n\nconst paintImageEvents: Types.Events.PaintImage[] = [];\n\nlet sessionMaxScore = 0;\n\nlet clsWindowID = -1;\n\nconst clusters: Types.Events.SyntheticLayoutShiftCluster[] = [];\nconst clustersByNavigationId = new Map<Types.Events.NavigationId, Types.Events.SyntheticLayoutShiftCluster[]>();\n\n// Represents a point in time in which a  LS score change\n// was recorded.\ntype ScoreRecord = {\n  ts: number,\n  score: number,\n};\n\n// The complete timeline of LS score changes in a trace.\n// Includes drops to 0 when session windows end.\nconst scoreRecords: ScoreRecord[] = [];\n\nexport function reset(): void {\n  layoutShiftEvents.length = 0;\n  layoutInvalidationEvents.length = 0;\n  scheduleStyleInvalidationEvents.length = 0;\n  styleRecalcInvalidationEvents.length = 0;\n  prePaintEvents.length = 0;\n  paintImageEvents.length = 0;\n  renderFrameImplCreateChildFrameEvents.length = 0;\n  layoutImageUnsizedEvents.length = 0;\n  domLoadingEvents.length = 0;\n  beginRemoteFontLoadEvents.length = 0;\n  backendNodeIds.clear();\n  clusters.length = 0;\n  sessionMaxScore = 0;\n  scoreRecords.length = 0;\n  clsWindowID = -1;\n  clustersByNavigationId.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isLayoutShift(event) && !event.args.data?.had_recent_input) {\n    layoutShiftEvents.push(event);\n    return;\n  }\n  if (Types.Events.isLayoutInvalidationTracking(event)) {\n    layoutInvalidationEvents.push(event);\n    return;\n  }\n  if (Types.Events.isScheduleStyleInvalidationTracking(event)) {\n    scheduleStyleInvalidationEvents.push(event);\n  }\n  if (Types.Events.isStyleRecalcInvalidationTracking(event)) {\n    styleRecalcInvalidationEvents.push(event);\n  }\n  if (Types.Events.isPrePaint(event)) {\n    prePaintEvents.push(event);\n    return;\n  }\n  if (Types.Events.isRenderFrameImplCreateChildFrame(event)) {\n    renderFrameImplCreateChildFrameEvents.push(event);\n  }\n  if (Types.Events.isDomLoading(event)) {\n    domLoadingEvents.push(event);\n  }\n  if (Types.Events.isLayoutImageUnsized(event)) {\n    layoutImageUnsizedEvents.push(event);\n  }\n  if (Types.Events.isBeginRemoteFontLoad(event)) {\n    beginRemoteFontLoadEvents.push(event);\n  }\n  if (Types.Events.isPaintImage(event)) {\n    paintImageEvents.push(event);\n  }\n}\n\nfunction traceWindowFromTime(time: Types.Timing.MicroSeconds): Types.Timing.TraceWindowMicroSeconds {\n  return {\n    min: time,\n    max: time,\n    range: Types.Timing.MicroSeconds(0),\n  };\n}\n\nfunction updateTraceWindowMax(\n    traceWindow: Types.Timing.TraceWindowMicroSeconds, newMax: Types.Timing.MicroSeconds): void {\n  traceWindow.max = newMax;\n  traceWindow.range = Types.Timing.MicroSeconds(traceWindow.max - traceWindow.min);\n}\n\nfunction findScreenshots(timestamp: Types.Timing.MicroSeconds): Types.Events.LayoutShiftParsedData['screenshots'] {\n  const screenshots = screenshotsHandlerData().all;\n  const before = Helpers.Trace.findPreviousEventBeforeTimestamp(screenshots, timestamp);\n  const after = before ? screenshots[screenshots.indexOf(before) + 1] : null;\n  return {before, after};\n}\n\nfunction buildScoreRecords(): void {\n  const {traceBounds} = metaHandlerData();\n  scoreRecords.push({ts: traceBounds.min, score: 0});\n\n  for (const cluster of clusters) {\n    let clusterScore = 0;\n    if (cluster.events[0].args.data) {\n      scoreRecords.push({ts: cluster.clusterWindow.min, score: cluster.events[0].args.data.weighted_score_delta});\n    }\n    for (let i = 0; i < cluster.events.length; i++) {\n      const event = cluster.events[i];\n      if (!event.args.data) {\n        continue;\n      }\n      clusterScore += event.args.data.weighted_score_delta;\n      scoreRecords.push({ts: event.ts, score: clusterScore});\n    }\n    scoreRecords.push({ts: cluster.clusterWindow.max, score: 0});\n  }\n}\n\n/**\n * Collects backend node ids coming from LayoutShift and LayoutInvalidation\n * events.\n */\nfunction collectNodes(): void {\n  backendNodeIds.clear();\n\n  // Collect the node ids present in the shifts.\n  for (const layoutShift of layoutShiftEvents) {\n    if (!layoutShift.args.data?.impacted_nodes) {\n      continue;\n    }\n    for (const node of layoutShift.args.data.impacted_nodes) {\n      backendNodeIds.add(node.node_id);\n    }\n  }\n\n  // Collect the node ids present in LayoutInvalidation & scheduleStyleInvalidation events.\n  for (const layoutInvalidation of layoutInvalidationEvents) {\n    if (!layoutInvalidation.args.data?.nodeId) {\n      continue;\n    }\n    backendNodeIds.add(layoutInvalidation.args.data.nodeId);\n  }\n  for (const scheduleStyleInvalidation of scheduleStyleInvalidationEvents) {\n    if (!scheduleStyleInvalidation.args.data?.nodeId) {\n      continue;\n    }\n    backendNodeIds.add(scheduleStyleInvalidation.args.data.nodeId);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // Ensure the events are sorted by #time ascending.\n  layoutShiftEvents.sort((a, b) => a.ts - b.ts);\n  prePaintEvents.sort((a, b) => a.ts - b.ts);\n  layoutInvalidationEvents.sort((a, b) => a.ts - b.ts);\n  renderFrameImplCreateChildFrameEvents.sort((a, b) => a.ts - b.ts);\n  domLoadingEvents.sort((a, b) => a.ts - b.ts);\n  layoutImageUnsizedEvents.sort((a, b) => a.ts - b.ts);\n  beginRemoteFontLoadEvents.sort((a, b) => a.ts - b.ts);\n  paintImageEvents.sort((a, b) => a.ts - b.ts);\n\n  // Each function transforms the data used by the next, as such the invoke order\n  // is important.\n  await buildLayoutShiftsClusters();\n  buildScoreRecords();\n  collectNodes();\n}\n\nasync function buildLayoutShiftsClusters(): Promise<void> {\n  const {navigationsByFrameId, mainFrameId, traceBounds} = metaHandlerData();\n  const navigations = navigationsByFrameId.get(mainFrameId) || [];\n  if (layoutShiftEvents.length === 0) {\n    return;\n  }\n  let firstShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftNavigation = null;\n  // Now step through each and create clusters.\n  // A cluster is equivalent to a session window (see https://web.dev/cls/#what-is-cls).\n  // To make the line chart clear, we explicitly demark the limits of each session window\n  // by starting the cumulative score of the window at the time of the first layout shift\n  // and ending it (dropping the line back to 0) when the window ends according to the\n  // thresholds (MAX_CLUSTER_DURATION, MAX_SHIFT_TIME_DELTA).\n  for (const event of layoutShiftEvents) {\n    // First detect if either the cluster duration or the #time between this and\n    // the last shift has been exceeded.\n    const clusterDurationExceeded = event.ts - firstShiftTime > MAX_CLUSTER_DURATION;\n    const maxTimeDeltaSinceLastShiftExceeded = event.ts - lastShiftTime > MAX_SHIFT_TIME_DELTA;\n\n    // Next take a look at navigations. If between this and the last shift we have navigated,\n    // note it.\n    const currentShiftNavigation = Platform.ArrayUtilities.nearestIndexFromEnd(navigations, nav => nav.ts < event.ts);\n    const hasNavigated = lastShiftNavigation !== currentShiftNavigation && currentShiftNavigation !== null;\n\n    // If any of the above criteria are met or if we don't have any cluster yet we should\n    // start a new one.\n    if (clusterDurationExceeded || maxTimeDeltaSinceLastShiftExceeded || hasNavigated || !clusters.length) {\n      // The cluster starts #time should be the timestamp of the first layout shift in it.\n      const clusterStartTime = event.ts;\n\n      // If the last session window ended because the max delta time between shifts\n      // was exceeded set the endtime to MAX_SHIFT_TIME_DELTA microseconds after the\n      // last shift in the session.\n      const endTimeByMaxSessionDuration = clusterDurationExceeded ? firstShiftTime + MAX_CLUSTER_DURATION : Infinity;\n\n      // If the last session window ended because the max session duration was\n      // surpassed, set the endtime so that the window length = MAX_CLUSTER_DURATION;\n      const endTimeByMaxShiftGap = maxTimeDeltaSinceLastShiftExceeded ? lastShiftTime + MAX_SHIFT_TIME_DELTA : Infinity;\n\n      // If there was a navigation during the last window, close it at the time\n      // of the navigation.\n      const endTimeByNavigation = hasNavigated ? navigations[currentShiftNavigation].ts : Infinity;\n\n      // End the previous cluster at the time of the first of the criteria above that was met.\n      const previousClusterEndTime = Math.min(endTimeByMaxSessionDuration, endTimeByMaxShiftGap, endTimeByNavigation);\n\n      // If there is an existing cluster update its closing time.\n      if (clusters.length > 0) {\n        const currentCluster = clusters[clusters.length - 1];\n        updateTraceWindowMax(currentCluster.clusterWindow, Types.Timing.MicroSeconds(previousClusterEndTime));\n      }\n\n      // If this cluster happened after a navigation, set the navigationId to\n      // the current navigation. This lets us easily group clusters by\n      // navigation.\n      const navigationId = currentShiftNavigation === null ?\n          Types.Events.NO_NAVIGATION :\n          navigations[currentShiftNavigation].args.data?.navigationId;\n      // TODO: `navigationId` is `string | undefined`, but the undefined portion\n      // comes from `data.navigationId`. I don't think that is possible for this\n      // event type. Can we make this typing stronger? In the meantime, we allow\n      // `navigationId` to include undefined values.\n\n      clusters.push({\n        name: 'SyntheticLayoutShiftCluster',\n        events: [],\n        clusterWindow: traceWindowFromTime(clusterStartTime),\n        clusterCumulativeScore: 0,\n        scoreWindows: {\n          good: traceWindowFromTime(clusterStartTime),\n        },\n        navigationId,\n        // Set default Event so that this event is treated accordingly for the track appender.\n        ts: event.ts,\n        pid: event.pid,\n        tid: event.tid,\n        ph: Types.Events.Phase.COMPLETE,\n        cat: '',\n        dur: Types.Timing.MicroSeconds(-1),  // This `cluster.dur` is updated below.\n      });\n\n      firstShiftTime = clusterStartTime;\n    }\n\n    // Given the above we should have a cluster available, so pick the most\n    // recent one and append the shift, bump its score and window values accordingly.\n    const currentCluster = clusters[clusters.length - 1];\n    const timeFromNavigation = currentShiftNavigation !== null ?\n        Types.Timing.MicroSeconds(event.ts - navigations[currentShiftNavigation].ts) :\n        undefined;\n\n    currentCluster.clusterCumulativeScore += event.args.data ? event.args.data.weighted_score_delta : 0;\n    if (!event.args.data) {\n      continue;\n    }\n    const shift =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticLayoutShift>({\n          rawSourceEvent: event,\n          ...event,\n          args: {\n            frame: event.args.frame,\n            data: {\n              ...event.args.data,\n              rawEvent: event,\n              navigationId: currentCluster.navigationId ?? undefined,\n            },\n          },\n          parsedData: {\n            timeFromNavigation,\n            screenshots: findScreenshots(event.ts),\n            cumulativeWeightedScoreInWindow: currentCluster.clusterCumulativeScore,\n            // The score of the session window is temporarily set to 0 just\n            // to initialize it. Since we need to get the score of all shifts\n            // in the session window to determine its value, its definite\n            // value is set when stepping through the built clusters.\n            sessionWindowData: {cumulativeWindowScore: 0, id: clusters.length},\n          },\n        });\n    currentCluster.events.push(shift);\n    updateTraceWindowMax(currentCluster.clusterWindow, event.ts);\n\n    lastShiftTime = event.ts;\n    lastShiftNavigation = currentShiftNavigation;\n  }\n\n  // Now step through each cluster and set up the times at which the value\n  // goes from Good, to needs improvement, to Bad. Note that if there is a\n  // large jump we may go from Good to Bad without ever creating a Needs\n  // Improvement window at all.\n  for (const cluster of clusters) {\n    let weightedScore = 0;\n    let windowID = -1;\n    // If this is the last cluster update its window. The cluster duration is determined\n    // by the minimum between: time to next navigation, trace end time, time to maximum\n    // cluster duration and time to maximum gap between layout shifts.\n    if (cluster === clusters[clusters.length - 1]) {\n      const clusterEndByMaxDuration = MAX_CLUSTER_DURATION + cluster.clusterWindow.min;\n      const clusterEndByMaxGap = cluster.clusterWindow.max + MAX_SHIFT_TIME_DELTA;\n      const nextNavigationIndex =\n          Platform.ArrayUtilities.nearestIndexFromBeginning(navigations, nav => nav.ts > cluster.clusterWindow.max);\n      const nextNavigationTime = nextNavigationIndex ? navigations[nextNavigationIndex].ts : Infinity;\n      const clusterEnd = Math.min(clusterEndByMaxDuration, clusterEndByMaxGap, traceBounds.max, nextNavigationTime);\n      updateTraceWindowMax(cluster.clusterWindow, Types.Timing.MicroSeconds(clusterEnd));\n    }\n\n    let largestScore: number = 0;\n    let worstShiftEvent: Types.Events.Event|null = null;\n\n    for (const shift of cluster.events) {\n      weightedScore += shift.args.data ? shift.args.data.weighted_score_delta : 0;\n      windowID = shift.parsedData.sessionWindowData.id;\n      const ts = shift.ts;\n      // Update the the CLS score of this shift's session window now that\n      // we have it.\n      shift.parsedData.sessionWindowData.cumulativeWindowScore = cluster.clusterCumulativeScore;\n      if (weightedScore < LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n        // Expand the Good window.\n        updateTraceWindowMax(cluster.scoreWindows.good, ts);\n      } else if (\n          weightedScore >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT && weightedScore < LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.needsImprovement) {\n          // Close the Good window, and open the needs improvement window.\n          updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.MicroSeconds(ts - 1));\n          cluster.scoreWindows.needsImprovement = traceWindowFromTime(ts);\n        }\n\n        // Expand the needs improvement window.\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, ts);\n      } else if (weightedScore >= LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.bad) {\n          // We may jump from Good to Bad here, so update whichever window is open.\n          if (cluster.scoreWindows.needsImprovement) {\n            updateTraceWindowMax(cluster.scoreWindows.needsImprovement, Types.Timing.MicroSeconds(ts - 1));\n          } else {\n            updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.MicroSeconds(ts - 1));\n          }\n\n          cluster.scoreWindows.bad = traceWindowFromTime(shift.ts);\n        }\n\n        // Expand the Bad window.\n        updateTraceWindowMax(cluster.scoreWindows.bad, ts);\n      }\n\n      // At this point the windows are set by the timestamps of the events, but the\n      // next cluster begins at the timestamp of its first event. As such we now\n      // need to expand the score window to the end of the cluster, and we do so\n      // by using the Bad widow if it's there, or the NI window, or finally the\n      // Good window.\n      if (cluster.scoreWindows.bad) {\n        updateTraceWindowMax(cluster.scoreWindows.bad, cluster.clusterWindow.max);\n      } else if (cluster.scoreWindows.needsImprovement) {\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, cluster.clusterWindow.max);\n      } else {\n        updateTraceWindowMax(cluster.scoreWindows.good, cluster.clusterWindow.max);\n      }\n\n      // Find the worst layout shift of the cluster.\n      const score = shift.args.data?.weighted_score_delta;\n      if (score !== undefined && score > largestScore) {\n        largestScore = score;\n        worstShiftEvent = shift;\n      }\n    }\n    // Update the cluster's worst layout shift.\n    if (worstShiftEvent) {\n      cluster.worstShiftEvent = worstShiftEvent;\n    }\n\n    // layout shifts are already sorted by time ascending.\n    // Capture the time range of the cluster.\n    cluster.ts = cluster.events[0].ts;\n    const lastShiftTimings = Helpers.Timing.eventTimingsMicroSeconds(cluster.events[cluster.events.length - 1]);\n    // Add MAX_SHIFT_TIME_DELTA, the section gap after the last layout shift. This marks the end of the cluster.\n    cluster.dur = Types.Timing.MicroSeconds((lastShiftTimings.endTime - cluster.events[0].ts) + MAX_SHIFT_TIME_DELTA);\n\n    if (weightedScore > sessionMaxScore) {\n      clsWindowID = windowID;\n      sessionMaxScore = weightedScore;\n    }\n\n    if (cluster.navigationId) {\n      const clustersForId = Platform.MapUtilities.getWithDefault(clustersByNavigationId, cluster.navigationId, () => {\n        return [];\n      });\n      clustersForId.push(cluster);\n    }\n  }\n}\n\nexport function data(): LayoutShifts {\n  return {\n    clusters,\n    sessionMaxScore,\n    clsWindowID,\n    prePaintEvents,\n    layoutInvalidationEvents,\n    scheduleStyleInvalidationEvents,\n    styleRecalcInvalidationEvents: [],\n    renderFrameImplCreateChildFrameEvents,\n    domLoadingEvents,\n    layoutImageUnsizedEvents,\n    beginRemoteFontLoadEvents,\n    scoreRecords,\n    // TODO(crbug/41484172): change the type so no need to clone\n    backendNodeIds: [...backendNodeIds],\n    clustersByNavigationId: new Map(clustersByNavigationId),\n    paintImageEvents,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Screenshots', 'Meta'];\n}\n\nexport function scoreClassificationForLayoutShift(score: number): ScoreClassification {\n  let state = ScoreClassification.GOOD;\n  if (score >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n    state = ScoreClassification.OK;\n  }\n\n  if (score >= LayoutShiftsThreshold.BAD) {\n    state = ScoreClassification.BAD;\n  }\n\n  return state;\n}\n\n// Based on https://web.dev/cls/\nexport const enum LayoutShiftsThreshold {\n  GOOD = 0,\n  NEEDS_IMPROVEMENT = 0.1,\n  BAD = 0.25,\n}\n"],
  "mappings": "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",
  "names": ["currentCluster", "LayoutShiftsThreshold"]
}
