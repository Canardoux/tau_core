{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/text_utils/StreamingContentData.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData, type ContentDataOrError} from './ContentData.js';\n\n/**\n * Usage of this class is mostly intended for content that is never \"complete\".\n * E.g. streaming XHR/fetch requests.\n *\n * Due to the streaming nature this class only supports base64-encoded binary data.\n * Decoding to text only happens on-demand by clients. This ensures that at most we have\n * incomplete unicode at the end and not in-between chunks.\n */\nexport class StreamingContentData extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  readonly mimeType: string;\n  readonly #charset?: string;\n\n  readonly #disallowStreaming: boolean;\n\n  #chunks: string[] = [];\n  #contentData?: ContentData;\n\n  private constructor(mimeType: string, charset?: string, initialContent?: ContentData) {\n    super();\n    this.mimeType = mimeType;\n    this.#charset = charset;\n    this.#disallowStreaming = Boolean(initialContent && !initialContent.createdFromBase64);\n    this.#contentData = initialContent;\n  }\n\n  /**\n   * Creates a new StreamingContentData with the given MIME type/charset.\n   */\n  static create(mimeType: string, charset?: string): StreamingContentData {\n    return new StreamingContentData(mimeType, charset);\n  }\n\n  /**\n   * Creates a new StringContentData from an existing ContentData instance.\n   *\n   * Calling `addChunk` is on the resulting `StreamingContentData` is illegal if\n   * `content` was not created from base64 data. The reason is that JavaScript TextEncoder\n   * only supports UTF-8. We can't convert text with arbitrary encoding back to base64 for concatenation.\n   */\n  static from(content: ContentData): StreamingContentData {\n    return new StreamingContentData(content.mimeType, content.charset, content);\n  }\n\n  /** @returns true, if this `ContentData` was constructed from text content or the mime type indicates text that can be decoded */\n  get isTextContent(): boolean {\n    if (this.#contentData) {\n      return this.#contentData.isTextContent;\n    }\n    return Platform.MimeType.isTextType(this.mimeType);\n  }\n\n  /** @param chunk base64 encoded data */\n  addChunk(chunk: string): void {\n    if (this.#disallowStreaming) {\n      throw new Error('Cannot add base64 data to a text-only ContentData.');\n    }\n\n    this.#chunks.push(chunk);\n    this.dispatchEventToListeners(Events.CHUNK_ADDED, {content: this, chunk});\n  }\n\n  /** @returns An immutable ContentData with all the bytes received so far */\n  content(): ContentData {\n    if (this.#contentData && this.#chunks.length === 0) {\n      return this.#contentData;\n    }\n\n    const initialBase64 = this.#contentData?.base64 ?? '';\n    const base64Content =\n        this.#chunks.reduce((acc, chunk) => Platform.StringUtilities.concatBase64(acc, chunk), initialBase64);\n    this.#contentData = new ContentData(base64Content, /* isBase64=*/ true, this.mimeType, this.#charset);\n    this.#chunks = [];\n    return this.#contentData;\n  }\n}\n\nexport type StreamingContentDataOrError = StreamingContentData|{error: string};\n\nexport const isError = function(contentDataOrError: StreamingContentDataOrError): contentDataOrError is {\nerror:\n  string,\n} {\n  return 'error' in contentDataOrError;\n};\n\nexport const asContentDataOrError = function(contentDataOrError: StreamingContentDataOrError): ContentDataOrError {\n  if (isError(contentDataOrError)) {\n    return contentDataOrError;\n  }\n  return contentDataOrError.content();\n};\n\nexport const enum Events {\n  CHUNK_ADDED = 'ChunkAdded',\n}\n\nexport type EventTypes = {\n  [Events.CHUNK_ADDED]: {content: StreamingContentData, chunk: string},\n};\n"],
  "mappings": ";AAIA,YAAY,YAAY;AACxB,YAAY,cAAc;AAE1B,SAAQ,mBAA2C;AAU5C,aAAM,6BAA6B,OAAO,cAAc,cAA0B;AAAA,EAC9E;AAAA,EACA;AAAA,EAEA;AAAA,EAET,UAAoB,CAAC;AAAA,EACrB;AAAA,EAEQ,YAAY,UAAkB,SAAkB,gBAA8B;AACpF,UAAM;AACN,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,SAAK,qBAAqB,QAAQ,kBAAkB,CAAC,eAAe,iBAAiB;AACrF,SAAK,eAAe;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,OAAO,UAAkB,SAAwC;AACtE,WAAO,IAAI,qBAAqB,UAAU,OAAO;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,KAAK,SAA4C;AACtD,WAAO,IAAI,qBAAqB,QAAQ,UAAU,QAAQ,SAAS,OAAO;AAAA,EAC5E;AAAA;AAAA,EAGA,IAAI,gBAAyB;AAC3B,QAAI,KAAK,cAAc;AACrB,aAAO,KAAK,aAAa;AAAA,IAC3B;AACA,WAAO,SAAS,SAAS,WAAW,KAAK,QAAQ;AAAA,EACnD;AAAA;AAAA,EAGA,SAAS,OAAqB;AAC5B,QAAI,KAAK,oBAAoB;AAC3B,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAEA,SAAK,QAAQ,KAAK,KAAK;AACvB,SAAK,yBAAyB,gCAAoB,EAAC,SAAS,MAAM,MAAK,CAAC;AAAA,EAC1E;AAAA;AAAA,EAGA,UAAuB;AACrB,QAAI,KAAK,gBAAgB,KAAK,QAAQ,WAAW,GAAG;AAClD,aAAO,KAAK;AAAA,IACd;AAEA,UAAM,gBAAgB,KAAK,cAAc,UAAU;AACnD,UAAM,gBACF,KAAK,QAAQ,OAAO,CAAC,KAAK,UAAU,SAAS,gBAAgB,aAAa,KAAK,KAAK,GAAG,aAAa;AACxG,SAAK,eAAe,IAAI;AAAA,MAAY;AAAA;AAAA,MAA8B;AAAA,MAAM,KAAK;AAAA,MAAU,KAAK;AAAA,IAAQ;AACpG,SAAK,UAAU,CAAC;AAChB,WAAO,KAAK;AAAA,EACd;AACF;AAIO,aAAM,UAAU,SAAS,oBAG9B;AACA,SAAO,WAAW;AACpB;AAEO,aAAM,uBAAuB,SAAS,oBAAqE;AAChH,MAAI,QAAQ,kBAAkB,GAAG;AAC/B,WAAO;AAAA,EACT;AACA,SAAO,mBAAmB,QAAQ;AACpC;AAEO,WAAW,SAAX,kBAAWA,YAAX;AACL,EAAAA,QAAA,iBAAc;AADE,SAAAA;AAAA,GAAA;",
  "names": ["Events"]
}
