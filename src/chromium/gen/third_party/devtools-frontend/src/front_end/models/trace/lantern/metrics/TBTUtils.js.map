{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/metrics/TBTUtils.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nconst BLOCKING_TIME_THRESHOLD = 50;\n\n/**\n * For TBT, We only want to consider tasks that fall in our time range\n * - FCP and TTI for navigation mode\n * - Trace start and trace end for timespan mode\n *\n * FCP is picked as `startTimeMs` because there is little risk of user input happening\n * before FCP so Long Queuing Qelay regions do not harm user experience. Developers should be\n * optimizing to reach FCP as fast as possible without having to worry about task lengths.\n *\n * TTI is picked as `endTimeMs` because we want a well defined end point for page load.\n *\n * @param startTimeMs Should be FCP in navigation mode and the trace start time in timespan mode\n * @param endTimeMs Should be TTI in navigation mode and the trace end time in timespan mode\n * @param topLevelEvent Leave unset if `event` is top level. Has no effect if `event` has the same duration as `topLevelEvent`.\n */\nfunction calculateTbtImpactForEvent(\n    event: {start: number, end: number, duration: number}, startTimeMs: number, endTimeMs: number,\n    topLevelEvent?: {start: number, end: number, duration: number}): number {\n  let threshold = BLOCKING_TIME_THRESHOLD;\n\n  // If a task is not top level, it doesn't make sense to subtract the entire 50ms\n  // blocking threshold from the event.\n  //\n  // e.g. A 80ms top level task with two 40ms children should attribute some blocking\n  // time to the 40ms tasks even though they do not meet the 50ms threshold.\n  //\n  // The solution is to scale the threshold for child events to be considered blocking.\n  if (topLevelEvent) {\n    threshold *= (event.duration / topLevelEvent.duration);\n  }\n\n  if (event.duration < threshold) {\n    return 0;\n  }\n  if (event.end < startTimeMs) {\n    return 0;\n  }\n  if (event.start > endTimeMs) {\n    return 0;\n  }\n\n  // Perform the clipping and then calculate Blocking Region. So if we have a 150ms task\n  // [0, 150] and `startTimeMs` is at 50ms, we first clip the task to [50, 150], and then\n  // calculate the Blocking Region to be [100, 150]. The rational here is that tasks before\n  // the start time are unimportant, so we care whether the main thread is busy more than\n  // 50ms at a time only after the start time.\n  const clippedStart = Math.max(event.start, startTimeMs);\n  const clippedEnd = Math.min(event.end, endTimeMs);\n  const clippedDuration = clippedEnd - clippedStart;\n  if (clippedDuration < threshold) {\n    return 0;\n  }\n\n  return clippedDuration - threshold;\n}\n\nfunction calculateSumOfBlockingTime(\n    topLevelEvents: Array<{start: number, end: number, duration: number}>, startTimeMs: number,\n    endTimeMs: number): number {\n  if (endTimeMs <= startTimeMs) {\n    return 0;\n  }\n\n  let sumBlockingTime = 0;\n  for (const event of topLevelEvents) {\n    sumBlockingTime += calculateTbtImpactForEvent(event, startTimeMs, endTimeMs);\n  }\n\n  return sumBlockingTime;\n}\n\nexport {\n  BLOCKING_TIME_THRESHOLD,\n  calculateSumOfBlockingTime,\n  calculateTbtImpactForEvent,\n};\n"],
  "mappings": ";AAIA,MAAM,0BAA0B;AAiBhC,SAAS,2BACL,OAAuD,aAAqB,WAC5E,eAAwE;AAC1E,MAAI,YAAY;AAShB,MAAI,eAAe;AACjB,iBAAc,MAAM,WAAW,cAAc;AAAA,EAC/C;AAEA,MAAI,MAAM,WAAW,WAAW;AAC9B,WAAO;AAAA,EACT;AACA,MAAI,MAAM,MAAM,aAAa;AAC3B,WAAO;AAAA,EACT;AACA,MAAI,MAAM,QAAQ,WAAW;AAC3B,WAAO;AAAA,EACT;AAOA,QAAM,eAAe,KAAK,IAAI,MAAM,OAAO,WAAW;AACtD,QAAM,aAAa,KAAK,IAAI,MAAM,KAAK,SAAS;AAChD,QAAM,kBAAkB,aAAa;AACrC,MAAI,kBAAkB,WAAW;AAC/B,WAAO;AAAA,EACT;AAEA,SAAO,kBAAkB;AAC3B;AAEA,SAAS,2BACL,gBAAuE,aACvE,WAA2B;AAC7B,MAAI,aAAa,aAAa;AAC5B,WAAO;AAAA,EACT;AAEA,MAAI,kBAAkB;AACtB,aAAW,SAAS,gBAAgB;AAClC,uBAAmB,2BAA2B,OAAO,aAAa,SAAS;AAAA,EAC7E;AAEA,SAAO;AACT;AAEA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA;",
  "names": []
}
