{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/extras/StackTraceForEvent.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as Handlers from '../handlers/handlers.js';\nimport type * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nexport const stackTraceForEventInTrace =\n    new Map<Handlers.Types.ParsedTrace, Map<Types.Events.Event, Protocol.Runtime.StackTrace>>();\n\nexport function clearCacheForTrace(parsedTrace: Handlers.Types.ParsedTrace): void {\n  stackTraceForEventInTrace.delete(parsedTrace);\n}\nexport function get(\n    event: Types.Events.Event, parsedTrace: Handlers.Types.ParsedTrace,\n    options?: {isIgnoreListedCallback?: (event: Types.Events.Event) => boolean}): Protocol.Runtime.StackTrace|null {\n  let cacheForTrace = stackTraceForEventInTrace.get(parsedTrace);\n  if (!cacheForTrace) {\n    cacheForTrace = new Map();\n    stackTraceForEventInTrace.set(parsedTrace, cacheForTrace);\n  }\n  const resultFromCache = cacheForTrace.get(event);\n  if (resultFromCache) {\n    return resultFromCache;\n  }\n  if (!Types.Events.isProfileCall(event)) {\n    return null;\n  }\n  const result = getForProfileCall(event, parsedTrace, options);\n  cacheForTrace.set(event, result);\n  return result;\n}\n\nfunction getForProfileCall(\n    event: Types.Events.SyntheticProfileCall, parsedTrace: Handlers.Types.ParsedTrace,\n    options?: {isIgnoreListedCallback?: (event: Types.Events.Event) => boolean}): Protocol.Runtime.StackTrace {\n  // When working with a CPU profile the renderer handler won't have\n  // entries in its tree.\n  const entryToNode =\n      parsedTrace.Renderer.entryToNode.size > 0 ? parsedTrace.Renderer.entryToNode : parsedTrace.Samples.entryToNode;\n  const topStackTrace: Protocol.Runtime.StackTrace = {callFrames: []};\n  let stackTrace: Protocol.Runtime.StackTrace = topStackTrace;\n  let currentEntry = event;\n  let node: Helpers.TreeHelpers.TraceEntryNode|null|undefined = entryToNode.get(event);\n  const traceCache =\n      stackTraceForEventInTrace.get(parsedTrace) || new Map<Types.Events.Event, Protocol.Runtime.StackTrace>();\n  stackTraceForEventInTrace.set(parsedTrace, traceCache);\n  // Move up this node's ancestor tree appending frames to its\n  // stack trace.\n  while (node) {\n    if (!Types.Events.isProfileCall(node.entry)) {\n      node = node.parent;\n      continue;\n    }\n\n    currentEntry = node.entry;\n    // First check if this entry was processed before.\n    const stackTraceFromCache = traceCache.get(node.entry);\n    if (stackTraceFromCache) {\n      stackTrace.callFrames.push(...stackTraceFromCache.callFrames.filter(callFrame => !isNativeJSFunction(callFrame)));\n      stackTrace.parent = stackTraceFromCache.parent;\n      // Only set the description to the cache value if we didn't\n      // compute it in the previous iteration, since the async stack\n      // trace descriptions / taskNames is only extracted when jumping\n      // to the async parent, and that might not have happened when\n      // the cached value was computed (e.g. the cached value\n      // computation started at some point inside the parent stack\n      // trace).\n      stackTrace.description = stackTrace.description || stackTraceFromCache.description;\n      break;\n    }\n\n    const ignorelisted = options?.isIgnoreListedCallback && options?.isIgnoreListedCallback(currentEntry);\n    if (!ignorelisted && !isNativeJSFunction(currentEntry.callFrame)) {\n      stackTrace.callFrames.push(currentEntry.callFrame);\n    }\n    const maybeAsyncParentEvent = parsedTrace.AsyncJSCalls.asyncCallToScheduler.get(currentEntry);\n    const maybeAsyncParentNode = maybeAsyncParentEvent && entryToNode.get(maybeAsyncParentEvent.scheduler);\n    if (maybeAsyncParentNode) {\n      // The Protocol.Runtime.StackTrace type is recursive, so we\n      // move one level deeper in it as we walk up the ancestor tree.\n      stackTrace.parent = {callFrames: []};\n      stackTrace = stackTrace.parent;\n      // Note: this description effectively corresponds to the name\n      // of the task that scheduled the stack trace we are jumping\n      // FROM, so it would make sense that it was set to that stack\n      // trace instead of the one we are jumping TO. However, the\n      // JS presentation utils we use to present async stack traces\n      // assume the description is added to the stack trace that\n      // scheduled the async task, so we build the data that way.\n      stackTrace.description = maybeAsyncParentEvent.taskName;\n      node = maybeAsyncParentNode;\n      continue;\n    }\n    node = node.parent;\n  }\n  return topStackTrace;\n}\n/**\n * Determines if a function is a native JS API (like setTimeout,\n * requestAnimationFrame, consoleTask.run. etc.). This is useful to\n * discard stack frames corresponding to the JS scheduler function\n * itself, since it's already being used as title of async stack traces\n * taken from the async `taskName`. This is also consistent with the\n * behaviour of the stack trace in the sources\n * panel.\n */\nfunction isNativeJSFunction({columnNumber, lineNumber, url, scriptId}: Protocol.Runtime.CallFrame): boolean {\n  return lineNumber === -1 && columnNumber === -1 && url === '' && scriptId === '0';\n}\n"],
  "mappings": ";AAOA,YAAY,WAAW;AAEhB,aAAM,4BACT,oBAAI,IAAsF;AAEvF,gBAAS,mBAAmB,aAA+C;AAChF,4BAA0B,OAAO,WAAW;AAC9C;AACO,gBAAS,IACZ,OAA2B,aAC3B,SAA+G;AACjH,MAAI,gBAAgB,0BAA0B,IAAI,WAAW;AAC7D,MAAI,CAAC,eAAe;AAClB,oBAAgB,oBAAI,IAAI;AACxB,8BAA0B,IAAI,aAAa,aAAa;AAAA,EAC1D;AACA,QAAM,kBAAkB,cAAc,IAAI,KAAK;AAC/C,MAAI,iBAAiB;AACnB,WAAO;AAAA,EACT;AACA,MAAI,CAAC,MAAM,OAAO,cAAc,KAAK,GAAG;AACtC,WAAO;AAAA,EACT;AACA,QAAM,SAAS,kBAAkB,OAAO,aAAa,OAAO;AAC5D,gBAAc,IAAI,OAAO,MAAM;AAC/B,SAAO;AACT;AAEA,SAAS,kBACL,OAA0C,aAC1C,SAA0G;AAG5G,QAAM,cACF,YAAY,SAAS,YAAY,OAAO,IAAI,YAAY,SAAS,cAAc,YAAY,QAAQ;AACvG,QAAM,gBAA6C,EAAC,YAAY,CAAC,EAAC;AAClE,MAAI,aAA0C;AAC9C,MAAI,eAAe;AACnB,MAAI,OAA0D,YAAY,IAAI,KAAK;AACnF,QAAM,aACF,0BAA0B,IAAI,WAAW,KAAK,oBAAI,IAAqD;AAC3G,4BAA0B,IAAI,aAAa,UAAU;AAGrD,SAAO,MAAM;AACX,QAAI,CAAC,MAAM,OAAO,cAAc,KAAK,KAAK,GAAG;AAC3C,aAAO,KAAK;AACZ;AAAA,IACF;AAEA,mBAAe,KAAK;AAEpB,UAAM,sBAAsB,WAAW,IAAI,KAAK,KAAK;AACrD,QAAI,qBAAqB;AACvB,iBAAW,WAAW,KAAK,GAAG,oBAAoB,WAAW,OAAO,eAAa,CAAC,mBAAmB,SAAS,CAAC,CAAC;AAChH,iBAAW,SAAS,oBAAoB;AAQxC,iBAAW,cAAc,WAAW,eAAe,oBAAoB;AACvE;AAAA,IACF;AAEA,UAAM,eAAe,SAAS,0BAA0B,SAAS,uBAAuB,YAAY;AACpG,QAAI,CAAC,gBAAgB,CAAC,mBAAmB,aAAa,SAAS,GAAG;AAChE,iBAAW,WAAW,KAAK,aAAa,SAAS;AAAA,IACnD;AACA,UAAM,wBAAwB,YAAY,aAAa,qBAAqB,IAAI,YAAY;AAC5F,UAAM,uBAAuB,yBAAyB,YAAY,IAAI,sBAAsB,SAAS;AACrG,QAAI,sBAAsB;AAGxB,iBAAW,SAAS,EAAC,YAAY,CAAC,EAAC;AACnC,mBAAa,WAAW;AAQxB,iBAAW,cAAc,sBAAsB;AAC/C,aAAO;AACP;AAAA,IACF;AACA,WAAO,KAAK;AAAA,EACd;AACA,SAAO;AACT;AAUA,SAAS,mBAAmB,EAAC,cAAc,YAAY,KAAK,SAAQ,GAAwC;AAC1G,SAAO,eAAe,MAAM,iBAAiB,MAAM,QAAQ,MAAM,aAAa;AAChF;",
  "names": []
}
