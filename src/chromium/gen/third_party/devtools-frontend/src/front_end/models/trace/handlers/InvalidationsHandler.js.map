{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/InvalidationsHandler.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nconst invalidationsForEvent = new Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>();\nconst invalidationCountForEvent = new Map<Types.Events.Event, number>();\n\nlet lastRecalcStyleEvent: Types.Events.UpdateLayoutTree|null = null;\n\n// Used to track paints so we track invalidations correctly per paint.\nlet hasPainted = false;\n\nconst allInvalidationTrackingEvents: Array<Types.Events.InvalidationTrackingEvent> = [];\n\nexport function reset(): void {\n  invalidationsForEvent.clear();\n  lastRecalcStyleEvent = null;\n  allInvalidationTrackingEvents.length = 0;\n  hasPainted = false;\n  maxInvalidationsPerEvent = null;\n}\n\nlet maxInvalidationsPerEvent: number|null = null;\nexport function handleUserConfig(userConfig: Types.Configuration.Configuration): void {\n  maxInvalidationsPerEvent = userConfig.maxInvalidationEventsPerEvent;\n}\n\nfunction addInvalidationToEvent(event: Types.Events.Event, invalidation: Types.Events.InvalidationTrackingEvent): void {\n  const existingInvalidations = invalidationsForEvent.get(event) || [];\n  existingInvalidations.push(invalidation);\n\n  if (maxInvalidationsPerEvent !== null && existingInvalidations.length > maxInvalidationsPerEvent) {\n    existingInvalidations.shift();\n  }\n  invalidationsForEvent.set(event, existingInvalidations);\n\n  const count = invalidationCountForEvent.get(event) ?? 0;\n  invalidationCountForEvent.set(event, count + 1);\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  // Special case: if we have been configured to not store any invalidations,\n  // we take that as a sign that we don't even want to gather any invalidations\n  // data at all and early exit.\n  if (maxInvalidationsPerEvent === 0) {\n    return;\n  }\n\n  if (Types.Events.isUpdateLayoutTree(event)) {\n    lastRecalcStyleEvent = event;\n\n    // Associate any prior invalidations with this recalc event.\n    for (const invalidation of allInvalidationTrackingEvents) {\n      if (Types.Events.isLayoutInvalidationTracking(invalidation)) {\n        // LayoutInvalidation events cannot be associated with a LayoutTree\n        // event.\n        continue;\n      }\n\n      const recalcFrameId = lastRecalcStyleEvent.args.beginData?.frame;\n\n      if (recalcFrameId && invalidation.args.data.frame === recalcFrameId) {\n        addInvalidationToEvent(event, invalidation);\n      }\n    }\n    return;\n  }\n\n  if (Types.Events.isInvalidationTracking(event)) {\n    if (hasPainted) {\n      // If we have painted, then we can clear out the list of all existing\n      // invalidations, as we cannot associate them across frames.\n      allInvalidationTrackingEvents.length = 0;\n      lastRecalcStyleEvent = null;\n      hasPainted = false;\n    }\n\n    // Style invalidation events can occur before and during recalc styles. When we get a recalc style event (aka UpdateLayoutTree), we check and associate any prior invalidations with it.\n    // But any invalidations that occur during a UpdateLayoutTree\n    // event would be reported in trace events after. So each time we get an\n    // invalidation that might be due to a style recalc, we check if the\n    // timings overlap and if so associate them.\n    if (lastRecalcStyleEvent &&\n        (Types.Events.isScheduleStyleInvalidationTracking(event) ||\n         Types.Events.isStyleRecalcInvalidationTracking(event) ||\n         Types.Events.isStyleInvalidatorInvalidationTracking(event))) {\n      const recalcEndTime = lastRecalcStyleEvent.ts + (lastRecalcStyleEvent.dur || 0);\n      if (event.ts >= lastRecalcStyleEvent.ts && event.ts <= recalcEndTime &&\n          lastRecalcStyleEvent.args.beginData?.frame === event.args.data.frame) {\n        addInvalidationToEvent(lastRecalcStyleEvent, event);\n      }\n    }\n\n    allInvalidationTrackingEvents.push(event);\n    return;\n  }\n\n  if (Types.Events.isPaint(event)) {\n    // Used to ensure that we do not create relationships across frames.\n    hasPainted = true;\n    return;\n  }\n\n  if (Types.Events.isLayout(event)) {\n    const layoutFrame = event.args.beginData.frame;\n    for (const invalidation of allInvalidationTrackingEvents) {\n      // The only invalidations that cause a Layout are LayoutInvalidations :)\n      if (!Types.Events.isLayoutInvalidationTracking(invalidation)) {\n        continue;\n      }\n\n      if (invalidation.args.data.frame === layoutFrame) {\n        addInvalidationToEvent(event, invalidation);\n      }\n    }\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\ninterface InvalidationsData {\n  invalidationsForEvent: Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>;\n  invalidationCountForEvent: Map<Types.Events.Event, number>;\n}\n\nexport function data(): InvalidationsData {\n  return {\n    invalidationsForEvent,\n    invalidationCountForEvent,\n  };\n}\n"],
  "mappings": ";AAIA,YAAY,WAAW;AAEvB,MAAM,wBAAwB,oBAAI,IAAkE;AACpG,MAAM,4BAA4B,oBAAI,IAAgC;AAEtE,IAAI,uBAA2D;AAG/D,IAAI,aAAa;AAEjB,MAAM,gCAA+E,CAAC;AAE/E,gBAAS,QAAc;AAC5B,wBAAsB,MAAM;AAC5B,yBAAuB;AACvB,gCAA8B,SAAS;AACvC,eAAa;AACb,6BAA2B;AAC7B;AAEA,IAAI,2BAAwC;AACrC,gBAAS,iBAAiB,YAAqD;AACpF,6BAA2B,WAAW;AACxC;AAEA,SAAS,uBAAuB,OAA2B,cAA4D;AACrH,QAAM,wBAAwB,sBAAsB,IAAI,KAAK,KAAK,CAAC;AACnE,wBAAsB,KAAK,YAAY;AAEvC,MAAI,6BAA6B,QAAQ,sBAAsB,SAAS,0BAA0B;AAChG,0BAAsB,MAAM;AAAA,EAC9B;AACA,wBAAsB,IAAI,OAAO,qBAAqB;AAEtD,QAAM,QAAQ,0BAA0B,IAAI,KAAK,KAAK;AACtD,4BAA0B,IAAI,OAAO,QAAQ,CAAC;AAChD;AAEO,gBAAS,YAAY,OAAiC;AAI3D,MAAI,6BAA6B,GAAG;AAClC;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,mBAAmB,KAAK,GAAG;AAC1C,2BAAuB;AAGvB,eAAW,gBAAgB,+BAA+B;AACxD,UAAI,MAAM,OAAO,6BAA6B,YAAY,GAAG;AAG3D;AAAA,MACF;AAEA,YAAM,gBAAgB,qBAAqB,KAAK,WAAW;AAE3D,UAAI,iBAAiB,aAAa,KAAK,KAAK,UAAU,eAAe;AACnE,+BAAuB,OAAO,YAAY;AAAA,MAC5C;AAAA,IACF;AACA;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,uBAAuB,KAAK,GAAG;AAC9C,QAAI,YAAY;AAGd,oCAA8B,SAAS;AACvC,6BAAuB;AACvB,mBAAa;AAAA,IACf;AAOA,QAAI,yBACC,MAAM,OAAO,oCAAoC,KAAK,KACtD,MAAM,OAAO,kCAAkC,KAAK,KACpD,MAAM,OAAO,uCAAuC,KAAK,IAAI;AAChE,YAAM,gBAAgB,qBAAqB,MAAM,qBAAqB,OAAO;AAC7E,UAAI,MAAM,MAAM,qBAAqB,MAAM,MAAM,MAAM,iBACnD,qBAAqB,KAAK,WAAW,UAAU,MAAM,KAAK,KAAK,OAAO;AACxE,+BAAuB,sBAAsB,KAAK;AAAA,MACpD;AAAA,IACF;AAEA,kCAA8B,KAAK,KAAK;AACxC;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,QAAQ,KAAK,GAAG;AAE/B,iBAAa;AACb;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,SAAS,KAAK,GAAG;AAChC,UAAM,cAAc,MAAM,KAAK,UAAU;AACzC,eAAW,gBAAgB,+BAA+B;AAExD,UAAI,CAAC,MAAM,OAAO,6BAA6B,YAAY,GAAG;AAC5D;AAAA,MACF;AAEA,UAAI,aAAa,KAAK,KAAK,UAAU,aAAa;AAChD,+BAAuB,OAAO,YAAY;AAAA,MAC5C;AAAA,IACF;AAAA,EACF;AACF;AAEA,sBAAsB,WAA0B;AAChD;AAOO,gBAAS,OAA0B;AACxC,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;",
  "names": []
}
