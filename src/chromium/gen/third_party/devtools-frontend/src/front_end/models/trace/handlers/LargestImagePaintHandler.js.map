{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/LargestImagePaintHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaData} from './MetaHandler.js';\nimport {data as networkRequestsData} from './NetworkRequestsHandler.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * If the LCP resource was an image, and that image was fetched over the\n * network, we want to be able to find the network request in order to construct\n * the critical path for an LCP image.\n * Within the trace file there are `LargestImagePaint::Candidate` events.\n * Within their data object, they contain a `DOMNodeId` property, which maps to\n * the DOM Node ID for that image.\n *\n * This id maps exactly to the `data.nodeId` property that a\n * `LargestContentfulPaint::Candidate` will have. So, when we find an image\n * paint candidate, we can store it, keying it on the node ID.\n * Then, when it comes to finding the network request for an LCP image, we can\n *\n * use the nodeId from the LCP candidate to find the image candidate. That image\n * candidate also contains a `imageUrl` property, which will have the full URL\n * to the image.\n **/\nconst imageByDOMNodeId = new Map<Protocol.DOM.BackendNodeId, Types.Events.LargestImagePaintCandidate>();\nconst lcpRequestByNavigation = new Map<Types.Events.NavigationStart|null, Types.Events.SyntheticNetworkRequest>();\nconst lcpPaintEventByNavigation = new Map<Types.Events.NavigationStart|null, Types.Events.LargestImagePaintCandidate>();\nlet currentNavigation: Types.Events.NavigationStart|null;\n\nexport function reset(): void {\n  imageByDOMNodeId.clear();\n  lcpRequestByNavigation.clear();\n  lcpPaintEventByNavigation.clear();\n  currentNavigation = null;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isNavigationStart(event)) {\n    currentNavigation = event;\n    return;\n  }\n\n  if (!Types.Events.isLargestImagePaintCandidate(event)) {\n    return;\n  }\n\n  if (!event.args.data) {\n    return;\n  }\n\n  imageByDOMNodeId.set(event.args.data.DOMNodeId, event);\n  lcpPaintEventByNavigation.set(currentNavigation, event);\n}\n\nexport async function finalize(): Promise<void> {\n  const requests = networkRequestsData().byTime;\n  const traceBounds = metaData().traceBounds;\n\n  for (const [navigation, event] of lcpPaintEventByNavigation) {\n    const lcpUrl = event.args.data?.imageUrl;\n    if (!lcpUrl) {\n      continue;\n    }\n\n    const startTime = navigation?.ts ?? traceBounds.min;\n    const endTime = event.ts;\n\n    let lcpRequest;\n    for (const request of requests) {\n      if (request.ts < startTime) {\n        continue;\n      }\n      if (request.ts >= endTime) {\n        break;\n      }\n\n      if (request.args.data.url === lcpUrl || request.args.data.redirects.some(r => r.url === lcpUrl)) {\n        lcpRequest = request;\n        break;\n      }\n    }\n\n    if (lcpRequest) {\n      lcpRequestByNavigation.set(navigation, lcpRequest);\n    }\n  }\n}\n\nexport interface LargestImagePaintData {\n  imageByDOMNodeId: Map<Protocol.DOM.BackendNodeId, Types.Events.LargestImagePaintCandidate>;\n  lcpRequestByNavigation: Map<Types.Events.NavigationStart|null, Types.Events.SyntheticNetworkRequest>;\n}\n\nexport function data(): LargestImagePaintData {\n  return {imageByDOMNodeId, lcpRequestByNavigation};\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'NetworkRequests'];\n}\n"],
  "mappings": ";AAKA,YAAY,WAAW;AAEvB,SAAQ,QAAQ,gBAAe;AAC/B,SAAQ,QAAQ,2BAA0B;AAoB1C,MAAM,mBAAmB,oBAAI,IAAyE;AACtG,MAAM,yBAAyB,oBAAI,IAA6E;AAChH,MAAM,4BAA4B,oBAAI,IAAgF;AACtH,IAAI;AAEG,gBAAS,QAAc;AAC5B,mBAAiB,MAAM;AACvB,yBAAuB,MAAM;AAC7B,4BAA0B,MAAM;AAChC,sBAAoB;AACtB;AAEO,gBAAS,YAAY,OAAiC;AAC3D,MAAI,MAAM,OAAO,kBAAkB,KAAK,GAAG;AACzC,wBAAoB;AACpB;AAAA,EACF;AAEA,MAAI,CAAC,MAAM,OAAO,6BAA6B,KAAK,GAAG;AACrD;AAAA,EACF;AAEA,MAAI,CAAC,MAAM,KAAK,MAAM;AACpB;AAAA,EACF;AAEA,mBAAiB,IAAI,MAAM,KAAK,KAAK,WAAW,KAAK;AACrD,4BAA0B,IAAI,mBAAmB,KAAK;AACxD;AAEA,sBAAsB,WAA0B;AAC9C,QAAM,WAAW,oBAAoB,EAAE;AACvC,QAAM,cAAc,SAAS,EAAE;AAE/B,aAAW,CAAC,YAAY,KAAK,KAAK,2BAA2B;AAC3D,UAAM,SAAS,MAAM,KAAK,MAAM;AAChC,QAAI,CAAC,QAAQ;AACX;AAAA,IACF;AAEA,UAAM,YAAY,YAAY,MAAM,YAAY;AAChD,UAAM,UAAU,MAAM;AAEtB,QAAI;AACJ,eAAW,WAAW,UAAU;AAC9B,UAAI,QAAQ,KAAK,WAAW;AAC1B;AAAA,MACF;AACA,UAAI,QAAQ,MAAM,SAAS;AACzB;AAAA,MACF;AAEA,UAAI,QAAQ,KAAK,KAAK,QAAQ,UAAU,QAAQ,KAAK,KAAK,UAAU,KAAK,OAAK,EAAE,QAAQ,MAAM,GAAG;AAC/F,qBAAa;AACb;AAAA,MACF;AAAA,IACF;AAEA,QAAI,YAAY;AACd,6BAAuB,IAAI,YAAY,UAAU;AAAA,IACnD;AAAA,EACF;AACF;AAOO,gBAAS,OAA8B;AAC5C,SAAO,EAAC,kBAAkB,uBAAsB;AAClD;AAEO,gBAAS,OAAsB;AACpC,SAAO,CAAC,QAAQ,iBAAiB;AACnC;",
  "names": []
}
