{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/InitiatorsHandler.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as AsyncJSCallsHandlerData} from './AsyncJSCallsHandler.js';\nimport {data as flowsHandlerData} from './FlowsHandler.js';\n\nconst lastScheduleStyleRecalcByFrame = new Map<string, Types.Events.ScheduleStyleRecalculation>();\n\n// This tracks the last event that is considered to have invalidated the layout\n// for a given frame.\n// Note that although there is an InvalidateLayout event, there are also other\n// events (ScheduleStyleRecalculation) that could be the reason a layout was\n// invalidated.\nconst lastInvalidationEventForFrame = new Map<string, Types.Events.Event>();\n\n// Important: although the event is called UpdateLayoutTree, in the UI we\n// present these to the user as \"Recalculate Style\". So don't get confused!\n// These are the same - just UpdateLayoutTree is what the event from Chromium\n// is called.\nconst lastUpdateLayoutTreeByFrame = new Map<string, Types.Events.UpdateLayoutTree>();\n\n// These two maps store the same data but in different directions.\n// For a given event, tell me what its initiator was. An event can only have one initiator.\nconst eventToInitiatorMap = new Map<Types.Events.Event, Types.Events.Event>();\n// For a given event, tell me what events it initiated. An event can initiate\n// multiple events, hence why the value for this map is an array.\nconst initiatorToEventsMap = new Map<Types.Events.Event, Types.Events.Event[]>();\n\nconst webSocketCreateEventsById: Map<number, Types.Events.WebSocketCreate> = new Map();\nconst schedulePostTaskCallbackEventsById: Map<number, Types.Events.SchedulePostTaskCallback> = new Map();\n\nexport function reset(): void {\n  lastScheduleStyleRecalcByFrame.clear();\n  lastInvalidationEventForFrame.clear();\n  lastUpdateLayoutTreeByFrame.clear();\n  eventToInitiatorMap.clear();\n  initiatorToEventsMap.clear();\n  webSocketCreateEventsById.clear();\n  schedulePostTaskCallbackEventsById.clear();\n}\n\nfunction storeInitiator(data: {initiator: Types.Events.Event, event: Types.Events.Event}): void {\n  eventToInitiatorMap.set(data.event, data.initiator);\n  const eventsForInitiator = initiatorToEventsMap.get(data.initiator) || [];\n  eventsForInitiator.push(data.event);\n  initiatorToEventsMap.set(data.initiator, eventsForInitiator);\n}\n\n/**\n * IMPORTANT: Before adding support for new initiator relationships in\n * trace events consider using Perfetto's flow API on the events in\n * question, so that they get automatically computed.\n * @see {@link flowsHandlerData}\n *\n * The events manually computed here were added before we had support\n * for flow events. As such they should be migrated to use the flow\n * API so that no manual parsing is needed.\n */\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isScheduleStyleRecalculation(event)) {\n    lastScheduleStyleRecalcByFrame.set(event.args.data.frame, event);\n  } else if (Types.Events.isUpdateLayoutTree(event)) {\n    // IMPORTANT: although the trace event is called UpdateLayoutTree, this\n    // represents a Styles Recalculation. This event in the timeline is shown to\n    // the user as \"Recalculate Styles.\"\n    if (event.args.beginData) {\n      // Store the last UpdateLayout event: we use this when we see an\n      // InvalidateLayout and try to figure out its initiator.\n      lastUpdateLayoutTreeByFrame.set(event.args.beginData.frame, event);\n\n      // If this frame has seen a ScheduleStyleRecalc event, then that event is\n      // considered to be the initiator of this StylesRecalc.\n      const scheduledStyleForFrame = lastScheduleStyleRecalcByFrame.get(event.args.beginData.frame);\n      if (scheduledStyleForFrame) {\n        storeInitiator({\n          event,\n          initiator: scheduledStyleForFrame,\n        });\n      }\n    }\n  } else if (Types.Events.isInvalidateLayout(event)) {\n    // By default, the InvalidateLayout event is what triggered the layout invalidation for this frame.\n    let invalidationInitiator: Types.Events.Event = event;\n\n    // However, if we have not had any prior invalidations for this frame, we\n    // want to consider StyleRecalculation events as they might be the actual\n    // cause of this layout invalidation.\n    if (!lastInvalidationEventForFrame.has(event.args.data.frame)) {\n      // 1. If we have not had an invalidation event for this frame\n      // 2. AND we have had an UpdateLayoutTree for this frame\n      // 3. AND the UpdateLayoutTree event ended AFTER the InvalidateLayout startTime\n      // 4. AND we have an initiator for the UpdateLayoutTree event\n      // 5. Then we set the last invalidation event for this frame to be the UpdateLayoutTree's initiator.\n      const lastUpdateLayoutTreeForFrame = lastUpdateLayoutTreeByFrame.get(event.args.data.frame);\n      if (lastUpdateLayoutTreeForFrame) {\n        const {endTime} = Helpers.Timing.eventTimingsMicroSeconds(lastUpdateLayoutTreeForFrame);\n        const initiatorOfUpdateLayout = eventToInitiatorMap.get(lastUpdateLayoutTreeForFrame);\n\n        if (initiatorOfUpdateLayout && endTime && endTime > event.ts) {\n          invalidationInitiator = initiatorOfUpdateLayout;\n        }\n      }\n    }\n    lastInvalidationEventForFrame.set(event.args.data.frame, invalidationInitiator);\n  } else if (Types.Events.isLayout(event)) {\n    // The initiator of a Layout event is the last Invalidation event.\n    const lastInvalidation = lastInvalidationEventForFrame.get(event.args.beginData.frame);\n    if (lastInvalidation) {\n      storeInitiator({\n        event,\n        initiator: lastInvalidation,\n      });\n    }\n    // Now clear the last invalidation for the frame: the last invalidation has been linked to a Layout event, so it cannot be the initiator for any future layouts.\n    lastInvalidationEventForFrame.delete(event.args.beginData.frame);\n  } else if (Types.Events.isWebSocketCreate(event)) {\n    webSocketCreateEventsById.set(event.args.data.identifier, event);\n  } else if (Types.Events.isWebSocketInfo(event) || Types.Events.isWebSocketTransfer(event)) {\n    const matchingCreateEvent = webSocketCreateEventsById.get(event.args.data.identifier);\n    if (matchingCreateEvent) {\n      storeInitiator({\n        event,\n        initiator: matchingCreateEvent,\n      });\n    }\n  } else if (Types.Events.isSchedulePostTaskCallback(event)) {\n    schedulePostTaskCallbackEventsById.set(event.args.data.taskId, event);\n  } else if (Types.Events.isRunPostTaskCallback(event) || Types.Events.isAbortPostTaskCallback(event)) {\n    const matchingSchedule = schedulePostTaskCallbackEventsById.get(event.args.data.taskId);\n    if (matchingSchedule) {\n      storeInitiator({event, initiator: matchingSchedule});\n    }\n  }\n}\n\nfunction createRelationshipsFromFlows(): void {\n  const flows = flowsHandlerData().flows;\n  for (let i = 0; i < flows.length; i++) {\n    const flow = flows[i];\n    for (let j = 0; j < flow.length - 1; j++) {\n      storeInitiator({event: flow[j + 1], initiator: flow[j]});\n    }\n  }\n}\n\nfunction createRelationshipsFromAsyncJSCalls(): void {\n  const asyncCallPairs = AsyncJSCallsHandlerData().schedulerToRunEntryPoints.entries();\n  for (const [asyncCaller, asyncCallees] of asyncCallPairs) {\n    for (const asyncCallee of asyncCallees) {\n      storeInitiator({event: asyncCallee, initiator: asyncCaller});\n    }\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  createRelationshipsFromFlows();\n  createRelationshipsFromAsyncJSCalls();\n}\n\nexport interface InitiatorsData {\n  eventToInitiator: Map<Types.Events.Event, Types.Events.Event>;\n  initiatorToEvents: Map<Types.Events.Event, Types.Events.Event[]>;\n}\n\nexport function data(): InitiatorsData {\n  return {\n    eventToInitiator: eventToInitiatorMap,\n    initiatorToEvents: initiatorToEventsMap,\n  };\n}\n\nexport function deps(): ['Flows', 'AsyncJSCalls'] {\n  return ['Flows', 'AsyncJSCalls'];\n}\n"],
  "mappings": "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",
  "names": ["data"]
}
