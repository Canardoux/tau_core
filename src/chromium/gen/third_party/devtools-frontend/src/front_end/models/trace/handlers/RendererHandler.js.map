{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/RendererHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as auctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport {data as metaHandlerData, type FrameProcessData} from './MetaHandler.js';\nimport {data as samplesHandlerData} from './SamplesHandler.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * This handler builds the hierarchy of trace events and profile calls\n * on each thread on each process.\n *\n * Throughout the code, trace events and profile calls are referred to\n * as \"entries\", but note they are different types of data. Trace events\n * come directly from the backend and it's the type the engine commonly\n * refers to. Profile calls on the other hand are built in the frontend,\n * and, for compatibility purposes, typed as an extension to the trace\n * event type.\n */\n\nconst processes = new Map<Types.Events.ProcessID, RendererProcess>();\n\n// We track the compositor tile worker thread name events so that at the end we\n// can return these keyed by the process ID. These are used in the frontend to\n// show the user the rasterization thread(s) on the main frame as tracks.\nconst compositorTileWorkers = Array<{\n  pid: Types.Events.ProcessID,\n  tid: Types.Events.ThreadID,\n}>();\nconst entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode> = new Map();\nlet allTraceEntries: Types.Events.Event[] = [];\n\nconst completeEventStack: (Types.Events.SyntheticComplete)[] = [];\n\nlet config: Types.Configuration.Configuration = Types.Configuration.defaults();\n\nconst makeRendererProcess = (): RendererProcess => ({\n  url: null,\n  isOnMainFrame: false,\n  threads: new Map(),\n});\n\nconst makeRendererThread = (): RendererThread => ({\n  name: null,\n  entries: [],\n  profileCalls: [],\n});\n\nconst getOrCreateRendererProcess =\n    (processes: Map<Types.Events.ProcessID, RendererProcess>, pid: Types.Events.ProcessID): RendererProcess => {\n      return Platform.MapUtilities.getWithDefault(processes, pid, makeRendererProcess);\n    };\n\nconst getOrCreateRendererThread = (process: RendererProcess, tid: Types.Events.ThreadID): RendererThread => {\n  return Platform.MapUtilities.getWithDefault(process.threads, tid, makeRendererThread);\n};\n\nexport function handleUserConfig(userConfig: Types.Configuration.Configuration): void {\n  config = userConfig;\n}\n\nexport function reset(): void {\n  processes.clear();\n  entryToNode.clear();\n  allTraceEntries.length = 0;\n  completeEventStack.length = 0;\n  compositorTileWorkers.length = 0;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isThreadName(event) && event.args.name?.startsWith('CompositorTileWorker')) {\n    compositorTileWorkers.push({\n      pid: event.pid,\n      tid: event.tid,\n    });\n  }\n\n  if (Types.Events.isBegin(event) || Types.Events.isEnd(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    const completeEvent = makeCompleteEvent(event);\n    if (!completeEvent) {\n      return;\n    }\n    thread.entries.push(completeEvent);\n    allTraceEntries.push(completeEvent);\n    return;\n  }\n\n  if (Types.Events.isInstant(event) || Types.Events.isComplete(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.entries.push(event);\n    allTraceEntries.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const {mainFrameId, rendererProcessesByFrame, threadsInProcess} = metaHandlerData();\n  assignMeta(processes, mainFrameId, rendererProcessesByFrame, threadsInProcess);\n  sanitizeProcesses(processes);\n  buildHierarchy(processes);\n  sanitizeThreads(processes);\n  Helpers.Trace.sortTraceEventsInPlace(allTraceEntries);\n}\n\nexport function data(): RendererHandlerData {\n  return {\n    processes: new Map(processes),\n    compositorTileWorkers: new Map(gatherCompositorThreads()),\n    entryToNode: new Map(entryToNode),\n    allTraceEntries: [...allTraceEntries],\n  };\n}\n\nfunction gatherCompositorThreads(): Map<Types.Events.ProcessID, Types.Events.ThreadID[]> {\n  const threadsByProcess = new Map<Types.Events.ProcessID, Types.Events.ThreadID[]>();\n  for (const worker of compositorTileWorkers) {\n    const byProcess = threadsByProcess.get(worker.pid) || [];\n    byProcess.push(worker.tid);\n    threadsByProcess.set(worker.pid, byProcess);\n  }\n  return threadsByProcess;\n}\n\n/**\n * Steps through all the renderer processes we've located so far in the meta\n * handler, obtaining their URL, checking whether they are the main frame, and\n * collecting each one of their threads' name. This meta handler's data is\n * assigned to the renderer handler's data.\n */\nexport function assignMeta(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData,\n    threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>): void {\n  assignOrigin(processes, rendererProcessesByFrame);\n  assignIsMainFrame(processes, mainFrameId, rendererProcessesByFrame);\n  assignThreadName(processes, rendererProcessesByFrame, threadsInProcess);\n}\n\n/**\n * Assigns origins to all threads in all processes.\n * @see assignMeta\n */\nexport function assignOrigin(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, rendererProcessesByFrame: FrameProcessData): void {\n  for (const renderProcessesByPid of rendererProcessesByFrame.values()) {\n    for (const [pid, processWindows] of renderProcessesByPid) {\n      for (const processInfo of processWindows.flat()) {\n        const process = getOrCreateRendererProcess(processes, pid);\n        // Sometimes a single process is responsible with rendering multiple\n        // frames at the same time. For example, see https://crbug.com/1334563.\n        // When this happens, we'd still like to assign a single url per process\n        // so: 1) use the first frame rendered by this process as the url source\n        // and 2) if the last url is \"about:blank\", use the next frame's url,\n        // data from about:blank is irrelevant.\n        if (process.url === null || process.url === 'about:blank') {\n          // If we are here, it's because we care about this process and the URL. But before we store\n          // it, we check if it is a valid URL by trying to create a URL object. If it isn't, we won't\n          // set it, and this process will be filtered out later.\n          try {\n            new URL(processInfo.frame.url);\n            process.url = processInfo.frame.url;\n          } catch (e) {\n            process.url = null;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Assigns whether or not a thread is the main frame to all threads in all processes.\n * @see assignMeta\n */\nexport function assignIsMainFrame(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData): void {\n  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      // We have this go in one direction; once a renderer has been flagged as\n      // being on the main frame, we don't unset it to false if were to show up\n      // in a subframe. Equally, if we already saw this renderer in a subframe,\n      // but it becomes the main frame, the flag would get updated.\n      if (frameId === mainFrameId) {\n        process.isOnMainFrame = true;\n      }\n    }\n  }\n}\n\n/**\n * Assigns the thread name to all threads in all processes.\n * @see assignMeta\n */\nexport function assignThreadName(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, rendererProcessesByFrame: FrameProcessData,\n    threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>): void {\n  for (const [pid, process] of processes) {\n    for (const [tid, threadInfo] of threadsInProcess.get(pid) ?? []) {\n      const thread = getOrCreateRendererThread(process, tid);\n      thread.name = threadInfo?.args.name ?? `${tid}`;\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes processes with an unkonwn origin.\n */\nexport function sanitizeProcesses(processes: Map<Types.Events.ProcessID, RendererProcess>): void {\n  const auctionWorklets = auctionWorkletsData().worklets;\n  const metaData = metaHandlerData();\n  if (metaData.traceIsGeneric) {\n    return;\n  }\n  for (const [pid, process] of processes) {\n    // If the process had no url, or if it had a malformed url that could not be\n    // parsed for some reason, or if it's an \"about:\" origin, delete it.\n    // This is done because we don't really care about processes for which we\n    // can't provide actionable insights to the user (e.g. about:blank pages).\n    //\n    // There is one exception; AuctionWorklet processes get parsed in a\n    // separate handler, so at this point we check to see if the process has\n    // been found by the AuctionWorkletsHandler, and if so we update the URL.\n    // This ensures that we keep this process around and do not drop it due to\n    // the lack of a URL.\n    if (process.url === null) {\n      const maybeWorklet = auctionWorklets.get(pid);\n      if (maybeWorklet) {\n        process.url = maybeWorklet.host;\n      } else {\n        processes.delete(pid);\n      }\n      continue;\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes threads with no roots.\n */\nexport function sanitizeThreads(processes: Map<Types.Events.ProcessID, RendererProcess>): void {\n  for (const [, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      // If the thread has no roots, delete it. Otherwise, there's going to\n      // be space taken, even though nothing is rendered in the track manager.\n      if (!thread.tree?.roots.size) {\n        process.threads.delete(tid);\n      }\n    }\n  }\n}\n\n/**\n * Creates a hierarchical structure from the trace events. Each thread in each\n * process will contribute to their own individual hierarchy.\n *\n * The trace data comes in as a contiguous array of events, against which we\n * make a couple of assumptions:\n *\n *  1. Events are temporally-ordered in terms of start time (though they're\n *     not necessarily ordered as such in the data stream).\n *  2. If event B's start and end times are within event A's time boundaries\n *     we assume that A is the parent of B.\n *\n * Therefore we expect to reformulate something like:\n *\n * [ Task A ][ Task B ][ Task C ][ Task D ][ Task E ]\n *\n * Into something hierarchically-arranged like below:\n *\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n */\nexport function buildHierarchy(\n    processes: Map<Types.Events.ProcessID, RendererProcess>,\n    options?: {filter: {has: (name: Types.Events.Name) => boolean}}): void {\n  const samplesData = samplesHandlerData();\n  for (const [pid, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      if (!thread.entries.length) {\n        thread.tree = Helpers.TreeHelpers.makeEmptyTraceEntryTree();\n        continue;\n      }\n      // Step 1. Massage the data.\n      Helpers.Trace.sortTraceEventsInPlace(thread.entries);\n      // Step 2. Inject profile calls from samples\n      const samplesDataForThread = samplesData.profilesInProcess.get(pid)?.get(tid);\n      if (samplesDataForThread) {\n        const cpuProfile = samplesDataForThread.parsedProfile;\n        const samplesIntegrator = cpuProfile &&\n            new Helpers.SamplesIntegrator.SamplesIntegrator(\n                cpuProfile, samplesDataForThread.profileId, pid, tid, config);\n        const profileCalls = samplesIntegrator?.buildProfileCalls(thread.entries);\n        if (samplesIntegrator && profileCalls) {\n          allTraceEntries = [...allTraceEntries, ...profileCalls];\n          thread.entries = Helpers.Trace.mergeEventsInOrder(thread.entries, profileCalls);\n          thread.profileCalls = profileCalls;\n          // We'll also inject the instant JSSample events (in debug mode only)\n          const jsSamples = samplesIntegrator.jsSampleEvents;\n          if (jsSamples) {\n            allTraceEntries = [...allTraceEntries, ...jsSamples];\n            thread.entries = Helpers.Trace.mergeEventsInOrder(thread.entries, jsSamples);\n          }\n        }\n      }\n      // Step 3. Build the tree.\n      const treeData = Helpers.TreeHelpers.treify(thread.entries, options);\n      thread.tree = treeData.tree;\n      // Update the entryToNode map with the entries from this thread\n      for (const [entry, node] of treeData.entryToNode) {\n        entryToNode.set(entry, node);\n      }\n    }\n  }\n}\n\nexport function makeCompleteEvent(event: Types.Events.Begin|Types.Events.End): Types.Events.SyntheticComplete|null {\n  if (Types.Events.isEnd(event)) {\n    // Quietly ignore unbalanced close events, they're legit (we could\n    // have missed start one).\n    const beginEvent = completeEventStack.pop();\n    if (!beginEvent) {\n      return null;\n    }\n    if (beginEvent.name !== event.name || beginEvent.cat !== event.cat) {\n      console.error(\n          'Begin/End events mismatch at ' + beginEvent.ts + ' (' + beginEvent.name + ') vs. ' + event.ts + ' (' +\n          event.name + ')');\n      return null;\n    }\n    // Update the begin event's duration using the timestamp of the end\n    // event.\n    beginEvent.dur = Types.Timing.MicroSeconds(event.ts - beginEvent.ts);\n    return null;\n  }\n\n  // Create a synthetic event using the begin event, when we find the\n  // matching end event later we will update its duration.\n  const syntheticComplete: Types.Events.SyntheticComplete = {\n    ...event,\n    ph: Types.Events.Phase.COMPLETE,\n    dur: Types.Timing.MicroSeconds(0),\n  };\n\n  completeEventStack.push(syntheticComplete);\n  return syntheticComplete;\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'Samples', 'AuctionWorklets'];\n}\n\nexport interface RendererHandlerData {\n  processes: Map<Types.Events.ProcessID, RendererProcess>;\n  /**\n   * A map of all compositor workers (which we show in the UI as Rasterizers)\n   * by the process ID.\n   */\n  compositorTileWorkers: Map<Types.Events.ProcessID, Types.Events.ThreadID[]>;\n  entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>;\n  /**\n   * All trace events and synthetic profile calls made from\n   * samples.\n   */\n  allTraceEntries: Types.Events.Event[];\n}\n\nexport interface RendererProcess {\n  // In an ideal world this would be modelled as a URL, but URLs cannot be sent\n  // between the main thread and workers, so we have to store it as a string.\n  url: string|null;\n  isOnMainFrame: boolean;\n  threads: Map<Types.Events.ThreadID, RendererThread>;\n}\n\nexport interface RendererThread {\n  name: string|null;\n  /**\n   * Contains trace events and synthetic profile calls made from\n   * samples.\n   */\n  entries: Types.Events.Event[];\n  profileCalls: Types.Events.SyntheticProfileCall[];\n  tree?: Helpers.TreeHelpers.TraceEntryTree;\n}\n"],
  "mappings": "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",
  "names": ["processes"]
}
