{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/MetaHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\n// We track the renderer processes we see in each frame on the way through the trace.\nconst rendererProcessesByFrameId: FrameProcessData = new Map();\n\n// We will often want to key data by Frame IDs, and commonly we'll care most\n// about the main frame's ID, so we store and expose that.\nlet mainFrameId: string = '';\nlet mainFrameURL: string = '';\n\nconst framesByProcessId = new Map<Types.Events.ProcessID, Map<string, Types.Events.TraceFrame>>();\n\n// We will often want to key data by the browser process, GPU process and top\n// level renderer IDs, so keep a track on those.\nlet browserProcessId: Types.Events.ProcessID = Types.Events.ProcessID(-1);\nlet browserThreadId: Types.Events.ThreadID = Types.Events.ThreadID(-1);\nlet gpuProcessId: Types.Events.ProcessID = Types.Events.ProcessID(-1);\nlet gpuThreadId: Types.Events.ThreadID = Types.Events.ThreadID(-1);\nlet viewportRect: DOMRect|null = null;\nlet devicePixelRatio: number|null = null;\n\nconst processNames: Map<Types.Events.ProcessID, Types.Events.ProcessName> = new Map();\n\nconst topLevelRendererIds = new Set<Types.Events.ProcessID>();\nconst traceBounds: Types.Timing.TraceWindowMicroSeconds = {\n  min: Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY),\n  max: Types.Timing.MicroSeconds(Number.NEGATIVE_INFINITY),\n  range: Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY),\n};\n\n/**\n * These represent the user navigating. Values such as First Contentful Paint,\n * etc, are relative to the navigation.\n *\n *  We store navigation events both by the frame and navigation ID. This means\n * when we need to look them up, we can use whichever ID we have.\n *\n * Note that these Maps will have the same values in them; these are just keyed\n * differently to make look-ups easier.\n *\n * We also additionally maintain an array of only navigations that occured on\n * the main frame. In many places in the UI we only care about highlighting\n * main frame navigations, so calculating this list here is better than\n * filtering either of the below maps over and over again at the UI layer.\n */\nconst navigationsByFrameId = new Map<string, Types.Events.NavigationStart[]>();\nconst navigationsByNavigationId = new Map<string, Types.Events.NavigationStart>();\nconst mainFrameNavigations: Types.Events.NavigationStart[] = [];\n\n// Represents all the threads in the trace, organized by process. This is mostly for internal\n// bookkeeping so that during the finalize pass we can obtain the main and browser thread IDs.\nconst threadsInProcess = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>();\n\nlet traceStartedTimeFromTracingStartedEvent = Types.Timing.MicroSeconds(-1);\nconst eventPhasesOfInterestForTraceBounds = new Set([\n  Types.Events.Phase.BEGIN,\n  Types.Events.Phase.END,\n  Types.Events.Phase.COMPLETE,\n  Types.Events.Phase.INSTANT,\n]);\n\n// Tracks if the trace is a generic trace, which here means that it did not come from athe DevTools Performance Panel recording.\n// We assume a trace is generic, and mark it as not generic if we see any of:\n// - TracingStartedInPage\n// - TracingStartedInBrowser\n// - TracingSessionIdForWorker\n// These are all events which indicate this is a Chrome browser trace.\nlet traceIsGeneric = true;\nconst CHROME_WEB_TRACE_EVENTS = new Set([\n  Types.Events.Name.TRACING_STARTED_IN_PAGE,\n  Types.Events.Name.TRACING_SESSION_ID_FOR_WORKER,\n  Types.Events.Name.TRACING_STARTED_IN_BROWSER,\n\n]);\n\nexport function reset(): void {\n  navigationsByFrameId.clear();\n  navigationsByNavigationId.clear();\n  processNames.clear();\n  mainFrameNavigations.length = 0;\n\n  browserProcessId = Types.Events.ProcessID(-1);\n  browserThreadId = Types.Events.ThreadID(-1);\n  gpuProcessId = Types.Events.ProcessID(-1);\n  gpuThreadId = Types.Events.ThreadID(-1);\n  viewportRect = null;\n  topLevelRendererIds.clear();\n  threadsInProcess.clear();\n  rendererProcessesByFrameId.clear();\n  framesByProcessId.clear();\n\n  traceBounds.min = Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY);\n  traceBounds.max = Types.Timing.MicroSeconds(Number.NEGATIVE_INFINITY);\n  traceBounds.range = Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY);\n  traceStartedTimeFromTracingStartedEvent = Types.Timing.MicroSeconds(-1);\n\n  traceIsGeneric = true;\n}\n\nfunction updateRendererProcessByFrame(event: Types.Events.Event, frame: Types.Events.TraceFrame): void {\n  const framesInProcessById = Platform.MapUtilities.getWithDefault(framesByProcessId, frame.processId, () => new Map());\n  framesInProcessById.set(frame.frame, frame);\n\n  const rendererProcessInFrame = Platform.MapUtilities.getWithDefault(\n      rendererProcessesByFrameId, frame.frame,\n      () => new Map<\n          Types.Events.ProcessID, {frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicroSeconds}[]>());\n  const rendererProcessInfo = Platform.MapUtilities.getWithDefault(rendererProcessInFrame, frame.processId, () => {\n    return [];\n  });\n  const lastProcessData = rendererProcessInfo.at(-1);\n\n  // Only store a new entry if the URL changed, otherwise it's just\n  // redundant information.\n  if (lastProcessData && lastProcessData.frame.url === frame.url) {\n    return;\n  }\n  // For now we store the time of the event as the min. In the finalize we step\n  // through each of these windows and update their max and range values.\n  rendererProcessInfo.push({\n    frame,\n    window: {\n      min: event.ts,\n      max: Types.Timing.MicroSeconds(0),\n      range: Types.Timing.MicroSeconds(0),\n    },\n  });\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (traceIsGeneric && CHROME_WEB_TRACE_EVENTS.has(event.name as Types.Events.Name)) {\n    traceIsGeneric = false;\n  }\n\n  if (Types.Events.isProcessName(event)) {\n    processNames.set(event.pid, event);\n  }\n\n  // If there is a timestamp (which meta events do not have), and the event does\n  // not end with ::UMA then it, and the event is in the set of valid phases,\n  // then it should be included for the purposes of calculating the trace bounds.\n  // The UMA events in particular seem to be reported on page unloading, which\n  // often extends the bounds of the trace unhelpfully.\n  if (event.ts !== 0 && !event.name.endsWith('::UMA') && eventPhasesOfInterestForTraceBounds.has(event.ph)) {\n    traceBounds.min = Types.Timing.MicroSeconds(Math.min(event.ts, traceBounds.min));\n    const eventDuration = event.dur ?? Types.Timing.MicroSeconds(0);\n    traceBounds.max = Types.Timing.MicroSeconds(Math.max(event.ts + eventDuration, traceBounds.max));\n  }\n\n  if (Types.Events.isProcessName(event) && (event.args.name === 'Browser' || event.args.name === 'HeadlessBrowser')) {\n    browserProcessId = event.pid;\n    return;\n  }\n\n  if (Types.Events.isProcessName(event) && (event.args.name === 'Gpu' || event.args.name === 'GPU Process')) {\n    gpuProcessId = event.pid;\n    return;\n  }\n\n  if (Types.Events.isThreadName(event) && event.args.name === 'CrGpuMain') {\n    gpuThreadId = event.tid;\n    return;\n  }\n\n  if (Types.Events.isThreadName(event) && event.args.name === 'CrBrowserMain') {\n    browserThreadId = event.tid;\n  }\n\n  if (Types.Events.isMainFrameViewport(event) && viewportRect === null) {\n    const rectAsArray = event.args.data.viewport_rect;\n    const viewportX = rectAsArray[0];\n    const viewportY = rectAsArray[1];\n    const viewportWidth = rectAsArray[2];\n    const viewportHeight = rectAsArray[5];\n    viewportRect = new DOMRect(viewportX, viewportY, viewportWidth, viewportHeight);\n    devicePixelRatio = event.args.data.dpr;\n  }\n\n  // The TracingStartedInBrowser event includes the data on which frames are\n  // in scope at the start of the trace. We use this to identify the frame with\n  // no parent, i.e. the top level frame.\n  if (Types.Events.isTracingStartedInBrowser(event)) {\n    traceStartedTimeFromTracingStartedEvent = event.ts;\n\n    if (!event.args.data) {\n      throw new Error('No frames found in trace data');\n    }\n\n    for (const frame of (event.args.data.frames ?? [])) {\n      updateRendererProcessByFrame(event, frame);\n\n      if (!frame.parent) {\n        topLevelRendererIds.add(frame.processId);\n      }\n      /**\n       * The code here uses a few different methods to try to determine the main frame.\n       * The ideal is that the frames have two flags present:\n       *\n       * 1. isOutermostMainFrame (added in April 2024 - crrev.com/c/5424783)\n       * 2. isInPrimaryMainFrame (added in June 2024 - crrev.com/c/5595033)\n       *\n       * The frame where both of these are set to `true` is the main frame. The\n       * reason we need both of these flags to have 100% confidence is because\n       * with the introduction of MPArch and pre-rendering, we can have other\n       * frames that are the outermost frame, but are not the primary process.\n       * Relying on isOutermostMainFrame in isolation caused the engine to\n       * incorrectly identify the wrong frame as main (see crbug.com/343873756).\n       *\n       * See https://source.chromium.org/chromium/chromium/src/+/main:docs/frame_trees.md\n       * for a bit more context on FrameTrees in Chromium.\n       *\n       * To avoid breaking entirely for traces pre-June 2024 that don't have\n       * both of these flags, we will fallback to less accurate methods:\n       *\n       * 1. If we have isOutermostMainFrame, we will use that\n       *    (and accept we might get it wrong)\n       * 2. If we don't have isOutermostMainFrame, we fallback to finding a\n       *    frame that has a URL, but doesn't have a parent. This is a crude\n       *    guess at the main frame...but better than nothing and is historically\n       *    how DevTools identified the main frame.\n       */\n\n      const traceHasPrimaryMainFrameFlag = 'isInPrimaryMainFrame' in frame;\n      const traceHasOutermostMainFrameFlag = 'isOutermostMainFrame' in frame;\n\n      if (traceHasPrimaryMainFrameFlag && traceHasOutermostMainFrameFlag) {\n        // Ideal situation: identify the main frame as the one that has both these flags set to true.\n        if (frame.isInPrimaryMainFrame && frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n      } else if (traceHasOutermostMainFrameFlag) {\n        // Less ideal: \"guess\" at the main thread by using this falg.\n        if (frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n      } else {\n        // Worst case: guess by seeing if the frame doesn't have a parent, and does have a URL.\n        if (!frame.parent && frame.url) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n      }\n    }\n\n    return;\n  }\n\n  // FrameCommittedInBrowser events tell us information about each frame\n  // and we use these to track how long each individual renderer is active\n  // for. We track all renderers here (top level and those in frames), but\n  // for convenience we also populate a set of top level renderer IDs.\n  if (Types.Events.isFrameCommittedInBrowser(event)) {\n    const frame = event.args.data;\n    if (!frame) {\n      return;\n    }\n\n    updateRendererProcessByFrame(event, frame);\n\n    if (frame.parent) {\n      return;\n    }\n\n    topLevelRendererIds.add(frame.processId);\n    return;\n  }\n\n  if (Types.Events.isCommitLoad(event)) {\n    const frameData = event.args.data;\n    if (!frameData) {\n      return;\n    }\n\n    const {frame, name, url} = frameData;\n    updateRendererProcessByFrame(event, {processId: event.pid, frame, name, url});\n    return;\n  }\n\n  // Track all threads based on the process & thread IDs.\n  if (Types.Events.isThreadName(event)) {\n    const threads = Platform.MapUtilities.getWithDefault(threadsInProcess, event.pid, () => new Map());\n    threads.set(event.tid, event);\n    return;\n  }\n\n  // Track all navigation events. Note that there can be navigation start events\n  // but where the documentLoaderURL is empty. As far as the trace rendering is\n  // concerned, these events are noise so we filter them out here.\n  // (The filtering of empty URLs is done in the isNavigationStart check)\n  if (Types.Events.isNavigationStart(event) && event.args.data) {\n    const navigationId = event.args.data.navigationId;\n    if (navigationsByNavigationId.has(navigationId)) {\n      // We have only ever seen this situation once, in crbug.com/1503982, where the user ran:\n      // window.location.href = 'javascript:console.log(\"foo\")'\n      // In this situation two identical navigationStart events are emitted with the same data, URL and ID.\n      // So, in this situation we drop/ignore any subsequent navigations if we have already seen that ID.\n      return;\n    }\n    navigationsByNavigationId.set(navigationId, event);\n\n    const frameId = event.args.frame;\n    const existingFrameNavigations = navigationsByFrameId.get(frameId) || [];\n    existingFrameNavigations.push(event);\n    navigationsByFrameId.set(frameId, existingFrameNavigations);\n    if (frameId === mainFrameId) {\n      mainFrameNavigations.push(event);\n    }\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // We try to set the minimum time by finding the event with the smallest\n  // timestamp. However, if we also got a timestamp from the\n  // TracingStartedInBrowser event, we should always use that.\n  // But in some traces (for example, CPU profiles) we do not get that event,\n  // hence why we need to check we got a timestamp from it before setting it.\n  if (traceStartedTimeFromTracingStartedEvent >= 0) {\n    traceBounds.min = traceStartedTimeFromTracingStartedEvent;\n  }\n  traceBounds.range = Types.Timing.MicroSeconds(traceBounds.max - traceBounds.min);\n\n  // If we go from foo.com to example.com we will get a new renderer, and\n  // therefore the \"top level renderer\" will have a different PID as it has\n  // changed. Here we step through each renderer process and updated its window\n  // bounds, such that we end up with the time ranges in the trace for when\n  // each particular renderer started and stopped being the main renderer\n  // process.\n  for (const [, processWindows] of rendererProcessesByFrameId) {\n    const processWindowValues = [...processWindows.values()].flat();\n    for (let i = 0; i < processWindowValues.length; i++) {\n      const currentWindow = processWindowValues[i];\n      const nextWindow = processWindowValues[i + 1];\n\n      // For the last window we set its max to be positive infinity.\n      // TODO: Move the trace bounds handler into meta so we can clamp first and last windows.\n      if (!nextWindow) {\n        currentWindow.window.max = Types.Timing.MicroSeconds(traceBounds.max);\n        currentWindow.window.range = Types.Timing.MicroSeconds(traceBounds.max - currentWindow.window.min);\n      } else {\n        currentWindow.window.max = Types.Timing.MicroSeconds(nextWindow.window.min - 1);\n        currentWindow.window.range = Types.Timing.MicroSeconds(currentWindow.window.max - currentWindow.window.min);\n      }\n    }\n  }\n\n  // Frame ids which we didn't register using either the TracingStartedInBrowser or\n  // the FrameCommittedInBrowser events are considered noise, so we filter them out, as well\n  // as the navigations that belong to such frames.\n  for (const [frameId, navigations] of navigationsByFrameId) {\n    // The frames in the rendererProcessesByFrameId map come only from the\n    // TracingStartedInBrowser and FrameCommittedInBrowser events, so we can use it as point\n    // of comparison to determine if a frameId should be discarded.\n    if (rendererProcessesByFrameId.has(frameId)) {\n      continue;\n    }\n    navigationsByFrameId.delete(frameId);\n    for (const navigation of navigations) {\n      if (!navigation.args.data) {\n        continue;\n      }\n      navigationsByNavigationId.delete(navigation.args.data.navigationId);\n    }\n  }\n\n  // Sometimes in traces the TracingStartedInBrowser event can give us an\n  // incorrect initial URL for the main frame's URL - about:blank or the URL of\n  // the previous page. This doesn't matter too much except we often use this\n  // URL as the visual name of the trace shown to the user (e.g. in the history\n  // dropdown). We can be more accurate by finding the first main frame\n  // navigaton, and using its URL, if we have it.\n  // However, to avoid doing this in a case where the first navigation is far\n  // into the trace's lifecycle, we only do this in situations where the first\n  // navigation happened very soon (0.5 seconds) after the trace started\n  // recording.\n  const firstMainFrameNav = mainFrameNavigations.at(0);\n  const firstNavTimeThreshold = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(0.5));\n  if (firstMainFrameNav) {\n    const navigationIsWithinThreshold = firstMainFrameNav.ts - traceBounds.min < firstNavTimeThreshold;\n    if (firstMainFrameNav.args.data?.isOutermostMainFrame && firstMainFrameNav.args.data?.documentLoaderURL &&\n        navigationIsWithinThreshold) {\n      mainFrameURL = firstMainFrameNav.args.data.documentLoaderURL;\n    }\n  }\n}\n\nexport type MetaHandlerData = {\n  traceIsGeneric: boolean,\n  traceBounds: Types.Timing.TraceWindowMicroSeconds,\n  browserProcessId: Types.Events.ProcessID,\n  processNames: Map<Types.Events.ProcessID, Types.Events.ProcessName>,\n  browserThreadId: Types.Events.ThreadID,\n  gpuProcessId: Types.Events.ProcessID,\n  navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>,\n  navigationsByNavigationId: Map<string, Types.Events.NavigationStart>,\n  threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>,\n  mainFrameId: string,\n  mainFrameURL: string,\n  /**\n   * A frame can have multiple renderer processes, at the same time,\n   * a renderer process can have multiple URLs. This map tracks the\n   * processes active on a given frame, with the time window in which\n   * they were active. Because a renderer process might have multiple\n   * URLs, each process in each frame has an array of windows, with an\n   * entry for each URL it had.\n   */\n  rendererProcessesByFrame: FrameProcessData,\n  topLevelRendererIds: Set<Types.Events.ProcessID>,\n  frameByProcessId: Map<Types.Events.ProcessID, Map<string, Types.Events.TraceFrame>>,\n  mainFrameNavigations: Types.Events.NavigationStart[],\n  gpuThreadId?: Types.Events.ThreadID,\n  viewportRect?: DOMRect,\n  devicePixelRatio?: number,\n};\n\n// Each frame has a single render process at a given time but it can have\n// multiple render processes  during a trace, for example if a navigation\n// occurred in the frame. This map tracks the process that was active for\n// each frame at each point in time. Also, because a process can be\n// assigned to multiple URLs, there is a window for each URL a process\n// was assigned.\n//\n// Note that different sites always end up in different render\n// processes, however two different URLs can point to the same site.\n// For example: https://google.com and https://maps.google.com point to\n// the same site.\n// Read more about this in\n// https://developer.chrome.com/articles/renderingng-architecture/#threads\n// and https://web.dev/same-site-same-origin/\nexport type FrameProcessData =\n    Map<string,\n        Map<Types.Events.ProcessID, {frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicroSeconds}[]>>;\n\nexport function data(): MetaHandlerData {\n  return {\n    traceBounds: {...traceBounds},\n    browserProcessId,\n    browserThreadId,\n    processNames,\n    gpuProcessId,\n    gpuThreadId: gpuThreadId === Types.Events.ThreadID(-1) ? undefined : gpuThreadId,\n    viewportRect: viewportRect || undefined,\n    devicePixelRatio: devicePixelRatio ?? undefined,\n    mainFrameId,\n    mainFrameURL,\n    navigationsByFrameId,\n    navigationsByNavigationId,\n    threadsInProcess,\n    rendererProcessesByFrame: rendererProcessesByFrameId,\n    topLevelRendererIds,\n    frameByProcessId: framesByProcessId,\n    mainFrameNavigations,\n    traceIsGeneric,\n  };\n}\n"],
  "mappings": ";AAIA,YAAY,cAAc;AAC1B,YAAY,aAAa;AACzB,YAAY,WAAW;AAGvB,MAAM,6BAA+C,oBAAI,IAAI;AAI7D,IAAI,cAAsB;AAC1B,IAAI,eAAuB;AAE3B,MAAM,oBAAoB,oBAAI,IAAkE;AAIhG,IAAI,mBAA2C,MAAM,OAAO,UAAU,EAAE;AACxE,IAAI,kBAAyC,MAAM,OAAO,SAAS,EAAE;AACrE,IAAI,eAAuC,MAAM,OAAO,UAAU,EAAE;AACpE,IAAI,cAAqC,MAAM,OAAO,SAAS,EAAE;AACjE,IAAI,eAA6B;AACjC,IAAI,mBAAgC;AAEpC,MAAM,eAAsE,oBAAI,IAAI;AAEpF,MAAM,sBAAsB,oBAAI,IAA4B;AAC5D,MAAM,cAAoD;AAAA,EACxD,KAAK,MAAM,OAAO,aAAa,OAAO,iBAAiB;AAAA,EACvD,KAAK,MAAM,OAAO,aAAa,OAAO,iBAAiB;AAAA,EACvD,OAAO,MAAM,OAAO,aAAa,OAAO,iBAAiB;AAC3D;AAiBA,MAAM,uBAAuB,oBAAI,IAA4C;AAC7E,MAAM,4BAA4B,oBAAI,IAA0C;AAChF,MAAM,uBAAuD,CAAC;AAI9D,MAAM,mBAAmB,oBAAI,IAAiF;AAE9G,IAAI,0CAA0C,MAAM,OAAO,aAAa,EAAE;AAC1E,MAAM,sCAAsC,oBAAI,IAAI;AAAA,EAClD,MAAM,OAAO,MAAM;AAAA,EACnB,MAAM,OAAO,MAAM;AAAA,EACnB,MAAM,OAAO,MAAM;AAAA,EACnB,MAAM,OAAO,MAAM;AACrB,CAAC;AAQD,IAAI,iBAAiB;AACrB,MAAM,0BAA0B,oBAAI,IAAI;AAAA,EACtC,MAAM,OAAO,KAAK;AAAA,EAClB,MAAM,OAAO,KAAK;AAAA,EAClB,MAAM,OAAO,KAAK;AAEpB,CAAC;AAEM,gBAAS,QAAc;AAC5B,uBAAqB,MAAM;AAC3B,4BAA0B,MAAM;AAChC,eAAa,MAAM;AACnB,uBAAqB,SAAS;AAE9B,qBAAmB,MAAM,OAAO,UAAU,EAAE;AAC5C,oBAAkB,MAAM,OAAO,SAAS,EAAE;AAC1C,iBAAe,MAAM,OAAO,UAAU,EAAE;AACxC,gBAAc,MAAM,OAAO,SAAS,EAAE;AACtC,iBAAe;AACf,sBAAoB,MAAM;AAC1B,mBAAiB,MAAM;AACvB,6BAA2B,MAAM;AACjC,oBAAkB,MAAM;AAExB,cAAY,MAAM,MAAM,OAAO,aAAa,OAAO,iBAAiB;AACpE,cAAY,MAAM,MAAM,OAAO,aAAa,OAAO,iBAAiB;AACpE,cAAY,QAAQ,MAAM,OAAO,aAAa,OAAO,iBAAiB;AACtE,4CAA0C,MAAM,OAAO,aAAa,EAAE;AAEtE,mBAAiB;AACnB;AAEA,SAAS,6BAA6B,OAA2B,OAAsC;AACrG,QAAM,sBAAsB,SAAS,aAAa,eAAe,mBAAmB,MAAM,WAAW,MAAM,oBAAI,IAAI,CAAC;AACpH,sBAAoB,IAAI,MAAM,OAAO,KAAK;AAE1C,QAAM,yBAAyB,SAAS,aAAa;AAAA,IACjD;AAAA,IAA4B,MAAM;AAAA,IAClC,MAAM,oBAAI,IACoG;AAAA,EAAC;AACnH,QAAM,sBAAsB,SAAS,aAAa,eAAe,wBAAwB,MAAM,WAAW,MAAM;AAC9G,WAAO,CAAC;AAAA,EACV,CAAC;AACD,QAAM,kBAAkB,oBAAoB,GAAG,EAAE;AAIjD,MAAI,mBAAmB,gBAAgB,MAAM,QAAQ,MAAM,KAAK;AAC9D;AAAA,EACF;AAGA,sBAAoB,KAAK;AAAA,IACvB;AAAA,IACA,QAAQ;AAAA,MACN,KAAK,MAAM;AAAA,MACX,KAAK,MAAM,OAAO,aAAa,CAAC;AAAA,MAChC,OAAO,MAAM,OAAO,aAAa,CAAC;AAAA,IACpC;AAAA,EACF,CAAC;AACH;AAEO,gBAAS,YAAY,OAAiC;AAC3D,MAAI,kBAAkB,wBAAwB,IAAI,MAAM,IAAyB,GAAG;AAClF,qBAAiB;AAAA,EACnB;AAEA,MAAI,MAAM,OAAO,cAAc,KAAK,GAAG;AACrC,iBAAa,IAAI,MAAM,KAAK,KAAK;AAAA,EACnC;AAOA,MAAI,MAAM,OAAO,KAAK,CAAC,MAAM,KAAK,SAAS,OAAO,KAAK,oCAAoC,IAAI,MAAM,EAAE,GAAG;AACxG,gBAAY,MAAM,MAAM,OAAO,aAAa,KAAK,IAAI,MAAM,IAAI,YAAY,GAAG,CAAC;AAC/E,UAAM,gBAAgB,MAAM,OAAO,MAAM,OAAO,aAAa,CAAC;AAC9D,gBAAY,MAAM,MAAM,OAAO,aAAa,KAAK,IAAI,MAAM,KAAK,eAAe,YAAY,GAAG,CAAC;AAAA,EACjG;AAEA,MAAI,MAAM,OAAO,cAAc,KAAK,MAAM,MAAM,KAAK,SAAS,aAAa,MAAM,KAAK,SAAS,oBAAoB;AACjH,uBAAmB,MAAM;AACzB;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,cAAc,KAAK,MAAM,MAAM,KAAK,SAAS,SAAS,MAAM,KAAK,SAAS,gBAAgB;AACzG,mBAAe,MAAM;AACrB;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,aAAa,KAAK,KAAK,MAAM,KAAK,SAAS,aAAa;AACvE,kBAAc,MAAM;AACpB;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,aAAa,KAAK,KAAK,MAAM,KAAK,SAAS,iBAAiB;AAC3E,sBAAkB,MAAM;AAAA,EAC1B;AAEA,MAAI,MAAM,OAAO,oBAAoB,KAAK,KAAK,iBAAiB,MAAM;AACpE,UAAM,cAAc,MAAM,KAAK,KAAK;AACpC,UAAM,YAAY,YAAY,CAAC;AAC/B,UAAM,YAAY,YAAY,CAAC;AAC/B,UAAM,gBAAgB,YAAY,CAAC;AACnC,UAAM,iBAAiB,YAAY,CAAC;AACpC,mBAAe,IAAI,QAAQ,WAAW,WAAW,eAAe,cAAc;AAC9E,uBAAmB,MAAM,KAAK,KAAK;AAAA,EACrC;AAKA,MAAI,MAAM,OAAO,0BAA0B,KAAK,GAAG;AACjD,8CAA0C,MAAM;AAEhD,QAAI,CAAC,MAAM,KAAK,MAAM;AACpB,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAEA,eAAW,SAAU,MAAM,KAAK,KAAK,UAAU,CAAC,GAAI;AAClD,mCAA6B,OAAO,KAAK;AAEzC,UAAI,CAAC,MAAM,QAAQ;AACjB,4BAAoB,IAAI,MAAM,SAAS;AAAA,MACzC;AA6BA,YAAM,+BAA+B,0BAA0B;AAC/D,YAAM,iCAAiC,0BAA0B;AAEjE,UAAI,gCAAgC,gCAAgC;AAElE,YAAI,MAAM,wBAAwB,MAAM,sBAAsB;AAC5D,wBAAc,MAAM;AACpB,yBAAe,MAAM;AAAA,QACvB;AAAA,MACF,WAAW,gCAAgC;AAEzC,YAAI,MAAM,sBAAsB;AAC9B,wBAAc,MAAM;AACpB,yBAAe,MAAM;AAAA,QACvB;AAAA,MACF,OAAO;AAEL,YAAI,CAAC,MAAM,UAAU,MAAM,KAAK;AAC9B,wBAAc,MAAM;AACpB,yBAAe,MAAM;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAEA;AAAA,EACF;AAMA,MAAI,MAAM,OAAO,0BAA0B,KAAK,GAAG;AACjD,UAAM,QAAQ,MAAM,KAAK;AACzB,QAAI,CAAC,OAAO;AACV;AAAA,IACF;AAEA,iCAA6B,OAAO,KAAK;AAEzC,QAAI,MAAM,QAAQ;AAChB;AAAA,IACF;AAEA,wBAAoB,IAAI,MAAM,SAAS;AACvC;AAAA,EACF;AAEA,MAAI,MAAM,OAAO,aAAa,KAAK,GAAG;AACpC,UAAM,YAAY,MAAM,KAAK;AAC7B,QAAI,CAAC,WAAW;AACd;AAAA,IACF;AAEA,UAAM,EAAC,OAAO,MAAM,IAAG,IAAI;AAC3B,iCAA6B,OAAO,EAAC,WAAW,MAAM,KAAK,OAAO,MAAM,IAAG,CAAC;AAC5E;AAAA,EACF;AAGA,MAAI,MAAM,OAAO,aAAa,KAAK,GAAG;AACpC,UAAM,UAAU,SAAS,aAAa,eAAe,kBAAkB,MAAM,KAAK,MAAM,oBAAI,IAAI,CAAC;AACjG,YAAQ,IAAI,MAAM,KAAK,KAAK;AAC5B;AAAA,EACF;AAMA,MAAI,MAAM,OAAO,kBAAkB,KAAK,KAAK,MAAM,KAAK,MAAM;AAC5D,UAAM,eAAe,MAAM,KAAK,KAAK;AACrC,QAAI,0BAA0B,IAAI,YAAY,GAAG;AAK/C;AAAA,IACF;AACA,8BAA0B,IAAI,cAAc,KAAK;AAEjD,UAAM,UAAU,MAAM,KAAK;AAC3B,UAAM,2BAA2B,qBAAqB,IAAI,OAAO,KAAK,CAAC;AACvE,6BAAyB,KAAK,KAAK;AACnC,yBAAqB,IAAI,SAAS,wBAAwB;AAC1D,QAAI,YAAY,aAAa;AAC3B,2BAAqB,KAAK,KAAK;AAAA,IACjC;AACA;AAAA,EACF;AACF;AAEA,sBAAsB,WAA0B;AAM9C,MAAI,2CAA2C,GAAG;AAChD,gBAAY,MAAM;AAAA,EACpB;AACA,cAAY,QAAQ,MAAM,OAAO,aAAa,YAAY,MAAM,YAAY,GAAG;AAQ/E,aAAW,CAAC,EAAE,cAAc,KAAK,4BAA4B;AAC3D,UAAM,sBAAsB,CAAC,GAAG,eAAe,OAAO,CAAC,EAAE,KAAK;AAC9D,aAAS,IAAI,GAAG,IAAI,oBAAoB,QAAQ,KAAK;AACnD,YAAM,gBAAgB,oBAAoB,CAAC;AAC3C,YAAM,aAAa,oBAAoB,IAAI,CAAC;AAI5C,UAAI,CAAC,YAAY;AACf,sBAAc,OAAO,MAAM,MAAM,OAAO,aAAa,YAAY,GAAG;AACpE,sBAAc,OAAO,QAAQ,MAAM,OAAO,aAAa,YAAY,MAAM,cAAc,OAAO,GAAG;AAAA,MACnG,OAAO;AACL,sBAAc,OAAO,MAAM,MAAM,OAAO,aAAa,WAAW,OAAO,MAAM,CAAC;AAC9E,sBAAc,OAAO,QAAQ,MAAM,OAAO,aAAa,cAAc,OAAO,MAAM,cAAc,OAAO,GAAG;AAAA,MAC5G;AAAA,IACF;AAAA,EACF;AAKA,aAAW,CAAC,SAAS,WAAW,KAAK,sBAAsB;AAIzD,QAAI,2BAA2B,IAAI,OAAO,GAAG;AAC3C;AAAA,IACF;AACA,yBAAqB,OAAO,OAAO;AACnC,eAAW,cAAc,aAAa;AACpC,UAAI,CAAC,WAAW,KAAK,MAAM;AACzB;AAAA,MACF;AACA,gCAA0B,OAAO,WAAW,KAAK,KAAK,YAAY;AAAA,IACpE;AAAA,EACF;AAYA,QAAM,oBAAoB,qBAAqB,GAAG,CAAC;AACnD,QAAM,wBAAwB,QAAQ,OAAO,sBAAsB,MAAM,OAAO,QAAQ,GAAG,CAAC;AAC5F,MAAI,mBAAmB;AACrB,UAAM,8BAA8B,kBAAkB,KAAK,YAAY,MAAM;AAC7E,QAAI,kBAAkB,KAAK,MAAM,wBAAwB,kBAAkB,KAAK,MAAM,qBAClF,6BAA6B;AAC/B,qBAAe,kBAAkB,KAAK,KAAK;AAAA,IAC7C;AAAA,EACF;AACF;AAiDO,gBAAS,OAAwB;AACtC,SAAO;AAAA,IACL,aAAa,EAAC,GAAG,YAAW;AAAA,IAC5B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,aAAa,gBAAgB,MAAM,OAAO,SAAS,EAAE,IAAI,SAAY;AAAA,IACrE,cAAc,gBAAgB;AAAA,IAC9B,kBAAkB,oBAAoB;AAAA,IACtC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,0BAA0B;AAAA,IAC1B;AAAA,IACA,kBAAkB;AAAA,IAClB;AAAA,IACA;AAAA,EACF;AACF;",
  "names": []
}
