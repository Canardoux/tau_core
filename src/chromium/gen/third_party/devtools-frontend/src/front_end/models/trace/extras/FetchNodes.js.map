{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/extras/FetchNodes.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as Handlers from '../handlers/handlers.js';\nimport * as Types from '../types/types.js';\n\nconst domLookUpSingleNodeCache =\n    new Map<Handlers.Types.ParsedTrace, Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>>();\nconst domLookUpBatchNodesCache = new Map<\n    Handlers.Types.ParsedTrace,\n    Map<Array<Protocol.DOM.BackendNodeId>, Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>>>();\n\nexport function clearCacheForTesting(): void {\n  domLookUpSingleNodeCache.clear();\n  domLookUpBatchNodesCache.clear();\n  layoutShiftSourcesCache.clear();\n  normalizedLayoutShiftNodesCache.clear();\n}\n\n/**\n * Looks up the DOM Node on the page for the given BackendNodeId. Uses the\n * provided ParsedTrace as the cache and will cache the result after the\n * first lookup.\n */\nexport async function domNodeForBackendNodeID(\n    modelData: Handlers.Types.ParsedTrace, nodeId: Protocol.DOM.BackendNodeId): Promise<SDK.DOMModel.DOMNode|null> {\n  const fromCache = domLookUpSingleNodeCache.get(modelData)?.get(nodeId);\n  if (fromCache !== undefined) {\n    return fromCache;\n  }\n\n  const target = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  const domModel = target?.model(SDK.DOMModel.DOMModel);\n  if (!domModel) {\n    return null;\n  }\n\n  const domNodesMap = await domModel.pushNodesByBackendIdsToFrontend(new Set([nodeId]));\n  const result = domNodesMap?.get(nodeId) || null;\n\n  const cacheForModel =\n      domLookUpSingleNodeCache.get(modelData) || new Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>();\n  cacheForModel.set(nodeId, result);\n  domLookUpSingleNodeCache.set(modelData, cacheForModel);\n\n  return result;\n}\n\nconst nodeIdsForEventCache = new WeakMap<Types.Events.Event, Set<Protocol.DOM.BackendNodeId>>();\n/**\n * Extracts a set of NodeIds for a given event.\n * NOTE: you probably don't want to call this and instead use\n * `extractRelatedDOMNodesFromEvent`, which will fetch the nodes over CDP.\n * This method is primarily exported so we can test the logic more easily\n * without having to mock the CDP layer.\n **/\nexport function nodeIdsForEvent(\n    modelData: Handlers.Types.ParsedTrace,\n    event: Types.Events.Event,\n    ): Set<Protocol.DOM.BackendNodeId> {\n  const fromCache = nodeIdsForEventCache.get(event);\n  if (fromCache) {\n    return fromCache;\n  }\n  const foundIds = new Set<Protocol.DOM.BackendNodeId>();\n\n  if (Types.Events.isLayout(event)) {\n    event.args.endData?.layoutRoots.forEach(root => foundIds.add(root.nodeId));\n  } else if (Types.Events.isSyntheticLayoutShift(event) && event.args.data?.impacted_nodes) {\n    event.args.data.impacted_nodes.forEach(node => foundIds.add(node.node_id));\n  } else if (Types.Events.isLargestContentfulPaintCandidate(event) && typeof event.args.data?.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (Types.Events.isPaint(event) && typeof event.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (Types.Events.isPaintImage(event) && typeof event.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (Types.Events.isScrollLayer(event) && typeof event.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.nodeId);\n  } else if (\n      Types.Events.isSyntheticAnimation(event) && typeof event.args.data.beginEvent.args.data.nodeId !== 'undefined') {\n    foundIds.add(event.args.data.beginEvent.args.data.nodeId);\n  } else if (Types.Events.isDecodeImage(event)) {\n    // For a DecodeImage event, we can use the ImagePaintingHandler, which has\n    // done the work to build the relationship between a DecodeImage event and\n    // the corresponding PaintImage event.\n    const paintImageEvent = modelData.ImagePainting.paintImageForEvent.get(event);\n    if (paintImageEvent && typeof paintImageEvent.args.data.nodeId !== 'undefined') {\n      foundIds.add(paintImageEvent.args.data.nodeId);\n    }\n  } else if (Types.Events.isDrawLazyPixelRef(event) && event.args?.LazyPixelRef) {\n    const paintImageEvent = modelData.ImagePainting.paintImageByDrawLazyPixelRef.get(event.args.LazyPixelRef);\n    if (paintImageEvent && typeof paintImageEvent.args.data.nodeId !== 'undefined') {\n      foundIds.add(paintImageEvent.args.data.nodeId);\n    }\n  } else if (Types.Events.isParseMetaViewport(event) && typeof event.args?.data.node_id !== 'undefined') {\n    foundIds.add(event.args.data.node_id);\n  }\n  nodeIdsForEventCache.set(event, foundIds);\n  return foundIds;\n}\n\n/**\n * Looks up for backend node ids in different types of trace events\n * and resolves them into related DOM nodes.\n * This method should be progressively updated to support more events\n * containing node ids which we want to resolve.\n */\nexport async function extractRelatedDOMNodesFromEvent(modelData: Handlers.Types.ParsedTrace, event: Types.Events.Event):\n    Promise<Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>|null> {\n  const nodeIds = nodeIdsForEvent(modelData, event);\n  if (nodeIds.size) {\n    return domNodesForMultipleBackendNodeIds(modelData, Array.from(nodeIds));\n  }\n  return null;\n}\n\n/**\n * Takes a set of Protocol.DOM.BackendNodeId ids and will return a map of NodeId=>DOMNode.\n * Results are cached based on 1) the provided ParsedTrace and 2) the provided set of IDs.\n */\nexport async function domNodesForMultipleBackendNodeIds(\n    modelData: Handlers.Types.ParsedTrace,\n    nodeIds: Array<Protocol.DOM.BackendNodeId>): Promise<Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>> {\n  const fromCache = domLookUpBatchNodesCache.get(modelData)?.get(nodeIds);\n  if (fromCache) {\n    return fromCache;\n  }\n  const target = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  const domModel = target?.model(SDK.DOMModel.DOMModel);\n  if (!domModel) {\n    return new Map();\n  }\n\n  const domNodesMap = await domModel.pushNodesByBackendIdsToFrontend(new Set(nodeIds)) || new Map();\n\n  const cacheForModel = domLookUpBatchNodesCache.get(modelData) ||\n      new Map<Array<Protocol.DOM.BackendNodeId>, Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>>();\n  cacheForModel.set(nodeIds, domNodesMap);\n  domLookUpBatchNodesCache.set(modelData, cacheForModel);\n\n  return domNodesMap;\n}\n\nconst layoutShiftSourcesCache =\n    new Map<Handlers.Types.ParsedTrace, Map<Types.Events.LayoutShift, readonly LayoutShiftSource[]>>();\n\nconst normalizedLayoutShiftNodesCache =\n    new Map<Handlers.Types.ParsedTrace, Map<Types.Events.LayoutShift, readonly Types.Events.TraceImpactedNode[]>>();\n\nexport interface LayoutShiftSource {\n  previousRect: DOMRect;\n  currentRect: DOMRect;\n  node: SDK.DOMModel.DOMNode;\n}\n\n/**\n * Calculates and returns a list of sources for a LayoutShift.\n * Here, a source is considered as a node that moved and contributed to the\n * given LayoutShift existing and the score it was given. Each source returned\n * contains a reference to the DOM Node, and its dimensions (as a DOMRect), both\n * before and now, so we can see how this node changed and how that impacted the\n * layout shift.\n *\n * This data is cached based on the provided model data and the given layout\n * shift, so it is is safe to call multiple times with the same input.\n */\nexport async function sourcesForLayoutShift(\n    modelData: Handlers.Types.ParsedTrace, event: Types.Events.LayoutShift): Promise<readonly LayoutShiftSource[]> {\n  const fromCache = layoutShiftSourcesCache.get(modelData)?.get(event);\n  if (fromCache) {\n    return fromCache;\n  }\n  const impactedNodes = event.args.data?.impacted_nodes;\n  if (!impactedNodes) {\n    return [];\n  }\n  const sources: LayoutShiftSource[] = [];\n  await Promise.all(impactedNodes.map(async node => {\n    const domNode = await domNodeForBackendNodeID(modelData, node.node_id);\n    if (domNode) {\n      sources.push({\n        previousRect: new DOMRect(node.old_rect[0], node.old_rect[1], node.old_rect[2], node.old_rect[3]),\n        currentRect: new DOMRect(node.new_rect[0], node.new_rect[1], node.new_rect[2], node.new_rect[3]),\n        node: domNode,\n      });\n    }\n  }));\n  const cacheForModel =\n      layoutShiftSourcesCache.get(modelData) || new Map<Types.Events.LayoutShift, LayoutShiftSource[]>();\n  cacheForModel.set(event, sources);\n  layoutShiftSourcesCache.set(modelData, cacheForModel);\n  return sources;\n}\n\n/**\n * Takes a LayoutShift and normalizes its node dimensions based on the device\n * pixel ratio (DPR) of the user's display.\n * This is required because the Layout Instability API is not based on CSS\n * pixels, but physical pixels. Therefore we need to map these to normalized CSS\n * pixels if we can. For example, if the user is on a device with a DPR of 2,\n * the values of the node dimensions reported by the Instability API need to be\n * divided by 2 to be accurate.\n * This function is safe to call multiple times as results are cached based on\n * the provided model data.\n * See https://crbug.com/1300309 for details.\n */\nexport async function normalizedImpactedNodesForLayoutShift(\n    modelData: Handlers.Types.ParsedTrace,\n    event: Types.Events.LayoutShift): Promise<readonly Types.Events.TraceImpactedNode[]> {\n  const fromCache = normalizedLayoutShiftNodesCache.get(modelData)?.get(event);\n  if (fromCache) {\n    return fromCache;\n  }\n  const impactedNodes = event.args?.data?.impacted_nodes;\n  if (!impactedNodes) {\n    return [];\n  }\n\n  let viewportScale: number|null = null;\n  const target = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  // Get the CSS-to-physical pixel ratio of the device the inspected\n  // target is running at.\n  const evaluateResult = await target?.runtimeAgent().invoke_evaluate({expression: 'window.devicePixelRatio'});\n  if (evaluateResult?.result.type === 'number') {\n    viewportScale = evaluateResult?.result.value as number ?? null;\n  }\n\n  if (!viewportScale) {\n    // Bail and return the nodes as is.\n    return impactedNodes;\n  }\n\n  const normalizedNodes: Types.Events.TraceImpactedNode[] = [];\n  for (const impactedNode of impactedNodes) {\n    const newNode = {...impactedNode};\n    for (let i = 0; i < impactedNode.old_rect.length; i++) {\n      newNode.old_rect[i] /= viewportScale;\n    }\n    for (let i = 0; i < impactedNode.new_rect.length; i++) {\n      newNode.new_rect[i] /= viewportScale;\n    }\n    normalizedNodes.push(newNode);\n  }\n\n  const cacheForModel = normalizedLayoutShiftNodesCache.get(modelData) ||\n      new Map<Types.Events.LayoutShift, readonly Types.Events.TraceImpactedNode[]>();\n  cacheForModel.set(event, normalizedNodes);\n  normalizedLayoutShiftNodesCache.set(modelData, cacheForModel);\n\n  return normalizedNodes;\n}\n"],
  "mappings": "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",
  "names": []
}
