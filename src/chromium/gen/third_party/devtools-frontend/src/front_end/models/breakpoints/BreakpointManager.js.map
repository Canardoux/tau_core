{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/breakpoints/BreakpointManager.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport {assertNotNullOrUndefined} from '../../core/platform/platform.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as Formatter from '../formatter/formatter.js';\nimport * as SourceMapScopes from '../source_map_scopes/source_map_scopes.js';\nimport type * as TextUtils from '../text_utils/text_utils.js';\nimport * as Workspace from '../workspace/workspace.js';\n\nlet breakpointManagerInstance: BreakpointManager;\nconst INITIAL_RESTORE_BREAKPOINT_COUNT = 100;\n\nexport class BreakpointManager extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements\n    SDK.TargetManager.SDKModelObserver<SDK.DebuggerModel.DebuggerModel> {\n  readonly storage = new Storage();\n  readonly #workspace: Workspace.Workspace.WorkspaceImpl;\n  readonly targetManager: SDK.TargetManager.TargetManager;\n  readonly debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding;\n  // For each source code, we remember the list or breakpoints that refer to that UI source code as\n  // their home UI source code. This is necessary to correctly remove the UI source code from\n  // breakpoints upon receiving the UISourceCodeRemoved event.\n  readonly #breakpointsForHomeUISourceCode = new Map<Workspace.UISourceCode.UISourceCode, Set<Breakpoint>>();\n  // Mapping of UI source codes to all the current breakpoint UI locations. For bound breakpoints,\n  // this is all the locations where the breakpoints was bound. For the unbound breakpoints,\n  // this is the default locations in the home UI source codes.\n  readonly #breakpointsForUISourceCode =\n      new Map<Workspace.UISourceCode.UISourceCode, Map<string, BreakpointLocation>>();\n  readonly #breakpointByStorageId = new Map<string, Breakpoint>();\n  #updateBindingsCallbacks: ((uiSourceCode: Workspace.UISourceCode.UISourceCode) => Promise<void>)[] = [];\n\n  private constructor(\n      targetManager: SDK.TargetManager.TargetManager, workspace: Workspace.Workspace.WorkspaceImpl,\n      debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding,\n      restoreInitialBreakpointCount?: number) {\n    super();\n    this.#workspace = workspace;\n    this.targetManager = targetManager;\n    this.debuggerWorkspaceBinding = debuggerWorkspaceBinding;\n\n    this.storage.mute();\n    this.#setInitialBreakpoints(restoreInitialBreakpointCount ?? INITIAL_RESTORE_BREAKPOINT_COUNT);\n    this.storage.unmute();\n\n    this.#workspace.addEventListener(Workspace.Workspace.Events.UISourceCodeAdded, this.uiSourceCodeAdded, this);\n    this.#workspace.addEventListener(Workspace.Workspace.Events.UISourceCodeRemoved, this.uiSourceCodeRemoved, this);\n    this.#workspace.addEventListener(Workspace.Workspace.Events.ProjectRemoved, this.projectRemoved, this);\n\n    this.targetManager.observeModels(SDK.DebuggerModel.DebuggerModel, this);\n  }\n\n  #setInitialBreakpoints(restoreInitialBreakpointCount: number): void {\n    let breakpointsToSkip = this.storage.breakpoints.size - restoreInitialBreakpointCount;\n    for (const storageState of this.storage.breakpoints.values()) {\n      if (breakpointsToSkip > 0) {\n        breakpointsToSkip--;\n        continue;\n      }\n      const storageId = Storage.computeId(storageState);\n      const breakpoint = new Breakpoint(this, null, storageState, BreakpointOrigin.OTHER);\n      this.#breakpointByStorageId.set(storageId, breakpoint);\n    }\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n    targetManager: SDK.TargetManager.TargetManager|null,\n    workspace: Workspace.Workspace.WorkspaceImpl|null,\n    debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding|null,\n    restoreInitialBreakpointCount?: number,\n  } = {forceNew: null, targetManager: null, workspace: null, debuggerWorkspaceBinding: null}): BreakpointManager {\n    const {forceNew, targetManager, workspace, debuggerWorkspaceBinding, restoreInitialBreakpointCount} = opts;\n    if (!breakpointManagerInstance || forceNew) {\n      if (!targetManager || !workspace || !debuggerWorkspaceBinding) {\n        throw new Error(\n            `Unable to create settings: targetManager, workspace, and debuggerWorkspaceBinding must be provided: ${\n                new Error().stack}`);\n      }\n\n      breakpointManagerInstance =\n          new BreakpointManager(targetManager, workspace, debuggerWorkspaceBinding, restoreInitialBreakpointCount);\n    }\n\n    return breakpointManagerInstance;\n  }\n\n  modelAdded(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    if (Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n      debuggerModel.setSynchronizeBreakpointsCallback(this.restoreBreakpointsForScript.bind(this));\n    }\n  }\n\n  modelRemoved(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModel.setSynchronizeBreakpointsCallback(null);\n  }\n\n  addUpdateBindingsCallback(callback: ((uiSourceCode: Workspace.UISourceCode.UISourceCode) => Promise<void>)): void {\n    this.#updateBindingsCallbacks.push(callback);\n  }\n\n  async copyBreakpoints(\n      fromSourceCode: Workspace.UISourceCode.UISourceCode,\n      toSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    const toSourceCodeIsRemoved = toSourceCode.project().uiSourceCodeForURL(toSourceCode.url()) !== toSourceCode ||\n        this.#workspace.project(toSourceCode.project().id()) !== toSourceCode.project();\n    const breakpointItems = this.storage.breakpointItems(fromSourceCode.url(), fromSourceCode.contentType().name());\n    for (const item of breakpointItems) {\n      if (toSourceCodeIsRemoved) {\n        // If the target source code has been detached from the workspace, then no breakpoint should refer\n        // to that source code. Let us only update the storage, so that the breakpoints appear once\n        // the user binds the file system again.\n        this.storage.updateBreakpoint(\n            {...item, url: toSourceCode.url(), resourceTypeName: toSourceCode.contentType().name()});\n      } else {\n        await this.setBreakpoint(\n            toSourceCode, item.lineNumber, item.columnNumber, item.condition, item.enabled, item.isLogpoint,\n            BreakpointOrigin.OTHER);\n      }\n    }\n  }\n\n  // This method explicitly awaits the source map (if necessary) and the uiSourceCodes\n  // required to set all breakpoints that are related to this script.\n  async restoreBreakpointsForScript(script: SDK.Script.Script): Promise<void> {\n    if (!Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n      return;\n    }\n    if (!script.sourceURL) {\n      return;\n    }\n\n    const uiSourceCode = await this.getUISourceCodeWithUpdatedBreakpointInfo(script);\n    if (this.#hasBreakpointsForUrl(script.sourceURL)) {\n      await this.#restoreBreakpointsForUrl(uiSourceCode);\n    }\n\n    const debuggerModel = script.debuggerModel;\n    // Handle source maps and the original sources.\n    const sourceMap = await debuggerModel.sourceMapManager().sourceMapForClientPromise(script);\n    if (sourceMap) {\n      for (const sourceURL of sourceMap.sourceURLs()) {\n        if (this.#hasBreakpointsForUrl(sourceURL)) {\n          const uiSourceCode = await this.debuggerWorkspaceBinding.uiSourceCodeForSourceMapSourceURLPromise(\n              debuggerModel, sourceURL, script.isContentScript());\n          await this.#restoreBreakpointsForUrl(uiSourceCode);\n        }\n      }\n    }\n\n    // Handle language plugins\n    const {pluginManager} = this.debuggerWorkspaceBinding;\n    const sourceUrls = await pluginManager.getSourcesForScript(script);\n    if (Array.isArray(sourceUrls)) {\n      for (const sourceURL of sourceUrls) {\n        if (this.#hasBreakpointsForUrl(sourceURL)) {\n          const uiSourceCode =\n              await this.debuggerWorkspaceBinding.uiSourceCodeForDebuggerLanguagePluginSourceURLPromise(\n                  debuggerModel, sourceURL);\n          assertNotNullOrUndefined(uiSourceCode);\n          await this.#restoreBreakpointsForUrl(uiSourceCode);\n        }\n      }\n    }\n  }\n\n  async getUISourceCodeWithUpdatedBreakpointInfo(script: SDK.Script.Script):\n      Promise<Workspace.UISourceCode.UISourceCode> {\n    const uiSourceCode = this.debuggerWorkspaceBinding.uiSourceCodeForScript(script);\n    assertNotNullOrUndefined(uiSourceCode);\n    await this.#updateBindings(uiSourceCode);\n    return uiSourceCode;\n  }\n\n  async #updateBindings(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    if (this.#updateBindingsCallbacks.length > 0) {\n      // It's possible to set breakpoints on files on the file system, and to have them\n      // hit whenever we navigate to a page that serves that file.\n      // To make sure that we have all breakpoint information moved from the file system\n      // to the served file, we need to update the bindings and await it. This will\n      // move the breakpoints from the FileSystem UISourceCode to the Network UiSourceCode.\n      const promises = [];\n      for (const callback of this.#updateBindingsCallbacks) {\n        promises.push(callback(uiSourceCode));\n      }\n      await Promise.all(promises);\n    }\n  }\n\n  async #restoreBreakpointsForUrl(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    this.restoreBreakpoints(uiSourceCode);\n    const breakpoints = this.#breakpointByStorageId.values();\n    const affectedBreakpoints = Array.from(breakpoints).filter(x => x.uiSourceCodes.has(uiSourceCode));\n    // Make sure to properly await their updates\n    await Promise.all(affectedBreakpoints.map(bp => bp.updateBreakpoint()));\n  }\n\n  #hasBreakpointsForUrl(url: Platform.DevToolsPath.UrlString): boolean {\n    // We intentionally don't specify a resource type here, but just check\n    // generally whether there's any breakpoint matching the given `url`.\n    const breakpointItems = this.storage.breakpointItems(url);\n    return breakpointItems.length > 0;\n  }\n\n  static getScriptForInlineUiSourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): SDK.Script.Script|null {\n    const script = Bindings.DefaultScriptMapping.DefaultScriptMapping.scriptForUISourceCode(uiSourceCode);\n    if (script && script.isInlineScript() && !script.hasSourceURL) {\n      return script;\n    }\n    return null;\n  }\n\n  // For inline scripts, this function translates the line-column coordinates into the coordinates\n  // of the embedding document. For other scripts, it just returns unchanged line-column.\n  static breakpointLocationFromUiLocation(uiLocation: Workspace.UISourceCode.UILocation):\n      {lineNumber: number, columnNumber: number|undefined} {\n    const uiSourceCode = uiLocation.uiSourceCode;\n    const script = BreakpointManager.getScriptForInlineUiSourceCode(uiSourceCode);\n    const {lineNumber, columnNumber} = script ? script.relativeLocationToRawLocation(uiLocation) : uiLocation;\n    return {lineNumber, columnNumber};\n  }\n\n  // For inline scripts, this function translates the line-column coordinates of the embedding\n  // document into the coordinates of the script. Other UI source code coordinated are not\n  // affected.\n  static uiLocationFromBreakpointLocation(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number,\n      columnNumber: number|undefined): Workspace.UISourceCode.UILocation {\n    const script = BreakpointManager.getScriptForInlineUiSourceCode(uiSourceCode);\n    if (script) {\n      ({lineNumber, columnNumber} = script.rawLocationToRelativeLocation({lineNumber, columnNumber}));\n    }\n    return uiSourceCode.uiLocation(lineNumber, columnNumber);\n  }\n\n  // Returns true for if the given (raw) position is within the script or if the script\n  // is null. This is used to filter breakpoints if a script is known.\n  static isValidPositionInScript(lineNumber: number, columnNumber: number|undefined, script: SDK.Script.Script|null):\n      boolean {\n    if (!script) {\n      return true;\n    }\n    if (lineNumber < script.lineOffset || lineNumber > script.endLine) {\n      return false;\n    }\n    if (lineNumber === script.lineOffset && columnNumber && columnNumber < script.columnOffset) {\n      return false;\n    }\n    if (lineNumber === script.endLine && (!columnNumber || columnNumber >= script.endColumn)) {\n      return false;\n    }\n    return true;\n  }\n\n  private restoreBreakpoints(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    const script = BreakpointManager.getScriptForInlineUiSourceCode(uiSourceCode);\n    const url = script?.sourceURL ?? uiSourceCode.url();\n    if (!url) {\n      return;\n    }\n    const contentType = uiSourceCode.contentType();\n\n    this.storage.mute();\n    const breakpoints = this.storage.breakpointItems(url, contentType.name());\n    for (const breakpoint of breakpoints) {\n      const {lineNumber, columnNumber} = breakpoint;\n      if (!BreakpointManager.isValidPositionInScript(lineNumber, columnNumber, script)) {\n        continue;\n      }\n      this.innerSetBreakpoint(\n          uiSourceCode, lineNumber, columnNumber, breakpoint.condition, breakpoint.enabled, breakpoint.isLogpoint,\n          BreakpointOrigin.OTHER);\n    }\n    this.storage.unmute();\n  }\n\n  private uiSourceCodeAdded(event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>): void {\n    const uiSourceCode = event.data;\n    this.restoreBreakpoints(uiSourceCode);\n  }\n\n  private uiSourceCodeRemoved(event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>): void {\n    const uiSourceCode = event.data;\n    this.removeUISourceCode(uiSourceCode);\n  }\n\n  private projectRemoved(event: Common.EventTarget.EventTargetEvent<Workspace.Workspace.Project>): void {\n    const project = event.data;\n    for (const uiSourceCode of project.uiSourceCodes()) {\n      this.removeUISourceCode(uiSourceCode);\n    }\n  }\n\n  private removeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    const breakpoints = this.#getAllBreakpointsForUISourceCode(uiSourceCode);\n    breakpoints.forEach(bp => bp.removeUISourceCode(uiSourceCode));\n  }\n\n  async setBreakpoint(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number, columnNumber: number|undefined,\n      condition: UserCondition, enabled: boolean, isLogpoint: boolean,\n      origin: BreakpointOrigin): Promise<Breakpoint|undefined> {\n    // As part of de-duplication, we always only show one uiSourceCode, but we may\n    // have several uiSourceCodes that correspond to the same\n    // file (but are attached to different targets), so set a breakpoint on all of them.\n    const compatibleUiSourceCodes = this.#workspace.findCompatibleUISourceCodes(uiSourceCode);\n\n    let primaryBreakpoint: Breakpoint|undefined;\n    for (const compatibleUiSourceCode of compatibleUiSourceCodes) {\n      const uiLocation = new Workspace.UISourceCode.UILocation(compatibleUiSourceCode, lineNumber, columnNumber);\n      const normalizedLocation = await this.debuggerWorkspaceBinding.normalizeUILocation(uiLocation);\n      const breakpointLocation = BreakpointManager.breakpointLocationFromUiLocation(normalizedLocation);\n\n      const breakpoint = this.innerSetBreakpoint(\n          normalizedLocation.uiSourceCode, breakpointLocation.lineNumber, breakpointLocation.columnNumber, condition,\n          enabled, isLogpoint, origin);\n\n      if (uiSourceCode === compatibleUiSourceCode) {\n        if (normalizedLocation.id() !== uiLocation.id()) {\n          // Only call this on the uiSourceCode that was initially selected for breakpoint setting.\n          void Common.Revealer.reveal(normalizedLocation);\n        }\n        primaryBreakpoint = breakpoint;\n      }\n    }\n\n    console.assert(primaryBreakpoint !== undefined, 'The passed uiSourceCode is expected to be a valid uiSourceCode');\n    return primaryBreakpoint;\n  }\n\n  private innerSetBreakpoint(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number, columnNumber: number|undefined,\n      condition: UserCondition, enabled: boolean, isLogpoint: boolean, origin: BreakpointOrigin): Breakpoint {\n    const url = BreakpointManager.getScriptForInlineUiSourceCode(uiSourceCode)?.sourceURL ?? uiSourceCode.url();\n    const resourceTypeName = uiSourceCode.contentType().name();\n    const storageState = {url, resourceTypeName, lineNumber, columnNumber, condition, enabled, isLogpoint};\n    const storageId = Storage.computeId(storageState);\n    let breakpoint = this.#breakpointByStorageId.get(storageId);\n    if (breakpoint) {\n      breakpoint.updateState(storageState);\n      breakpoint.addUISourceCode(uiSourceCode);\n      void breakpoint.updateBreakpoint();\n      return breakpoint;\n    }\n    breakpoint = new Breakpoint(this, uiSourceCode, storageState, origin);\n    this.#breakpointByStorageId.set(storageId, breakpoint);\n    return breakpoint;\n  }\n\n  findBreakpoint(uiLocation: Workspace.UISourceCode.UILocation): BreakpointLocation|null {\n    const breakpoints = this.#breakpointsForUISourceCode.get(uiLocation.uiSourceCode);\n    return breakpoints ? (breakpoints.get(uiLocation.id())) || null : null;\n  }\n\n  addHomeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode, breakpoint: Breakpoint): void {\n    let breakpoints = this.#breakpointsForHomeUISourceCode.get(uiSourceCode);\n    if (!breakpoints) {\n      breakpoints = new Set();\n      this.#breakpointsForHomeUISourceCode.set(uiSourceCode, breakpoints);\n    }\n    breakpoints.add(breakpoint);\n  }\n\n  removeHomeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode, breakpoint: Breakpoint): void {\n    const breakpoints = this.#breakpointsForHomeUISourceCode.get(uiSourceCode);\n    if (!breakpoints) {\n      return;\n    }\n    breakpoints.delete(breakpoint);\n    if (breakpoints.size === 0) {\n      this.#breakpointsForHomeUISourceCode.delete(uiSourceCode);\n    }\n  }\n\n  async possibleBreakpoints(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode,\n      textRange: TextUtils.TextRange.TextRange): Promise<Workspace.UISourceCode.UILocation[]> {\n    const rawLocationRanges =\n        await this.debuggerWorkspaceBinding.uiLocationRangeToRawLocationRanges(uiSourceCode, textRange);\n    const breakLocationLists = await Promise.all(rawLocationRanges.map(\n        ({start, end}) => start.debuggerModel.getPossibleBreakpoints(start, end, /* restrictToFunction */ false)));\n    const breakLocations = breakLocationLists.flat();\n\n    const uiLocations = new Map<string, Workspace.UISourceCode.UILocation>();\n    await Promise.all(breakLocations.map(async breakLocation => {\n      const uiLocation = await this.debuggerWorkspaceBinding.rawLocationToUILocation(breakLocation);\n      if (uiLocation === null) {\n        return;\n      }\n\n      // The \"canonical\" UI locations don't need to be in our `uiSourceCode`.\n      if (uiLocation.uiSourceCode !== uiSourceCode) {\n        return;\n      }\n\n      // Since we ask for all overlapping ranges above, we might also get breakable locations\n      // outside of the `textRange`.\n      if (!textRange.containsLocation(uiLocation.lineNumber, uiLocation.columnNumber ?? 0)) {\n        return;\n      }\n\n      uiLocations.set(uiLocation.id(), uiLocation);\n    }));\n    return [...uiLocations.values()];\n  }\n\n  breakpointLocationsForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): BreakpointLocation[] {\n    const breakpoints = this.#breakpointsForUISourceCode.get(uiSourceCode);\n    return breakpoints ? Array.from(breakpoints.values()) : [];\n  }\n\n  #getAllBreakpointsForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): Breakpoint[] {\n    const uiBreakpoints = this.breakpointLocationsForUISourceCode(uiSourceCode).map(b => b.breakpoint);\n    return uiBreakpoints.concat(Array.from(this.#breakpointsForHomeUISourceCode.get(uiSourceCode) ?? []));\n  }\n\n  allBreakpointLocations(): BreakpointLocation[] {\n    const result = [];\n    for (const breakpoints of this.#breakpointsForUISourceCode.values()) {\n      result.push(...breakpoints.values());\n    }\n    return result;\n  }\n\n  removeBreakpoint(breakpoint: Breakpoint, removeFromStorage: boolean): void {\n    const storageId = breakpoint.breakpointStorageId();\n    if (removeFromStorage) {\n      this.storage.removeBreakpoint(storageId);\n    }\n    this.#breakpointByStorageId.delete(storageId);\n  }\n\n  uiLocationAdded(breakpoint: Breakpoint, uiLocation: Workspace.UISourceCode.UILocation): void {\n    let breakpoints = this.#breakpointsForUISourceCode.get(uiLocation.uiSourceCode);\n    if (!breakpoints) {\n      breakpoints = new Map();\n      this.#breakpointsForUISourceCode.set(uiLocation.uiSourceCode, breakpoints);\n    }\n    const breakpointLocation = new BreakpointLocation(breakpoint, uiLocation);\n    breakpoints.set(uiLocation.id(), breakpointLocation);\n    this.dispatchEventToListeners(Events.BreakpointAdded, breakpointLocation);\n  }\n\n  uiLocationRemoved(breakpoint: Breakpoint, uiLocation: Workspace.UISourceCode.UILocation): void {\n    const breakpoints = this.#breakpointsForUISourceCode.get(uiLocation.uiSourceCode);\n    if (!breakpoints) {\n      return;\n    }\n    const breakpointLocation = breakpoints.get(uiLocation.id()) || null;\n    if (!breakpointLocation) {\n      return;\n    }\n    breakpoints.delete(uiLocation.id());\n    if (breakpoints.size === 0) {\n      this.#breakpointsForUISourceCode.delete(uiLocation.uiSourceCode);\n    }\n    this.dispatchEventToListeners(Events.BreakpointRemoved, breakpointLocation);\n  }\n\n  supportsConditionalBreakpoints(uiSourceCode: Workspace.UISourceCode.UISourceCode): boolean {\n    return this.debuggerWorkspaceBinding.supportsConditionalBreakpoints(uiSourceCode);\n  }\n}\n\nexport enum Events {\n  /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n  BreakpointAdded = 'breakpoint-added',\n  BreakpointRemoved = 'breakpoint-removed',\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport type EventTypes = {\n  [Events.BreakpointAdded]: BreakpointLocation,\n  [Events.BreakpointRemoved]: BreakpointLocation,\n};\n\nexport const enum DebuggerUpdateResult {\n  OK = 'OK',\n  ERROR_BREAKPOINT_CLASH = 'ERROR_BREAKPOINT_CLASH',\n  ERROR_BACKEND = 'ERROR_BACKEND',\n\n  // PENDING implies that the current update requires another re-run.\n  PENDING = 'PENDING',\n}\n\nexport type ScheduleUpdateResult =\n    DebuggerUpdateResult.OK|DebuggerUpdateResult.ERROR_BACKEND|DebuggerUpdateResult.ERROR_BREAKPOINT_CLASH;\n\nconst enum ResolveLocationResult {\n  OK = 'OK',\n  ERROR = 'ERROR',\n}\n\nexport class Breakpoint implements SDK.TargetManager.SDKModelObserver<SDK.DebuggerModel.DebuggerModel> {\n  readonly breakpointManager: BreakpointManager;\n  /** Bound locations */\n  readonly #uiLocations = new Set<Workspace.UISourceCode.UILocation>();\n  /** All known UISourceCodes with this url. This also includes UISourceCodes for the inline scripts embedded in a resource with this URL. */\n  readonly uiSourceCodes = new Set<Workspace.UISourceCode.UISourceCode>();\n  #storageState!: BreakpointStorageState;\n  #origin: BreakpointOrigin;\n  isRemoved = false;\n  /**\n   * Fallback positions in case a target doesn't have a script where this breakpoint would fit.\n   * The `ModelBreakpoint` sends this optimistically to a target in case a matching script is\n   * loaded later.\n   *\n   * Since every `ModelBreakpoint` can read/write this variable, it's slightly arbitrary. In\n   * general `lastResolvedState` contains the state of the last `ModelBreakpoint` that attempted\n   * to update the breakpoint(s) in the backend.\n   *\n   * The state gets populated from the storage if/when we set all breakpoints eagerly\n   * on debugger startup so that the backend sets the breakpoints as soon as possible\n   * (crbug.com/1442232, under a flag).\n   */\n  #lastResolvedState: Breakpoint.State|null = null;\n  readonly #modelBreakpoints = new Map<SDK.DebuggerModel.DebuggerModel, ModelBreakpoint>();\n\n  constructor(\n      breakpointManager: BreakpointManager, primaryUISourceCode: Workspace.UISourceCode.UISourceCode|null,\n      storageState: BreakpointStorageState, origin: BreakpointOrigin) {\n    this.breakpointManager = breakpointManager;\n    this.#origin = origin;\n\n    this.updateState(storageState);\n    if (primaryUISourceCode) {\n      // User is setting the breakpoint in an existing source.\n      console.assert(primaryUISourceCode.contentType().name() === storageState.resourceTypeName);\n      this.addUISourceCode(primaryUISourceCode);\n    } else {\n      // We are setting the breakpoint from storage.\n      this.#setLastResolvedStateFromStorage(storageState);\n    }\n\n    this.breakpointManager.targetManager.observeModels(SDK.DebuggerModel.DebuggerModel, this);\n  }\n\n  #setLastResolvedStateFromStorage(storageState: BreakpointStorageState): void {\n    if (storageState.resolvedState) {\n      this.#lastResolvedState = storageState.resolvedState.map(s => ({...s, scriptHash: ''}));\n    } else if (storageState.resourceTypeName === Common.ResourceType.resourceTypes.Script.name()) {\n      // If we are setting the breakpoint from storage (i.e., primaryUISourceCode is null),\n      // and the location is not source mapped, then set the last known state to\n      // the state from storage so that the breakpoints are pre-set into the backend eagerly.\n      this.#lastResolvedState = [{\n        url: storageState.url,\n        lineNumber: storageState.lineNumber,\n        columnNumber: storageState.columnNumber,\n        scriptHash: '',\n        condition: this.backendCondition(),\n      }];\n    }\n  }\n\n  getLastResolvedState(): Breakpoint.State|null {\n    return this.#lastResolvedState;\n  }\n\n  updateLastResolvedState(locations: Position[]|null): void {\n    this.#lastResolvedState = locations;\n\n    let locationsOrUndefined: ScriptBreakpointLocation[]|undefined = undefined;\n    if (locations) {\n      locationsOrUndefined = locations.map(\n          p => ({url: p.url, lineNumber: p.lineNumber, columnNumber: p.columnNumber, condition: p.condition}));\n    }\n\n    if (resolvedStateEqual(this.#storageState.resolvedState, locationsOrUndefined)) {\n      return;\n    }\n    this.#storageState = {...this.#storageState, resolvedState: locationsOrUndefined};\n    this.breakpointManager.storage.updateBreakpoint(this.#storageState);\n  }\n\n  get origin(): BreakpointOrigin {\n    return this.#origin;\n  }\n\n  async refreshInDebugger(): Promise<void> {\n    if (!this.isRemoved) {\n      const modelBreakpoints = Array.from(this.#modelBreakpoints.values());\n      await Promise.all(modelBreakpoints.map(async modelBreakpoint => {\n        await modelBreakpoint.resetBreakpoint();\n        return this.#updateModel(modelBreakpoint);\n      }));\n    }\n  }\n\n  modelAdded(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    const debuggerWorkspaceBinding = this.breakpointManager.debuggerWorkspaceBinding;\n    const modelBreakpoint = new ModelBreakpoint(debuggerModel, this, debuggerWorkspaceBinding);\n    this.#modelBreakpoints.set(debuggerModel, modelBreakpoint);\n    void this.#updateModel(modelBreakpoint);\n\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.DebuggerWasEnabled, this.#onDebuggerEnabled, this);\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.DebuggerWasDisabled, this.#onDebuggerDisabled, this);\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.ScriptSourceWasEdited, this.#onScriptWasEdited, this);\n  }\n\n  modelRemoved(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    const modelBreakpoint = this.#modelBreakpoints.get(debuggerModel);\n    modelBreakpoint?.cleanUpAfterDebuggerIsGone();\n    this.#modelBreakpoints.delete(debuggerModel);\n\n    this.#removeDebuggerModelListeners(debuggerModel);\n  }\n\n  #removeDebuggerModelListeners(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.DebuggerWasEnabled, this.#onDebuggerEnabled, this);\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.DebuggerWasDisabled, this.#onDebuggerDisabled, this);\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.ScriptSourceWasEdited, this.#onScriptWasEdited, this);\n  }\n\n  #onDebuggerEnabled(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    const debuggerModel = event.data;\n    const model = this.#modelBreakpoints.get(debuggerModel);\n    if (model) {\n      void this.#updateModel(model);\n    }\n  }\n\n  #onDebuggerDisabled(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    const debuggerModel = event.data;\n    const model = this.#modelBreakpoints.get(debuggerModel);\n    model?.cleanUpAfterDebuggerIsGone();\n  }\n\n  async #onScriptWasEdited(\n      event: Common.EventTarget\n          .EventTargetEvent<{script: SDK.Script.Script, status: Protocol.Debugger.SetScriptSourceResponseStatus}>):\n      Promise<void> {\n    const {source: debuggerModel, data: {script, status}} = event;\n    if (status !== Protocol.Debugger.SetScriptSourceResponseStatus.Ok) {\n      return;\n    }\n\n    // V8 throws away breakpoints on all functions in a live edited script. Here we attempt to re-set them again at the\n    // same position. This is because we don't know what was edited and how the breakpoint should move, e.g. if the file\n    // was originally changed on the filesystem (via workspace).\n    // If the live edit originated in DevTools (in CodeMirror), then the `DebuggerPlugin` will remove the breakpoint\n    // wholesale and re-apply based on the diff.\n\n    console.assert(debuggerModel instanceof SDK.DebuggerModel.DebuggerModel);\n    const model = this.#modelBreakpoints.get(debuggerModel as SDK.DebuggerModel.DebuggerModel);\n    if (model?.wasSetIn(script.scriptId)) {\n      await model.resetBreakpoint();\n      void this.#updateModel(model);\n    }\n  }\n\n  modelBreakpoint(debuggerModel: SDK.DebuggerModel.DebuggerModel): ModelBreakpoint|undefined {\n    return this.#modelBreakpoints.get(debuggerModel);\n  }\n\n  addUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    if (!this.uiSourceCodes.has(uiSourceCode)) {\n      this.uiSourceCodes.add(uiSourceCode);\n      this.breakpointManager.addHomeUISourceCode(uiSourceCode, this);\n      if (!this.bound()) {\n        this.breakpointManager.uiLocationAdded(this, this.defaultUILocation(uiSourceCode));\n      }\n    }\n  }\n\n  clearUISourceCodes(): void {\n    if (!this.bound()) {\n      this.removeAllUnboundLocations();\n    }\n    for (const uiSourceCode of this.uiSourceCodes) {\n      this.removeUISourceCode(uiSourceCode);\n    }\n  }\n\n  removeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    if (this.uiSourceCodes.has(uiSourceCode)) {\n      this.uiSourceCodes.delete(uiSourceCode);\n      this.breakpointManager.removeHomeUISourceCode(uiSourceCode, this);\n      if (!this.bound()) {\n        this.breakpointManager.uiLocationRemoved(this, this.defaultUILocation(uiSourceCode));\n      }\n    }\n\n    // Do we need to do this? Not sure if bound locations will leak...\n    if (this.bound()) {\n      for (const uiLocation of this.#uiLocations) {\n        if (uiLocation.uiSourceCode === uiSourceCode) {\n          this.#uiLocations.delete(uiLocation);\n          this.breakpointManager.uiLocationRemoved(this, uiLocation);\n        }\n      }\n\n      if (!this.bound() && !this.isRemoved) {\n        // Switch to unbound locations\n        this.addAllUnboundLocations();\n      }\n    }\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.#storageState.url;\n  }\n\n  lineNumber(): number {\n    return this.#storageState.lineNumber;\n  }\n\n  columnNumber(): number|undefined {\n    return this.#storageState.columnNumber;\n  }\n\n  uiLocationAdded(uiLocation: Workspace.UISourceCode.UILocation): void {\n    if (this.isRemoved) {\n      return;\n    }\n    if (!this.bound()) {\n      // This is our first bound location; remove all unbound locations\n      this.removeAllUnboundLocations();\n    }\n    this.#uiLocations.add(uiLocation);\n    this.breakpointManager.uiLocationAdded(this, uiLocation);\n  }\n\n  uiLocationRemoved(uiLocation: Workspace.UISourceCode.UILocation): void {\n    if (this.#uiLocations.has(uiLocation)) {\n      this.#uiLocations.delete(uiLocation);\n      this.breakpointManager.uiLocationRemoved(this, uiLocation);\n      if (!this.bound() && !this.isRemoved) {\n        this.addAllUnboundLocations();\n      }\n    }\n  }\n\n  enabled(): boolean {\n    return this.#storageState.enabled;\n  }\n\n  bound(): boolean {\n    return this.#uiLocations.size !== 0;\n  }\n\n  hasBoundScript(): boolean {\n    for (const uiSourceCode of this.uiSourceCodes) {\n      if (uiSourceCode.project().type() === Workspace.Workspace.projectTypes.Network) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  setEnabled(enabled: boolean): void {\n    this.updateState({...this.#storageState, enabled});\n  }\n\n  /**\n   * The breakpoint condition as entered by the user.\n   */\n  condition(): UserCondition {\n    return this.#storageState.condition;\n  }\n\n  /**\n   * The breakpoint condition as it is sent to V8.\n   */\n  backendCondition(): SDK.DebuggerModel.BackendCondition;\n  backendCondition(location: SDK.DebuggerModel.Location): Promise<SDK.DebuggerModel.BackendCondition>;\n  backendCondition(location?: SDK.DebuggerModel.Location): SDK.DebuggerModel.BackendCondition\n      |Promise<SDK.DebuggerModel.BackendCondition> {\n    const condition: string = this.condition();\n    if (condition === '') {\n      return '' as SDK.DebuggerModel.BackendCondition;\n    }\n\n    const addSourceUrl = (condition: string): SDK.DebuggerModel.BackendCondition => {\n      let sourceUrl = SDK.DebuggerModel.COND_BREAKPOINT_SOURCE_URL;\n      if (this.isLogpoint()) {\n        condition = `${LOGPOINT_PREFIX}${condition}${LOGPOINT_SUFFIX}`;\n        sourceUrl = SDK.DebuggerModel.LOGPOINT_SOURCE_URL;\n      }\n      return `${condition}\\n\\n//# sourceURL=${sourceUrl}` as SDK.DebuggerModel.BackendCondition;\n    };\n\n    if (location) {\n      return SourceMapScopes.NamesResolver.allVariablesAtPosition(location)\n          .then(\n              nameMap => nameMap.size > 0 ?\n                  Formatter.FormatterWorkerPool.formatterWorkerPool().javaScriptSubstitute(condition, nameMap) :\n                  condition)\n          .then(subsitutedCondition => addSourceUrl(subsitutedCondition), () => addSourceUrl(condition));\n    }\n    return addSourceUrl(condition);\n  }\n\n  setCondition(condition: UserCondition, isLogpoint: boolean): void {\n    this.updateState({...this.#storageState, condition, isLogpoint});\n  }\n\n  isLogpoint(): boolean {\n    return this.#storageState.isLogpoint;\n  }\n\n  get storageState(): BreakpointStorageState {\n    return this.#storageState;\n  }\n\n  updateState(newState: BreakpointStorageState): void {\n    // Only 'enabled', 'condition' and 'isLogpoint' can change (except during initialization).\n    if (this.#storageState &&\n        (this.#storageState.url !== newState.url || this.#storageState.lineNumber !== newState.lineNumber ||\n         this.#storageState.columnNumber !== newState.columnNumber)) {\n      throw new Error('Invalid breakpoint state update');\n    }\n    if (this.#storageState?.enabled === newState.enabled && this.#storageState?.condition === newState.condition &&\n        this.#storageState?.isLogpoint === newState.isLogpoint) {\n      return;\n    }\n    this.#storageState = newState;\n    this.breakpointManager.storage.updateBreakpoint(this.#storageState);\n    void this.updateBreakpoint();\n  }\n\n  async updateBreakpoint(): Promise<void> {\n    if (!this.bound()) {\n      this.removeAllUnboundLocations();\n      if (!this.isRemoved) {\n        this.addAllUnboundLocations();\n      }\n    }\n    return this.#updateModels();\n  }\n\n  async remove(keepInStorage: boolean): Promise<void> {\n    if (this.getIsRemoved()) {\n      return;\n    }\n    this.isRemoved = true;\n    const removeFromStorage = !keepInStorage;\n\n    for (const debuggerModel of this.#modelBreakpoints.keys()) {\n      this.#removeDebuggerModelListeners(debuggerModel);\n    }\n    await this.#updateModels();\n\n    this.breakpointManager.removeBreakpoint(this, removeFromStorage);\n    this.breakpointManager.targetManager.unobserveModels(SDK.DebuggerModel.DebuggerModel, this);\n    this.clearUISourceCodes();\n  }\n\n  breakpointStorageId(): string {\n    return Storage.computeId(this.#storageState);\n  }\n\n  private defaultUILocation(uiSourceCode: Workspace.UISourceCode.UISourceCode): Workspace.UISourceCode.UILocation {\n    return BreakpointManager.uiLocationFromBreakpointLocation(\n        uiSourceCode, this.#storageState.lineNumber, this.#storageState.columnNumber);\n  }\n\n  private removeAllUnboundLocations(): void {\n    for (const uiSourceCode of this.uiSourceCodes) {\n      this.breakpointManager.uiLocationRemoved(this, this.defaultUILocation(uiSourceCode));\n    }\n  }\n\n  private addAllUnboundLocations(): void {\n    for (const uiSourceCode of this.uiSourceCodes) {\n      this.breakpointManager.uiLocationAdded(this, this.defaultUILocation(uiSourceCode));\n    }\n  }\n\n  getUiSourceCodes(): Set<Workspace.UISourceCode.UISourceCode> {\n    return this.uiSourceCodes;\n  }\n\n  getIsRemoved(): boolean {\n    return this.isRemoved;\n  }\n\n  async #updateModels(): Promise<void> {\n    await Promise.all(Array.from(this.#modelBreakpoints.values()).map(model => this.#updateModel(model)));\n  }\n\n  async #updateModel(model: ModelBreakpoint): Promise<void> {\n    const result = await model.scheduleUpdateInDebugger();\n    if (result === DebuggerUpdateResult.ERROR_BACKEND) {\n      await this.remove(true /* keepInStorage */);\n    } else if (result === DebuggerUpdateResult.ERROR_BREAKPOINT_CLASH) {\n      await this.remove(false /* keepInStorage */);\n    }\n  }\n}\n\n/**\n * Represents a single `Breakpoint` for a specific target.\n *\n * The `BreakpointManager` unconditionally creates a `ModelBreakpoint` instance\n * for each target since any target could load a matching script after the fact.\n *\n * Each `ModelBreakpoint` can represent multiple actual breakpoints in V8. E.g.\n * inlining in WASM or multiple bundles containing the same utility function.\n *\n * This means each `Modelbreakpoint` represents 0 to n actual breakpoints in\n * for it's specific target.\n */\nexport class ModelBreakpoint {\n  #debuggerModel: SDK.DebuggerModel.DebuggerModel;\n  #breakpoint: Breakpoint;\n  readonly #debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding;\n  readonly #liveLocations = new Bindings.LiveLocation.LiveLocationPool();\n  readonly #uiLocations = new Map<Bindings.LiveLocation.LiveLocation, Workspace.UISourceCode.UILocation>();\n  #updateMutex = new Common.Mutex.Mutex();\n  #cancelCallback = false;\n  #currentState: Breakpoint.State|null = null;\n  #breakpointIds: Protocol.Debugger.BreakpointId[] = [];\n  /**\n   * We track all the script IDs this ModelBreakpoint was actually set in. This allows us\n   * to properly reset this ModelBreakpoint after a script was live edited.\n   */\n  #resolvedScriptIds = new Set<Protocol.Runtime.ScriptId>();\n\n  constructor(\n      debuggerModel: SDK.DebuggerModel.DebuggerModel, breakpoint: Breakpoint,\n      debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding) {\n    this.#debuggerModel = debuggerModel;\n    this.#breakpoint = breakpoint;\n    this.#debuggerWorkspaceBinding = debuggerWorkspaceBinding;\n  }\n\n  get currentState(): Breakpoint.State|null {\n    return this.#currentState;\n  }\n\n  resetLocations(): void {\n    for (const uiLocation of this.#uiLocations.values()) {\n      this.#breakpoint.uiLocationRemoved(uiLocation);\n    }\n\n    this.#uiLocations.clear();\n    this.#liveLocations.disposeAll();\n    this.#resolvedScriptIds.clear();\n  }\n\n  async scheduleUpdateInDebugger(): Promise<ScheduleUpdateResult> {\n    if (!this.#debuggerModel.debuggerEnabled()) {\n      return DebuggerUpdateResult.OK;\n    }\n\n    const release = await this.#updateMutex.acquire();\n    let result = DebuggerUpdateResult.PENDING;\n    while (result === DebuggerUpdateResult.PENDING) {\n      result = await this.#updateInDebugger();\n    }\n    release();\n    return result;\n  }\n\n  private scriptDiverged(): boolean {\n    for (const uiSourceCode of this.#breakpoint.getUiSourceCodes()) {\n      const scriptFile = this.#debuggerWorkspaceBinding.scriptFile(uiSourceCode, this.#debuggerModel);\n      if (scriptFile && scriptFile.hasDivergedFromVM()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  async #updateInDebugger(): Promise<DebuggerUpdateResult> {\n    if (this.#debuggerModel.target().isDisposed()) {\n      this.cleanUpAfterDebuggerIsGone();\n      return DebuggerUpdateResult.OK;\n    }\n    const lineNumber = this.#breakpoint.lineNumber();\n    const columnNumber = this.#breakpoint.columnNumber();\n    const condition = this.#breakpoint.backendCondition();\n\n    // Calculate the new state.\n    let newState: Breakpoint.State|null = null;\n    if (!this.#breakpoint.getIsRemoved() && this.#breakpoint.enabled() && !this.scriptDiverged()) {\n      let debuggerLocations: SDK.DebuggerModel.Location[] = [];\n      for (const uiSourceCode of this.#breakpoint.getUiSourceCodes()) {\n        const {lineNumber: uiLineNumber, columnNumber: uiColumnNumber} =\n            BreakpointManager.uiLocationFromBreakpointLocation(uiSourceCode, lineNumber, columnNumber);\n        const locations =\n            await Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().uiLocationToRawLocations(\n                uiSourceCode, uiLineNumber, uiColumnNumber);\n        debuggerLocations = locations.filter(location => location.debuggerModel === this.#debuggerModel);\n        if (debuggerLocations.length) {\n          break;\n        }\n      }\n      if (debuggerLocations.length && debuggerLocations.every(loc => loc.script())) {\n        const positions = await Promise.all(debuggerLocations.map(async loc => {\n          const script = loc.script() as SDK.Script.Script;\n          const condition = await this.#breakpoint.backendCondition(loc);\n          return {\n            url: script.sourceURL,\n            scriptHash: script.hash,\n            lineNumber: loc.lineNumber,\n            columnNumber: loc.columnNumber,\n            condition,\n          };\n        }));\n        newState = positions.slice(0);  // Create a copy\n      } else if (!Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n        // Use this fallback if we do not have instrumentation breakpoints enabled yet. This currently makes\n        // sure that v8 knows about the breakpoint and is able to restore it whenever the script is parsed.\n        const lastResolvedState = this.#breakpoint.getLastResolvedState();\n        if (lastResolvedState) {\n          // Re-use position information from fallback but use up-to-date condition.\n          newState = lastResolvedState.map(position => ({...position, condition}));\n        } else {\n          // TODO(bmeurer): This fallback doesn't make a whole lot of sense, we should\n          // at least signal a warning to the developer that this #breakpoint wasn't\n          // really resolved.\n          const position = {\n            url: this.#breakpoint.url(),\n            scriptHash: '',\n            lineNumber,\n            columnNumber,\n            condition,\n          };\n          newState = [position];\n        }\n      }\n    }\n    const hasBackendState = this.#breakpointIds.length;\n\n    // Case 1: Back-end has some breakpoints and the new state is a proper subset\n    // of the back-end state (in particular the new state contains at least a single\n    // position, meaning we're not removing the breakpoint completely).\n    if (hasBackendState && Breakpoint.State.subset(newState, this.#currentState)) {\n      return DebuggerUpdateResult.OK;\n    }\n\n    this.#breakpoint.updateLastResolvedState(newState);\n\n    // Case 2: State has changed, and the back-end has outdated information on old\n    // breakpoints.\n    if (hasBackendState) {\n      // Reset the current state.\n      await this.resetBreakpoint();\n      // Schedule another run of updates, to finally update to the new state.\n      return DebuggerUpdateResult.PENDING;\n    }\n\n    // Case 3: State is null (no breakpoints to set), and back-end is up to date\n    // (no info on breakpoints).\n    if (!newState) {\n      return DebuggerUpdateResult.OK;\n    }\n\n    // Case 4: State is not null, so we have breakpoints to set and the back-end\n    // has no information on breakpoints yet. Set the breakpoints.\n    const {breakpointIds, locations, serverError} = await this.#setBreakpointOnBackend(newState);\n\n    const maybeRescheduleUpdate =\n        serverError && this.#debuggerModel.debuggerEnabled() && !this.#debuggerModel.isReadyToPause();\n    if (!breakpointIds.length && maybeRescheduleUpdate) {\n      // TODO(crbug.com/1229541): This is a quickfix to prevent #breakpoints from\n      // disappearing if the Debugger is actually not enabled\n      // yet. This quickfix should be removed as soon as we have a solution\n      // to correctly synchronize the front-end with the inspector back-end.\n      return DebuggerUpdateResult.PENDING;\n    }\n\n    this.#currentState = newState;\n    if (this.#cancelCallback) {\n      this.#cancelCallback = false;\n      return DebuggerUpdateResult.OK;\n    }\n\n    // Something went wrong: we expect to have a non-null state, but have not received any\n    // breakpointIds from the back-end.\n    if (!breakpointIds.length) {\n      return DebuggerUpdateResult.ERROR_BACKEND;\n    }\n\n    this.#breakpointIds = breakpointIds;\n    this.#breakpointIds.forEach(\n        breakpointId => this.#debuggerModel.addBreakpointListener(breakpointId, this.breakpointResolved, this));\n    const resolvedResults = await Promise.all(locations.map(location => this.addResolvedLocation(location)));\n\n    // Breakpoint clash: the resolved location resolves to a different breakpoint, report an error.\n    if (resolvedResults.includes(ResolveLocationResult.ERROR)) {\n      return DebuggerUpdateResult.ERROR_BREAKPOINT_CLASH;\n    }\n    return DebuggerUpdateResult.OK;\n  }\n\n  async #setBreakpointOnBackend(positions: Breakpoint.State): Promise<{\n    breakpointIds: Protocol.Debugger.BreakpointId[],\n    locations: SDK.DebuggerModel.Location[],\n    serverError: boolean,\n  }> {\n    const results = await Promise.all(positions.map(pos => {\n      if (pos.url) {\n        return this.#debuggerModel.setBreakpointByURL(pos.url, pos.lineNumber, pos.columnNumber, pos.condition);\n      }\n      return this.#debuggerModel.setBreakpointInAnonymousScript(\n          pos.scriptHash as string, pos.lineNumber, pos.columnNumber, pos.condition);\n    }));\n    const breakpointIds: Protocol.Debugger.BreakpointId[] = [];\n    let locations: SDK.DebuggerModel.Location[] = [];\n    let serverError = false;\n    for (const result of results) {\n      if (result.breakpointId) {\n        breakpointIds.push(result.breakpointId);\n        locations = locations.concat(result.locations);\n      } else {\n        serverError = true;\n      }\n    }\n    return {breakpointIds, locations, serverError};\n  }\n\n  async resetBreakpoint(): Promise<void> {\n    if (!this.#breakpointIds.length) {\n      return;\n    }\n    this.resetLocations();\n    await Promise.all(this.#breakpointIds.map(id => this.#debuggerModel.removeBreakpoint(id)));\n    this.didRemoveFromDebugger();\n    this.#currentState = null;\n  }\n\n  private didRemoveFromDebugger(): void {\n    if (this.#cancelCallback) {\n      this.#cancelCallback = false;\n      return;\n    }\n\n    this.resetLocations();\n    this.#breakpointIds.forEach(\n        breakpointId => this.#debuggerModel.removeBreakpointListener(breakpointId, this.breakpointResolved, this));\n    this.#breakpointIds = [];\n  }\n\n  private async breakpointResolved({data: location}: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.Location>):\n      Promise<void> {\n    const result = await this.addResolvedLocation(location);\n    if (result === ResolveLocationResult.ERROR) {\n      await this.#breakpoint.remove(false /* keepInStorage */);\n    }\n  }\n\n  private async locationUpdated(liveLocation: Bindings.LiveLocation.LiveLocation): Promise<void> {\n    const oldUILocation = this.#uiLocations.get(liveLocation);\n    const uiLocation = await liveLocation.uiLocation();\n\n    if (oldUILocation) {\n      this.#breakpoint.uiLocationRemoved(oldUILocation);\n    }\n\n    if (uiLocation) {\n      this.#uiLocations.set(liveLocation, uiLocation);\n      this.#breakpoint.uiLocationAdded(uiLocation);\n    } else {\n      this.#uiLocations.delete(liveLocation);\n    }\n  }\n\n  private async addResolvedLocation(location: SDK.DebuggerModel.Location): Promise<ResolveLocationResult> {\n    this.#resolvedScriptIds.add(location.scriptId);\n    const uiLocation = await this.#debuggerWorkspaceBinding.rawLocationToUILocation(location);\n    if (!uiLocation) {\n      return ResolveLocationResult.OK;\n    }\n    const breakpointLocation = this.#breakpoint.breakpointManager.findBreakpoint(uiLocation);\n    if (breakpointLocation && breakpointLocation.breakpoint !== this.#breakpoint) {\n      // location clash\n      return ResolveLocationResult.ERROR;\n    }\n    await this.#debuggerWorkspaceBinding.createLiveLocation(\n        location, this.locationUpdated.bind(this), this.#liveLocations);\n    return ResolveLocationResult.OK;\n  }\n\n  cleanUpAfterDebuggerIsGone(): void {\n    this.#cancelCallback = true;\n    this.resetLocations();\n    this.#currentState = null;\n    if (this.#breakpointIds.length) {\n      this.didRemoveFromDebugger();\n    }\n  }\n\n  /** @returns true, iff this `ModelBreakpoint` was set (at some point) in `scriptId` */\n  wasSetIn(scriptId: Protocol.Runtime.ScriptId): boolean {\n    return this.#resolvedScriptIds.has(scriptId);\n  }\n}\n\n/**\n * A concrete breakpoint position in a specific target. Each `ModelBreakpoint`\n * consists of multiple of these.\n *\n * Note that a `Position` only denotes where we *want* to set a breakpoint, not\n * where it was actually set by V8 after the fact.\n */\ninterface Position {\n  url: Platform.DevToolsPath.UrlString;\n  scriptHash: string;\n  lineNumber: number;\n  columnNumber?: number;\n  condition: SDK.DebuggerModel.BackendCondition;\n}\n\nexport const enum BreakpointOrigin {\n  USER_ACTION = 'USER_ACTION',\n  OTHER = 'RESTORED',\n}\n\nexport namespace Breakpoint {\n\n  export type State = Position[];\n  export namespace State {\n    export function subset(stateA?: State|null, stateB?: State|null): boolean {\n      if (stateA === stateB) {\n        return true;\n      }\n      if (!stateA || !stateB) {\n        return false;\n      }\n      if (stateA.length === 0) {\n        return false;\n      }\n      for (const positionA of stateA) {\n        if (stateB.find(\n                positionB => positionA.url === positionB.url && positionA.scriptHash === positionB.scriptHash &&\n                    positionA.lineNumber === positionB.lineNumber &&\n                    positionA.columnNumber === positionB.columnNumber &&\n                    positionA.condition === positionB.condition) === undefined) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n}\n\nclass Storage {\n  readonly setting: Common.Settings.Setting<BreakpointStorageState[]>;\n  readonly breakpoints: Map<string, BreakpointStorageState>;\n  #muted: boolean;\n\n  constructor() {\n    this.setting = Common.Settings.Settings.instance().createLocalSetting('breakpoints', []);\n    this.breakpoints = new Map();\n    this.#muted = false;\n    for (const breakpoint of this.setting.get()) {\n      this.breakpoints.set(Storage.computeId(breakpoint), breakpoint);\n    }\n  }\n\n  mute(): void {\n    this.#muted = true;\n  }\n\n  unmute(): void {\n    this.#muted = false;\n  }\n\n  breakpointItems(url: Platform.DevToolsPath.UrlString, resourceTypeName?: string): BreakpointStorageState[] {\n    const breakpoints = [];\n    for (const breakpoint of this.breakpoints.values()) {\n      if (breakpoint.url !== url) {\n        continue;\n      }\n      if (breakpoint.resourceTypeName !== resourceTypeName && resourceTypeName !== undefined) {\n        continue;\n      }\n      breakpoints.push(breakpoint);\n    }\n    return breakpoints;\n  }\n\n  updateBreakpoint(storageState: BreakpointStorageState): void {\n    if (this.#muted) {\n      return;\n    }\n    const storageId = Storage.computeId(storageState);\n    if (!storageId) {\n      return;\n    }\n    // Delete the breakpoint and re-insert it so that it is moved to the last position in the iteration order.\n    this.breakpoints.delete(storageId);\n    this.breakpoints.set(storageId, storageState);\n    this.save();\n  }\n\n  removeBreakpoint(storageId: string): void {\n    if (this.#muted) {\n      return;\n    }\n    this.breakpoints.delete(storageId);\n    this.save();\n  }\n\n  private save(): void {\n    this.setting.set(Array.from(this.breakpoints.values()));\n  }\n\n  static computeId({url, resourceTypeName, lineNumber, columnNumber}: BreakpointStorageState): string {\n    if (!url) {\n      return '';\n    }\n    let id = `${url}:${resourceTypeName}:${lineNumber}`;\n    if (columnNumber !== undefined) {\n      id += `:${columnNumber}`;\n    }\n    return id;\n  }\n}\n\nfunction resolvedStateEqual(\n    lhs: ScriptBreakpointLocation[]|undefined, rhs: ScriptBreakpointLocation[]|undefined): boolean {\n  if (lhs === rhs) {\n    return true;\n  }\n  if (!lhs || !rhs || lhs.length !== rhs.length) {\n    return false;\n  }\n  for (let i = 0; i < lhs.length; i++) {\n    const lhsLoc = lhs[i];\n    const rhsLoc = rhs[i];\n    if (lhsLoc.url !== rhsLoc.url || lhsLoc.lineNumber !== rhsLoc.lineNumber ||\n        lhsLoc.columnNumber !== rhsLoc.columnNumber || lhsLoc.condition !== rhsLoc.condition) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * A breakpoint condition as entered by the user. We use the type to\n * distinguish from {@link SDK.DebuggerModel.BackendCondition}.\n */\nexport type UserCondition = Platform.Brand.Brand<string, 'UserCondition'>;\nexport const EMPTY_BREAKPOINT_CONDITION = '' as UserCondition;\nexport const NEVER_PAUSE_HERE_CONDITION = 'false' as UserCondition;\n\nexport interface ScriptBreakpointLocation {\n  readonly url: Platform.DevToolsPath.UrlString;\n  readonly lineNumber: number;\n  readonly columnNumber?: number;\n  readonly condition: SDK.DebuggerModel.BackendCondition;\n}\n\n/**\n * All the data for a single `Breakpoint` thats stored in the settings.\n * Whenever any of these change, we need to update the settings.\n */\nexport interface BreakpointStorageState {\n  readonly url: Platform.DevToolsPath.UrlString;\n  readonly resourceTypeName: string;\n  readonly lineNumber: number;\n  readonly columnNumber?: number;\n  readonly condition: UserCondition;\n  readonly enabled: boolean;\n  readonly isLogpoint: boolean;\n  readonly resolvedState?: ScriptBreakpointLocation[];\n}\n\nexport class BreakpointLocation {\n  readonly breakpoint: Breakpoint;\n  readonly uiLocation: Workspace.UISourceCode.UILocation;\n\n  constructor(breakpoint: Breakpoint, uiLocation: Workspace.UISourceCode.UILocation) {\n    this.breakpoint = breakpoint;\n    this.uiLocation = uiLocation;\n  }\n}\n\nconst LOGPOINT_PREFIX = '/** DEVTOOLS_LOGPOINT */ console.log(';\nconst LOGPOINT_SUFFIX = ')';\n"],
  "mappings": "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",
  "names": ["uiSourceCode", "Events", "DebuggerUpdateResult", "ResolveLocationResult", "condition", "locations", "BreakpointOrigin", "Breakpoint", "State"]
}
