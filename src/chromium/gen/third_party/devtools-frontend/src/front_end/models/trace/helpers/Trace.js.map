{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/helpers/Trace.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\nimport {SyntheticEventsManager} from './SyntheticEvents.js';\nimport {eventTimingsMicroSeconds} from './Timing.js';\n\ntype MatchedPairType<T extends Types.Events.PairableAsync> = Types.Events.SyntheticEventPair<T>;\ntype MatchingPairableAsyncEvents = {\n  begin: Types.Events.PairableAsyncBegin|null,\n  end: Types.Events.PairableAsyncEnd|null,\n  instant?: Types.Events.PairableAsyncInstant[],\n};\n\n/**\n * Extracts the raw stack trace of known trace events. Most likely than\n * not you want to use `getZeroIndexedStackTraceForEvent`, which returns\n * the stack with zero based numbering. Since some trace events are\n * one based this function can yield unexpected results when used\n * indiscriminately.\n */\nexport function stackTraceForEvent(event: Types.Events.Event): Types.Events.CallFrame[]|null {\n  if (event.args?.data?.stackTrace) {\n    return event.args.data.stackTrace;\n  }\n  if (event.args?.stackTrace) {\n    return event.args.stackTrace;\n  }\n  if (Types.Events.isUpdateLayoutTree(event)) {\n    return event.args.beginData?.stackTrace || null;\n  }\n  if (Types.Extensions.isSyntheticExtensionEntry(event)) {\n    return stackTraceForEvent(event.rawSourceEvent);\n  }\n  if (Types.Events.isSyntheticUserTiming(event)) {\n    return stackTraceForEvent(event.rawSourceEvent);\n  }\n  return null;\n}\n\nexport function extractOriginFromTrace(firstNavigationURL: string): string|null {\n  const url = Common.ParsedURL.ParsedURL.fromString(firstNavigationURL);\n  if (url) {\n    // We do this to save some space in the toolbar - seeing the `www` is less\n    // useful than seeing `foo.com` if it's truncated at narrow widths\n    if (url.host.startsWith('www.')) {\n      return url.host.slice(4);\n    }\n    return url.host;\n  }\n  return null;\n}\n\nexport type EventsInThread<T extends Types.Events.Event> = Map<Types.Events.ThreadID, T[]>;\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nexport function addEventToProcessThread<T extends Types.Events.Event>(\n    event: T,\n    eventsInProcessThread: Map<Types.Events.ProcessID, EventsInThread<T>>,\n    ): void {\n  const {tid, pid} = event;\n  let eventsInThread = eventsInProcessThread.get(pid);\n  if (!eventsInThread) {\n    eventsInThread = new Map<Types.Events.ThreadID, T[]>();\n  }\n\n  let events = eventsInThread.get(tid);\n  if (!events) {\n    events = [];\n  }\n\n  events.push(event);\n  eventsInThread.set(event.tid, events);\n  eventsInProcessThread.set(event.pid, eventsInThread);\n}\n\nexport type TimeSpan = {\n  ts: Types.Timing.MicroSeconds,\n  dur?: Types.Timing.MicroSeconds,\n};\nexport function eventTimeComparator(a: TimeSpan, b: TimeSpan): -1|0|1 {\n  const aBeginTime = a.ts;\n  const bBeginTime = b.ts;\n  if (aBeginTime < bBeginTime) {\n    return -1;\n  }\n  if (aBeginTime > bBeginTime) {\n    return 1;\n  }\n  const aDuration = a.dur ?? 0;\n  const bDuration = b.dur ?? 0;\n  const aEndTime = aBeginTime + aDuration;\n  const bEndTime = bBeginTime + bDuration;\n  if (aEndTime > bEndTime) {\n    return -1;\n  }\n  if (aEndTime < bEndTime) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Sorts all the events in place, in order, by their start time. If they have\n * the same start time, orders them by longest first.\n */\nexport function sortTraceEventsInPlace(events: {ts: Types.Timing.MicroSeconds, dur?: Types.Timing.MicroSeconds}[]):\n    void {\n  events.sort(eventTimeComparator);\n}\n\n/**\n * Returns an array of ordered events that results after merging the two\n * ordered input arrays.\n */\nexport function mergeEventsInOrder<T1 extends Types.Events.Event, T2 extends Types.Events.Event>(\n    eventsArray1: readonly T1[], eventsArray2: readonly T2[]): (T1|T2)[] {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < eventsArray1.length && j < eventsArray2.length) {\n    const event1 = eventsArray1[i];\n    const event2 = eventsArray2[j];\n    const compareValue = eventTimeComparator(event1, event2);\n    if (compareValue <= 0) {\n      result.push(event1);\n      i++;\n    }\n    if (compareValue === 1) {\n      result.push(event2);\n      j++;\n    }\n  }\n  while (i < eventsArray1.length) {\n    result.push(eventsArray1[i++]);\n  }\n  while (j < eventsArray2.length) {\n    result.push(eventsArray2[j++]);\n  }\n  return result;\n}\n\nexport function getNavigationForTraceEvent(\n    event: Types.Events.Event,\n    eventFrameId: string,\n    navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>,\n    ): Types.Events.NavigationStart|null {\n  const navigations = navigationsByFrameId.get(eventFrameId);\n  if (!navigations || eventFrameId === '') {\n    // This event's navigation has been filtered out by the meta handler as a noise event\n    // or contains an empty frameId.\n    return null;\n  }\n\n  const eventNavigationIndex =\n      Platform.ArrayUtilities.nearestIndexFromEnd(navigations, navigation => navigation.ts <= event.ts);\n\n  if (eventNavigationIndex === null) {\n    // This event's navigation has been filtered out by the meta handler as a noise event.\n    return null;\n  }\n  return navigations[eventNavigationIndex];\n}\n\nexport function extractId(event: Types.Events.PairableAsync|MatchedPairType<Types.Events.PairableAsync>): string|\n    undefined {\n  return event.id ?? event.id2?.global ?? event.id2?.local;\n}\n\nexport function activeURLForFrameAtTime(\n    frameId: string, time: Types.Timing.MicroSeconds,\n    rendererProcessesByFrame: Map<\n        string,\n        Map<Types.Events.ProcessID, {frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicroSeconds}[]>>):\n    string|null {\n  const processData = rendererProcessesByFrame.get(frameId);\n  if (!processData) {\n    return null;\n  }\n  for (const processes of processData.values()) {\n    for (const processInfo of processes) {\n      if (processInfo.window.min > time || processInfo.window.max < time) {\n        continue;\n      }\n      return processInfo.frame.url;\n    }\n  }\n  return null;\n}\n\n/**\n * @param node the node attached to the profile call. Here a node represents a function in the call tree.\n * @param profileId the profile ID that the sample came from that backs this call.\n * @param sampleIndex the index of the sample in the given profile that this call was created from\n * @param ts the timestamp of the profile call\n * @param pid the process ID of the profile call\n * @param tid the thread ID of the profile call\n *\n * See `panels/timeline/docs/profile_calls.md` for more context on how these events are created.\n */\nexport function makeProfileCall(\n    node: CPUProfile.ProfileTreeModel.ProfileNode, profileId: Types.Events.ProfileID, sampleIndex: number,\n    ts: Types.Timing.MicroSeconds, pid: Types.Events.ProcessID,\n    tid: Types.Events.ThreadID): Types.Events.SyntheticProfileCall {\n  return {\n    cat: '',\n    name: 'ProfileCall',\n    nodeId: node.id,\n    args: {},\n    ph: Types.Events.Phase.COMPLETE,\n    pid,\n    tid,\n    ts,\n    dur: Types.Timing.MicroSeconds(0),\n    callFrame: node.callFrame,\n    sampleIndex,\n    profileId,\n  };\n}\n\n/**\n * Matches beginning events with PairableAsyncEnd and PairableAsyncInstant (ASYNC_NESTABLE_INSTANT)\n * if provided, though currently only coming from Animations. Traces may contain multiple instant events so we need to\n * account for that.\n *\n * @returns {Map<string, MatchingPairableAsyncEvents>} Map of the animation's ID to it's matching events.\n */\nexport function matchEvents(unpairedEvents: Types.Events.PairableAsync[]): Map<string, MatchingPairableAsyncEvents> {\n  // map to store begin and end of the event\n  const matchedPairs: Map<string, MatchingPairableAsyncEvents> = new Map();\n\n  // looking for start and end\n  for (const event of unpairedEvents) {\n    const syntheticId = getSyntheticId(event);\n    if (syntheticId === undefined) {\n      continue;\n    }\n    // Create a synthetic id to prevent collisions across categories.\n    // Console timings can be dispatched with the same id, so use the\n    // event name as well to generate unique ids.\n    const otherEventsWithID = Platform.MapUtilities.getWithDefault(matchedPairs, syntheticId, () => {\n      return {begin: null, end: null, instant: []};\n    });\n\n    const isStartEvent = event.ph === Types.Events.Phase.ASYNC_NESTABLE_START;\n    const isEndEvent = event.ph === Types.Events.Phase.ASYNC_NESTABLE_END;\n    const isInstantEvent = event.ph === Types.Events.Phase.ASYNC_NESTABLE_INSTANT;\n\n    if (isStartEvent) {\n      otherEventsWithID.begin = event as Types.Events.PairableAsyncBegin;\n    } else if (isEndEvent) {\n      otherEventsWithID.end = event as Types.Events.PairableAsyncEnd;\n    } else if (isInstantEvent) {\n      if (!otherEventsWithID.instant) {\n        otherEventsWithID.instant = [];\n      }\n      otherEventsWithID.instant.push(event as Types.Events.PairableAsyncInstant);\n    }\n  }\n  return matchedPairs;\n}\n\nfunction getSyntheticId(event: Types.Events.PairableAsync): string|undefined {\n  const id = extractId(event);\n  return id && `${event.cat}:${id}:${event.name}`;\n}\n\nexport function createSortedSyntheticEvents<T extends Types.Events.PairableAsync>(\n    matchedPairs: Map<string, {\n      begin: Types.Events.PairableAsyncBegin | null,\n      end: Types.Events.PairableAsyncEnd | null,\n      instant?: Types.Events.PairableAsyncInstant[],\n    }>,\n    syntheticEventCallback?: (syntheticEvent: MatchedPairType<T>) => void,\n    ): MatchedPairType<T>[] {\n  const syntheticEvents: MatchedPairType<T>[] = [];\n  for (const [id, eventsTriplet] of matchedPairs.entries()) {\n    const beginEvent = eventsTriplet.begin;\n    const endEvent = eventsTriplet.end;\n    const instantEvents = eventsTriplet.instant;\n    if (!beginEvent || !(endEvent || instantEvents)) {\n      // This should never happen, the backend only creates the events once it\n      // has them both (beginEvent & endEvent/instantEvents), so we should never get into this state.\n      // If we do, something is very wrong, so let's just drop that problematic event.\n      continue;\n    }\n    const triplet = {beginEvent, endEvent, instantEvents};\n    /**\n     * When trying to pair events with instant events present, there are times when these\n     * ASYNC_NESTABLE_INSTANT ('n') don't have a corresponding ASYNC_NESTABLE_END ('e') event.\n     * In these cases, pair without needing the endEvent.\n     */\n    function eventsArePairable(data: {\n      beginEvent: Types.Events.PairableAsyncBegin,\n      endEvent: Types.Events.PairableAsyncEnd|null,\n      instantEvents?: Types.Events.PairableAsyncInstant[],\n    }): data is MatchedPairType<T>['args']['data'] {\n      const instantEventsMatch = data.instantEvents ? data.instantEvents.some(e => id === getSyntheticId(e)) : false;\n      const endEventMatch = data.endEvent ? id === getSyntheticId(data.endEvent) : false;\n      return Boolean(id) && (instantEventsMatch || endEventMatch);\n    }\n    if (!eventsArePairable(triplet)) {\n      continue;\n    }\n    const targetEvent = endEvent || beginEvent;\n\n    const event = SyntheticEventsManager.registerSyntheticEvent<MatchedPairType<T>>({\n      rawSourceEvent: beginEvent,\n      cat: targetEvent.cat,\n      ph: targetEvent.ph,\n      pid: targetEvent.pid,\n      tid: targetEvent.tid,\n      id,\n      // Both events have the same name, so it doesn't matter which we pick to\n      // use as the description\n      name: beginEvent.name,\n      dur: Types.Timing.MicroSeconds(targetEvent.ts - beginEvent.ts),\n      ts: beginEvent.ts,\n      args: {\n        data: triplet,\n      },\n    });\n\n    if (event.dur < 0) {\n      // We have seen in the backend that sometimes animation events get\n      // generated with multiple begin entries, or multiple end entries, and this\n      // can cause invalid data on the performance panel, so we drop them.\n      // crbug.com/1472375\n      continue;\n    }\n    syntheticEventCallback?.(event);\n    syntheticEvents.push(event);\n  }\n  return syntheticEvents.sort((a, b) => a.ts - b.ts);\n}\n\nexport function createMatchedSortedSyntheticEvents<T extends Types.Events.PairableAsync>(\n    unpairedAsyncEvents: T[],\n    syntheticEventCallback?: (syntheticEvent: MatchedPairType<T>) => void): MatchedPairType<T>[] {\n  const matchedPairs = matchEvents(unpairedAsyncEvents);\n  const syntheticEvents = createSortedSyntheticEvents<T>(matchedPairs, syntheticEventCallback);\n  return syntheticEvents;\n}\n\n/**\n * Different trace events return line/column numbers that are 1 or 0 indexed.\n * This function knows which events return 1 indexed numbers and normalizes\n * them. The UI expects 0 indexed line numbers, so that is what we return.\n */\nexport function getZeroIndexedLineAndColumnForEvent(event: Types.Events.Event): {\n  lineNumber?: number,\n  columnNumber?: number,\n} {\n  // Some events emit line numbers that are 1 indexed, but the UI layer expects\n  // numbers to be 0 indexed. So here, if the event matches a known 1-indexed\n  // number event, we subtract one from the line and column numbers.\n  // Otherwise, if the event has args.data.lineNumber/colNumber, we return it\n  // as is.\n  const numbers = getRawLineAndColumnNumbersForEvent(event);\n  const {lineNumber, columnNumber} = numbers;\n\n  switch (event.name) {\n    // All these events have line/column numbers which are 1 indexed; so we\n    // subtract to make them 0 indexed.\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.EVALUATE_SCRIPT:\n    case Types.Events.Name.COMPILE:\n    case Types.Events.Name.CACHE_SCRIPT: {\n      return {\n        lineNumber: typeof lineNumber === 'number' ? lineNumber - 1 : undefined,\n        columnNumber: typeof columnNumber === 'number' ? columnNumber - 1 : undefined,\n      };\n    }\n    default: {\n      return numbers;\n    }\n  }\n}\n\n/**\n * Different trace events contain stack traces with line/column numbers\n * that are 1 or 0 indexed.\n * This function knows which events return 1 indexed numbers and normalizes\n * them. The UI expects 0 indexed line numbers, so that is what we return.\n */\nexport function getZeroIndexedStackTraceForEvent(event: Types.Events.Event): Types.Events.CallFrame[]|null {\n  const stack = stackTraceForEvent(event);\n  if (!stack) {\n    return null;\n  }\n  return stack.map(callFrame => {\n    switch (event.name) {\n      case Types.Events.Name.SCHEDULE_STYLE_RECALCULATION:\n      case Types.Events.Name.INVALIDATE_LAYOUT:\n      case Types.Events.Name.UPDATE_LAYOUT_TREE: {\n        return makeZeroBasedCallFrame(callFrame);\n      }\n      default: {\n        if (Types.Events.isUserTiming(event) || Types.Extensions.isSyntheticExtensionEntry(event)) {\n          return makeZeroBasedCallFrame(callFrame);\n        }\n      }\n    }\n    return callFrame;\n  });\n}\n\n/**\n * Given a 1-based call frame creates a 0-based one.\n */\nexport function makeZeroBasedCallFrame(callFrame: Types.Events.CallFrame): Types.Events.CallFrame {\n  const normalizedCallFrame = {...callFrame};\n\n  normalizedCallFrame.lineNumber = callFrame.lineNumber && callFrame.lineNumber - 1;\n  normalizedCallFrame.columnNumber = callFrame.columnNumber && callFrame.columnNumber - 1;\n  return normalizedCallFrame;\n}\n\n/**\n * NOTE: you probably do not want this function! (Which is why it is not exported).\n *\n * Some trace events have 0 indexed line/column numbers, and others have 1\n * indexed. This function does NOT normalize them, but\n * `getZeroIndexedLineAndColumnNumbersForEvent` does. It is best to use that!\n *\n * @see {@link getZeroIndexedLineAndColumnForEvent}\n **/\nfunction getRawLineAndColumnNumbersForEvent(event: Types.Events.Event): {\n  lineNumber?: number,\n  columnNumber?: number,\n} {\n  if (!event.args?.data) {\n    return {\n      lineNumber: undefined,\n      columnNumber: undefined,\n    };\n  }\n  let lineNumber: number|undefined = undefined;\n  let columnNumber: number|undefined = undefined;\n  if ('lineNumber' in event.args.data && typeof event.args.data.lineNumber === 'number') {\n    lineNumber = event.args.data.lineNumber;\n  }\n  if ('columnNumber' in event.args.data && typeof event.args.data.columnNumber === 'number') {\n    columnNumber = event.args.data.columnNumber;\n  }\n\n  return {lineNumber, columnNumber};\n}\n\nexport function frameIDForEvent(event: Types.Events.Event): string|null {\n  // There are a few events (for example UpdateLayoutTree, ParseHTML) that have\n  // the frame stored in args.beginData\n  // Rather than list them all we just check for the presence of the field, so\n  // we are robust against future trace events also doing this.\n  // This check seems very robust, but it also helps satisfy TypeScript and\n  // prevents us against unexpected data.\n  if (event.args && 'beginData' in event.args && typeof event.args.beginData === 'object' &&\n      event.args.beginData !== null && 'frame' in event.args.beginData &&\n      typeof event.args.beginData.frame === 'string') {\n    return event.args.beginData.frame;\n  }\n  // Otherwise, we expect frame to be in args.data\n  if (event.args?.data?.frame) {\n    return event.args.data.frame;\n  }\n\n  // No known frame for this event.\n  return null;\n}\n\nconst DevToolsTimelineEventCategory = 'disabled-by-default-devtools.timeline';\nexport function isTopLevelEvent(event: Types.Events.Event): boolean {\n  if (event.name === 'JSRoot' && event.cat === 'toplevel') {\n    // This is used in TimelineJSProfile to insert a fake event prior to the\n    // CPU Profile in order to ensure the trace isn't truncated. So if we see\n    // this, we want to treat it as a top level event.\n    // TODO(crbug.com/341234884): do we need this?\n    return true;\n  }\n  return event.cat.includes(DevToolsTimelineEventCategory) && event.name === Types.Events.Name.RUN_TASK;\n}\n\nfunction topLevelEventIndexEndingAfter(events: Types.Events.Event[], time: Types.Timing.MicroSeconds): number {\n  let index = Platform.ArrayUtilities.upperBound(events, time, (time, event) => time - event.ts) - 1;\n  while (index > 0 && !isTopLevelEvent(events[index])) {\n    index--;\n  }\n  return Math.max(index, 0);\n}\nexport function findUpdateLayoutTreeEvents(\n    events: Types.Events.Event[], startTime: Types.Timing.MicroSeconds,\n    endTime?: Types.Timing.MicroSeconds): Types.Events.UpdateLayoutTree[] {\n  const foundEvents: Types.Events.UpdateLayoutTree[] = [];\n  const startEventIndex = topLevelEventIndexEndingAfter(events, startTime);\n  for (let i = startEventIndex; i < events.length; i++) {\n    const event = events[i];\n    if (!Types.Events.isUpdateLayoutTree(event)) {\n      continue;\n    }\n    if (event.ts >= (endTime || Infinity)) {\n      continue;\n    }\n    foundEvents.push(event);\n  }\n  return foundEvents;\n}\n\nexport function findNextEventAfterTimestamp<T extends Types.Events.Event>(\n    candidates: T[], ts: Types.Timing.MicroSeconds): T|null {\n  const index = Platform.ArrayUtilities.nearestIndexFromBeginning(candidates, candidate => ts < candidate.ts);\n  return index === null ? null : candidates[index];\n}\n\nexport function findPreviousEventBeforeTimestamp<T extends Types.Events.Event>(\n    candidates: T[], ts: Types.Timing.MicroSeconds): T|null {\n  const index = Platform.ArrayUtilities.nearestIndexFromEnd(candidates, candidate => candidate.ts < ts);\n  return index === null ? null : candidates[index];\n}\n\nexport interface ForEachEventConfig {\n  onStartEvent: (event: Types.Events.Event) => void;\n  onEndEvent: (event: Types.Events.Event) => void;\n  onInstantEvent?: (event: Types.Events.Event) => void;\n  eventFilter?: (event: Types.Events.Event) => boolean;\n  startTime?: Types.Timing.MicroSeconds;\n  endTime?: Types.Timing.MicroSeconds;\n  /* If async events should be skipped. Defaults to true */\n  ignoreAsyncEvents?: boolean;\n}\n\n/**\n * Iterates events in a tree hierarchically, from top to bottom,\n * calling back on every event's start and end in the order\n * dictated by the corresponding timestamp.\n *\n * Events are assumed to be in ascendent order by timestamp.\n *\n * Events with 0 duration are treated as instant events. These do not have a\n * begin and end, but will be passed to the config.onInstantEvent callback as\n * they are discovered. Do not provide this callback if you are not interested\n * in them.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |---------------A---------------|\n *  |------B------||-------D------|\n *    |---C---|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n *\n * By default, async events are skipped. This behaviour can be\n * overriden making use of the config.ignoreAsyncEvents parameter.\n */\nexport function forEachEvent(\n    events: Types.Events.Event[],\n    config: ForEachEventConfig,\n    ): void {\n  const globalStartTime = config.startTime ?? Types.Timing.MicroSeconds(0);\n  const globalEndTime = config.endTime || Types.Timing.MicroSeconds(Infinity);\n  const ignoreAsyncEvents = config.ignoreAsyncEvents === false ? false : true;\n\n  const stack: Types.Events.Event[] = [];\n  const startEventIndex = topLevelEventIndexEndingAfter(events, globalStartTime);\n  for (let i = startEventIndex; i < events.length; i++) {\n    const currentEvent = events[i];\n    const currentEventTimings = eventTimingsMicroSeconds(currentEvent);\n    if (currentEventTimings.endTime < globalStartTime) {\n      continue;\n    }\n    if (currentEventTimings.startTime > globalEndTime) {\n      break;\n    }\n\n    const isIgnoredAsyncEvent = ignoreAsyncEvents && Types.Events.isPhaseAsync(currentEvent.ph);\n    if (isIgnoredAsyncEvent || Types.Events.isFlowPhase(currentEvent.ph)) {\n      continue;\n    }\n\n    // If we have now reached an event that is after a bunch of events, we need\n    // to call the onEndEvent callback for those events before moving on.\n    let lastEventOnStack = stack.at(-1);\n    let lastEventEndTime = lastEventOnStack ? eventTimingsMicroSeconds(lastEventOnStack).endTime : null;\n    while (lastEventOnStack && lastEventEndTime && lastEventEndTime <= currentEventTimings.startTime) {\n      stack.pop();\n      config.onEndEvent(lastEventOnStack);\n      lastEventOnStack = stack.at(-1);\n      lastEventEndTime = lastEventOnStack ? eventTimingsMicroSeconds(lastEventOnStack).endTime : null;\n    }\n\n    // Now we have dealt with all events prior to this one, see if we need to care about this one.\n    if (config.eventFilter && !config.eventFilter(currentEvent)) {\n      // The user has chosen to filter this event out, so continue on and do nothing\n      continue;\n    }\n\n    if (currentEventTimings.duration) {\n      config.onStartEvent(currentEvent);\n      stack.push(currentEvent);\n    } else if (config.onInstantEvent) {\n      // An event with 0 duration is an instant event.\n      config.onInstantEvent(currentEvent);\n    }\n  }\n\n  // Now we have finished looping over all events; any events remaining on the\n  // stack need to have their onEndEvent called.\n  while (stack.length) {\n    const last = stack.pop();\n    if (last) {\n      config.onEndEvent(last);\n    }\n  }\n}\n\n// Parsed categories are cached to prevent calling cat.split()\n// multiple times on the same categories string.\nconst parsedCategories = new Map<string, Set<string>>();\nexport function eventHasCategory(event: Types.Events.Event, category: string): boolean {\n  let parsedCategoriesForEvent = parsedCategories.get(event.cat);\n  if (!parsedCategoriesForEvent) {\n    parsedCategoriesForEvent = new Set(event.cat.split(',') || []);\n  }\n  return parsedCategoriesForEvent.has(category);\n}\n\nexport function nodeIdForInvalidationEvent(event: Types.Events.InvalidationTrackingEvent): Protocol.DOM.BackendNodeId|\n    null {\n  return event.args.data.nodeId ?? null;\n}\n"],
  "mappings": "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",
  "names": ["eventsArePairable", "time"]
}
