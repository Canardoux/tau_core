{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/FlowsHandler.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\n\n// A flow is a logic connection between trace events. We display this\n// connection as arrows between trace events belonging to the same flow.\n\n// In the trace event format, flows are represented with pairing \"flow\n// phase\" events. Each flow phase event corresponds to one trace event\n// and indicates the role a trace event plays in a flow (start, step or\n// end). For each flow, one `start` and one `end` phase events are\n// included, while the amount of `step` phase events can be >= 0.\n\n// A flow phase event is assigned to a trace event when their cat, tid,\n// pid and ts are equal (see @flowPhaseBindingTokenForEvent ).\n\n// It's possible for a single event to belong to multiple flows. In that\n// case, it will have multiple corresponding flow phase events (one\n// per flow).\n\n// To parse flows, we first handle flow phase events, by creating unique\n// flows with the timestamps of each phase. Then, we place trace events\n// in the flows where their corresponding phase events were placed (if\n// there are any corresponding flow phase events at all).\nconst flowDataByGroupToken = new Map<string, {flowId: number, times: Types.Timing.MicroSeconds[]}>();\nconst flowPhaseBindingTokenToFlowId = new Map<string, Set<number>>();\nconst flowsById = new Map<number, {times: Types.Timing.MicroSeconds[], events: Types.Events.Event[]}>();\nconst flowEvents: Types.Events.FlowEvent[] = [];\nconst nonFlowEvents: Types.Events.Event[] = [];\nlet flows: Types.Events.Event[][] = [];\nconst ID_COMPONENT_SEPARATOR = '-$-';\nexport function reset(): void {\n  flows = [];\n  flowEvents.length = 0;\n  nonFlowEvents.length = 0;\n  flowDataByGroupToken.clear();\n  flowPhaseBindingTokenToFlowId.clear();\n  flowsById.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isFlowPhaseEvent(event)) {\n    flowEvents.push(event);\n    return;\n  }\n  nonFlowEvents.push(event);\n}\n\nfunction processNonFlowEvent(event: Types.Events.Event): void {\n  const flowPhaseBindingToken = flowPhaseBindingTokenForEvent(event);\n  const flowIds = flowPhaseBindingTokenToFlowId.get(flowPhaseBindingToken);\n  if (!flowIds) {\n    return;\n  }\n  for (const flowId of flowIds) {\n    const flow = flowsById.get(flowId);\n    if (!flow) {\n      continue;\n    }\n    const timeIndex = flow.times.indexOf(event.ts);\n    if (timeIndex < 0) {\n      continue;\n    }\n    flow.events[timeIndex] = event;\n  }\n}\n\n/**\n * Creates unique flows by tracking flow phase events. A new created\n * flow whenever a flow start phase event is detected.\n * Subsequent flow phase events with the same group token are added to\n * this flow until a flow end phase is detected.\n */\nfunction processFlowEvent(flowPhaseEvent: Types.Events.FlowEvent): void {\n  const flowGroup = flowGroupTokenForFlowPhaseEvent(flowPhaseEvent);\n  switch (flowPhaseEvent.ph) {\n    case (Types.Events.Phase.FLOW_START): {\n      const flowMetadata = {flowId: flowPhaseEvent.id, times: [flowPhaseEvent.ts]};\n      flowDataByGroupToken.set(flowGroup, flowMetadata);\n      addFlowIdToFlowPhaseBinding(flowPhaseBindingTokenForEvent(flowPhaseEvent), flowMetadata.flowId);\n      return;\n    }\n    case (Types.Events.Phase.FLOW_STEP): {\n      const flow = flowDataByGroupToken.get(flowGroup);\n      if (!flow || flow.times.length < 0) {\n        // Found non-start flow event with no corresponding start flow,\n        // start event. Quietly ignore problematic event.\n        return;\n      }\n      addFlowIdToFlowPhaseBinding(flowPhaseBindingTokenForEvent(flowPhaseEvent), flow.flowId);\n      flow.times.push(flowPhaseEvent.ts);\n      return;\n    }\n    case (Types.Events.Phase.FLOW_END): {\n      const flow = flowDataByGroupToken.get(flowGroup);\n      if (!flow || flow.times.length < 0) {\n        // Found non-start flow event with no corresponding start flow,\n        // start event. Quietly ignore problematic event.\n        return;\n      }\n      addFlowIdToFlowPhaseBinding(flowPhaseBindingTokenForEvent(flowPhaseEvent), flow.flowId);\n      flow.times.push(flowPhaseEvent.ts);\n      flowsById.set(flow.flowId, {times: flow.times, events: []});\n      // We don't need this data anymore as the flow has been finished,\n      // so we can drop it.\n      flowDataByGroupToken.delete(flowGroup);\n    }\n  }\n}\n\n/**\n * A single trace event can belong to multiple flows. This method\n * tracks which flows (flowId) an event belongs to (given\n * its flow phase binding token).\n */\nfunction addFlowIdToFlowPhaseBinding(flowPhaseBinding: string, flowId: number): void {\n  let flowIds = flowPhaseBindingTokenToFlowId.get(flowPhaseBinding);\n  if (!flowIds) {\n    flowIds = new Set();\n  }\n  flowIds.add(flowId);\n  flowPhaseBindingTokenToFlowId.set(flowPhaseBinding, flowIds);\n}\n\n/**\n * Returns a token to group flow phase events (start, step and end)\n * belonging to the same flow. Flow phase events belonging to the same\n * flow share category, thread id, process id and name.\n *\n * Note that other phase events of other flows can share these\n * attributes too. For this reason, we group flow phase events in\n * cycles. A cycle starts on a flow start phase event and finishes on a\n * flow end phase event. For this reason, flow phase events need to be\n * handled in timestamp order.\n */\nfunction flowGroupTokenForFlowPhaseEvent(event: Types.Events.FlowEvent): string {\n  return `${event.cat}${ID_COMPONENT_SEPARATOR}${event.name}${ID_COMPONENT_SEPARATOR}${event.id}`;\n}\n\n/**\n * A flow phase binding is a token that allows us to associate a flow\n * phase event to its corresponding event. This association indicates\n * what role a trace event plays in a flow.\n * We can assign a trace event with a flow phase when its category,\n * thread id, process id and timestamp matches those of a flow phase\n * event.\n */\nfunction flowPhaseBindingTokenForEvent(event: Types.Events.Event): string {\n  // This function is called many times (one per event) and creating a\n  // string every time can trigger GC. If this becomes a problem, a\n  // possible optimization is to use a multi-key map with the\n  // binding token components, a trade off between memory performance\n  // and readability.\n  return `${event.cat}${ID_COMPONENT_SEPARATOR}${event.tid}${ID_COMPONENT_SEPARATOR}${event.pid}${\n      ID_COMPONENT_SEPARATOR}${event.ts}`;\n}\n\nexport async function finalize(): Promise<void> {\n  // Order is important: flow events need to be handled first.\n  flowEvents.forEach(processFlowEvent);\n  nonFlowEvents.forEach(processNonFlowEvent);\n  flows = [...flowsById.values()].map(f => f.events).filter(flow => flow.length > 1);\n}\n\nexport function data(): {flows: Types.Events.Event[][]} {\n  return {\n    flows,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
