{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/metrics/SpeedIndex.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\n\nconst mobileSlow4GRtt = 150;\n\nclass SpeedIndex extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      // Note that the optimistic estimate is based on the real observed speed index rather than a\n      // real lantern graph (and the final estimate will be Math.max(FCP, Speed Index)).\n      intercept: 0,\n      optimistic: 1.4,\n      pessimistic: 0.4,\n    };\n  }\n\n  static override getScaledCoefficients(rttMs: number): MetricCoefficients {\n    // We want to scale our default coefficients based on the speed of the connection.\n    // We will linearly interpolate coefficients for the passed-in rttMs based on two pre-determined points:\n    //   1. Baseline point of 30 ms RTT where Speed Index should be a ~50/50 blend of optimistic/pessimistic.\n    //      30 ms was based on a typical home WiFi connection's actual RTT.\n    //      Coefficients here follow from the fact that the optimistic estimate should be very close\n    //      to reality at this connection speed and the pessimistic estimate compensates for minor\n    //      connection speed differences.\n    //   2. Default throttled point of 150 ms RTT where the default coefficients have been determined to be most accurate.\n    //      Coefficients here were determined through thorough analysis and linear regression on the\n    //      lantern test data set. See core/scripts/test-lantern.sh for more detail.\n    // While the coefficients haven't been analyzed at the interpolated points, it's our current best effort.\n    const defaultCoefficients = this.coefficients;\n    const defaultRttExcess = mobileSlow4GRtt - 30;\n    const multiplier = Math.max((rttMs - 30) / defaultRttExcess, 0);\n\n    return {\n      intercept: defaultCoefficients.intercept * multiplier,\n      optimistic: 0.5 + (defaultCoefficients.optimistic - 0.5) * multiplier,\n      pessimistic: 0.5 + (defaultCoefficients.pessimistic - 0.5) * multiplier,\n    };\n  }\n\n  static override getOptimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getPessimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulationResult: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.fcpResult) {\n      throw new Core.LanternError('missing fcpResult');\n    }\n    if (extras.observedSpeedIndex === undefined) {\n      throw new Core.LanternError('missing observedSpeedIndex');\n    }\n\n    const fcpTimeInMs = extras.fcpResult.pessimisticEstimate.timeInMs;\n    const estimate = extras.optimistic ?\n        extras.observedSpeedIndex :\n        SpeedIndex.computeLayoutBasedSpeedIndex(simulationResult.nodeTimings, fcpTimeInMs);\n    return {\n      timeInMs: estimate,\n      nodeTimings: simulationResult.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the SpeedIndex metric');\n    }\n\n    const metricResult = super.compute(data, extras);\n    metricResult.timing = Math.max(metricResult.timing, fcpResult.timing);\n    return metricResult;\n  }\n\n  /**\n   * Approximate speed index using layout events from the simulated node timings.\n   * The layout-based speed index is the weighted average of the endTime of CPU nodes that contained\n   * a 'Layout' task. log(duration) is used as the weight to stand for \"significance\" to the page.\n   *\n   * If no layout events can be found or the endTime of a CPU task is too early, FCP is used instead.\n   *\n   * This approach was determined after evaluating the accuracy/complexity tradeoff of many\n   * different methods. Read more in the evaluation doc.\n   *\n   * @see https://docs.google.com/document/d/1qJWXwxoyVLVadezIp_Tgdk867G3tDNkkVRvUJSH3K1E/edit#\n   */\n  static computeLayoutBasedSpeedIndex(nodeTimings: Simulation.Result['nodeTimings'], fcpTimeInMs: number): number {\n    const layoutWeights: Array<{time: number, weight: number}> = [];\n    for (const [node, timing] of nodeTimings.entries()) {\n      if (node.type !== Graph.BaseNode.types.CPU) {\n        continue;\n      }\n\n      if (node.childEvents.some(x => x.name === 'Layout')) {\n        const timingWeight = Math.max(Math.log2(timing.endTime - timing.startTime), 0);\n        layoutWeights.push({time: timing.endTime, weight: timingWeight});\n      }\n    }\n\n    const totalWeightedTime =\n        layoutWeights.map(evt => evt.weight * Math.max(evt.time, fcpTimeInMs)).reduce((a, b) => a + b, 0);\n    const totalWeight = layoutWeights.map(evt => evt.weight).reduce((a, b) => a + b, 0);\n\n    if (!totalWeight) {\n      return fcpTimeInMs;\n    }\n    return totalWeightedTime / totalWeight;\n  }\n}\n\nexport {SpeedIndex};\n"],
  "mappings": ";AAIA,YAAY,UAAU;AACtB,YAAY,WAAW;AAGvB;AAAA,EAEE;AAAA,OAIK;AAEP,MAAM,kBAAkB;AAExB,MAAM,mBAAmB,OAAO;AAAA,EAC9B,WAAoB,eAAmC;AACrD,WAAO;AAAA;AAAA;AAAA,MAGL,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,aAAa;AAAA,IACf;AAAA,EACF;AAAA,EAEA,OAAgB,sBAAsB,OAAmC;AAYvE,UAAM,sBAAsB,KAAK;AACjC,UAAM,mBAAmB,kBAAkB;AAC3C,UAAM,aAAa,KAAK,KAAK,QAAQ,MAAM,kBAAkB,CAAC;AAE9D,WAAO;AAAA,MACL,WAAW,oBAAoB,YAAY;AAAA,MAC3C,YAAY,OAAO,oBAAoB,aAAa,OAAO;AAAA,MAC3D,aAAa,OAAO,oBAAoB,cAAc,OAAO;AAAA,IAC/D;AAAA,EACF;AAAA,EAEA,OAAgB,mBAAmB,iBAAyC;AAC1E,WAAO;AAAA,EACT;AAAA,EAEA,OAAgB,oBAAoB,iBAAyC;AAC3E,WAAO;AAAA,EACT;AAAA,EAEA,OAAgB,0BAA0B,kBAAqC,QAAmC;AAChH,QAAI,CAAC,OAAO,WAAW;AACrB,YAAM,IAAI,KAAK,aAAa,mBAAmB;AAAA,IACjD;AACA,QAAI,OAAO,uBAAuB,QAAW;AAC3C,YAAM,IAAI,KAAK,aAAa,4BAA4B;AAAA,IAC1D;AAEA,UAAM,cAAc,OAAO,UAAU,oBAAoB;AACzD,UAAM,WAAW,OAAO,aACpB,OAAO,qBACP,WAAW,6BAA6B,iBAAiB,aAAa,WAAW;AACrF,WAAO;AAAA,MACL,UAAU;AAAA,MACV,aAAa,iBAAiB;AAAA,IAChC;AAAA,EACF;AAAA,EAEA,OAAgB,QAAQ,MAAkC,QAAmD;AAC3G,UAAM,YAAY,QAAQ;AAC1B,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,KAAK,aAAa,oDAAoD;AAAA,IAClF;AAEA,UAAM,eAAe,MAAM,QAAQ,MAAM,MAAM;AAC/C,iBAAa,SAAS,KAAK,IAAI,aAAa,QAAQ,UAAU,MAAM;AACpE,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,OAAO,6BAA6B,aAA+C,aAA6B;AAC9G,UAAM,gBAAuD,CAAC;AAC9D,eAAW,CAAC,MAAM,MAAM,KAAK,YAAY,QAAQ,GAAG;AAClD,UAAI,KAAK,SAAS,MAAM,SAAS,MAAM,KAAK;AAC1C;AAAA,MACF;AAEA,UAAI,KAAK,YAAY,KAAK,OAAK,EAAE,SAAS,QAAQ,GAAG;AACnD,cAAM,eAAe,KAAK,IAAI,KAAK,KAAK,OAAO,UAAU,OAAO,SAAS,GAAG,CAAC;AAC7E,sBAAc,KAAK,EAAC,MAAM,OAAO,SAAS,QAAQ,aAAY,CAAC;AAAA,MACjE;AAAA,IACF;AAEA,UAAM,oBACF,cAAc,IAAI,SAAO,IAAI,SAAS,KAAK,IAAI,IAAI,MAAM,WAAW,CAAC,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AACpG,UAAM,cAAc,cAAc,IAAI,SAAO,IAAI,MAAM,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AAElF,QAAI,CAAC,aAAa;AAChB,aAAO;AAAA,IACT;AACA,WAAO,oBAAoB;AAAA,EAC7B;AACF;AAEA,SAAQ;",
  "names": []
}
