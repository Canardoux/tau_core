{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/SamplesHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nconst events = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.Complete[]>>();\n\nconst profilesInProcess = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, ProfileData>>();\nconst entryToNode = new Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>();\n\n// The profile head, containing its metadata like its start\n// time, comes in a \"Profile\" event. The sample data comes in\n// \"ProfileChunk\" events. We match these ProfileChunks with their head\n// using process and profile ids. However, in order to integrate sample\n// data with trace data, we need the thread id that owns each profile.\n// This thread id is extracted from the head event.\n// For this reason, we have a preprocessed data structure, where events\n// are matched by profile id, which we then finish processing to export\n// events matched by thread id.\nconst preprocessedData = new Map<Types.Events.ProcessID, Map<Types.Events.ProfileID, PreprocessedData>>();\n\nfunction buildProfileCalls(): void {\n  for (const [processId, profiles] of preprocessedData) {\n    for (const [profileId, preProcessedData] of profiles) {\n      const threadId = preProcessedData.threadId;\n      if (!preProcessedData.rawProfile.nodes.length || threadId === undefined) {\n        continue;\n      }\n      const indexStack: number[] = [];\n\n      const profileModel = new CPUProfile.CPUProfileDataModel.CPUProfileDataModel(preProcessedData.rawProfile);\n      const profileTree = Helpers.TreeHelpers.makeEmptyTraceEntryTree();\n      profileTree.maxDepth = profileModel.maxDepth;\n\n      const finalizedData: ProfileData = {\n        rawProfile: preProcessedData.rawProfile,\n        parsedProfile: profileModel,\n        profileCalls: [],\n        profileTree,\n        profileId,\n      };\n\n      const dataByThread = Platform.MapUtilities.getWithDefault(profilesInProcess, processId, () => new Map());\n      profileModel.forEachFrame(openFrameCallback, closeFrameCallback);\n      dataByThread.set(threadId, finalizedData);\n\n      function openFrameCallback(\n          depth: number, node: CPUProfile.ProfileTreeModel.ProfileNode, sampleIndex: number,\n          timeStampMilliseconds: number): void {\n        if (threadId === undefined) {\n          return;\n        }\n        const ts = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(timeStampMilliseconds));\n        const nodeId = node.id as Helpers.TreeHelpers.TraceEntryNodeId;\n\n        const profileCall = Helpers.Trace.makeProfileCall(node, profileId, sampleIndex, ts, processId, threadId);\n        finalizedData.profileCalls.push(profileCall);\n        indexStack.push(finalizedData.profileCalls.length - 1);\n        const traceEntryNode = Helpers.TreeHelpers.makeEmptyTraceEntryNode(profileCall, nodeId);\n        entryToNode.set(profileCall, traceEntryNode);\n        traceEntryNode.depth = depth;\n        if (indexStack.length === 1) {\n          // First call in the stack is a root call.\n          finalizedData.profileTree?.roots.add(traceEntryNode);\n        }\n      }\n      function closeFrameCallback(\n          _depth: number, _node: CPUProfile.ProfileTreeModel.ProfileNode, _sampleIndex: number,\n          _timeStampMillis: number, durMs: number, selfTimeMs: number): void {\n        const profileCallIndex = indexStack.pop();\n        const profileCall = profileCallIndex !== undefined && finalizedData.profileCalls[profileCallIndex];\n        if (!profileCall) {\n          return;\n        }\n        const {callFrame, ts, pid, tid} = profileCall;\n        const traceEntryNode = entryToNode.get(profileCall);\n        if (callFrame === undefined || ts === undefined || pid === undefined || profileId === undefined ||\n            tid === undefined || traceEntryNode === undefined) {\n          return;\n        }\n        const dur = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(durMs));\n        const selfTime = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(selfTimeMs));\n        profileCall.dur = dur;\n        traceEntryNode.selfTime = selfTime;\n\n        const parentIndex = indexStack.at(-1);\n        const parent = parentIndex !== undefined && finalizedData.profileCalls.at(parentIndex);\n        const parentNode = parent && entryToNode.get(parent);\n        if (!parentNode) {\n          return;\n        }\n        traceEntryNode.parent = parentNode;\n        parentNode.children.push(traceEntryNode);\n      }\n    }\n  }\n}\n\nexport function reset(): void {\n  events.clear();\n  preprocessedData.clear();\n  profilesInProcess.clear();\n  entryToNode.clear();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  /**\n   * A fake trace event created to support CDP.Profiler.Profiles in the\n   * trace engine.\n   */\n  if (Types.Events.isSyntheticCpuProfile(event)) {\n    // At the moment we are attaching to a single node target so we\n    // should only get a single CPU profile. The values of the process\n    // id and thread id are not really important, so we use the data\n    // in the fake event. Should multi-thread CPU profiling be supported\n    // we could use these fields in the event to pass thread info.\n    const pid = event.pid;\n    const tid = event.tid;\n    // Create an arbitrary profile id.\n    const profileId = '0x1' as Types.Events.ProfileID;\n    const profileData = getOrCreatePreProcessedData(pid, profileId);\n    profileData.rawProfile = event.args.data.cpuProfile;\n    profileData.threadId = tid;\n    return;\n  }\n\n  if (Types.Events.isProfile(event)) {\n    // Do not use event.args.data.startTime as it is in CLOCK_MONOTONIC domain,\n    // but use profileEvent.ts which has been translated to Perfetto's clock\n    // domain. Also convert from ms to us.\n    // Note: events are collected on a different thread than what's sampled.\n    // The correct process and thread ids are specified by the profile.\n    const profileData = getOrCreatePreProcessedData(event.pid, event.id);\n    profileData.rawProfile.startTime = event.ts;\n    profileData.threadId = event.tid;\n    return;\n  }\n  if (Types.Events.isProfileChunk(event)) {\n    const profileData = getOrCreatePreProcessedData(event.pid, event.id);\n    const cdpProfile = profileData.rawProfile;\n    const nodesAndSamples: Types.Events.PartialProfile|undefined = event.args?.data?.cpuProfile || {samples: []};\n    const samples = nodesAndSamples?.samples || [];\n    const nodes: CPUProfile.CPUProfileDataModel.ExtendedProfileNode[] = [];\n    for (const n of nodesAndSamples?.nodes || []) {\n      const lineNumber = typeof n.callFrame.lineNumber === 'undefined' ? -1 : n.callFrame.lineNumber;\n      const columnNumber = typeof n.callFrame.columnNumber === 'undefined' ? -1 : n.callFrame.columnNumber;\n\n      const scriptId = String(n.callFrame.scriptId) as Protocol.Runtime.ScriptId;\n      const url = n.callFrame.url || '';\n      const node = {\n        ...n,\n        callFrame: {\n          ...n.callFrame,\n          url,\n          lineNumber,\n          columnNumber,\n          scriptId,\n        },\n      };\n      nodes.push(node);\n    }\n\n    const timeDeltas = event.args.data?.timeDeltas || [];\n    const lines = event.args.data?.lines || Array(samples.length).fill(0);\n    cdpProfile.nodes.push(...nodes);\n    cdpProfile.samples?.push(...samples);\n    cdpProfile.timeDeltas?.push(...timeDeltas);\n    cdpProfile.lines?.push(...lines);\n    if (cdpProfile.samples && cdpProfile.timeDeltas && cdpProfile.samples.length !== cdpProfile.timeDeltas.length) {\n      console.error('Failed to parse CPU profile.');\n      return;\n    }\n    if (!cdpProfile.endTime && cdpProfile.timeDeltas) {\n      const timeDeltas: number[] = cdpProfile.timeDeltas;\n      cdpProfile.endTime = timeDeltas.reduce((x, y) => x + y, cdpProfile.startTime);\n    }\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  buildProfileCalls();\n}\n\nexport function data(): SamplesHandlerData {\n  return {\n    profilesInProcess,\n    entryToNode,\n  };\n}\n\nfunction getOrCreatePreProcessedData(\n    processId: Types.Events.ProcessID, profileId: Types.Events.ProfileID): PreprocessedData {\n  const profileById = Platform.MapUtilities.getWithDefault(preprocessedData, processId, () => new Map());\n  return Platform.MapUtilities.getWithDefault<Types.Events.ProfileID, PreprocessedData>(\n      profileById, profileId, () => ({\n                                rawProfile: {\n                                  startTime: 0,\n                                  endTime: 0,\n                                  nodes: [],\n                                  samples: [],\n                                  timeDeltas: [],\n                                  lines: [],\n                                },\n                                profileId,\n                              }));\n}\n\nexport interface SamplesHandlerData {\n  profilesInProcess: typeof profilesInProcess;\n  entryToNode: typeof entryToNode;\n}\n\nexport type ProfileData = {\n  profileId: Types.Events.ProfileID,\n  rawProfile: CPUProfile.CPUProfileDataModel.ExtendedProfile,\n  parsedProfile: CPUProfile.CPUProfileDataModel.CPUProfileDataModel,\n  /**\n   * Contains the calls built from the CPU profile samples.\n   * Note: This doesn't contain real trace events coming from the\n   * browser, only calls synthetically typed as trace events for\n   * compatibility, as such it only makes sense to use them in pure CPU\n   * profiles.\n   *\n   * If you need the profile calls from a CPU profile obtained from a\n   * web trace, use the data exported by the RendererHandler instead.\n   */\n  profileCalls: Types.Events.SyntheticProfileCall[],\n  /**\n   * Contains the call tree built from the CPU profile samples.\n   * Similar to the profileCalls field, this tree does not contain nor\n   * take into account trace events, as such it only makes sense to use\n   * them in pure CPU profiles.\n   */\n  profileTree?: Helpers.TreeHelpers.TraceEntryTree,\n};\n\ntype PreprocessedData = {\n  rawProfile: CPUProfile.CPUProfileDataModel.ExtendedProfile,\n  profileId: Types.Events.ProfileID,\n  threadId?: Types.Events.ThreadID,\n};\n\n/**\n * Returns the name of a function for a given synthetic profile call.\n * We first look to find the ProfileNode representing this call, and use its\n * function name. This is preferred (and should always exist) because if we\n * resolve sourcemaps, we will update this name. If that name is not present,\n * we fall back to the function name that was in the callframe that we got\n * when parsing the profile's trace data.\n */\nexport function getProfileCallFunctionName(data: SamplesHandlerData, entry: Types.Events.SyntheticProfileCall): string {\n  const profile = data.profilesInProcess.get(entry.pid)?.get(entry.tid);\n  const node = profile?.parsedProfile.nodeById(entry.nodeId);\n  if (node?.functionName) {\n    return node.functionName;\n  }\n  return entry.callFrame.functionName;\n}\n"],
  "mappings": "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",
  "names": ["openFrameCallback", "closeFrameCallback", "timeDeltas", "data"]
}
