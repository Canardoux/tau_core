{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/extras/MainThreadActivity.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nconst IDLE_FUNCTION_CALL_NAMES = new Set([\n  '(program)',\n  '(idle)',\n  '(root)',\n]);\n\nexport function calculateWindow(\n    traceBounds: Types.Timing.TraceWindowMicroSeconds,\n    mainThreadEntries: readonly Types.Events.Event[]): Types.Timing.TraceWindowMicroSeconds {\n  if (!mainThreadEntries.length) {\n    return traceBounds;\n  }\n  const entriesWithIdleRemoved = mainThreadEntries.filter(entry => {\n    if (Types.Events.isProfileCall(entry) &&\n        (IDLE_FUNCTION_CALL_NAMES.has(entry.callFrame.functionName) || !entry.callFrame.functionName)) {\n      return false;\n    }\n    return true;\n  });\n\n  if (entriesWithIdleRemoved.length === 0) {\n    return traceBounds;\n  }\n  /**\n   * Calculates regions of low utilization and returns the index of the event\n   * that is the first event that should be included.\n   **/\n  function findLowUtilizationRegion(startIndex: number, stopIndex: number): number {\n    const threshold = 0.1;\n\n    let cutIndex = startIndex;\n    const entryAtCut = entriesWithIdleRemoved[cutIndex];\n    const timings = Helpers.Timing.eventTimingsMicroSeconds(entryAtCut);\n    let cutTime = (timings.startTime + timings.endTime) / 2;\n    let usedTime = 0;\n    const step = Math.sign(stopIndex - startIndex);\n    for (let i = startIndex; i !== stopIndex; i += step) {\n      const task = entriesWithIdleRemoved[i];\n      const taskTimings = Helpers.Timing.eventTimingsMicroSeconds(task);\n      const taskTime = (taskTimings.startTime + taskTimings.endTime) / 2;\n      const interval = Math.abs(cutTime - taskTime);\n      if (usedTime < threshold * interval) {\n        cutIndex = i;\n        cutTime = taskTime;\n        usedTime = 0;\n      }\n      usedTime += taskTimings.duration;\n    }\n    return cutIndex;\n  }\n  const rightIndex = findLowUtilizationRegion(entriesWithIdleRemoved.length - 1, 0);\n  const leftIndex = findLowUtilizationRegion(0, rightIndex);\n  const leftTimings = Helpers.Timing.eventTimingsMicroSeconds(entriesWithIdleRemoved[leftIndex]);\n  const rightTimings = Helpers.Timing.eventTimingsMicroSeconds(entriesWithIdleRemoved[rightIndex]);\n\n  let leftTime = leftTimings.startTime;\n  let rightTime = rightTimings.endTime;\n  const zoomedInSpan = rightTime - leftTime;\n\n  if (zoomedInSpan < traceBounds.range * 0.1) {\n    // If the area we have chosen to zoom into is less than 10% of the entire\n    // span, we bail and show the entire trace. It would not be so useful to\n    // the user to zoom in on such a small area; we assume they have\n    // purposefully recorded a trace that contains empty periods of time.\n    return traceBounds;\n  }\n\n  // Adjust the left time down by 5%, and the right time up by 5%, so that\n  // we give the range we want to zoom a bit of breathing space. At the\n  // same time, ensure that we do not stray beyond the bounds of the\n  // min/max time of the entire trace.\n  leftTime = Types.Timing.MicroSeconds(Math.max(leftTime - 0.05 * zoomedInSpan, traceBounds.min));\n  rightTime = Types.Timing.MicroSeconds(Math.min(rightTime + 0.05 * zoomedInSpan, traceBounds.max));\n\n  return {\n    min: leftTime,\n    max: rightTime,\n    range: Types.Timing.MicroSeconds(rightTime - leftTime),\n  };\n}\n"],
  "mappings": ";AAGA,YAAY,aAAa;AACzB,YAAY,WAAW;AAEvB,MAAM,2BAA2B,oBAAI,IAAI;AAAA,EACvC;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAEM,gBAAS,gBACZ,aACA,mBAAwF;AAC1F,MAAI,CAAC,kBAAkB,QAAQ;AAC7B,WAAO;AAAA,EACT;AACA,QAAM,yBAAyB,kBAAkB,OAAO,WAAS;AAC/D,QAAI,MAAM,OAAO,cAAc,KAAK,MAC/B,yBAAyB,IAAI,MAAM,UAAU,YAAY,KAAK,CAAC,MAAM,UAAU,eAAe;AACjG,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AAED,MAAI,uBAAuB,WAAW,GAAG;AACvC,WAAO;AAAA,EACT;AAKA,WAAS,yBAAyB,YAAoB,WAA2B;AAC/E,UAAM,YAAY;AAElB,QAAI,WAAW;AACf,UAAM,aAAa,uBAAuB,QAAQ;AAClD,UAAM,UAAU,QAAQ,OAAO,yBAAyB,UAAU;AAClE,QAAI,WAAW,QAAQ,YAAY,QAAQ,WAAW;AACtD,QAAI,WAAW;AACf,UAAM,OAAO,KAAK,KAAK,YAAY,UAAU;AAC7C,aAAS,IAAI,YAAY,MAAM,WAAW,KAAK,MAAM;AACnD,YAAM,OAAO,uBAAuB,CAAC;AACrC,YAAM,cAAc,QAAQ,OAAO,yBAAyB,IAAI;AAChE,YAAM,YAAY,YAAY,YAAY,YAAY,WAAW;AACjE,YAAM,WAAW,KAAK,IAAI,UAAU,QAAQ;AAC5C,UAAI,WAAW,YAAY,UAAU;AACnC,mBAAW;AACX,kBAAU;AACV,mBAAW;AAAA,MACb;AACA,kBAAY,YAAY;AAAA,IAC1B;AACA,WAAO;AAAA,EACT;AACA,QAAM,aAAa,yBAAyB,uBAAuB,SAAS,GAAG,CAAC;AAChF,QAAM,YAAY,yBAAyB,GAAG,UAAU;AACxD,QAAM,cAAc,QAAQ,OAAO,yBAAyB,uBAAuB,SAAS,CAAC;AAC7F,QAAM,eAAe,QAAQ,OAAO,yBAAyB,uBAAuB,UAAU,CAAC;AAE/F,MAAI,WAAW,YAAY;AAC3B,MAAI,YAAY,aAAa;AAC7B,QAAM,eAAe,YAAY;AAEjC,MAAI,eAAe,YAAY,QAAQ,KAAK;AAK1C,WAAO;AAAA,EACT;AAMA,aAAW,MAAM,OAAO,aAAa,KAAK,IAAI,WAAW,OAAO,cAAc,YAAY,GAAG,CAAC;AAC9F,cAAY,MAAM,OAAO,aAAa,KAAK,IAAI,YAAY,OAAO,cAAc,YAAY,GAAG,CAAC;AAEhG,SAAO;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,OAAO,MAAM,OAAO,aAAa,YAAY,QAAQ;AAAA,EACvD;AACF;",
  "names": []
}
