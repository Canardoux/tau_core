{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/simulation/SimulationTimingMap.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * @fileoverview\n *\n * This class encapsulates the type-related validation logic for moving timing information for nodes\n * through the different simulation phases. Methods here ensure that the invariants of simulation hold\n * as nodes are queued, partially simulated, and completed.\n */\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\n\ninterface NodeTimingComplete {\n  startTime: number;\n  endTime: number;\n  queuedTime: number;\n  estimatedTimeElapsed: number;\n  timeElapsed: number;\n  timeElapsedOvershoot: number;\n  bytesDownloaded: number;\n}\n\ntype NodeTimingQueued = Pick<NodeTimingComplete, 'queuedTime'>;\n\ntype CpuNodeTimingStarted = NodeTimingQueued&Pick<NodeTimingComplete, 'startTime'|'timeElapsed'>;\ntype NetworkNodeTimingStarted = CpuNodeTimingStarted&Pick<NodeTimingComplete, 'timeElapsedOvershoot'|'bytesDownloaded'>;\n\ntype CpuNodeTimingInProgress = CpuNodeTimingStarted&Pick<NodeTimingComplete, 'estimatedTimeElapsed'>;\ntype NetworkNodeTimingInProgress = NetworkNodeTimingStarted&Pick<NodeTimingComplete, 'estimatedTimeElapsed'>;\n\nexport type CpuNodeTimingComplete = CpuNodeTimingInProgress&Pick<NodeTimingComplete, 'endTime'>;\nexport type NetworkNodeTimingComplete =\n    NetworkNodeTimingInProgress&Pick<NodeTimingComplete, 'endTime'>&{connectionTiming: ConnectionTiming};\nexport type CompleteNodeTiming = CpuNodeTimingComplete|NetworkNodeTimingComplete;\n\ntype NodeTimingData = NodeTimingQueued|CpuNodeTimingStarted|NetworkNodeTimingStarted|CpuNodeTimingInProgress|\n    NetworkNodeTimingInProgress|CpuNodeTimingComplete|NetworkNodeTimingComplete;\n\nexport interface ConnectionTiming {\n  dnsResolutionTime?: number;\n  connectionTime?: number;\n  sslTime?: number;\n  timeToFirstByte: number;\n}\n\nclass SimulatorTimingMap {\n  nodeTimings: Map<Graph.Node, NodeTimingData>;\n\n  constructor() {\n    this.nodeTimings = new Map<Graph.Node, NodeTimingData>();\n  }\n\n  getNodes(): Graph.Node[] {\n    return Array.from(this.nodeTimings.keys());\n  }\n\n  setReadyToStart(node: Graph.Node, values: {queuedTime: number}): void {\n    this.nodeTimings.set(node, values);\n  }\n\n  setInProgress(node: Graph.Node, values: {startTime: number}): void {\n    const nodeTiming = {\n      ...this.getQueued(node),\n      startTime: values.startTime,\n      timeElapsed: 0,\n    };\n\n    this.nodeTimings.set(\n        node,\n        node.type === Graph.BaseNode.types.NETWORK ? {...nodeTiming, timeElapsedOvershoot: 0, bytesDownloaded: 0} :\n                                                     nodeTiming,\n    );\n  }\n\n  setCompleted(node: Graph.Node, values: {endTime: number, connectionTiming?: ConnectionTiming}): void {\n    const nodeTiming = {\n      ...this.getInProgress(node),\n      endTime: values.endTime,\n      connectionTiming: values.connectionTiming,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setCpu(node: Graph.CPUNode, values: {timeElapsed: number}): void {\n    const nodeTiming = {\n      ...this.getCpuStarted(node),\n      timeElapsed: values.timeElapsed,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setCpuEstimated(node: Graph.CPUNode, values: {estimatedTimeElapsed: number}): void {\n    const nodeTiming = {\n      ...this.getCpuStarted(node),\n      estimatedTimeElapsed: values.estimatedTimeElapsed,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setNetwork(\n      node: Graph.NetworkNode,\n      values: {timeElapsed: number, timeElapsedOvershoot: number, bytesDownloaded: number}): void {\n    const nodeTiming = {\n      ...this.getNetworkStarted(node),\n      timeElapsed: values.timeElapsed,\n      timeElapsedOvershoot: values.timeElapsedOvershoot,\n      bytesDownloaded: values.bytesDownloaded,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setNetworkEstimated(node: Graph.NetworkNode, values: {estimatedTimeElapsed: number}): void {\n    const nodeTiming = {\n      ...this.getNetworkStarted(node),\n      estimatedTimeElapsed: values.estimatedTimeElapsed,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  getQueued(node: Graph.Node): NodeTimingData {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    return timing;\n  }\n\n  getCpuStarted(node: Graph.CPUNode): CpuNodeTimingStarted {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if ('bytesDownloaded' in timing) {\n      throw new Core.LanternError(`Node ${node.id} timing not valid`);\n    }\n    return timing;\n  }\n\n  getNetworkStarted(node: Graph.NetworkNode): NetworkNodeTimingStarted {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if (!('bytesDownloaded' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} timing not valid`);\n    }\n    return timing;\n  }\n\n  getInProgress(node: Graph.Node): CpuNodeTimingInProgress|NetworkNodeTimingInProgress {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if (!('estimatedTimeElapsed' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet in progress`);\n    }\n    return timing;\n  }\n\n  getCompleted(node: Graph.Node): CpuNodeTimingComplete|NetworkNodeTimingComplete {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if (!('estimatedTimeElapsed' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet in progress`);\n    }\n    if (!('endTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet completed`);\n    }\n    return timing;\n  }\n}\n\nexport {SimulatorTimingMap};\n"],
  "mappings": "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",
  "names": []
}
