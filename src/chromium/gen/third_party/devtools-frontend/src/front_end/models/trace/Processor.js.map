{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/Processor.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport * as Insights from './insights/insights.js';\nimport * as Lantern from './lantern/lantern.js';\nimport * as LanternComputationData from './LanternComputationData.js';\nimport type * as Model from './ModelImpl.js';\nimport * as Types from './types/types.js';\n\nconst enum Status {\n  IDLE = 'IDLE',\n  PARSING = 'PARSING',\n  FINISHED_PARSING = 'FINISHED_PARSING',\n  ERRORED_WHILE_PARSING = 'ERRORED_WHILE_PARSING',\n}\n\nexport class TraceParseProgressEvent extends Event {\n  static readonly eventName = 'traceparseprogress';\n  constructor(public data: Model.TraceParseEventProgressData, init: EventInit = {bubbles: true}) {\n    super(TraceParseProgressEvent.eventName, init);\n  }\n}\n\n/**\n * Parsing a trace can take time. On large traces we see a breakdown of time like so:\n *   - handleEvent() loop:  ~20%\n *   - finalize() loop:     ~60%\n *   - shallowClone calls:  ~20%\n * The numbers below are set so we can report a progress percentage of [0...1]\n */\nconst enum ProgressPhase {\n  HANDLE_EVENT = 0.2,\n  FINALIZE = 0.8,\n  CLONE = 1.0,\n}\nfunction calculateProgress(value: number, phase: ProgressPhase): number {\n  // Finalize values should be [0.2...0.8]\n  if (phase === ProgressPhase.FINALIZE) {\n    return (value * (ProgressPhase.FINALIZE - ProgressPhase.HANDLE_EVENT)) + ProgressPhase.HANDLE_EVENT;\n  }\n  return value * phase;\n}\n\ndeclare global {\n  interface HTMLElementEventMap {\n    [TraceParseProgressEvent.eventName]: TraceParseProgressEvent;\n  }\n}\n\nexport interface ParseOptions {\n  /**\n   * If the trace was just recorded on the current page, rather than an imported file.\n   * TODO(paulirish): Maybe remove. This is currently unused by the Processor and Handlers\n   * @default false\n   */\n  isFreshRecording?: boolean;\n  /**\n   * If the trace is a CPU Profile rather than a Chrome tracing trace.\n   * @default false\n   */\n  isCPUProfile?: boolean;\n}\n\nexport class TraceProcessor extends EventTarget {\n  // We force the Meta handler to be enabled, so the TraceHandlers type here is\n  // the model handlers the user passes in and the Meta handler.\n  readonly #traceHandlers: Partial<Handlers.Types.Handlers>;\n  #status = Status.IDLE;\n  #modelConfiguration = Types.Configuration.defaults();\n  #data: Handlers.Types.ParsedTrace|null = null;\n  #insights: Insights.Types.TraceInsightSets|null = null;\n\n  static createWithAllHandlers(): TraceProcessor {\n    return new TraceProcessor(Handlers.ModelHandlers, Types.Configuration.defaults());\n  }\n\n  static getEnabledInsightRunners(parsedTrace: Handlers.Types.ParsedTrace): Partial<Insights.Types.InsightModelsType> {\n    const enabledInsights = {} as Insights.Types.InsightModelsType;\n    for (const [name, insight] of Object.entries(Insights.Models)) {\n      const deps = insight.deps();\n      if (deps.some(dep => !parsedTrace[dep])) {\n        continue;\n      }\n      Object.assign(enabledInsights, {[name]: insight});\n    }\n    return enabledInsights;\n  }\n\n  constructor(traceHandlers: Partial<Handlers.Types.Handlers>, modelConfiguration?: Types.Configuration.Configuration) {\n    super();\n\n    this.#verifyHandlers(traceHandlers);\n    this.#traceHandlers = {\n      Meta: Handlers.ModelHandlers.Meta,\n      ...traceHandlers,\n    };\n    if (modelConfiguration) {\n      this.#modelConfiguration = modelConfiguration;\n    }\n    this.#passConfigToHandlers();\n  }\n\n  #passConfigToHandlers(): void {\n    for (const handler of Object.values(this.#traceHandlers)) {\n      // Bit of an odd double check, but without this TypeScript refuses to let\n      // you call the function as it thinks it might be undefined.\n      if ('handleUserConfig' in handler && handler.handleUserConfig) {\n        handler.handleUserConfig(this.#modelConfiguration);\n      }\n    }\n  }\n\n  /**\n   * When the user passes in a set of handlers, we want to ensure that we have all\n   * the required handlers. Handlers can depend on other handlers, so if the user\n   * passes in FooHandler which depends on BarHandler, they must also pass in\n   * BarHandler too. This method verifies that all dependencies are met, and\n   * throws if not.\n   **/\n  #verifyHandlers(providedHandlers: Partial<Handlers.Types.Handlers>): void {\n    // Tiny optimisation: if the amount of provided handlers matches the amount\n    // of handlers in the Handlers.ModelHandlers object, that means that the\n    // user has passed in every handler we have. So therefore they cannot have\n    // missed any, and there is no need to iterate through the handlers and\n    // check the dependencies.\n    if (Object.keys(providedHandlers).length === Object.keys(Handlers.ModelHandlers).length) {\n      return;\n    }\n    const requiredHandlerKeys: Set<Handlers.Types.HandlerName> = new Set();\n    for (const [handlerName, handler] of Object.entries(providedHandlers)) {\n      requiredHandlerKeys.add(handlerName as Handlers.Types.HandlerName);\n      const deps = 'deps' in handler ? handler.deps() : [];\n      for (const depName of deps) {\n        requiredHandlerKeys.add(depName);\n      }\n    }\n\n    const providedHandlerKeys = new Set(Object.keys(providedHandlers));\n    // We always force the Meta handler to be enabled when creating the\n    // Processor, so if it is missing from the set the user gave us that is OK,\n    // as we will have enabled it anyway.\n    requiredHandlerKeys.delete('Meta');\n\n    for (const requiredKey of requiredHandlerKeys) {\n      if (!providedHandlerKeys.has(requiredKey)) {\n        throw new Error(`Required handler ${requiredKey} not provided.`);\n      }\n    }\n  }\n\n  reset(): void {\n    if (this.#status === Status.PARSING) {\n      throw new Error('Trace processor can\\'t reset while parsing.');\n    }\n\n    const handlers = Object.values(this.#traceHandlers);\n    for (const handler of handlers) {\n      handler.reset();\n    }\n\n    this.#data = null;\n    this.#insights = null;\n    this.#status = Status.IDLE;\n  }\n\n  async parse(traceEvents: readonly Types.Events.Event[], options: ParseOptions): Promise<void> {\n    if (this.#status !== Status.IDLE) {\n      throw new Error(`Trace processor can't start parsing when not idle. Current state: ${this.#status}`);\n    }\n    try {\n      this.#status = Status.PARSING;\n      await this.#computeParsedTrace(traceEvents);\n      if (this.#data && !options.isCPUProfile) {  // We do not calculate insights for CPU Profiles.\n        this.#computeInsights(this.#data, traceEvents);\n      }\n      this.#status = Status.FINISHED_PARSING;\n    } catch (e) {\n      this.#status = Status.ERRORED_WHILE_PARSING;\n      throw e;\n    }\n  }\n\n  /**\n   * Run all the handlers and set the result to `#data`.\n   */\n  async #computeParsedTrace(traceEvents: readonly Types.Events.Event[]): Promise<void> {\n    /**\n     * We want to yield regularly to maintain responsiveness. If we yield too often, we're wasting idle time.\n     * We could do this by checking `performance.now()` regularly, but it's an expensive call in such a hot loop.\n     * `eventsPerChunk` is an approximated proxy metric.\n     * But how big a chunk? We're aiming for long tasks that are no smaller than 100ms and not bigger than 200ms.\n     * It's CPU dependent, so it should be calibrated on oldish hardware.\n     * Illustration of a previous change to `eventsPerChunk`: https://imgur.com/wzp8BnR\n     */\n    const eventsPerChunk = 50_000;\n    // Convert to array so that we are able to iterate all handlers multiple times.\n    const sortedHandlers = [...sortHandlers(this.#traceHandlers).values()];\n\n    // Reset.\n    for (const handler of sortedHandlers) {\n      handler.reset();\n    }\n\n    // Handle each event.\n    for (let i = 0; i < traceEvents.length; ++i) {\n      // Every so often we take a break just to render.\n      if (i % eventsPerChunk === 0 && i) {\n        // Take the opportunity to provide status update events.\n        const percent = calculateProgress(i / traceEvents.length, ProgressPhase.HANDLE_EVENT);\n        this.dispatchEvent(new TraceParseProgressEvent({percent}));\n        // TODO(paulirish): consider using `scheduler.yield()` or `scheduler.postTask(() => {}, {priority: 'user-blocking'})`\n        await new Promise(resolve => setTimeout(resolve, 0));\n      }\n      const event = traceEvents[i];\n      for (let j = 0; j < sortedHandlers.length; ++j) {\n        sortedHandlers[j].handleEvent(event);\n      }\n    }\n\n    // Finalize.\n    for (const [i, handler] of sortedHandlers.entries()) {\n      if (handler.finalize) {\n        // Yield to the UI because finalize() calls can be expensive\n        // TODO(jacktfranklin): consider using `scheduler.yield()` or `scheduler.postTask(() => {}, {priority: 'user-blocking'})`\n        await new Promise(resolve => setTimeout(resolve, 0));\n        await handler.finalize();\n      }\n      const percent = calculateProgress(i / sortedHandlers.length, ProgressPhase.FINALIZE);\n      this.dispatchEvent(new TraceParseProgressEvent({percent}));\n    }\n\n    // Handlers that depend on other handlers do so via .data(), which used to always\n    // return a shallow clone of its internal data structures. However, that pattern\n    // easily results in egregious amounts of allocation. Now .data() does not do any\n    // cloning, and it happens here instead so that users of the trace processor may\n    // still assume that the parsed data is theirs.\n    // See: crbug/41484172\n    const shallowClone = (value: unknown, recurse = true): unknown => {\n      if (value instanceof Map) {\n        return new Map(value);\n      }\n      if (value instanceof Set) {\n        return new Set(value);\n      }\n      if (Array.isArray(value)) {\n        return [...value];\n      }\n      if (typeof value === 'object' && value && recurse) {\n        const obj: Record<string, unknown> = {};\n        for (const [key, v] of Object.entries(value)) {\n          obj[key] = shallowClone(v, false);\n        }\n        return obj;\n      }\n      return value;\n    };\n\n    const parsedTrace = {};\n    for (const [name, handler] of Object.entries(this.#traceHandlers)) {\n      const data = shallowClone(handler.data());\n      Object.assign(parsedTrace, {[name]: data});\n    }\n    this.dispatchEvent(new TraceParseProgressEvent({percent: ProgressPhase.CLONE}));\n\n    this.#data = parsedTrace as Handlers.Types.ParsedTrace;\n  }\n\n  get parsedTrace(): Handlers.Types.ParsedTrace|null {\n    if (this.#status !== Status.FINISHED_PARSING) {\n      return null;\n    }\n\n    return this.#data;\n  }\n\n  get insights(): Insights.Types.TraceInsightSets|null {\n    if (this.#status !== Status.FINISHED_PARSING) {\n      return null;\n    }\n\n    return this.#insights;\n  }\n\n  #createLanternContext(\n      parsedTrace: Handlers.Types.ParsedTrace, traceEvents: readonly Types.Events.Event[], frameId: string,\n      navigationId: string): Insights.Types.LanternContext|undefined {\n    // Check for required handlers.\n    if (!parsedTrace.NetworkRequests || !parsedTrace.Workers || !parsedTrace.PageLoadMetrics) {\n      return;\n    }\n    if (!parsedTrace.NetworkRequests.byTime.length) {\n      throw new Lantern.Core.LanternError('No network requests found in trace');\n    }\n\n    const navStarts = parsedTrace.Meta.navigationsByFrameId.get(frameId);\n    const navStartIndex = navStarts?.findIndex(n => n.args.data?.navigationId === navigationId);\n    if (!navStarts || navStartIndex === undefined || navStartIndex === -1) {\n      throw new Lantern.Core.LanternError('Could not find navigation start');\n    }\n\n    const startTime = navStarts[navStartIndex].ts;\n    const endTime = navStartIndex + 1 < navStarts.length ? navStarts[navStartIndex + 1].ts : Number.POSITIVE_INFINITY;\n    const boundedTraceEvents = traceEvents.filter(e => e.ts >= startTime && e.ts < endTime);\n\n    // Lantern.Types.TraceEvent and Types.Events.Event represent the same\n    // object - a trace event - but one is more flexible than the other. It should be safe to cast between them.\n    const trace: Lantern.Types.Trace = {\n      traceEvents: boundedTraceEvents as unknown as Lantern.Types.TraceEvent[],\n    };\n\n    const requests = LanternComputationData.createNetworkRequests(trace, parsedTrace, startTime, endTime);\n    const graph = LanternComputationData.createGraph(requests, trace, parsedTrace);\n    const processedNavigation = LanternComputationData.createProcessedNavigation(parsedTrace, frameId, navigationId);\n\n    const networkAnalysis = Lantern.Core.NetworkAnalyzer.analyze(requests);\n    if (!networkAnalysis) {\n      return;\n    }\n\n    const simulator: Lantern.Simulation.Simulator<Types.Events.SyntheticNetworkRequest> =\n        Lantern.Simulation.Simulator.createSimulator({\n          // TODO(crbug.com/372674229): if devtools throttling was on, does this network analysis capture\n          // that? Do we need to set 'devtools' throttlingMethod?\n          networkAnalysis,\n          throttlingMethod: 'provided',\n        });\n\n    const computeData = {graph, simulator, processedNavigation};\n    const fcpResult = Lantern.Metrics.FirstContentfulPaint.compute(computeData);\n    const lcpResult = Lantern.Metrics.LargestContentfulPaint.compute(computeData, {fcpResult});\n    const interactiveResult = Lantern.Metrics.Interactive.compute(computeData, {lcpResult});\n    const tbtResult = Lantern.Metrics.TotalBlockingTime.compute(computeData, {fcpResult, interactiveResult});\n    const metrics = {\n      firstContentfulPaint: fcpResult,\n      interactive: interactiveResult,\n      largestContentfulPaint: lcpResult,\n      totalBlockingTime: tbtResult,\n    };\n\n    return {graph, simulator, metrics};\n  }\n\n  #computeInsightSets(\n      insights: Insights.Types.TraceInsightSets, parsedTrace: Handlers.Types.ParsedTrace,\n      insightRunners: Partial<typeof Insights.Models>, context: Insights.Types.InsightSetContext): void {\n    const model = {} as Insights.Types.InsightSet['model'];\n\n    for (const [name, insight] of Object.entries(insightRunners)) {\n      let insightResult;\n      try {\n        insightResult = insight.generateInsight(parsedTrace, context);\n      } catch (err) {\n        insightResult = err;\n      }\n      Object.assign(model, {[name]: insightResult});\n    }\n\n    let id, urlString, navigation;\n    if (context.navigation) {\n      id = context.navigationId;\n      urlString = context.navigation.args.data?.documentLoaderURL ?? parsedTrace.Meta.mainFrameURL;\n      navigation = context.navigation;\n    } else {\n      id = Types.Events.NO_NAVIGATION;\n      urlString = parsedTrace.Meta.mainFrameURL;\n    }\n\n    let url;\n    try {\n      url = new URL(urlString);\n    } catch {\n      // We're pretty sure this only happens for our test fixture: missing-url.json.gz. Shouldn't\n      // happen for real traces.\n      return;\n    }\n\n    const insightSets = {\n      id,\n      url,\n      navigation,\n      frameId: context.frameId,\n      bounds: context.bounds,\n      model,\n    };\n    insights.set(insightSets.id, insightSets);\n  }\n\n  /**\n   * Run all the insights and set the result to `#insights`.\n   */\n  #computeInsights(parsedTrace: Handlers.Types.ParsedTrace, traceEvents: readonly Types.Events.Event[]): void {\n    this.#insights = new Map();\n\n    const enabledInsightRunners = TraceProcessor.getEnabledInsightRunners(parsedTrace);\n\n    const navigations = parsedTrace.Meta.mainFrameNavigations.filter(\n        navigation => navigation.args.frame && navigation.args.data?.navigationId);\n\n    // Check if there is a meaningful chunk of work happening prior to the first navigation.\n    // If so, we run the insights on that initial bounds.\n    // Otherwise, there are no navigations and we do a no-navigation insights pass on the entire trace.\n    if (navigations.length) {\n      const bounds = Helpers.Timing.traceWindowFromMicroSeconds(parsedTrace.Meta.traceBounds.min, navigations[0].ts);\n      // When using \"Record and reload\" option, it typically takes ~5ms. So use 50ms to be safe.\n      const threshold = Helpers.Timing.millisecondsToMicroseconds(50 as Types.Timing.MilliSeconds);\n      if (bounds.range > threshold) {\n        const context: Insights.Types.InsightSetContext = {\n          bounds,\n          frameId: parsedTrace.Meta.mainFrameId,\n        };\n        this.#computeInsightSets(this.#insights, parsedTrace, enabledInsightRunners, context);\n      }\n      // If threshold is not met, then the very beginning of the trace is ignored by the insights engine.\n    } else {\n      const context: Insights.Types.InsightSetContext = {\n        bounds: parsedTrace.Meta.traceBounds,\n        frameId: parsedTrace.Meta.mainFrameId,\n      };\n      this.#computeInsightSets(this.#insights, parsedTrace, enabledInsightRunners, context);\n    }\n\n    // Now run the insights for each navigation in isolation.\n    for (const [i, navigation] of navigations.entries()) {\n      // The above filter guarantees these are present.\n      const frameId = navigation.args.frame;\n      const navigationId = navigation.args.data?.navigationId as string;\n\n      // The lantern sub-context is optional on InsightSetContext, so not setting it is OK.\n      // This is also a hedge against an error inside Lantern resulting in breaking the entire performance panel.\n      // Additionally, many trace fixtures are too old to be processed by Lantern.\n      let lantern;\n      try {\n        lantern = this.#createLanternContext(parsedTrace, traceEvents, frameId, navigationId);\n      } catch (e) {\n        // Don't allow an error in constructing the Lantern graphs to break the rest of the trace processor.\n        // Log unexpected errors, but suppress anything that occurs from a trace being too old.\n        // Otherwise tests using old fixtures become way too noisy.\n        const expectedErrors = [\n          'mainDocumentRequest not found',\n          'missing metric scores for main frame',\n          'missing metric: FCP',\n          'missing metric: LCP',\n          'No network requests found in trace',\n          'Trace is too old',\n        ];\n        if (!(e instanceof Lantern.Core.LanternError)) {\n          // If this wasn't a managed LanternError, the stack trace is likely needed for debugging.\n          console.error(e);\n        } else if (!expectedErrors.some(err => e.message === err)) {\n          // To reduce noise from tests, only print errors that are not expected to occur because a trace is\n          // too old (for which there is no single check).\n          console.error(e);\n        }\n      }\n\n      const min = navigation.ts;\n      const max = i + 1 < navigations.length ? navigations[i + 1].ts : parsedTrace.Meta.traceBounds.max;\n      const bounds = Helpers.Timing.traceWindowFromMicroSeconds(min, max);\n      const context: Insights.Types.InsightSetContext = {\n        bounds,\n        frameId,\n        navigation,\n        navigationId,\n        lantern,\n      };\n\n      this.#computeInsightSets(this.#insights, parsedTrace, enabledInsightRunners, context);\n    }\n  }\n}\n\n/**\n * Some Handlers need data provided by others. Dependencies of a handler handler are\n * declared in the `deps` field.\n * @returns A map from trace event handler name to trace event hander whose entries\n * iterate in such a way that each handler is visited after its dependencies.\n */\nexport function sortHandlers(traceHandlers: Partial<{[key in Handlers.Types.HandlerName]: Handlers.Types.Handler}>):\n    Map<Handlers.Types.HandlerName, Handlers.Types.Handler> {\n  const sortedMap = new Map<Handlers.Types.HandlerName, Handlers.Types.Handler>();\n  const visited = new Set<Handlers.Types.HandlerName>();\n  const visitHandler = (handlerName: Handlers.Types.HandlerName): void => {\n    if (sortedMap.has(handlerName)) {\n      return;\n    }\n    if (visited.has(handlerName)) {\n      let stackPath = '';\n      for (const handler of visited) {\n        if (stackPath || handler === handlerName) {\n          stackPath += `${handler}->`;\n        }\n      }\n      stackPath += handlerName;\n      throw new Error(`Found dependency cycle in trace event handlers: ${stackPath}`);\n    }\n    visited.add(handlerName);\n    const handler = traceHandlers[handlerName];\n    if (!handler) {\n      return;\n    }\n    const deps = handler.deps?.();\n    if (deps) {\n      deps.forEach(visitHandler);\n    }\n    sortedMap.set(handlerName, handler);\n  };\n\n  for (const handlerName of Object.keys(traceHandlers)) {\n    visitHandler(handlerName as Handlers.Types.HandlerName);\n  }\n  return sortedMap;\n}\n"],
  "mappings": "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",
  "names": ["Status", "ProgressPhase", "handler"]
}
