{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/lantern/simulation/ConnectionPool.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport type * as Lantern from '../types/types.js';\n\nimport {TCPConnection} from './TCPConnection.js';\n\nconst DEFAULT_SERVER_RESPONSE_TIME = 30;\nconst TLS_SCHEMES = ['https', 'wss'];\n\n// Each origin can have 6 simulatenous connections open\n// https://cs.chromium.org/chromium/src/net/socket/client_socket_pool_manager.cc?type=cs&q=\"int+g_max_sockets_per_group\"\nconst CONNECTIONS_PER_ORIGIN = 6;\n\nexport class ConnectionPool {\n  options: Required<Lantern.Simulation.Options>;\n  records: Lantern.NetworkRequest[];\n  connectionsByOrigin: Map<string, TCPConnection[]>;\n  connectionsByRequest: Map<Lantern.NetworkRequest, TCPConnection>;\n  _connectionsInUse: Set<TCPConnection>;\n  connectionReusedByRequestId: Map<string, boolean>;\n\n  constructor(records: Lantern.NetworkRequest[], options: Required<Lantern.Simulation.Options>) {\n    this.options = options;\n\n    this.records = records;\n    this.connectionsByOrigin = new Map();\n    this.connectionsByRequest = new Map();\n    this._connectionsInUse = new Set();\n    this.connectionReusedByRequestId = Core.NetworkAnalyzer.estimateIfConnectionWasReused(records, {\n      forceCoarseEstimates: true,\n    });\n\n    this.initializeConnections();\n  }\n\n  connectionsInUse(): TCPConnection[] {\n    return Array.from(this._connectionsInUse);\n  }\n\n  initializeConnections(): void {\n    const connectionReused = this.connectionReusedByRequestId;\n    const additionalRttByOrigin = this.options.additionalRttByOrigin;\n    const serverResponseTimeByOrigin = this.options.serverResponseTimeByOrigin;\n\n    const recordsByOrigin = Core.NetworkAnalyzer.groupByOrigin(this.records);\n    for (const [origin, requests] of recordsByOrigin.entries()) {\n      const connections = [];\n      const additionalRtt = additionalRttByOrigin.get(origin) || 0;\n      const responseTime = serverResponseTimeByOrigin.get(origin) || DEFAULT_SERVER_RESPONSE_TIME;\n\n      for (const request of requests) {\n        if (connectionReused.get(request.requestId)) {\n          continue;\n        }\n\n        const isTLS = TLS_SCHEMES.includes(request.parsedURL.scheme);\n        const isH2 = request.protocol === 'h2';\n        const connection = new TCPConnection(\n            this.options.rtt + additionalRtt,\n            this.options.throughput,\n            responseTime,\n            isTLS,\n            isH2,\n        );\n\n        connections.push(connection);\n      }\n\n      if (!connections.length) {\n        throw new Core.LanternError(`Could not find a connection for origin: ${origin}`);\n      }\n\n      // Make sure each origin has minimum number of connections available for max throughput.\n      // But only if it's not over H2 which maximizes throughput already.\n      const minConnections = connections[0].isH2() ? 1 : CONNECTIONS_PER_ORIGIN;\n      while (connections.length < minConnections) {\n        connections.push(connections[0].clone());\n      }\n\n      this.connectionsByOrigin.set(origin, connections);\n    }\n  }\n\n  findAvailableConnectionWithLargestCongestionWindow(connections: TCPConnection[]): TCPConnection|null {\n    let maxConnection: TCPConnection|null = null;\n    for (let i = 0; i < connections.length; i++) {\n      const connection = connections[i];\n\n      // Connections that are in use are never available.\n      if (this._connectionsInUse.has(connection)) {\n        continue;\n      }\n\n      // This connection is a match and is available! Update our max if it has a larger congestionWindow\n      const currentMax = (maxConnection?.congestionWindow) || -Infinity;\n      if (connection.congestionWindow > currentMax) {\n        maxConnection = connection;\n      }\n    }\n\n    return maxConnection;\n  }\n\n  /**\n   * This method finds an available connection to the origin specified by the network request or null\n   * if no connection was available. If returned, connection will not be available for other network\n   * records until release is called.\n   */\n  acquire(request: Lantern.NetworkRequest): TCPConnection|null {\n    if (this.connectionsByRequest.has(request)) {\n      throw new Core.LanternError('Record already has a connection');\n    }\n\n    const origin = request.parsedURL.securityOrigin;\n    const connections = this.connectionsByOrigin.get(origin) || [];\n    const connectionToUse = this.findAvailableConnectionWithLargestCongestionWindow(connections);\n\n    if (!connectionToUse) {\n      return null;\n    }\n\n    this._connectionsInUse.add(connectionToUse);\n    this.connectionsByRequest.set(request, connectionToUse);\n    return connectionToUse;\n  }\n\n  /**\n   * Return the connection currently being used to fetch a request. If no connection\n   * currently being used for this request, an error will be thrown.\n   */\n  acquireActiveConnectionFromRequest(request: Lantern.NetworkRequest): TCPConnection {\n    const activeConnection = this.connectionsByRequest.get(request);\n    if (!activeConnection) {\n      throw new Core.LanternError('Could not find an active connection for request');\n    }\n\n    return activeConnection;\n  }\n\n  release(request: Lantern.NetworkRequest): void {\n    const connection = this.connectionsByRequest.get(request);\n    this.connectionsByRequest.delete(request);\n    if (connection) {\n      this._connectionsInUse.delete(connection);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
