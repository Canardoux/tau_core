{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/models/trace/handlers/FramesHandler.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {type AuctionWorkletsData, data as auctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport {data as layerTreeHandlerData, type LayerTreeData} from './LayerTreeHandler.js';\nimport {data as metaHandlerData, type MetaHandlerData} from './MetaHandler.js';\nimport {data as rendererHandlerData, type RendererHandlerData} from './RendererHandler.js';\nimport * as Threads from './Threads.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * IMPORTANT: this handler is slightly different to the rest. This is because\n * it is an adaptation of the TimelineFrameModel that has been used in DevTools\n * for many years. Rather than re-implement all the logic from scratch, instead\n * this handler gathers up the events and instantitates the class in the\n * finalize() method. Once the class has parsed all events, it is used to then\n * return the array of frames.\n *\n * In time we expect to migrate this code to a more \"typical\" handler.\n */\n\nconst allEvents: Types.Events.Event[] = [];\nlet model: TimelineFrameModel|null = null;\n\nexport function reset(): void {\n  allEvents.length = 0;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  allEvents.push(event);\n}\n\nexport async function finalize(): Promise<void> {\n  // Snapshot events can be emitted out of order, so we need to sort before\n  // building the frames model.\n  Helpers.Trace.sortTraceEventsInPlace(allEvents);\n\n  const modelForTrace = new TimelineFrameModel(\n      allEvents,\n      rendererHandlerData(),\n      auctionWorkletsData(),\n      metaHandlerData(),\n      layerTreeHandlerData(),\n  );\n  model = modelForTrace;\n}\n\nexport interface FramesData {\n  frames: readonly Types.Events.LegacyTimelineFrame[];\n  framesById: Readonly<Record<number, Types.Events.LegacyTimelineFrame|undefined>>;\n}\n\nexport function data(): FramesData {\n  return {\n    frames: model ? Array.from(model.frames()) : [],\n    framesById: model ? {...model.framesById()} : {},\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'Renderer', 'AuctionWorklets', 'LayerTree'];\n}\n\ntype FrameEvent = Types.Events.BeginFrame|Types.Events.DroppedFrame|Types.Events.RequestMainThreadFrame|\n                  Types.Events.BeginMainThreadFrame|Types.Events.Commit|Types.Events.CompositeLayers|\n                  Types.Events.ActivateLayerTree|Types.Events.NeedsBeginFrameChanged|Types.Events.DrawFrame;\n\nfunction isFrameEvent(event: Types.Events.Event): event is FrameEvent {\n  return (\n      Types.Events.isSetLayerId(event) || Types.Events.isBeginFrame(event) || Types.Events.isDroppedFrame(event) ||\n      Types.Events.isRequestMainThreadFrame(event) || Types.Events.isBeginMainThreadFrame(event) ||\n      Types.Events.isNeedsBeginFrameChanged(event) ||\n      // Note that \"Commit\" is the replacement for \"CompositeLayers\" so in a trace\n      // we wouldn't expect to see a combination of these. All \"new\" trace\n      // recordings use \"Commit\", but we can easily support \"CompositeLayers\" too\n      // to not break older traces being imported.\n      Types.Events.isCommit(event) || Types.Events.isCompositeLayers(event) ||\n      Types.Events.isActivateLayerTree(event) || Types.Events.isDrawFrame(event));\n}\n\nfunction entryIsTopLevel(entry: Types.Events.Event): boolean {\n  const devtoolsTimelineCategory = 'disabled-by-default-devtools.timeline';\n  return entry.name === Types.Events.Name.RUN_TASK && entry.cat.includes(devtoolsTimelineCategory);\n}\n\nexport class TimelineFrameModel {\n  #frames: TimelineFrame[] = [];\n  #frameById: {\n    [x: number]: TimelineFrame,\n  } = {};\n  #beginFrameQueue: TimelineFrameBeginFrameQueue = new TimelineFrameBeginFrameQueue();\n  #lastFrame: TimelineFrame|null = null;\n  #mainFrameCommitted = false;\n  #mainFrameRequested = false;\n  #lastLayerTree: Types.Events.LegacyFrameLayerTreeData|null = null;\n  #framePendingActivation: PendingFrame|null = null;\n  #framePendingCommit: PendingFrame|null = null;\n  #lastBeginFrame: number|null = null;\n  #lastNeedsBeginFrame: number|null = null;\n  #lastTaskBeginTime: Types.Timing.MicroSeconds|null = null;\n  #layerTreeId: number|null = null;\n  #activeProcessId: Types.Events.ProcessID|null = null;\n  #activeThreadId: Types.Events.ThreadID|null = null;\n  #layerTreeData: LayerTreeData;\n\n  constructor(\n      allEvents: readonly Types.Events.Event[], rendererData: RendererHandlerData,\n      auctionWorkletsData: AuctionWorkletsData, metaData: MetaHandlerData, layerTreeData: LayerTreeData) {\n    // We only care about getting threads from the Renderer, not Samples,\n    // because Frames don't exist in a CPU Profile (which won't have Renderer\n    // threads.)\n    const mainThreads = Threads.threadsInRenderer(rendererData, auctionWorkletsData).filter(thread => {\n      return thread.type === Threads.ThreadType.MAIN_THREAD && thread.processIsOnMainFrame;\n    });\n    const threadData = mainThreads.map(thread => {\n      return {\n        tid: thread.tid,\n        pid: thread.pid,\n        startTime: thread.entries[0].ts,\n      };\n    });\n\n    this.#layerTreeData = layerTreeData;\n    this.#addTraceEvents(allEvents, threadData, metaData.mainFrameId);\n  }\n\n  framesById(): Readonly<Record<number, TimelineFrame|undefined>> {\n    return this.#frameById;\n  }\n\n  frames(): TimelineFrame[] {\n    return this.#frames;\n  }\n\n  #handleBeginFrame(startTime: Types.Timing.MicroSeconds, seqId: number): void {\n    if (!this.#lastFrame) {\n      this.#startFrame(startTime, seqId);\n    }\n    this.#lastBeginFrame = startTime;\n\n    this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, false, false);\n  }\n\n  #handleDroppedFrame(startTime: Types.Timing.MicroSeconds, seqId: number, isPartial: boolean): void {\n    if (!this.#lastFrame) {\n      this.#startFrame(startTime, seqId);\n    }\n\n    // This line handles the case where no BeginFrame event is issued for\n    // the dropped frame. In this situation, add a BeginFrame to the queue\n    // as if it actually occurred.\n    this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, true, isPartial);\n    this.#beginFrameQueue.setDropped(seqId, true);\n    this.#beginFrameQueue.setPartial(seqId, isPartial);\n  }\n\n  #handleDrawFrame(startTime: Types.Timing.MicroSeconds, seqId: number): void {\n    if (!this.#lastFrame) {\n      this.#startFrame(startTime, seqId);\n      return;\n    }\n\n    // - if it wasn't drawn, it didn't happen!\n    // - only show frames that either did not wait for the main thread frame or had one committed.\n    if (this.#mainFrameCommitted || !this.#mainFrameRequested) {\n      if (this.#lastNeedsBeginFrame) {\n        const idleTimeEnd = this.#framePendingActivation ? this.#framePendingActivation.triggerTime :\n                                                           (this.#lastBeginFrame || this.#lastNeedsBeginFrame);\n        if (idleTimeEnd > this.#lastFrame.startTime) {\n          this.#lastFrame.idle = true;\n          this.#lastBeginFrame = null;\n        }\n        this.#lastNeedsBeginFrame = null;\n      }\n\n      const framesToVisualize = this.#beginFrameQueue.processPendingBeginFramesOnDrawFrame(seqId);\n\n      // Visualize the current frame and all pending frames before it.\n      for (const frame of framesToVisualize) {\n        const isLastFrameIdle = this.#lastFrame.idle;\n\n        // If |frame| is the first frame after an idle period, the CPU time\n        // will be logged (\"committed\") under |frame| if applicable.\n        this.#startFrame(frame.startTime, seqId);\n        if (isLastFrameIdle && this.#framePendingActivation) {\n          this.#commitPendingFrame();\n        }\n        if (frame.isDropped) {\n          this.#lastFrame.dropped = true;\n        }\n        if (frame.isPartial) {\n          this.#lastFrame.isPartial = true;\n        }\n      }\n    }\n    this.#mainFrameCommitted = false;\n  }\n\n  #handleActivateLayerTree(): void {\n    if (!this.#lastFrame) {\n      return;\n    }\n    if (this.#framePendingActivation && !this.#lastNeedsBeginFrame) {\n      this.#commitPendingFrame();\n    }\n  }\n\n  #handleRequestMainThreadFrame(): void {\n    if (!this.#lastFrame) {\n      return;\n    }\n    this.#mainFrameRequested = true;\n  }\n\n  #handleCommit(): void {\n    if (!this.#framePendingCommit) {\n      return;\n    }\n    this.#framePendingActivation = this.#framePendingCommit;\n    this.#framePendingCommit = null;\n    this.#mainFrameRequested = false;\n    this.#mainFrameCommitted = true;\n  }\n\n  #handleLayerTreeSnapshot(layerTree: Types.Events.LegacyFrameLayerTreeData): void {\n    this.#lastLayerTree = layerTree;\n  }\n\n  #handleNeedFrameChanged(startTime: Types.Timing.MicroSeconds, needsBeginFrame: boolean): void {\n    if (needsBeginFrame) {\n      this.#lastNeedsBeginFrame = startTime;\n    }\n  }\n\n  #startFrame(startTime: Types.Timing.MicroSeconds, seqId: number): void {\n    if (this.#lastFrame) {\n      this.#flushFrame(this.#lastFrame, startTime);\n    }\n    this.#lastFrame =\n        new TimelineFrame(seqId, startTime, Types.Timing.MicroSeconds(startTime - metaHandlerData().traceBounds.min));\n  }\n\n  #flushFrame(frame: TimelineFrame, endTime: Types.Timing.MicroSeconds): void {\n    frame.setLayerTree(this.#lastLayerTree);\n    frame.setEndTime(endTime);\n    if (this.#lastLayerTree) {\n      this.#lastLayerTree.paints = frame.paints;\n    }\n    const lastFrame = this.#frames[this.#frames.length - 1];\n    if (this.#frames.length && lastFrame &&\n        (frame.startTime !== lastFrame.endTime || frame.startTime > frame.endTime)) {\n      console.assert(\n          false, `Inconsistent frame time for frame ${this.#frames.length} (${frame.startTime} - ${frame.endTime})`);\n    }\n    const newFramesLength = this.#frames.push(frame);\n    frame.setIndex(newFramesLength - 1);\n    if (typeof frame.mainFrameId === 'number') {\n      this.#frameById[frame.mainFrameId] = frame;\n    }\n  }\n\n  #commitPendingFrame(): void {\n    if (!this.#framePendingActivation || !this.#lastFrame) {\n      return;\n    }\n\n    this.#lastFrame.paints = this.#framePendingActivation.paints;\n    this.#lastFrame.mainFrameId = this.#framePendingActivation.mainFrameId;\n    this.#framePendingActivation = null;\n  }\n\n  #addTraceEvents(\n      events: readonly Types.Events.Event[], threadData: {\n        pid: Types.Events.ProcessID,\n        tid: Types.Events.ThreadID,\n        startTime: Types.Timing.MicroSeconds,\n      }[],\n      mainFrameId: string): void {\n    let j = 0;\n    this.#activeThreadId = threadData.length && threadData[0].tid || null;\n    this.#activeProcessId = threadData.length && threadData[0].pid || null;\n    for (let i = 0; i < events.length; ++i) {\n      while (j + 1 < threadData.length && threadData[j + 1].startTime <= events[i].ts) {\n        this.#activeThreadId = threadData[++j].tid;\n        this.#activeProcessId = threadData[j].pid;\n      }\n      this.#addTraceEvent(events[i], mainFrameId);\n    }\n    this.#activeThreadId = null;\n    this.#activeProcessId = null;\n  }\n\n  #addTraceEvent(event: Types.Events.Event, mainFrameId: string): void {\n    if (Types.Events.isSetLayerId(event) && event.args.data.frame === mainFrameId) {\n      this.#layerTreeId = event.args.data.layerTreeId;\n    } else if (Types.Events.isLayerTreeHostImplSnapshot(event) && Number(event.id) === this.#layerTreeId) {\n      this.#handleLayerTreeSnapshot({\n        entry: event,\n        paints: [],\n      });\n    } else {\n      if (isFrameEvent(event)) {\n        this.#processCompositorEvents(event);\n      }\n      // Make sure we only use events from the main thread: we check the PID as\n      // well in case two processes have a thread with the same TID.\n      if (event.tid === this.#activeThreadId && event.pid === this.#activeProcessId) {\n        this.#addMainThreadTraceEvent(event);\n      }\n    }\n  }\n\n  #processCompositorEvents(entry: FrameEvent): void {\n    if (entry.args['layerTreeId'] !== this.#layerTreeId) {\n      return;\n    }\n    if (Types.Events.isBeginFrame(entry)) {\n      this.#handleBeginFrame(entry.ts, entry.args['frameSeqId']);\n    } else if (Types.Events.isDrawFrame(entry)) {\n      this.#handleDrawFrame(entry.ts, entry.args['frameSeqId']);\n    } else if (Types.Events.isActivateLayerTree(entry)) {\n      this.#handleActivateLayerTree();\n    } else if (Types.Events.isRequestMainThreadFrame(entry)) {\n      this.#handleRequestMainThreadFrame();\n    } else if (Types.Events.isNeedsBeginFrameChanged(entry)) {\n      // needsBeginFrame property will either be 0 or 1, which represents\n      // true/false in this case, hence the Boolean() wrapper.\n      this.#handleNeedFrameChanged(entry.ts, entry.args['data'] && Boolean(entry.args['data']['needsBeginFrame']));\n    } else if (Types.Events.isDroppedFrame(entry)) {\n      this.#handleDroppedFrame(entry.ts, entry.args['frameSeqId'], Boolean(entry.args['hasPartialUpdate']));\n    }\n  }\n\n  #addMainThreadTraceEvent(entry: Types.Events.Event): void {\n    if (entryIsTopLevel(entry)) {\n      this.#lastTaskBeginTime = entry.ts;\n    }\n    if (!this.#framePendingCommit && MAIN_FRAME_MARKERS.has(entry.name as Types.Events.Name)) {\n      this.#framePendingCommit = new PendingFrame(this.#lastTaskBeginTime || entry.ts);\n    }\n    if (!this.#framePendingCommit) {\n      return;\n    }\n\n    if (Types.Events.isBeginMainThreadFrame(entry) && entry.args.data.frameId) {\n      this.#framePendingCommit.mainFrameId = entry.args.data.frameId;\n    }\n    if (Types.Events.isPaint(entry)) {\n      const snapshot = this.#layerTreeData.paintsToSnapshots.get(entry);\n      if (snapshot) {\n        this.#framePendingCommit.paints.push(new LayerPaintEvent(entry, snapshot));\n      }\n    }\n    // Commit will be replacing CompositeLayers but CompositeLayers is kept\n    // around for backwards compatibility.\n    if ((Types.Events.isCompositeLayers(entry) || Types.Events.isCommit(entry)) &&\n        entry.args['layerTreeId'] === this.#layerTreeId) {\n      this.#handleCommit();\n    }\n  }\n}\n\nconst MAIN_FRAME_MARKERS = new Set<Types.Events.Name>([\n  Types.Events.Name.SCHEDULE_STYLE_RECALCULATION,\n  Types.Events.Name.INVALIDATE_LAYOUT,\n  Types.Events.Name.BEGIN_MAIN_THREAD_FRAME,\n  Types.Events.Name.SCROLL_LAYER,\n]);\n\n/**\n * Legacy class that represents TimelineFrames that was ported from the old SDK.\n * This class is purposefully not exported as it breaks the abstraction that\n * every event shown on the timeline is a trace event. Instead, we use the Type\n * LegacyTimelineFrame to represent frames in the codebase. These do implement\n * the right interface to be treated just like they were a trace event.\n */\nclass TimelineFrame implements Types.Events.LegacyTimelineFrame {\n  // These fields exist to satisfy the base Event type which all\n  // \"trace events\" must implement. They aren't used, but doing this means we\n  // can pass `TimelineFrame` instances into places that expect\n  // Types.Events.Event.\n  cat = 'devtools.legacy_frame';\n  name = 'frame';\n  ph = Types.Events.Phase.COMPLETE;\n  ts: Types.Timing.MicroSeconds;\n  pid = Types.Events.ProcessID(-1);\n  tid = Types.Events.ThreadID(-1);\n\n  index: number = -1;\n  startTime: Types.Timing.MicroSeconds;\n  startTimeOffset: Types.Timing.MicroSeconds;\n  endTime: Types.Timing.MicroSeconds;\n  duration: Types.Timing.MicroSeconds;\n  idle: boolean;\n  dropped: boolean;\n  isPartial: boolean;\n  layerTree: Types.Events.LegacyFrameLayerTreeData|null;\n  paints: LayerPaintEvent[];\n  mainFrameId: number|undefined;\n  readonly seqId: number;\n\n  constructor(seqId: number, startTime: Types.Timing.MicroSeconds, startTimeOffset: Types.Timing.MicroSeconds) {\n    this.seqId = seqId;\n    this.startTime = startTime;\n    this.ts = startTime;\n    this.startTimeOffset = startTimeOffset;\n    this.endTime = this.startTime;\n    this.duration = Types.Timing.MicroSeconds(0);\n    this.idle = false;\n    this.dropped = false;\n    this.isPartial = false;\n    this.layerTree = null;\n    this.paints = [];\n    this.mainFrameId = undefined;\n  }\n\n  setIndex(i: number): void {\n    this.index = i;\n  }\n\n  setEndTime(endTime: Types.Timing.MicroSeconds): void {\n    this.endTime = endTime;\n    this.duration = Types.Timing.MicroSeconds(this.endTime - this.startTime);\n  }\n\n  setLayerTree(layerTree: Types.Events.LegacyFrameLayerTreeData|null): void {\n    this.layerTree = layerTree;\n  }\n\n  /**\n   * Fake the `dur` field to meet the expected value given that we pretend\n   * these TimelineFrame classes are trace events across the codebase.\n   */\n  get dur(): Types.Timing.MicroSeconds {\n    return this.duration;\n  }\n}\n\nexport class LayerPaintEvent implements Types.Events.LegacyLayerPaintEvent {\n  readonly #event: Types.Events.Paint;\n  #snapshot: Types.Events.DisplayItemListSnapshot;\n\n  constructor(event: Types.Events.Paint, snapshot: Types.Events.DisplayItemListSnapshot) {\n    this.#event = event;\n    this.#snapshot = snapshot;\n  }\n\n  layerId(): number {\n    return this.#event.args.data.layerId;\n  }\n\n  event(): Types.Events.Paint {\n    return this.#event;\n  }\n\n  picture(): Types.Events.LegacyLayerPaintEventPicture|null {\n    const rect = this.#snapshot.args.snapshot.params?.layer_rect;\n    const pictureData = this.#snapshot.args.snapshot.skp64;\n    return rect && pictureData ? {rect, serializedPicture: pictureData} : null;\n  }\n}\n\nexport class PendingFrame {\n  paints: LayerPaintEvent[];\n  mainFrameId: number|undefined;\n  triggerTime: number;\n  constructor(triggerTime: number) {\n    this.paints = [];\n    this.mainFrameId = undefined;\n    this.triggerTime = triggerTime;\n  }\n}\n\n// The parameters of an impl-side BeginFrame.\nclass BeginFrameInfo {\n  seqId: number;\n  startTime: Types.Timing.MicroSeconds;\n  isDropped: boolean;\n  isPartial: boolean;\n  constructor(seqId: number, startTime: Types.Timing.MicroSeconds, isDropped: boolean, isPartial: boolean) {\n    this.seqId = seqId;\n    this.startTime = startTime;\n    this.isDropped = isDropped;\n    this.isPartial = isPartial;\n  }\n}\n\n// A queue of BeginFrames pending visualization.\n// BeginFrames are added into this queue as they occur; later when their\n// corresponding DrawFrames occur (or lack thereof), the BeginFrames are removed\n// from the queue and their timestamps are used for visualization.\nexport class TimelineFrameBeginFrameQueue {\n  private queueFrames: number[] = [];\n\n  // Maps frameSeqId to BeginFrameInfo.\n  private mapFrames: {\n    [x: number]: BeginFrameInfo,\n  } = {};\n\n  // Add a BeginFrame to the queue, if it does not already exit.\n  addFrameIfNotExists(seqId: number, startTime: Types.Timing.MicroSeconds, isDropped: boolean, isPartial: boolean):\n      void {\n    if (!(seqId in this.mapFrames)) {\n      this.mapFrames[seqId] = new BeginFrameInfo(seqId, startTime, isDropped, isPartial);\n      this.queueFrames.push(seqId);\n    }\n  }\n\n  // Set a BeginFrame in queue as dropped.\n  setDropped(seqId: number, isDropped: boolean): void {\n    if (seqId in this.mapFrames) {\n      this.mapFrames[seqId].isDropped = isDropped;\n    }\n  }\n\n  setPartial(seqId: number, isPartial: boolean): void {\n    if (seqId in this.mapFrames) {\n      this.mapFrames[seqId].isPartial = isPartial;\n    }\n  }\n\n  processPendingBeginFramesOnDrawFrame(seqId: number): BeginFrameInfo[] {\n    const framesToVisualize: BeginFrameInfo[] = [];\n\n    // Do not visualize this frame in the rare case where the current DrawFrame\n    // does not have a corresponding BeginFrame.\n    if (seqId in this.mapFrames) {\n      // Pop all BeginFrames before the current frame, and add only the dropped\n      // ones in |frames_to_visualize|.\n      // Non-dropped frames popped here are BeginFrames that are never\n      // drawn (but not considered dropped either for some reason).\n      // Those frames do not require an proactive visualization effort and will\n      // be naturally presented as continuationss of other frames.\n      while (this.queueFrames[0] !== seqId) {\n        const currentSeqId = this.queueFrames[0];\n        if (this.mapFrames[currentSeqId].isDropped) {\n          framesToVisualize.push(this.mapFrames[currentSeqId]);\n        }\n\n        delete this.mapFrames[currentSeqId];\n        this.queueFrames.shift();\n      }\n\n      // Pop the BeginFrame associated with the current DrawFrame.\n      framesToVisualize.push(this.mapFrames[seqId]);\n      delete this.mapFrames[seqId];\n      this.queueFrames.shift();\n    }\n    return framesToVisualize;\n  }\n}\n\nexport function framesWithinWindow(\n    frames: readonly Types.Events.LegacyTimelineFrame[], startTime: Types.Timing.MicroSeconds,\n    endTime: Types.Timing.MicroSeconds): Types.Events.LegacyTimelineFrame[] {\n  const firstFrame = Platform.ArrayUtilities.lowerBound(frames, startTime || 0, (time, frame) => time - frame.endTime);\n  const lastFrame =\n      Platform.ArrayUtilities.lowerBound(frames, endTime || Infinity, (time, frame) => time - frame.startTime);\n  return frames.slice(firstFrame, lastFrame);\n}\n"],
  "mappings": ";AAIA,YAAY,cAAc;AAC1B,YAAY,aAAa;AACzB,YAAY,WAAW;AAEvB,SAAkC,QAAQ,2BAA0B;AACpE,SAAQ,QAAQ,4BAA+C;AAC/D,SAAQ,QAAQ,uBAA4C;AAC5D,SAAQ,QAAQ,2BAAoD;AACpE,YAAY,aAAa;AAczB,MAAM,YAAkC,CAAC;AACzC,IAAI,QAAiC;AAE9B,gBAAS,QAAc;AAC5B,YAAU,SAAS;AACrB;AAEO,gBAAS,YAAY,OAAiC;AAC3D,YAAU,KAAK,KAAK;AACtB;AAEA,sBAAsB,WAA0B;AAG9C,UAAQ,MAAM,uBAAuB,SAAS;AAE9C,QAAM,gBAAgB,IAAI;AAAA,IACtB;AAAA,IACA,oBAAoB;AAAA,IACpB,oBAAoB;AAAA,IACpB,gBAAgB;AAAA,IAChB,qBAAqB;AAAA,EACzB;AACA,UAAQ;AACV;AAOO,gBAAS,OAAmB;AACjC,SAAO;AAAA,IACL,QAAQ,QAAQ,MAAM,KAAK,MAAM,OAAO,CAAC,IAAI,CAAC;AAAA,IAC9C,YAAY,QAAQ,EAAC,GAAG,MAAM,WAAW,EAAC,IAAI,CAAC;AAAA,EACjD;AACF;AAEO,gBAAS,OAAsB;AACpC,SAAO,CAAC,QAAQ,YAAY,mBAAmB,WAAW;AAC5D;AAMA,SAAS,aAAa,OAAgD;AACpE,SACI,MAAM,OAAO,aAAa,KAAK,KAAK,MAAM,OAAO,aAAa,KAAK,KAAK,MAAM,OAAO,eAAe,KAAK,KACzG,MAAM,OAAO,yBAAyB,KAAK,KAAK,MAAM,OAAO,uBAAuB,KAAK,KACzF,MAAM,OAAO,yBAAyB,KAAK;AAAA;AAAA;AAAA;AAAA,EAK3C,MAAM,OAAO,SAAS,KAAK,KAAK,MAAM,OAAO,kBAAkB,KAAK,KACpE,MAAM,OAAO,oBAAoB,KAAK,KAAK,MAAM,OAAO,YAAY,KAAK;AAC/E;AAEA,SAAS,gBAAgB,OAAoC;AAC3D,QAAM,2BAA2B;AACjC,SAAO,MAAM,SAAS,MAAM,OAAO,KAAK,YAAY,MAAM,IAAI,SAAS,wBAAwB;AACjG;AAEO,aAAM,mBAAmB;AAAA,EAC9B,UAA2B,CAAC;AAAA,EAC5B,aAEI,CAAC;AAAA,EACL,mBAAiD,IAAI,6BAA6B;AAAA,EAClF,aAAiC;AAAA,EACjC,sBAAsB;AAAA,EACtB,sBAAsB;AAAA,EACtB,iBAA6D;AAAA,EAC7D,0BAA6C;AAAA,EAC7C,sBAAyC;AAAA,EACzC,kBAA+B;AAAA,EAC/B,uBAAoC;AAAA,EACpC,qBAAqD;AAAA,EACrD,eAA4B;AAAA,EAC5B,mBAAgD;AAAA,EAChD,kBAA8C;AAAA,EAC9C;AAAA,EAEA,YACIA,YAA0C,cAC1CC,sBAA0C,UAA2B,eAA8B;AAIrG,UAAM,cAAc,QAAQ,kBAAkB,cAAcA,oBAAmB,EAAE,OAAO,YAAU;AAChG,aAAO,OAAO,SAAS,QAAQ,WAAW,eAAe,OAAO;AAAA,IAClE,CAAC;AACD,UAAM,aAAa,YAAY,IAAI,YAAU;AAC3C,aAAO;AAAA,QACL,KAAK,OAAO;AAAA,QACZ,KAAK,OAAO;AAAA,QACZ,WAAW,OAAO,QAAQ,CAAC,EAAE;AAAA,MAC/B;AAAA,IACF,CAAC;AAED,SAAK,iBAAiB;AACtB,SAAK,gBAAgBD,YAAW,YAAY,SAAS,WAAW;AAAA,EAClE;AAAA,EAEA,aAAgE;AAC9D,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,SAA0B;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,kBAAkB,WAAsC,OAAqB;AAC3E,QAAI,CAAC,KAAK,YAAY;AACpB,WAAK,YAAY,WAAW,KAAK;AAAA,IACnC;AACA,SAAK,kBAAkB;AAEvB,SAAK,iBAAiB,oBAAoB,OAAO,WAAW,OAAO,KAAK;AAAA,EAC1E;AAAA,EAEA,oBAAoB,WAAsC,OAAe,WAA0B;AACjG,QAAI,CAAC,KAAK,YAAY;AACpB,WAAK,YAAY,WAAW,KAAK;AAAA,IACnC;AAKA,SAAK,iBAAiB,oBAAoB,OAAO,WAAW,MAAM,SAAS;AAC3E,SAAK,iBAAiB,WAAW,OAAO,IAAI;AAC5C,SAAK,iBAAiB,WAAW,OAAO,SAAS;AAAA,EACnD;AAAA,EAEA,iBAAiB,WAAsC,OAAqB;AAC1E,QAAI,CAAC,KAAK,YAAY;AACpB,WAAK,YAAY,WAAW,KAAK;AACjC;AAAA,IACF;AAIA,QAAI,KAAK,uBAAuB,CAAC,KAAK,qBAAqB;AACzD,UAAI,KAAK,sBAAsB;AAC7B,cAAM,cAAc,KAAK,0BAA0B,KAAK,wBAAwB,cAC5B,KAAK,mBAAmB,KAAK;AACjF,YAAI,cAAc,KAAK,WAAW,WAAW;AAC3C,eAAK,WAAW,OAAO;AACvB,eAAK,kBAAkB;AAAA,QACzB;AACA,aAAK,uBAAuB;AAAA,MAC9B;AAEA,YAAM,oBAAoB,KAAK,iBAAiB,qCAAqC,KAAK;AAG1F,iBAAW,SAAS,mBAAmB;AACrC,cAAM,kBAAkB,KAAK,WAAW;AAIxC,aAAK,YAAY,MAAM,WAAW,KAAK;AACvC,YAAI,mBAAmB,KAAK,yBAAyB;AACnD,eAAK,oBAAoB;AAAA,QAC3B;AACA,YAAI,MAAM,WAAW;AACnB,eAAK,WAAW,UAAU;AAAA,QAC5B;AACA,YAAI,MAAM,WAAW;AACnB,eAAK,WAAW,YAAY;AAAA,QAC9B;AAAA,MACF;AAAA,IACF;AACA,SAAK,sBAAsB;AAAA,EAC7B;AAAA,EAEA,2BAAiC;AAC/B,QAAI,CAAC,KAAK,YAAY;AACpB;AAAA,IACF;AACA,QAAI,KAAK,2BAA2B,CAAC,KAAK,sBAAsB;AAC9D,WAAK,oBAAoB;AAAA,IAC3B;AAAA,EACF;AAAA,EAEA,gCAAsC;AACpC,QAAI,CAAC,KAAK,YAAY;AACpB;AAAA,IACF;AACA,SAAK,sBAAsB;AAAA,EAC7B;AAAA,EAEA,gBAAsB;AACpB,QAAI,CAAC,KAAK,qBAAqB;AAC7B;AAAA,IACF;AACA,SAAK,0BAA0B,KAAK;AACpC,SAAK,sBAAsB;AAC3B,SAAK,sBAAsB;AAC3B,SAAK,sBAAsB;AAAA,EAC7B;AAAA,EAEA,yBAAyB,WAAwD;AAC/E,SAAK,iBAAiB;AAAA,EACxB;AAAA,EAEA,wBAAwB,WAAsC,iBAAgC;AAC5F,QAAI,iBAAiB;AACnB,WAAK,uBAAuB;AAAA,IAC9B;AAAA,EACF;AAAA,EAEA,YAAY,WAAsC,OAAqB;AACrE,QAAI,KAAK,YAAY;AACnB,WAAK,YAAY,KAAK,YAAY,SAAS;AAAA,IAC7C;AACA,SAAK,aACD,IAAI,cAAc,OAAO,WAAW,MAAM,OAAO,aAAa,YAAY,gBAAgB,EAAE,YAAY,GAAG,CAAC;AAAA,EAClH;AAAA,EAEA,YAAY,OAAsB,SAA0C;AAC1E,UAAM,aAAa,KAAK,cAAc;AACtC,UAAM,WAAW,OAAO;AACxB,QAAI,KAAK,gBAAgB;AACvB,WAAK,eAAe,SAAS,MAAM;AAAA,IACrC;AACA,UAAM,YAAY,KAAK,QAAQ,KAAK,QAAQ,SAAS,CAAC;AACtD,QAAI,KAAK,QAAQ,UAAU,cACtB,MAAM,cAAc,UAAU,WAAW,MAAM,YAAY,MAAM,UAAU;AAC9E,cAAQ;AAAA,QACJ;AAAA,QAAO,qCAAqC,KAAK,QAAQ,MAAM,KAAK,MAAM,SAAS,MAAM,MAAM,OAAO;AAAA,MAAG;AAAA,IAC/G;AACA,UAAM,kBAAkB,KAAK,QAAQ,KAAK,KAAK;AAC/C,UAAM,SAAS,kBAAkB,CAAC;AAClC,QAAI,OAAO,MAAM,gBAAgB,UAAU;AACzC,WAAK,WAAW,MAAM,WAAW,IAAI;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,sBAA4B;AAC1B,QAAI,CAAC,KAAK,2BAA2B,CAAC,KAAK,YAAY;AACrD;AAAA,IACF;AAEA,SAAK,WAAW,SAAS,KAAK,wBAAwB;AACtD,SAAK,WAAW,cAAc,KAAK,wBAAwB;AAC3D,SAAK,0BAA0B;AAAA,EACjC;AAAA,EAEA,gBACI,QAAuC,YAKvC,aAA2B;AAC7B,QAAI,IAAI;AACR,SAAK,kBAAkB,WAAW,UAAU,WAAW,CAAC,EAAE,OAAO;AACjE,SAAK,mBAAmB,WAAW,UAAU,WAAW,CAAC,EAAE,OAAO;AAClE,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACtC,aAAO,IAAI,IAAI,WAAW,UAAU,WAAW,IAAI,CAAC,EAAE,aAAa,OAAO,CAAC,EAAE,IAAI;AAC/E,aAAK,kBAAkB,WAAW,EAAE,CAAC,EAAE;AACvC,aAAK,mBAAmB,WAAW,CAAC,EAAE;AAAA,MACxC;AACA,WAAK,eAAe,OAAO,CAAC,GAAG,WAAW;AAAA,IAC5C;AACA,SAAK,kBAAkB;AACvB,SAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEA,eAAe,OAA2B,aAA2B;AACnE,QAAI,MAAM,OAAO,aAAa,KAAK,KAAK,MAAM,KAAK,KAAK,UAAU,aAAa;AAC7E,WAAK,eAAe,MAAM,KAAK,KAAK;AAAA,IACtC,WAAW,MAAM,OAAO,4BAA4B,KAAK,KAAK,OAAO,MAAM,EAAE,MAAM,KAAK,cAAc;AACpG,WAAK,yBAAyB;AAAA,QAC5B,OAAO;AAAA,QACP,QAAQ,CAAC;AAAA,MACX,CAAC;AAAA,IACH,OAAO;AACL,UAAI,aAAa,KAAK,GAAG;AACvB,aAAK,yBAAyB,KAAK;AAAA,MACrC;AAGA,UAAI,MAAM,QAAQ,KAAK,mBAAmB,MAAM,QAAQ,KAAK,kBAAkB;AAC7E,aAAK,yBAAyB,KAAK;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AAAA,EAEA,yBAAyB,OAAyB;AAChD,QAAI,MAAM,KAAK,aAAa,MAAM,KAAK,cAAc;AACnD;AAAA,IACF;AACA,QAAI,MAAM,OAAO,aAAa,KAAK,GAAG;AACpC,WAAK,kBAAkB,MAAM,IAAI,MAAM,KAAK,YAAY,CAAC;AAAA,IAC3D,WAAW,MAAM,OAAO,YAAY,KAAK,GAAG;AAC1C,WAAK,iBAAiB,MAAM,IAAI,MAAM,KAAK,YAAY,CAAC;AAAA,IAC1D,WAAW,MAAM,OAAO,oBAAoB,KAAK,GAAG;AAClD,WAAK,yBAAyB;AAAA,IAChC,WAAW,MAAM,OAAO,yBAAyB,KAAK,GAAG;AACvD,WAAK,8BAA8B;AAAA,IACrC,WAAW,MAAM,OAAO,yBAAyB,KAAK,GAAG;AAGvD,WAAK,wBAAwB,MAAM,IAAI,MAAM,KAAK,MAAM,KAAK,QAAQ,MAAM,KAAK,MAAM,EAAE,iBAAiB,CAAC,CAAC;AAAA,IAC7G,WAAW,MAAM,OAAO,eAAe,KAAK,GAAG;AAC7C,WAAK,oBAAoB,MAAM,IAAI,MAAM,KAAK,YAAY,GAAG,QAAQ,MAAM,KAAK,kBAAkB,CAAC,CAAC;AAAA,IACtG;AAAA,EACF;AAAA,EAEA,yBAAyB,OAAiC;AACxD,QAAI,gBAAgB,KAAK,GAAG;AAC1B,WAAK,qBAAqB,MAAM;AAAA,IAClC;AACA,QAAI,CAAC,KAAK,uBAAuB,mBAAmB,IAAI,MAAM,IAAyB,GAAG;AACxF,WAAK,sBAAsB,IAAI,aAAa,KAAK,sBAAsB,MAAM,EAAE;AAAA,IACjF;AACA,QAAI,CAAC,KAAK,qBAAqB;AAC7B;AAAA,IACF;AAEA,QAAI,MAAM,OAAO,uBAAuB,KAAK,KAAK,MAAM,KAAK,KAAK,SAAS;AACzE,WAAK,oBAAoB,cAAc,MAAM,KAAK,KAAK;AAAA,IACzD;AACA,QAAI,MAAM,OAAO,QAAQ,KAAK,GAAG;AAC/B,YAAM,WAAW,KAAK,eAAe,kBAAkB,IAAI,KAAK;AAChE,UAAI,UAAU;AACZ,aAAK,oBAAoB,OAAO,KAAK,IAAI,gBAAgB,OAAO,QAAQ,CAAC;AAAA,MAC3E;AAAA,IACF;AAGA,SAAK,MAAM,OAAO,kBAAkB,KAAK,KAAK,MAAM,OAAO,SAAS,KAAK,MACrE,MAAM,KAAK,aAAa,MAAM,KAAK,cAAc;AACnD,WAAK,cAAc;AAAA,IACrB;AAAA,EACF;AACF;AAEA,MAAM,qBAAqB,oBAAI,IAAuB;AAAA,EACpD,MAAM,OAAO,KAAK;AAAA,EAClB,MAAM,OAAO,KAAK;AAAA,EAClB,MAAM,OAAO,KAAK;AAAA,EAClB,MAAM,OAAO,KAAK;AACpB,CAAC;AASD,MAAM,cAA0D;AAAA;AAAA;AAAA;AAAA;AAAA,EAK9D,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK,MAAM,OAAO,MAAM;AAAA,EACxB;AAAA,EACA,MAAM,MAAM,OAAO,UAAU,EAAE;AAAA,EAC/B,MAAM,MAAM,OAAO,SAAS,EAAE;AAAA,EAE9B,QAAgB;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACS;AAAA,EAET,YAAY,OAAe,WAAsC,iBAA4C;AAC3G,SAAK,QAAQ;AACb,SAAK,YAAY;AACjB,SAAK,KAAK;AACV,SAAK,kBAAkB;AACvB,SAAK,UAAU,KAAK;AACpB,SAAK,WAAW,MAAM,OAAO,aAAa,CAAC;AAC3C,SAAK,OAAO;AACZ,SAAK,UAAU;AACf,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,SAAS,CAAC;AACf,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,SAAS,GAAiB;AACxB,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,WAAW,SAA0C;AACnD,SAAK,UAAU;AACf,SAAK,WAAW,MAAM,OAAO,aAAa,KAAK,UAAU,KAAK,SAAS;AAAA,EACzE;AAAA,EAEA,aAAa,WAA6D;AACxE,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,MAAiC;AACnC,WAAO,KAAK;AAAA,EACd;AACF;AAEO,aAAM,gBAA8D;AAAA,EAChE;AAAA,EACT;AAAA,EAEA,YAAY,OAA2B,UAAgD;AACrF,SAAK,SAAS;AACd,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,UAAkB;AAChB,WAAO,KAAK,OAAO,KAAK,KAAK;AAAA,EAC/B;AAAA,EAEA,QAA4B;AAC1B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,UAA0D;AACxD,UAAM,OAAO,KAAK,UAAU,KAAK,SAAS,QAAQ;AAClD,UAAM,cAAc,KAAK,UAAU,KAAK,SAAS;AACjD,WAAO,QAAQ,cAAc,EAAC,MAAM,mBAAmB,YAAW,IAAI;AAAA,EACxE;AACF;AAEO,aAAM,aAAa;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,aAAqB;AAC/B,SAAK,SAAS,CAAC;AACf,SAAK,cAAc;AACnB,SAAK,cAAc;AAAA,EACrB;AACF;AAGA,MAAM,eAAe;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,OAAe,WAAsC,WAAoB,WAAoB;AACvG,SAAK,QAAQ;AACb,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,YAAY;AAAA,EACnB;AACF;AAMO,aAAM,6BAA6B;AAAA,EAChC,cAAwB,CAAC;AAAA;AAAA,EAGzB,YAEJ,CAAC;AAAA;AAAA,EAGL,oBAAoB,OAAe,WAAsC,WAAoB,WACpF;AACP,QAAI,EAAE,SAAS,KAAK,YAAY;AAC9B,WAAK,UAAU,KAAK,IAAI,IAAI,eAAe,OAAO,WAAW,WAAW,SAAS;AACjF,WAAK,YAAY,KAAK,KAAK;AAAA,IAC7B;AAAA,EACF;AAAA;AAAA,EAGA,WAAW,OAAe,WAA0B;AAClD,QAAI,SAAS,KAAK,WAAW;AAC3B,WAAK,UAAU,KAAK,EAAE,YAAY;AAAA,IACpC;AAAA,EACF;AAAA,EAEA,WAAW,OAAe,WAA0B;AAClD,QAAI,SAAS,KAAK,WAAW;AAC3B,WAAK,UAAU,KAAK,EAAE,YAAY;AAAA,IACpC;AAAA,EACF;AAAA,EAEA,qCAAqC,OAAiC;AACpE,UAAM,oBAAsC,CAAC;AAI7C,QAAI,SAAS,KAAK,WAAW;AAO3B,aAAO,KAAK,YAAY,CAAC,MAAM,OAAO;AACpC,cAAM,eAAe,KAAK,YAAY,CAAC;AACvC,YAAI,KAAK,UAAU,YAAY,EAAE,WAAW;AAC1C,4BAAkB,KAAK,KAAK,UAAU,YAAY,CAAC;AAAA,QACrD;AAEA,eAAO,KAAK,UAAU,YAAY;AAClC,aAAK,YAAY,MAAM;AAAA,MACzB;AAGA,wBAAkB,KAAK,KAAK,UAAU,KAAK,CAAC;AAC5C,aAAO,KAAK,UAAU,KAAK;AAC3B,WAAK,YAAY,MAAM;AAAA,IACzB;AACA,WAAO;AAAA,EACT;AACF;AAEO,gBAAS,mBACZ,QAAqD,WACrD,SAAwE;AAC1E,QAAM,aAAa,SAAS,eAAe,WAAW,QAAQ,aAAa,GAAG,CAAC,MAAM,UAAU,OAAO,MAAM,OAAO;AACnH,QAAM,YACF,SAAS,eAAe,WAAW,QAAQ,WAAW,UAAU,CAAC,MAAM,UAAU,OAAO,MAAM,SAAS;AAC3G,SAAO,OAAO,MAAM,YAAY,SAAS;AAC3C;",
  "names": ["allEvents", "auctionWorkletsData"]
}
