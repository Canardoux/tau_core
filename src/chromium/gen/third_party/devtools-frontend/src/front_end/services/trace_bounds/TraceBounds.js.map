{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/services/trace_bounds/TraceBounds.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../models/trace/trace.js';\n\nlet instance: BoundsManager|null = null;\n\nexport class StateChangedEvent extends Event {\n  static readonly eventName = 'traceboundsstatechanged';\n  constructor(\n      public state: Readonly<State>,\n      public updateType: 'RESET'|'MINIMAP_BOUNDS'|'VISIBLE_WINDOW',\n      public options: {\n        shouldAnimate?: boolean,\n      } = {shouldAnimate: false},\n  ) {\n    super(StateChangedEvent.eventName, {composed: true, bubbles: true});\n  }\n}\n\n// Exposed as a shortcut to BoundsManager.instance().addEventListener, which\n// also takes care of type-casting the event to StateChangedEvent.\nexport function onChange(cb: (event: StateChangedEvent) => void): void {\n  BoundsManager.instance().addEventListener(\n      StateChangedEvent.eventName,\n      // Cast the callback as TS doesn't know that these events will emit\n      // StateChangedEvent types.\n      cb as (event: Event) => void);\n}\n\nexport function removeListener(cb: (event: StateChangedEvent) => void): void {\n  BoundsManager.instance().removeEventListener(StateChangedEvent.eventName, cb as (event: Event) => void);\n}\n\nexport interface State {\n  readonly micro: Readonly<TraceWindows<Trace.Types.Timing.MicroSeconds>>;\n  readonly milli: Readonly<TraceWindows<Trace.Types.Timing.MilliSeconds>>;\n}\n\nexport interface TraceWindows<TimeFormat extends Trace.Types.Timing.MicroSeconds|Trace.Types.Timing.MilliSeconds> {\n  /**\n   * This is the bounds of the entire trace. Once a trace is imported/recorded\n   * and this is set, it cannot be changed.\n   */\n  readonly entireTraceBounds: Trace.Types.Timing.TraceWindow<TimeFormat>;\n  /**\n   * This is the bounds of the minimap and represents the left and right bound\n   * being shown by the minimap. It can be changed by a user action: for\n   * example, when a user creates a breadcrumb, that breadcrumb becomes the\n   * minimap trace bounds. By default, and when a trace is first loaded, the\n   * minimapTraceBounds are equivalent to the entireTraceBounds.\n   * Note that this is NOT the active time window that the user has dragged\n   * the minimap handles to; this is the min/max being shown by the minimap.\n   */\n  minimapTraceBounds: Trace.Types.Timing.TraceWindow<TimeFormat>;\n  /**\n   * This represents the trace window that is being shown on the main timeline.\n   * The reason this is called a \"Window\" rather than \"Bounds\" is because the\n   * user is not bound by this value - they can use their mouse to pan/zoom\n   * in/out beyond the limits of this window (the limit is the\n   * minimapTraceBounds). Another way to think of this value is that the\n   * min/max of this value is what is represented by the two drag handles on\n   * the TimelineMiniMap that the user can drag to change their current window.\n   */\n  timelineTraceWindow: Trace.Types.Timing.TraceWindow<TimeFormat>;\n}\n\nexport class BoundsManager extends EventTarget {\n  static instance(opts: {\n    forceNew: boolean|null,\n  } = {forceNew: null}): BoundsManager {\n    const forceNew = Boolean(opts.forceNew);\n    if (!instance || forceNew) {\n      instance = new BoundsManager();\n    }\n    return instance;\n  }\n\n  static removeInstance(): void {\n    instance = null;\n  }\n\n  #currentState: TraceWindows<Trace.Types.Timing.MicroSeconds>|null = null;\n\n  private constructor() {\n    // Defined to enable us to mark it as Private.\n    super();\n  }\n\n  resetWithNewBounds(initialBounds: Trace.Types.Timing.TraceWindowMicroSeconds): this {\n    this.#currentState = {\n      entireTraceBounds: initialBounds,\n      minimapTraceBounds: initialBounds,\n      timelineTraceWindow: initialBounds,\n    };\n    this.dispatchEvent(new StateChangedEvent(this.state() as State, 'RESET'));\n    return this;\n  }\n\n  state(): Readonly<State>|null {\n    if (this.#currentState === null) {\n      return null;\n    }\n    const entireBoundsMilli = Trace.Helpers.Timing.traceWindowMilliSeconds(this.#currentState.entireTraceBounds);\n    const minimapBoundsMilli = Trace.Helpers.Timing.traceWindowMilliSeconds(this.#currentState.minimapTraceBounds);\n    const timelineTraceWindowMilli =\n        Trace.Helpers.Timing.traceWindowMilliSeconds(this.#currentState.timelineTraceWindow);\n\n    return {\n      micro: this.#currentState,\n      milli: {\n        entireTraceBounds: entireBoundsMilli,\n        minimapTraceBounds: minimapBoundsMilli,\n        timelineTraceWindow: timelineTraceWindowMilli,\n      },\n    };\n  }\n\n  setMiniMapBounds(newBounds: Trace.Types.Timing.TraceWindowMicroSeconds): void {\n    if (!this.#currentState) {\n      // If we don't have the existing state and know the trace bounds, we\n      // cannot set the minimap bounds.\n      console.error('TraceBounds.setMiniMapBounds could not set bounds because there is no existing trace window set.');\n      return;\n    }\n    const existingBounds = this.#currentState.minimapTraceBounds;\n    if (newBounds.min === existingBounds.min && newBounds.max === existingBounds.max) {\n      // New bounds are identical to the old ones so no action required.\n      return;\n    }\n\n    if (newBounds.range < 1_000) {\n      // Minimum minimap bounds range is 1 millisecond.\n      return;\n    }\n\n    this.#currentState.minimapTraceBounds = newBounds;\n    // this.state() cannot be null here.\n    this.dispatchEvent(new StateChangedEvent(this.state() as State, 'MINIMAP_BOUNDS'));\n  }\n\n  /**\n   * Updates the visible part of the trace that the user can see.\n   * @param options.ignoreMiniMapBounds - by default the visible window will be\n   * bound by the minimap bounds. If you set this to `true` then the timeline\n   * visible window will not be constrained by the minimap bounds. Be careful\n   * with this! Unless you deal with this situation, the UI of the performance\n   * panel will break.\n   */\n  setTimelineVisibleWindow(newWindow: Trace.Types.Timing.TraceWindowMicroSeconds, options: {\n    shouldAnimate?: boolean,\n    ignoreMiniMapBounds?: boolean,\n  } = {\n    shouldAnimate: false,\n    ignoreMiniMapBounds: false,\n  }): void {\n    if (!this.#currentState) {\n      // This is a weird state to be in: we can't change the visible timeline\n      // window if we don't alreayd have an existing state with the trace\n      // bounds set.\n      console.error(\n          'TraceBounds.setTimelineVisibleWindow could not set bounds because there is no existing trace window set.');\n      return;\n    }\n    const existingWindow = this.#currentState.timelineTraceWindow;\n    if (newWindow.range < 1_000) {\n      // Minimum timeline visible window range is 1 millisecond.\n      return;\n    }\n\n    if (newWindow.min === existingWindow.min && newWindow.max === existingWindow.max) {\n      // New bounds are identical to the old ones so no action required.\n      return;\n    }\n\n    if (!options.ignoreMiniMapBounds) {\n      // Ensure that the setTimelineVisibleWindow can never go outside the bounds of the minimap bounds.\n      newWindow.min =\n          Trace.Types.Timing.MicroSeconds(Math.max(this.#currentState.minimapTraceBounds.min, newWindow.min));\n      newWindow.max =\n          Trace.Types.Timing.MicroSeconds(Math.min(this.#currentState.minimapTraceBounds.max, newWindow.max));\n    }\n\n    if (newWindow.min === existingWindow.min && newWindow.max === existingWindow.max) {\n      // If, after we adjust for the minimap bounds, the new window matches the\n      // old one, we can exit as no action is required.\n      return;\n    }\n\n    this.#currentState.timelineTraceWindow = newWindow;\n    this.dispatchEvent(\n        new StateChangedEvent(this.state() as State, 'VISIBLE_WINDOW', {shouldAnimate: options.shouldAnimate}));\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
