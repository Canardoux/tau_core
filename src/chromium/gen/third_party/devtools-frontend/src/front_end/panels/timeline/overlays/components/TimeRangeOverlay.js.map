{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/timeline/overlays/components/TimeRangeOverlay.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport type * as Trace from '../../../../models/trace/trace.js';\nimport * as LitHtml from '../../../../ui/lit-html/lit-html.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\n\nimport styles from './timeRangeOverlay.css.js';\n\nconst {html} = LitHtml;\n\nconst UIStrings = {\n  /**\n   *@description Accessible label used to explain to a user that they are viewing an entry label.\n   */\n  timeRange: 'Time range',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/TimeRangeOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class TimeRangeLabelChangeEvent extends Event {\n  static readonly eventName = 'timerangelabelchange';\n\n  constructor(public newLabel: string) {\n    super(TimeRangeLabelChangeEvent.eventName);\n  }\n}\n\nexport class TimeRangeRemoveEvent extends Event {\n  static readonly eventName = 'timerangeremoveevent';\n\n  constructor() {\n    super(TimeRangeRemoveEvent.eventName);\n  }\n}\n\nexport class TimeRangeOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #duration: Trace.Types.Timing.MicroSeconds|null = null;\n  #canvasRect: DOMRect|null = null;\n  #label: string;\n\n  // The label is set to editable and in focus anytime the label is empty and when the label it is double clicked.\n  // If the user clicks away from the selected range element and the label is not empty, the lable is set to not editable until it is double clicked.\n  #isLabelEditable: boolean = true;\n\n  #rangeContainer: HTMLElement|null = null;\n  #labelBox: HTMLElement|null = null;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [styles];\n  }\n\n  constructor(initialLabel: string) {\n    super();\n    this.#render();\n    this.#rangeContainer = this.#shadow.querySelector<HTMLElement>('.range-container');\n    this.#labelBox = this.#rangeContainer?.querySelector<HTMLElement>('.label-text') ?? null;\n    this.#label = initialLabel;\n    if (!this.#labelBox) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#labelBox.innerText = initialLabel;\n    if (initialLabel) {\n      this.#labelBox?.setAttribute('aria-label', initialLabel);\n      // To construct a time range with a predefined label, it must have been\n      // loaded from the trace file. In this case we do not want it to default\n      // to editable.\n      this.#setLabelEditability(false);\n    }\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (rect === null) {\n      return;\n    }\n    if (this.#canvasRect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  set duration(duration: Trace.Types.Timing.MicroSeconds|null) {\n    if (duration === this.#duration) {\n      return;\n    }\n    this.#duration = duration;\n    this.#render();\n  }\n\n  /**\n   * This calculates how much of the time range is in the user's view. This is\n   * used to determine how much of the label can fit into the view, and if we\n   * should even show the label.\n   */\n  #visibleOverlayWidth(overlayRect: DOMRect): number {\n    if (!this.#canvasRect) {\n      return 0;\n    }\n\n    const {x: overlayStartX, width} = overlayRect;\n    const overlayEndX = overlayStartX + width;\n\n    const canvasStartX = this.#canvasRect.x;\n    const canvasEndX = this.#canvasRect.x + this.#canvasRect.width;\n\n    const leftVisible = Math.max(canvasStartX, overlayStartX);\n    const rightVisible = Math.min(canvasEndX, overlayEndX);\n    return rightVisible - leftVisible;\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  updateLabelPositioning(): void {\n    if (!this.#rangeContainer) {\n      return;\n    }\n\n    if (!this.#canvasRect || !this.#labelBox) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n    const overlayRect = this.getBoundingClientRect();\n    const labelFocused = this.#shadow.activeElement === this.#labelBox;\n\n    const labelRect = this.#rangeContainer.getBoundingClientRect();\n    const visibleOverlayWidth = this.#visibleOverlayWidth(overlayRect) - paddingForScrollbar;\n\n    const durationBox = this.#rangeContainer.querySelector<HTMLElement>('.duration') ?? null;\n    const durationBoxLength = durationBox?.getBoundingClientRect().width;\n    if (!durationBoxLength) {\n      return;\n    }\n    const overlayTooNarrow = visibleOverlayWidth <= durationBoxLength;\n    // We do not hide the label if:\n    // 1. it is focused (user is typing into it)\n    // 2. it is empty - this means it's a new label and we need to let the user type into it!\n    // 3. it is too narrow - narrower than the duration length\n    const hideLabel = overlayTooNarrow && !labelFocused && this.#label.length > 0;\n    this.#rangeContainer.classList.toggle('labelHidden', hideLabel);\n\n    if (hideLabel) {\n      // Label is invisible, no need to do all the layout.\n      return;\n    }\n\n    // Check if label is off the LHS of the screen.\n    const labelLeftMarginToCenter = (overlayRect.width - labelRect.width) / 2;\n    const newLabelX = overlayRect.x + labelLeftMarginToCenter;\n\n    const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n    this.#rangeContainer.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n    // Check if label is off the RHS of the screen\n    const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n    // The label's right hand edge is the gap from the left of the range to the\n    // label, and then the width of the label.\n    const labelRightEdge = overlayRect.x + labelLeftMarginToCenter + labelRect.width;\n    const labelOffRightOfScreen = labelRightEdge > rightBound;\n    this.#rangeContainer.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n    if (labelOffLeftOfScreen) {\n      // If the label is off the left of the screen, we adjust by the\n      // difference between the X that represents the start of the cavnas, and\n      // the X that represents the start of the overlay.\n      // We then take the absolute value of this - because if the canvas starts\n      // at 0, and the overlay is -200px, we have to adjust the label by +200.\n      // Add on 9 pixels to pad from the left; this is the width of the sidebar\n      // on the RHS so we match it so the label is equally padded on either\n      // side.\n      this.#rangeContainer.style.marginLeft = `${Math.abs(this.#canvasRect.x - overlayRect.x) + paddingForScrollbar}px`;\n    } else if (labelOffRightOfScreen) {\n      // If the label is off the right of the screen, we adjust by adding the\n      // right margin equal to the difference between the right edge of the\n      // overlay and the right edge of the canvas.\n      this.#rangeContainer.style.marginRight = `${overlayRect.right - this.#canvasRect.right + paddingForScrollbar}px`;\n    } else {\n      // Keep the label central.\n      this.#rangeContainer.style.margin = '0px';\n    }\n\n    // If the text is empty, set the label editibility to true.\n    // Only allow to remove the focus and save the range as annotation if the label is not empty.\n    if (this.#labelBox?.innerText === '') {\n      this.#setLabelEditability(true);\n    }\n  }\n\n  #focusInputBox(): void {\n    if (!this.#labelBox) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#labelBox.focus();\n  }\n\n  #setLabelEditability(editable: boolean): void {\n    // Always keep focus on the label input field if the label is empty.\n    // TODO: Do not remove a range that is being navigated away from if the label is not empty\n    if (this.#labelBox?.innerText === '') {\n      this.#focusInputBox();\n      return;\n    }\n    this.#isLabelEditable = editable;\n    this.#render();\n    // If the label is editable, focus cursor on it\n    if (editable) {\n      this.#focusInputBox();\n    }\n  }\n\n  #handleLabelInputKeyUp(): void {\n    // If the label changed on key up, dispatch label changed event\n    const labelBoxTextContent = this.#labelBox?.textContent ?? '';\n    if (labelBoxTextContent !== this.#label) {\n      this.#label = labelBoxTextContent;\n      this.dispatchEvent(new TimeRangeLabelChangeEvent(this.#label));\n      this.#labelBox?.setAttribute('aria-label', labelBoxTextContent);\n    }\n  }\n\n  #handleLabelInputKeyDown(event: KeyboardEvent): boolean {\n    // If the new key is `Enter` or `Escape` key, treat it\n    // as the end of the label input and blur the input field.\n    // If the text field is empty when `Enter` or `Escape` are pressed,\n    // dispatch an event to remove the time range.\n    if (event.key === 'Enter' || event.key === 'Escape') {\n      // In DevTools, the `Escape` button will by default toggle the console\n      // drawer, which we don't want here, so we need to call\n      // `stopPropagation()`.\n      event.stopPropagation();\n      if (this.#label === '') {\n        this.dispatchEvent(new TimeRangeRemoveEvent());\n      }\n      this.#labelBox?.blur();\n      return false;\n    }\n\n    return true;\n  }\n\n  #render(): void {\n    const durationText = this.#duration ? i18n.TimeUtilities.formatMicroSecondsTime(this.#duration) : '';\n    // clang-format off\n    LitHtml.render(\n        html`\n          <span class=\"range-container\" role=\"region\" aria-label=${i18nString(UIStrings.timeRange)}>\n            <span\n             class=\"label-text\"\n             role=\"textbox\"\n             @focusout=${() => this.#setLabelEditability(false)}\n             @dblclick=${() => this.#setLabelEditability(true)}\n             @keydown=${this.#handleLabelInputKeyDown}\n             @keyup=${this.#handleLabelInputKeyUp}\n             contenteditable=${this.#isLabelEditable ? 'plaintext-only' : false}\n             jslog=${VisualLogging.textField('timeline.annotations.time-range-label-input').track({keydown: true, click: true})}\n            ></span>\n            <span class=\"duration\">${durationText}</span>\n          </span>\n          `,\n        this.#shadow, {host: this});\n    // clang-format on\n\n    // Now we have rendered, we need to re-run the code to tweak the margin &\n    // positioning of the label.\n    this.updateLabelPositioning();\n  }\n}\n\ncustomElements.define('devtools-time-range-overlay', TimeRangeOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-time-range-overlay': TimeRangeOverlay;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
