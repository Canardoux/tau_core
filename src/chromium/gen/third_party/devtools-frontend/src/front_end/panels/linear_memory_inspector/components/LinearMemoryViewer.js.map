{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/linear_memory_inspector/components/LinearMemoryViewer.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\nimport * as VisualLogging from '../../../ui/visual_logging/visual_logging.js';\n\nimport {toHexString} from './LinearMemoryInspectorUtils.js';\nimport linearMemoryViewerStyles from './linearMemoryViewer.css.js';\nimport type {HighlightInfo} from './LinearMemoryViewerUtils.js';\n\nconst {render, html} = LitHtml;\n\nexport interface LinearMemoryViewerData {\n  memory: Uint8Array;\n  address: number;\n  memoryOffset: number;\n  focus: boolean;\n  highlightInfo?: HighlightInfo;\n  focusedMemoryHighlight?: HighlightInfo;\n}\n\nexport class ByteSelectedEvent extends Event {\n  static readonly eventName = 'byteselected';\n  data: number;\n\n  constructor(address: number) {\n    super(ByteSelectedEvent.eventName);\n    this.data = address;\n  }\n}\n\nexport class ResizeEvent extends Event {\n  static readonly eventName = 'resize';\n  data: number;\n\n  constructor(numBytesPerPage: number) {\n    super(ResizeEvent.eventName);\n    this.data = numBytesPerPage;\n  }\n}\n\nconst BYTE_GROUP_MARGIN = 8;\nconst BYTE_GROUP_SIZE = 4;\n\nexport class LinearMemoryViewer extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n\n  readonly #resizeObserver = new ResizeObserver(() => this.#resize());\n  #isObservingResize = false;\n\n  #memory = new Uint8Array();\n  #address = 0;\n  #memoryOffset = 0;\n  #highlightInfo?: HighlightInfo;\n  #focusedMemoryHighlight?: HighlightInfo;\n\n  #numRows = 1;\n  #numBytesInRow = BYTE_GROUP_SIZE;\n\n  #focusOnByte = true;\n\n  #lastKeyUpdateSent: number|undefined = undefined;\n\n  set data(data: LinearMemoryViewerData) {\n    if (data.address < data.memoryOffset || data.address > data.memoryOffset + data.memory.length || data.address < 0) {\n      throw new Error('Address is out of bounds.');\n    }\n\n    if (data.memoryOffset < 0) {\n      throw new Error('Memory offset has to be greater or equal to zero.');\n    }\n\n    this.#memory = data.memory;\n    this.#address = data.address;\n    this.#highlightInfo = data.highlightInfo;\n    this.#focusedMemoryHighlight = data.focusedMemoryHighlight;\n    this.#memoryOffset = data.memoryOffset;\n    this.#focusOnByte = data.focus;\n    this.#update();\n  }\n\n  connectedCallback(): void {\n    this.style.setProperty('--byte-group-margin', `${BYTE_GROUP_MARGIN}px`);\n    this.#shadow.adoptedStyleSheets = [linearMemoryViewerStyles];\n  }\n\n  disconnectedCallback(): void {\n    this.#isObservingResize = false;\n    this.#resizeObserver.disconnect();\n  }\n\n  #update(): void {\n    this.#updateDimensions();\n    this.#render();\n    this.#focusOnView();\n    this.#engageResizeObserver();\n  }\n\n  #focusOnView(): void {\n    if (this.#focusOnByte) {\n      const view = this.#shadow.querySelector<HTMLDivElement>('.view');\n      if (view) {\n        view.focus();\n      }\n    }\n  }\n\n  #resize(): void {\n    this.#update();\n    this.dispatchEvent(new ResizeEvent(this.#numBytesInRow * this.#numRows));\n  }\n\n  /** Recomputes the number of rows and (byte) columns that fit into the current view. */\n  #updateDimensions(): void {\n    if (this.clientWidth === 0 || this.clientHeight === 0 || !this.shadowRoot) {\n      this.#numBytesInRow = BYTE_GROUP_SIZE;\n      this.#numRows = 1;\n      return;\n    }\n\n    // We initially just plot one row with one byte group (here: byte group size of 4).\n    // Depending on that initially plotted row we can determine how many rows and\n    // bytes per row we can fit.\n    // >    0000000 | b0 b1 b2 b4 | a0 a1 a2 a3    <\n    //      ^-------^ ^-^           ^-^\n    //          |     byteCellWidth textCellWidth\n    //          |\n    //     addressTextAndDividerWidth\n    //  ^--^   +     ^----------------------------^\n    //      widthToFill\n\n    const firstByteCell = this.shadowRoot.querySelector('.byte-cell');\n    const textCell = this.shadowRoot.querySelector('.text-cell');\n    const divider = this.shadowRoot.querySelector('.divider');\n    const rowElement = this.shadowRoot.querySelector('.row');\n    const addressText = this.shadowRoot.querySelector('.address');\n\n    if (!firstByteCell || !textCell || !divider || !rowElement || !addressText) {\n      this.#numBytesInRow = BYTE_GROUP_SIZE;\n      this.#numRows = 1;\n      return;\n    }\n\n    // Calculate the width required for each (unsplittable) group of bytes.\n    const byteCellWidth = firstByteCell.getBoundingClientRect().width;\n    const textCellWidth = textCell.getBoundingClientRect().width;\n    const groupWidth = BYTE_GROUP_SIZE * (byteCellWidth + textCellWidth) + BYTE_GROUP_MARGIN;\n\n    // Calculate the width to fill.\n    const dividerWidth = divider.getBoundingClientRect().width;\n    const addressTextAndDividerWidth =\n        firstByteCell.getBoundingClientRect().left - addressText.getBoundingClientRect().left;\n\n    // this.clientWidth is rounded, while the other values are not. Subtract 1 to make\n    // sure that we correctly calculate the widths.\n    const widthToFill = this.clientWidth - 1 - addressTextAndDividerWidth - dividerWidth;\n\n    if (widthToFill < groupWidth) {\n      this.#numBytesInRow = BYTE_GROUP_SIZE;\n      this.#numRows = 1;\n      return;\n    }\n    this.#numBytesInRow = Math.floor(widthToFill / groupWidth) * BYTE_GROUP_SIZE;\n    this.#numRows = Math.floor(this.clientHeight / rowElement.clientHeight);\n  }\n\n  #engageResizeObserver(): void {\n    if (!this.#resizeObserver || this.#isObservingResize) {\n      return;\n    }\n\n    this.#resizeObserver.observe(this);\n    this.#isObservingResize = true;\n  }\n\n  #render(): void {\n    const jslog = VisualLogging.section()\n                      .track({keydown: 'ArrowUp|ArrowDown|ArrowLeft|ArrowRight|PageUp|PageDown'})\n                      .context('linear-memory-inspector.viewer');\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    render(html`\n      <div class=\"view\" tabindex=\"0\" @keydown=${this.#onKeyDown} jslog=${jslog}>\n        ${this.#renderView()}\n      </div>\n      `, this.#shadow, {host: this});\n  }\n\n  #onKeyDown(event: Event): void {\n    const keyboardEvent = event as KeyboardEvent;\n    let newAddress = undefined;\n    if (keyboardEvent.code === 'ArrowUp') {\n      newAddress = this.#address - this.#numBytesInRow;\n    } else if (keyboardEvent.code === 'ArrowDown') {\n      newAddress = this.#address + this.#numBytesInRow;\n    } else if (keyboardEvent.code === 'ArrowLeft') {\n      newAddress = this.#address - 1;\n    } else if (keyboardEvent.code === 'ArrowRight') {\n      newAddress = this.#address + 1;\n    } else if (keyboardEvent.code === 'PageUp') {\n      newAddress = this.#address - this.#numBytesInRow * this.#numRows;\n    } else if (keyboardEvent.code === 'PageDown') {\n      newAddress = this.#address + this.#numBytesInRow * this.#numRows;\n    }\n\n    if (newAddress !== undefined && newAddress !== this.#lastKeyUpdateSent) {\n      this.#lastKeyUpdateSent = newAddress;\n      this.dispatchEvent(new ByteSelectedEvent(newAddress));\n    }\n  }\n\n  #renderView(): LitHtml.TemplateResult {\n    const itemTemplates = [];\n    for (let i = 0; i < this.#numRows; ++i) {\n      itemTemplates.push(this.#renderRow(i));\n    }\n    return html`${itemTemplates}`;\n  }\n\n  #renderRow(row: number): LitHtml.TemplateResult {\n    const {startIndex, endIndex} = {startIndex: row * this.#numBytesInRow, endIndex: (row + 1) * this.#numBytesInRow};\n\n    const classMap = {\n      address: true,\n      selected: Math.floor((this.#address - this.#memoryOffset) / this.#numBytesInRow) === row,\n    };\n    return html`\n    <div class=\"row\">\n      <span class=${LitHtml.Directives.classMap(classMap)}>${toHexString({number: startIndex + this.#memoryOffset, pad: 8, prefix: false})}</span>\n      <span class=\"divider\"></span>\n      ${this.#renderByteValues(startIndex, endIndex)}\n      <span class=\"divider\"></span>\n      ${this.#renderCharacterValues(startIndex, endIndex)}\n    </div>\n    `;\n  }\n\n  #renderByteValues(startIndex: number, endIndex: number): LitHtml.TemplateResult {\n    const cells = [];\n    for (let i = startIndex; i < endIndex; ++i) {\n      const actualIndex = i + this.#memoryOffset;\n      // Add margin after each group of bytes of size byteGroupSize.\n      const addMargin = i !== startIndex && (i - startIndex) % BYTE_GROUP_SIZE === 0;\n      const selected = i === this.#address - this.#memoryOffset;\n      const shouldBeHighlighted = this.#shouldBeHighlighted(actualIndex);\n      const focusedMemoryArea = this.#isFocusedArea(actualIndex);\n      const classMap = {\n        cell: true,\n        'byte-cell': true,\n        'byte-group-margin': addMargin,\n        selected,\n        'highlight-area': shouldBeHighlighted,\n        'focused-area': focusedMemoryArea,\n      };\n      const isSelectableCell = i < this.#memory.length;\n      const byteValue = isSelectableCell ? html`${toHexString({number: this.#memory[i], pad: 2, prefix: false})}` : '';\n      const onSelectedByte = isSelectableCell ? this.#onSelectedByte.bind(this, actualIndex) : '';\n      const jslog = VisualLogging.tableCell('linear-memory-inspector.byte-cell').track({click: true});\n      cells.push(html`<span class=${LitHtml.Directives.classMap(classMap)} @click=${onSelectedByte} jslog=${jslog}>${byteValue}</span>`);\n    }\n    return html`${cells}`;\n  }\n\n  #renderCharacterValues(startIndex: number, endIndex: number): LitHtml.TemplateResult {\n    const cells = [];\n    for (let i = startIndex; i < endIndex; ++i) {\n      const actualIndex = i + this.#memoryOffset;\n      const shouldBeHighlighted = this.#shouldBeHighlighted(actualIndex);\n      const focusedMemoryArea = this.#isFocusedArea(actualIndex);\n      const classMap = {\n        cell: true,\n        'text-cell': true,\n        selected: this.#address - this.#memoryOffset === i,\n        'highlight-area': shouldBeHighlighted,\n        'focused-area': focusedMemoryArea,\n      };\n      const isSelectableCell = i < this.#memory.length;\n      const value = isSelectableCell ? html`${this.#toAscii(this.#memory[i])}` : '';\n      const onSelectedByte = isSelectableCell ? this.#onSelectedByte.bind(this, i + this.#memoryOffset) : '';\n      const jslog = VisualLogging.tableCell('linear-memory-inspector.text-cell').track({click: true});\n      cells.push(html`<span class=${LitHtml.Directives.classMap(classMap)} @click=${onSelectedByte} jslog=${jslog}>${value}</span>`);\n    }\n    return html`${cells}`;\n  }\n\n  #toAscii(byte: number): string {\n    if (byte >= 20 && byte <= 0x7F) {\n      return String.fromCharCode(byte);\n    }\n    return '.';\n  }\n\n  #onSelectedByte(index: number): void {\n    this.dispatchEvent(new ByteSelectedEvent(index));\n  }\n\n  #shouldBeHighlighted(index: number): boolean {\n    if (this.#highlightInfo === undefined) {\n      return false;\n    }\n    return this.#highlightInfo.startAddress <= index\n    && index < this.#highlightInfo.startAddress + this.#highlightInfo.size;\n  }\n\n  #isFocusedArea(index: number): boolean {\n    if (!this.#focusedMemoryHighlight) {\n      return false;\n    }\n    return this.#focusedMemoryHighlight.startAddress <= index\n    && index < this.#focusedMemoryHighlight.startAddress + this.#focusedMemoryHighlight.size;\n  }\n}\n\ncustomElements.define('devtools-linear-memory-inspector-viewer', LinearMemoryViewer);\n\ndeclare global {\n\ninterface HTMLElementTagNameMap {\n    'devtools-linear-memory-inspector-viewer': LinearMemoryViewer;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
