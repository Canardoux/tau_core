{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/recorder/injected/util.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Schema} from '../../../third_party/puppeteer-replay/puppeteer-replay.js';\n\nexport function assert<Condition>(condition: Condition): asserts condition {\n  if (!condition) {\n    throw new Error('Assertion failed!');\n  }\n}\n\nexport const haultImmediateEvent = (event: Event): void => {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n};\n\nexport const getMouseEventOffsets = (event: MouseEvent, target: Element): {offsetX: number, offsetY: number} => {\n  const rect = target.getBoundingClientRect();\n  return {offsetX: event.clientX - rect.x, offsetY: event.clientY - rect.y};\n};\n\n/**\n * @returns the element that emitted the event.\n */\nexport const getClickableTargetFromEvent = (event: Event): Element => {\n  for (const element of event.composedPath()) {\n    if (!(element instanceof Element)) {\n      continue;\n    }\n    // If an element has no width or height, we skip this target.\n    const rect = element.getBoundingClientRect();\n    if (rect.width === 0 || rect.height === 0) {\n      continue;\n    }\n    return element;\n  }\n  throw new Error(`No target is found in event of type ${event.type}`);\n};\n\nexport const createClickAttributes = (event: MouseEvent, target: Element): Schema.ClickAttributes|undefined => {\n  let deviceType: 'pen'|'touch'|undefined;\n  if (event instanceof PointerEvent) {\n    switch (event.pointerType) {\n      case 'mouse':\n        // Default device.\n        break;\n      case 'pen':\n      case 'touch':\n        deviceType = event.pointerType;\n        break;\n      default:\n        // Unsupported device type.\n        return;\n    }\n  }\n  const {offsetX, offsetY} = getMouseEventOffsets(event, target);\n  if (offsetX < 0 || offsetY < 0) {\n    // Event comes from outside the viewport. Can happen as a result of a\n    // simulated click (through a keyboard event e.g.).\n    return;\n  }\n  return {\n    button: (['auxiliary', 'secondary', 'back', 'forward'] as const)[event.button - 1],\n    deviceType,\n    offsetX,\n    offsetY,\n  };\n};\n"],
  "mappings": ";AAMO,gBAAS,OAAkB,WAAyC;AACzE,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AACF;AAEO,aAAM,sBAAsB,CAAC,UAAuB;AACzD,QAAM,eAAe;AACrB,QAAM,yBAAyB;AACjC;AAEO,aAAM,uBAAuB,CAAC,OAAmB,WAAwD;AAC9G,QAAM,OAAO,OAAO,sBAAsB;AAC1C,SAAO,EAAC,SAAS,MAAM,UAAU,KAAK,GAAG,SAAS,MAAM,UAAU,KAAK,EAAC;AAC1E;AAKO,aAAM,8BAA8B,CAAC,UAA0B;AACpE,aAAW,WAAW,MAAM,aAAa,GAAG;AAC1C,QAAI,EAAE,mBAAmB,UAAU;AACjC;AAAA,IACF;AAEA,UAAM,OAAO,QAAQ,sBAAsB;AAC3C,QAAI,KAAK,UAAU,KAAK,KAAK,WAAW,GAAG;AACzC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,QAAM,IAAI,MAAM,uCAAuC,MAAM,IAAI,EAAE;AACrE;AAEO,aAAM,wBAAwB,CAAC,OAAmB,WAAsD;AAC7G,MAAI;AACJ,MAAI,iBAAiB,cAAc;AACjC,YAAQ,MAAM,aAAa;AAAA,MACzB,KAAK;AAEH;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,qBAAa,MAAM;AACnB;AAAA,MACF;AAEE;AAAA,IACJ;AAAA,EACF;AACA,QAAM,EAAC,SAAS,QAAO,IAAI,qBAAqB,OAAO,MAAM;AAC7D,MAAI,UAAU,KAAK,UAAU,GAAG;AAG9B;AAAA,EACF;AACA,SAAO;AAAA,IACL,QAAS,CAAC,aAAa,aAAa,QAAQ,SAAS,EAAY,MAAM,SAAS,CAAC;AAAA,IACjF;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;",
  "names": []
}
