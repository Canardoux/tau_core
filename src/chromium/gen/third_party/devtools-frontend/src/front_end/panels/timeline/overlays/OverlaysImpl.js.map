{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/timeline/overlays/OverlaysImpl.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Common from '../../../core/common/common.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Trace from '../../../models/trace/trace.js';\nimport type * as PerfUI from '../../../ui/legacy/components/perf_ui/perf_ui.js';\nimport * as VisualLogging from '../../../ui/visual_logging/visual_logging.js';\nimport {EntryStyles} from '../../timeline/utils/utils.js';\n\nimport * as Components from './components/components.js';\n\n/**\n * Below the network track there is a resize bar the user can click and drag.\n */\nconst NETWORK_RESIZE_ELEM_HEIGHT_PX = 8;\n\n/**\n * Represents which flamechart an entry is rendered in.\n * We need to know this because when we place an overlay for an entry we need\n * to adjust its Y value if it's in the main chart which is drawn below the\n * network chart\n */\nexport type EntryChartLocation = 'main'|'network';\n\n/**\n * You can add overlays to trace events, but also right now frames are drawn on\n * the timeline but they are not trace events, so we need to allow for that.\n * In the future when the frames track has been migrated to be powered by\n * animation frames (crbug.com/345144583), we can remove the requirement to\n * support TimelineFrame instances (which themselves will be removed from the\n * codebase.)\n */\nexport type OverlayEntry = Trace.Types.Events.Event|Trace.Types.Events.LegacyTimelineFrame;\n\n/**\n * Represents when a user has selected an entry in the timeline\n */\nexport interface EntrySelected {\n  type: 'ENTRY_SELECTED';\n  entry: OverlayEntry;\n}\n\n/**\n * Drawn around an entry when we want to highlight it to the user.\n */\nexport interface EntryOutline {\n  type: 'ENTRY_OUTLINE';\n  entry: OverlayEntry;\n  outlineReason: 'ERROR'|'INFO';\n}\n\n/**\n * Represents an object created when a user creates a label for an entry in the timeline.\n */\nexport interface EntryLabel {\n  type: 'ENTRY_LABEL';\n  entry: OverlayEntry;\n  label: string;\n}\n\nexport interface EntriesLink {\n  type: 'ENTRIES_LINK';\n  state: Trace.Types.File.EntriesLinkState;\n  entryFrom: OverlayEntry;\n  entryTo?: OverlayEntry;\n}\n\n/**\n * Represents a time range on the trace. Also used when the user shift+clicks\n * and drags to create a time range.\n */\nexport interface TimeRangeLabel {\n  type: 'TIME_RANGE';\n  bounds: Trace.Types.Timing.TraceWindowMicroSeconds;\n  label: string;\n  showDuration: boolean;\n}\n\n/**\n * Given a list of overlays, this method will calculate the smallest possible\n * trace window that will contain all of the overlays.\n * `overlays` is expected to be non-empty.\n */\nexport function traceWindowContainingOverlays(overlays: TimelineOverlay[]): Trace.Types.Timing.TraceWindowMicroSeconds {\n  let minTime = Trace.Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY);\n  let maxTime = Trace.Types.Timing.MicroSeconds(Number.NEGATIVE_INFINITY);\n\n  for (const overlay of overlays) {\n    const windowForOverlay = traceWindowForOverlay(overlay);\n    if (windowForOverlay.min < minTime) {\n      minTime = windowForOverlay.min;\n    }\n    if (windowForOverlay.max > maxTime) {\n      maxTime = windowForOverlay.max;\n    }\n  }\n\n  return Trace.Helpers.Timing.traceWindowFromMicroSeconds(minTime, maxTime);\n}\n\nfunction traceWindowForOverlay(overlay: TimelineOverlay): Trace.Types.Timing.TraceWindowMicroSeconds {\n  const overlayMinBounds: Trace.Types.Timing.MicroSeconds[] = [];\n  const overlayMaxBounds: Trace.Types.Timing.MicroSeconds[] = [];\n\n  switch (overlay.type) {\n    case 'ENTRY_SELECTED': {\n      const timings = timingsForOverlayEntry(overlay.entry);\n      overlayMinBounds.push(timings.startTime);\n      overlayMaxBounds.push(timings.endTime);\n      break;\n    }\n    case 'ENTRY_OUTLINE': {\n      const timings = timingsForOverlayEntry(overlay.entry);\n      overlayMinBounds.push(timings.startTime);\n      overlayMaxBounds.push(timings.endTime);\n      break;\n    }\n\n    case 'TIME_RANGE': {\n      overlayMinBounds.push(overlay.bounds.min);\n      overlayMaxBounds.push(overlay.bounds.max);\n      break;\n    }\n    case 'ENTRY_LABEL': {\n      const timings = timingsForOverlayEntry(overlay.entry);\n      overlayMinBounds.push(timings.startTime);\n      overlayMaxBounds.push(timings.endTime);\n      break;\n    }\n\n    case 'ENTRIES_LINK': {\n      const timingsFrom = timingsForOverlayEntry(overlay.entryFrom);\n      overlayMinBounds.push(timingsFrom.startTime);\n      if (overlay.entryTo) {\n        const timingsTo = timingsForOverlayEntry(overlay.entryTo);\n        // No need to push the startTime; it must be larger than the entryFrom start time.\n        overlayMaxBounds.push(timingsTo.endTime);\n      } else {\n        // Only use the end time if we have no entryTo; otherwise the entryTo\n        // endTime is guaranteed to be larger than the entryFrom endTime.\n        overlayMaxBounds.push(timingsFrom.endTime);\n      }\n\n      break;\n    }\n    case 'TIMESPAN_BREAKDOWN': {\n      if (overlay.entry) {\n        const timings = timingsForOverlayEntry(overlay.entry);\n        overlayMinBounds.push(timings.startTime);\n        overlayMaxBounds.push(timings.endTime);\n      }\n      for (const section of overlay.sections) {\n        overlayMinBounds.push(section.bounds.min);\n        overlayMaxBounds.push(section.bounds.max);\n      }\n      break;\n    }\n    case 'TIMESTAMP_MARKER': {\n      overlayMinBounds.push(overlay.timestamp);\n      break;\n    }\n    case 'CANDY_STRIPED_TIME_RANGE': {\n      const timings = timingsForOverlayEntry(overlay.entry);\n      overlayMinBounds.push(timings.startTime);\n      overlayMaxBounds.push(timings.endTime);\n      overlayMinBounds.push(overlay.bounds.min);\n      overlayMaxBounds.push(overlay.bounds.max);\n      break;\n    }\n    case 'TIMINGS_MARKER': {\n      const timings = timingsForOverlayEntry(overlay.entries[0]);\n      overlayMinBounds.push(timings.startTime);\n      break;\n    }\n    default:\n      Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n  }\n\n  const min = Trace.Types.Timing.MicroSeconds(Math.min(...overlayMinBounds));\n  const max = Trace.Types.Timing.MicroSeconds(Math.max(...overlayMaxBounds));\n  return Trace.Helpers.Timing.traceWindowFromMicroSeconds(min, max);\n}\n\n/**\n * Get a list of entries for a given overlay.\n */\nexport function entriesForOverlay(overlay: TimelineOverlay): readonly OverlayEntry[] {\n  const entries: OverlayEntry[] = [];\n\n  switch (overlay.type) {\n    case 'ENTRY_SELECTED': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'ENTRY_OUTLINE': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'TIME_RANGE': {\n      // Time ranges are not associated with entries.\n      break;\n    }\n    case 'ENTRY_LABEL': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'ENTRIES_LINK': {\n      entries.push(overlay.entryFrom);\n      if (overlay.entryTo) {\n        entries.push(overlay.entryTo);\n      }\n      break;\n    }\n    case 'TIMESPAN_BREAKDOWN': {\n      if (overlay.entry) {\n        entries.push(overlay.entry);\n      }\n      break;\n    }\n    case 'TIMESTAMP_MARKER': {\n      // This overlay type isn't associated to any entry, so just break here.\n      break;\n    }\n    case 'CANDY_STRIPED_TIME_RANGE': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'TIMINGS_MARKER': {\n      entries.push(...overlay.entries);\n      break;\n    }\n    default:\n      Platform.assertNever(overlay, `Unknown overlay type ${JSON.stringify(overlay)}`);\n  }\n\n  return entries;\n}\nexport function chartForEntry(entry: OverlayEntry): EntryChartLocation {\n  if (Trace.Types.Events.isNetworkTrackEntry(entry)) {\n    return 'network';\n  }\n\n  return 'main';\n}\n\n/**\n * Used to highlight with a red-candy stripe a time range. It takes an entry\n * because this entry is the row that will be used to place the candy stripe,\n * and its height will be set to the height of that row.\n */\nexport interface CandyStripedTimeRange {\n  type: 'CANDY_STRIPED_TIME_RANGE';\n  bounds: Trace.Types.Timing.TraceWindowMicroSeconds;\n  entry: Trace.Types.Events.Event;\n}\n\n/**\n * Represents a timespan on a trace broken down into parts. Each part has a label to it.\n * If an entry is defined, the breakdown will be vertically positioned based on it.\n */\nexport interface TimespanBreakdown {\n  type: 'TIMESPAN_BREAKDOWN';\n  sections: Array<Components.TimespanBreakdownOverlay.EntryBreakdown>;\n  entry?: Trace.Types.Events.Event;\n  renderLocation?: 'BOTTOM_OF_TIMELINE'|'BELOW_EVENT'|'ABOVE_EVENT';\n}\n\nexport interface TimestampMarker {\n  type: 'TIMESTAMP_MARKER';\n  timestamp: Trace.Types.Timing.MicroSeconds;\n}\n\n/**\n * Represents a timings marker. This has a line that runs up the whole canvas.\n * We can hold an array of entries, in the case we want to hold more than one with the same timestamp.\n * The adjusted timestamp being the timestamp for the event adjusted by closest navigation.\n */\nexport interface TimingsMarker {\n  type: 'TIMINGS_MARKER';\n  entries: Trace.Types.Events.Event[];\n  adjustedTimestamp: Trace.Types.Timing.MicroSeconds;\n}\n\n/**\n * All supported overlay types.\n */\nexport type TimelineOverlay = EntrySelected|EntryOutline|TimeRangeLabel|EntryLabel|EntriesLink|TimespanBreakdown|\n    TimestampMarker|CandyStripedTimeRange|TimingsMarker;\n\nexport interface TimelineOverlaySetOptions {\n  updateTraceWindow: boolean;\n}\n\n/**\n * Denotes overlays that are singletons; only one of these will be allowed to\n * exist at any given time. If one exists and the add() method is called, the\n * new overlay will replace the existing one.\n */\ntype SingletonOverlay = EntrySelected|TimestampMarker;\nexport function overlayIsSingleton(overlay: TimelineOverlay): overlay is SingletonOverlay {\n  return overlay.type === 'TIMESTAMP_MARKER' || overlay.type === 'ENTRY_SELECTED';\n}\n\n/**\n * To be able to draw overlays accurately at the correct pixel position, we\n * need a variety of pixel values from both flame charts (Network and \"Rest\").\n * As each FlameChart draws, it emits an event with its latest set of\n * dimensions. That updates the Overlays and causes them to redraw.\n * Note that we can't use the visible trace window from the TraceBounds\n * service as that can get out of sync with rapid FlameChart draws. To ensure\n * we draw overlays smoothly as the FlameChart renders we use the latest values\n * provided to us from the FlameChart. In `FlameChart#draw` we dispatch an\n * event containing the latest dimensions, and those are passed into the\n * Overlays system via TimelineFlameChartView.\n */\ninterface ActiveDimensions {\n  trace: {\n    visibleWindow: Trace.Types.Timing.TraceWindowMicroSeconds|null,\n  };\n  charts: {\n    main: FlameChartDimensions|null,\n    network: FlameChartDimensions|null,\n  };\n}\n\n/**\n * The dimensions each flame chart reports. Note that in the current UI they\n * will always have the same width, so theoretically we could only gather that\n * from one chart, but we gather it from both for simplicity and to cover us in\n * the future should the UI change and the charts have different widths.\n */\ninterface FlameChartDimensions {\n  widthPixels: number;\n  heightPixels: number;\n  scrollOffsetPixels: number;\n  // If every single group (e.g. track) within the chart is collapsed or not.\n  // This matters because in the network track if every group (there is only\n  // one) is collapsed, there is no resizer bar shown, which impacts our pixel\n  // calculations for overlay positioning.\n  allGroupsCollapsed: boolean;\n}\n\nexport interface TimelineCharts {\n  mainChart: PerfUI.FlameChart.FlameChart;\n  mainProvider: PerfUI.FlameChart.FlameChartDataProvider;\n  networkChart: PerfUI.FlameChart.FlameChart;\n  networkProvider: PerfUI.FlameChart.FlameChartDataProvider;\n}\n\nexport interface OverlayEntryQueries {\n  isEntryCollapsedByUser: (entry: Trace.Types.Events.Event) => boolean;\n  firstVisibleParentForEntry: (entry: Trace.Types.Events.Event) => Trace.Types.Events.Event | null;\n}\n\n// An event dispatched when one of the Annotation Overlays (overlay created by the user,\n// ex. EntryLabel) is removed or updated. When one of the Annotation Overlays is removed or updated,\n// ModificationsManager listens to this event and updates the current annotations.\nexport type UpdateAction = 'Remove'|'Update';\nexport class AnnotationOverlayActionEvent extends Event {\n  static readonly eventName = 'annotationoverlayactionsevent';\n\n  constructor(public overlay: TimelineOverlay, public action: UpdateAction) {\n    super(AnnotationOverlayActionEvent.eventName);\n  }\n}\n\nexport class TimeRangeMouseOverEvent extends Event {\n  static readonly eventName = 'timerangemouseoverevent';\n\n  constructor(public overlay: TimeRangeLabel) {\n    super(TimeRangeMouseOverEvent.eventName, {bubbles: true});\n  }\n}\n\nexport class TimeRangeMouseOutEvent extends Event {\n  static readonly eventName = 'timerangemouseoutevent';\n\n  constructor() {\n    super(TimeRangeMouseOutEvent.eventName, {bubbles: true});\n  }\n}\n\ninterface EntriesLinkVisibleEntries {\n  entryFrom: Trace.Types.Events.Event;\n  entryTo: Trace.Types.Events.Event|undefined;\n  entryFromIsSource: boolean;\n  entryToIsSource: boolean;\n}\n\nexport class EventReferenceClick extends Event {\n  static readonly eventName = 'eventreferenceclick';\n\n  constructor(public event: Trace.Types.Events.Event) {\n    super(EventReferenceClick.eventName, {bubbles: true, composed: true});\n  }\n}\n\n/**\n * This class manages all the overlays that get drawn onto the performance\n * timeline. Overlays are DOM and are drawn above the network and main flame\n * chart.\n *\n * For more documentation, see `timeline/README.md` which has a section on overlays.\n */\nexport class Overlays extends EventTarget {\n  /**\n   * The list of active overlays. Overlays can't be marked as visible or\n   * hidden; every overlay in this list is rendered.\n   * We track each overlay against the HTML Element we have rendered. This is\n   * because on first render of a new overlay, we create it, but then on\n   * subsequent renders we do not destroy and recreate it, instead we update it\n   * based on the new position of the timeline.\n   */\n  #overlaysToElements: Map<TimelineOverlay, HTMLElement|null> = new Map();\n\n  // When the Entries Link Annotation is created, the arrow needs to follow the mouse.\n  // Update the mouse coordinates while it is being created.\n  #lastMouseOffsetX: number|null = null;\n  #lastMouseOffsetY: number|null = null;\n  // `entriesLinkInProgress` is the entries link Overlay that has not yet been fully created\n  // and only has the entry that the link starts from set.\n  // We save it as a separate variable because when the second entry of the link is not chosen yet,\n  // the arrow follows the mouse. To achieve that, update the coordinates of `entriesLinkInProgress`\n  // on mousemove. There can only be one link in the process on being created so the mousemove\n  // only needs to update `entriesLinkInProgress` link overlay.\n  #entriesLinkInProgress: EntriesLink|null;\n\n  #dimensions: ActiveDimensions = {\n    trace: {\n      visibleWindow: null,\n    },\n    charts: {\n      main: null,\n      network: null,\n    },\n  };\n\n  /**\n   * To calculate the Y pixel value for an event we need access to the chart\n   * and data provider in order to find out what level the event is on, and from\n   * there calculate the pixel value for that level.\n   */\n  #charts: TimelineCharts;\n\n  /**\n   * The Overlays class will take each overlay, generate its HTML, and add it\n   * to the container. This container is provided for us when the class is\n   * created so we can manage its contents as overlays come and go.\n   */\n  #overlaysContainer: HTMLElement;\n\n  // Setting that specififed if the annotations overlays need to be visible.\n  // It is switched on/off from the annotations tab in the sidebar.\n  readonly #annotationsHiddenSetting: Common.Settings.Setting<boolean>;\n\n  /**\n   * The OverlaysManager sometimes needs to find out if an entry is visible or\n   * not, and if not, why not - for example, if the user has collapsed its\n   * parent. We define these query functions that must be supplied in order to\n   * answer these questions.\n   */\n  #queries: OverlayEntryQueries;\n\n  constructor(init: {\n    container: HTMLElement,\n    flameChartsContainers: {\n      main: HTMLElement,\n      network: HTMLElement,\n    },\n    charts: TimelineCharts,\n    entryQueries: OverlayEntryQueries,\n  }) {\n    super();\n    this.#overlaysContainer = init.container;\n    this.#charts = init.charts;\n    this.#queries = init.entryQueries;\n    this.#entriesLinkInProgress = null;\n    this.#annotationsHiddenSetting = Common.Settings.Settings.instance().moduleSetting('annotations-hidden');\n    this.#annotationsHiddenSetting.addChangeListener(this.update.bind(this));\n\n    // HTMLElements of both Flamecharts. They are used to get the mouse position over the Flamecharts.\n    init.flameChartsContainers.main.addEventListener(\n        'mousemove', event => this.#updateMouseCoordinatesProgressEntriesLink.bind(this)(event, 'main'));\n    init.flameChartsContainers.network.addEventListener(\n        'mousemove', event => this.#updateMouseCoordinatesProgressEntriesLink.bind(this)(event, 'network'));\n  }\n\n  // Mousemove event listener to get mouse coordinates and update them for the entries link that is being created.\n  //\n  // The 'mousemove' event is attached to `flameChartsContainers` instead of `overlaysContainer`\n  // because `overlaysContainer` doesn't have events to enable the interaction with the\n  // Flamecharts beneath it.\n  #updateMouseCoordinatesProgressEntriesLink(event: Event, chart: EntryChartLocation): void {\n    const mouseEvent = (event as MouseEvent);\n    this.#lastMouseOffsetX = mouseEvent.offsetX;\n    this.#lastMouseOffsetY = mouseEvent.offsetY;\n\n    if (this.#entriesLinkInProgress?.state !== Trace.Types.File.EntriesLinkState.PENDING_TO_EVENT) {\n      return;\n    }\n\n    // The Overlays layer coordinates cover both Network and Main Charts, while the mousemove\n    // coordinates are received from the charts individually and start from 0 for each chart.\n    //\n    // To make it work on the overlays, we need to know which chart the entry belongs to and,\n    // if it is on the main chart, add the height of the Network chart to get correct Entry\n    // coordinates on the Overlays layer.\n    const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n    const linkInProgressElement = this.#overlaysToElements.get(this.#entriesLinkInProgress);\n\n    if (linkInProgressElement) {\n      const component = linkInProgressElement.querySelector('devtools-entries-link-overlay') as\n          Components.EntriesLinkOverlay.EntriesLinkOverlay;\n      const yCoordinate = mouseEvent.offsetY + ((chart === 'main') ? networkHeight : 0);\n      component.toEntryCoordinateAndDimentions = {x: mouseEvent.offsetX, y: yCoordinate};\n    }\n  }\n\n  /**\n   * Add a new overlay to the view.\n   */\n  add<T extends TimelineOverlay>(newOverlay: T): T {\n    if (this.#overlaysToElements.has(newOverlay)) {\n      return newOverlay;\n    }\n\n    /**\n     * If the overlay type is a singleton, and we already have one, we update\n     * the existing one, rather than create a new one. This ensures you can only\n     * ever have one instance of the overlay type.\n     */\n    const existing = this.overlaysOfType<T>(newOverlay.type);\n    if (overlayIsSingleton(newOverlay) && existing[0]) {\n      this.updateExisting(existing[0], newOverlay);\n      return existing[0];\n    }\n\n    // By setting the value to null, we ensure that on the next render that the\n    // overlay will have a new HTML element created for it.\n    this.#overlaysToElements.set(newOverlay, null);\n    return newOverlay;\n  }\n\n  /**\n   * Update an existing overlay without destroying and recreating its\n   * associated DOM.\n   *\n   * This is useful if you need to rapidly update an overlay's data - e.g.\n   * dragging to create time ranges - without the thrashing of destroying the\n   * old overlay and re-creating the new one.\n   */\n  updateExisting<T extends TimelineOverlay>(existingOverlay: T, newData: Partial<T>): void {\n    if (!this.#overlaysToElements.has(existingOverlay)) {\n      console.error('Trying to update an overlay that does not exist.');\n      return;\n    }\n\n    for (const [key, value] of Object.entries(newData)) {\n      // newData is of type Partial<T>, so each key must exist in T, but\n      // Object.entries doesn't carry that information.\n      const k = key as keyof T;\n      existingOverlay[k] = value;\n    }\n  }\n\n  enterLabelEditMode(overlay: EntryLabel): void {\n    // Entry edit state can be triggered from outside the label component by clicking on the\n    // Entry that already has a label. Instead of creating a new label, set the existing entry\n    // label into an editable state.\n    const element = this.#overlaysToElements.get(overlay);\n    const component = element?.querySelector('devtools-entry-label-overlay');\n    if (component) {\n      component.setLabelEditabilityAndRemoveEmptyLabel(true);\n    }\n  }\n\n  /**\n   * @returns the list of overlays associated with a given entry.\n   */\n  overlaysForEntry(entry: OverlayEntry): TimelineOverlay[] {\n    const matches: TimelineOverlay[] = [];\n    for (const [overlay] of this.#overlaysToElements) {\n      if ('entry' in overlay && overlay.entry === entry) {\n        matches.push(overlay);\n      }\n    }\n    return matches;\n  }\n\n  /**\n   * Removes any active overlays that match the provided type.\n   * @returns the number of overlays that were removed.\n   */\n  removeOverlaysOfType(type: TimelineOverlay['type']): number {\n    const overlaysToRemove = Array.from(this.#overlaysToElements.keys()).filter(overlay => {\n      return overlay.type === type;\n    });\n    for (const overlay of overlaysToRemove) {\n      this.remove(overlay);\n    }\n    return overlaysToRemove.length;\n  }\n\n  /**\n   * @returns all overlays that match the provided type.\n   */\n  overlaysOfType<T extends TimelineOverlay>(type: T['type']): NoInfer<T>[] {\n    const matches: T[] = [];\n\n    function overlayIsOfType(overlay: TimelineOverlay): overlay is T {\n      return overlay.type === type;\n    }\n\n    for (const [overlay] of this.#overlaysToElements) {\n      if (overlayIsOfType(overlay)) {\n        matches.push(overlay);\n      }\n    }\n    return matches;\n  }\n\n  /**\n   * Removes the provided overlay from the list of overlays and destroys any\n   * DOM associated with it.\n   */\n  remove(overlay: TimelineOverlay): void {\n    const htmlElement = this.#overlaysToElements.get(overlay);\n    if (htmlElement && this.#overlaysContainer) {\n      this.#overlaysContainer.removeChild(htmlElement);\n    }\n    this.#overlaysToElements.delete(overlay);\n  }\n\n  /**\n   * Update the dimenions of a chart.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateChartDimensions(chart: EntryChartLocation, dimensions: FlameChartDimensions): void {\n    this.#dimensions.charts[chart] = dimensions;\n  }\n\n  /**\n   * Update the visible window of the UI.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateVisibleWindow(visibleWindow: Trace.Types.Timing.TraceWindowMicroSeconds): void {\n    this.#dimensions.trace.visibleWindow = visibleWindow;\n  }\n\n  /**\n   * Clears all overlays and all data. Call this when the trace is changing\n   * (e.g. the user has imported/recorded a new trace) and we need to start from\n   * scratch and remove all overlays relating to the preivous trace.\n   */\n  reset(): void {\n    if (this.#overlaysContainer) {\n      this.#overlaysContainer.innerHTML = '';\n    }\n    this.#overlaysToElements.clear();\n\n    // Clear out dimensions from the old Flame Charts.\n    this.#dimensions.trace.visibleWindow = null;\n    this.#dimensions.charts.main = null;\n    this.#dimensions.charts.network = null;\n  }\n\n  /**\n   * Updates the Overlays UI: new overlays will be rendered onto the view, and\n   * existing overlays will have their positions changed to ensure they are\n   * rendered in the right place.\n   */\n  async update(): Promise<void> {\n    const timeRangeOverlays: TimeRangeLabel[] = [];\n    const timingsMarkerOverlays: TimingsMarker[] = [];\n\n    for (const [overlay, existingElement] of this.#overlaysToElements) {\n      const element = existingElement || this.#createElementForNewOverlay(overlay);\n      if (!existingElement) {\n        // This is a new overlay, so we have to store the element and add it to the DOM.\n        this.#overlaysToElements.set(overlay, element);\n        this.#overlaysContainer.appendChild(element);\n      }\n\n      // A chance to update the overlay before we re-position it. If an\n      // overlay's data changed, this is where we can pass that data into the\n      // overlay's component so it has the latest data.\n      this.#updateOverlayBeforePositioning(overlay, element);\n\n      // Now we position the overlay on the timeline.\n      this.#positionOverlay(overlay, element);\n\n      // And now we give every overlay a chance to react to its new position,\n      // if it needs to\n      this.#updateOverlayAfterPositioning(overlay, element);\n\n      if (overlay.type === 'TIME_RANGE') {\n        timeRangeOverlays.push(overlay);\n      }\n      if (overlay.type === 'TIMINGS_MARKER') {\n        timingsMarkerOverlays.push(overlay);\n      }\n    }\n\n    if (timeRangeOverlays.length > 1) {  // If there are 0 or 1 overlays, they can't overlap\n      this.#positionOverlappingTimeRangeLabels(timeRangeOverlays);\n    }\n  }\n\n  /**\n   * If any time-range overlays overlap, we try to adjust their horizontal\n   * position in order to make sure you can distinguish them and that the labels\n   * do not entirely overlap.\n   * This is very much minimal best effort, and does not guarantee that all\n   * labels will remain readable.\n   */\n  #positionOverlappingTimeRangeLabels(overlays: readonly TimeRangeLabel[]): void {\n    const overlaysSorted = overlays.toSorted((o1, o2) => {\n      return o1.bounds.min - o2.bounds.min;\n    });\n\n    // Track the overlays which overlap other overlays.\n    // This isn't bi-directional: if we find that O2 overlaps O1, we will\n    // store O1 => [O2]. We will not then also store O2 => [O1], because we\n    // only need to deal with the overlap once.\n    const overlapsByOverlay: Map<TimeRangeLabel, TimeRangeLabel[]> = new Map();\n\n    for (let i = 0; i < overlaysSorted.length; i++) {\n      const current = overlaysSorted[i];\n      const overlaps: TimeRangeLabel[] = [];\n\n      // Walk through subsequent overlays and find stop when you find the next one that does not overlap.\n      for (let j = i + 1; j < overlaysSorted.length; j++) {\n        const next = overlaysSorted[j];\n        const currentAndNextOverlap = Trace.Helpers.Timing.boundsIncludeTimeRange({\n          bounds: current.bounds,\n          timeRange: next.bounds,\n        });\n        if (currentAndNextOverlap) {\n          overlaps.push(next);\n        } else {\n          // Overlays are sorted by time, if this one does not overlap, the next one will not, so we can break.\n          break;\n        }\n      }\n      overlapsByOverlay.set(current, overlaps);\n    }\n    for (const [firstOverlay, overlappingOverlays] of overlapsByOverlay) {\n      const element = this.#overlaysToElements.get(firstOverlay);\n      if (!element) {\n        continue;\n      }\n\n      // If the first overlay is adjusted, we can start back from 0 again\n      // rather than continually increment up.\n      let firstIndexForOverlapClass = 1;\n      if (element.getAttribute('class')?.includes('overlap-')) {\n        firstIndexForOverlapClass = 0;\n      }\n\n      overlappingOverlays.forEach(overlay => {\n        const element = this.#overlaysToElements.get(overlay);\n        element?.classList.add(`overlap-${firstIndexForOverlapClass++}`);\n      });\n    }\n  }\n\n  #positionOverlay(overlay: TimelineOverlay, element: HTMLElement): void {\n    const annotationsAreHidden = this.#annotationsHiddenSetting.get();\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED': {\n        const isVisible = this.entryIsVisibleOnChart(overlay.entry);\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionEntryBorderOutlineType(overlay.entry, element);\n        }\n        break;\n      }\n      case 'ENTRY_OUTLINE': {\n        const selectedOverlay = this.overlaysOfType<EntrySelected>('ENTRY_SELECTED')?.at(0);\n        // Check if this entry has also been selected by the user. If it has,\n        // do not show the outline, but only show the selected outline.\n        const outlinedEntryIsSelected = Boolean(selectedOverlay && selectedOverlay.entry === overlay.entry);\n        if (!outlinedEntryIsSelected && this.entryIsVisibleOnChart(overlay.entry)) {\n          this.#setOverlayElementVisibility(element, true);\n          this.#positionEntryBorderOutlineType(overlay.entry, element);\n        } else {\n          this.#setOverlayElementVisibility(element, false);\n        }\n        break;\n      }\n\n      case 'TIME_RANGE': {\n        // The time range annotation can also be used to measure a selection in the timeline and is not saved if no label is added.\n        // Therefore, we only care about the annotation hidden setting if the time range has a label.\n        if (overlay.label.length) {\n          this.#setOverlayElementVisibility(element, !annotationsAreHidden);\n        }\n        this.#positionTimeRangeOverlay(overlay, element);\n        break;\n      }\n      case 'ENTRY_LABEL': {\n        const entryVisible = this.entryIsVisibleOnChart(overlay.entry);\n        this.#setOverlayElementVisibility(element, entryVisible && !annotationsAreHidden);\n        if (entryVisible) {\n          const entryLabelVisibleHeight = this.#positionEntryLabelOverlay(overlay, element);\n          const component = element.querySelector('devtools-entry-label-overlay');\n          if (component && entryLabelVisibleHeight) {\n            component.entryLabelVisibleHeight = entryLabelVisibleHeight;\n          }\n        }\n        break;\n      }\n      case 'ENTRIES_LINK': {\n        // The exact entries that are linked to could be collapsed in a flame\n        // chart, so we figure out the best visible entry pairs to draw\n        // between.\n        const entriesToConnect = this.#calculateFromAndToForEntriesLink(overlay);\n        const isVisible = entriesToConnect !== null && !annotationsAreHidden;\n        this.#setOverlayElementVisibility(element, isVisible);\n\n        if (isVisible) {\n          this.#positionEntriesLinkOverlay(overlay, element, entriesToConnect);\n        }\n        break;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        this.#positionTimespanBreakdownOverlay(overlay, element);\n        // TODO: Have the timespan squeeze instead.\n        if (overlay.entry) {\n          const {visibleWindow} = this.#dimensions.trace;\n          const isVisible = Boolean(\n              visibleWindow && this.#entryIsVerticallyVisibleOnChart(overlay.entry) &&\n                  Trace.Helpers.Timing.boundsIncludeTimeRange({\n                    bounds: visibleWindow,\n                    timeRange: overlay.sections[0].bounds,\n                  }),\n          );\n          this.#setOverlayElementVisibility(element, isVisible);\n        }\n        break;\n      }\n\n      case 'TIMESTAMP_MARKER': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // Only update the position if the timestamp of this marker is within\n        // the visible bounds.\n        const isVisible =\n            Boolean(visibleWindow && Trace.Helpers.Timing.timestampIsInBounds(visibleWindow, overlay.timestamp));\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionTimingOverlay(overlay, element);\n        }\n        break;\n      }\n\n      case 'CANDY_STRIPED_TIME_RANGE': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // If the bounds of this overlay are not within the visible bounds, we\n        // can skip updating its position and just hide it.\n\n        const isVisible = Boolean(\n            visibleWindow && this.#entryIsVerticallyVisibleOnChart(overlay.entry) &&\n            Trace.Helpers.Timing.boundsIncludeTimeRange({\n              bounds: visibleWindow,\n              timeRange: overlay.bounds,\n            }));\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionCandyStripedTimeRange(overlay, element);\n        }\n        break;\n      }\n\n      case 'TIMINGS_MARKER': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // All the entries have the same ts, so can use the first.\n        const isVisible = Boolean(visibleWindow && this.#entryIsHorizontallyVisibleOnChart(overlay.entries[0]));\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionTimingOverlay(overlay, element);\n        }\n        break;\n      }\n\n      default: {\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unknown overlay: ${JSON.stringify(overlay)}`);\n      }\n    }\n  }\n\n  #positionTimingOverlay(overlay: TimestampMarker|TimingsMarker, element: HTMLElement): void {\n    let left;\n    switch (overlay.type) {\n      case 'TIMINGS_MARKER': {\n        // All the entries have the same ts, so can use the first.\n        const timings = Trace.Helpers.Timing.eventTimingsMicroSeconds(overlay.entries[0]);\n        left = this.#xPixelForMicroSeconds('main', timings.startTime);\n        break;\n      }\n      case 'TIMESTAMP_MARKER': {\n        // Because we are adjusting the x position, we can use either chart here.\n        left = this.#xPixelForMicroSeconds('main', overlay.timestamp);\n        break;\n      }\n    }\n    element.style.left = `${left}px`;\n  }\n\n  #positionTimespanBreakdownOverlay(overlay: TimespanBreakdown, element: HTMLElement): void {\n    if (overlay.sections.length === 0) {\n      return;\n    }\n\n    const component = element.querySelector('devtools-timespan-breakdown-overlay');\n    const elementSections = component?.renderedSections() ?? [];\n\n    // Handle horizontal positioning.\n    const leftEdgePixel = this.#xPixelForMicroSeconds('main', overlay.sections[0].bounds.min);\n    const rightEdgePixel =\n        this.#xPixelForMicroSeconds('main', overlay.sections[overlay.sections.length - 1].bounds.max);\n    if (leftEdgePixel === null || rightEdgePixel === null) {\n      return;\n    }\n\n    const rangeWidth = rightEdgePixel - leftEdgePixel;\n    element.style.left = `${leftEdgePixel}px`;\n    element.style.width = `${rangeWidth}px`;\n\n    if (elementSections.length === 0) {\n      return;\n    }\n\n    let count = 0;\n    for (const section of overlay.sections) {\n      const leftPixel = this.#xPixelForMicroSeconds('main', section.bounds.min);\n      const rightPixel = this.#xPixelForMicroSeconds('main', section.bounds.max);\n      if (leftPixel === null || rightPixel === null) {\n        return;\n      }\n      const rangeWidth = rightPixel - leftPixel;\n      const sectionElement = elementSections[count];\n\n      sectionElement.style.left = `${leftPixel}px`;\n      sectionElement.style.width = `${rangeWidth}px`;\n      count++;\n    }\n\n    // Handle vertical positioning based on the entry's vertical position.\n    if (overlay.entry && (overlay.renderLocation === 'BELOW_EVENT' || overlay.renderLocation === 'ABOVE_EVENT')) {\n      // Max height for the overlay box when attached to an entry.\n      const MAX_BOX_HEIGHT = 50;\n      element.style.maxHeight = `${MAX_BOX_HEIGHT}px`;\n\n      const y = this.yPixelForEventOnChart(overlay.entry);\n      if (y === null) {\n        return;\n      }\n      const eventHeight = this.pixelHeightForEventOnChart(overlay.entry);\n      if (eventHeight === null) {\n        return;\n      }\n\n      if (overlay.renderLocation === 'BELOW_EVENT') {\n        const top = y + eventHeight;\n        element.style.top = `${top}px`;\n      } else {\n        // Some padding so the box hovers just on top.\n        const PADDING = 7;\n\n        // Where the timespan breakdown should sit. Slightly on top of the entry.\n        const bottom = y - PADDING;\n\n        // Available space between the bottom of the overlay and top of the chart.\n        const minSpace = Math.max(bottom, 0);\n        // Contrain height to available space.\n        const height = Math.min(MAX_BOX_HEIGHT, minSpace);\n\n        const top = bottom - height;\n        element.style.top = `${top}px`;\n      }\n    }\n  }\n\n  /**\n   * Positions the arrow between two entries. Takes in the entriesToConnect\n   * because if one of the original entries is hidden in a collapsed main thread\n   * icicle, we use its parent to connect to.\n   */\n  #positionEntriesLinkOverlay(overlay: EntriesLink, element: HTMLElement, entriesToConnect: EntriesLinkVisibleEntries):\n      void {\n    const component = element.querySelector('devtools-entries-link-overlay');\n\n    if (component) {\n      const fromEntryInCollapsedTrack = this.#entryIsInCollapsedTrack(entriesToConnect.entryFrom);\n      const toEntryInCollapsedTrack =\n          entriesToConnect.entryTo && this.#entryIsInCollapsedTrack(entriesToConnect.entryTo);\n\n      const bothEntriesInCollapsedTrack = Boolean(fromEntryInCollapsedTrack && toEntryInCollapsedTrack);\n      // If both entries are in collapsed tracks, we hide the overlay completely.\n      if (bothEntriesInCollapsedTrack) {\n        this.#setOverlayElementVisibility(element, false);\n        return;\n      }\n\n      // If either entry (but not both) is in a track that the user has collapsed, we do not\n      // show the connection at all, but we still show the borders around\n      // the entry. So in this case we mark the overlay as visible, but\n      // tell it to not draw the arrow.\n      const hideArrow = Boolean(fromEntryInCollapsedTrack || toEntryInCollapsedTrack);\n      component.hideArrow = hideArrow;\n\n      const {entryFrom, entryTo, entryFromIsSource, entryToIsSource} = entriesToConnect;\n      const entryFromWrapper = component.entryFromWrapper();\n\n      // Should not happen, the 'from' wrapper should always exist. Something went wrong, return in this case.\n      if (!entryFromWrapper) {\n        return;\n      }\n\n      const fromEntryParams = this.#positionEntryBorderOutlineType(entriesToConnect.entryFrom, entryFromWrapper);\n\n      if (!fromEntryParams) {\n        // Something went wrong, we should always have parameters for the 'from' entry\n        return;\n      }\n\n      const {\n        entryHeight: fromEntryHeight,\n        entryWidth: fromEntryWidth,\n        cutOffHeight: fromCutOffHeight = 0,\n        x: fromEntryX,\n        y: fromEntryY,\n      } = fromEntryParams;\n\n      const entryFromVisibility = this.entryIsVisibleOnChart(entryFrom) && !fromEntryInCollapsedTrack;\n      const entryToVisibility = entryTo ? this.entryIsVisibleOnChart(entryTo) && !toEntryInCollapsedTrack : false;\n\n      // If `fromEntry` is not visible and the link creation is not started yet, meaning that\n      // only the button to create the link is displayed, delete the whole overlay.\n      if (!entryFromVisibility && overlay.state === Trace.Types.File.EntriesLinkState.CREATION_NOT_STARTED) {\n        this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n      }\n\n      // If the 'from' entry is visible, set the entry Y as an arrow start coordinate. Ff not, get the canvas edge coordinate to for the arrow to start from.\n      const yPixelForFromArrow =\n          (entryFromVisibility ? fromEntryY : this.#yCoordinateForNotVisibleEntry(entryFrom)) ?? 0;\n      component.fromEntryIsSource = entryFromIsSource;\n      component.toEntryIsSource = entryToIsSource;\n\n      component.entriesVisibility = {\n        fromEntryVisibility: entryFromVisibility,\n        toEntryVisibility: entryToVisibility,\n      };\n\n      component.fromEntryCoordinateAndDimentions =\n          {x: fromEntryX, y: yPixelForFromArrow, length: fromEntryWidth, height: fromEntryHeight - fromCutOffHeight};\n\n      // If entryTo exists, pass the coordinates and dimentions of the entry that the arrow snaps to.\n      // If it does not, the event tracking mouse coordinates updates 'to coordinates' so the arrow follows the mouse instead.\n      const entryToWrapper = component.entryToWrapper();\n\n      if (entryTo && entryToWrapper) {\n        const toEntryParams = this.#positionEntryBorderOutlineType(entryTo, entryToWrapper);\n\n        if (!toEntryParams) {\n          // Something went wrong, we should have those parameters if 'to' entry exists\n          return;\n        }\n        const {\n          entryHeight: toEntryHeight,\n          entryWidth: toEntryWidth,\n          cutOffHeight: toCutOffHeight = 0,\n          x: toEntryX,\n          y: toEntryY,\n        } = toEntryParams;\n\n        // If the 'to' entry is visible, set the entry Y as an arrow coordinate to point to. If not, get the canvas edge coordate to point the arrow to.\n        const yPixelForToArrow =\n            this.entryIsVisibleOnChart(entryTo) ? toEntryY : this.#yCoordinateForNotVisibleEntry(entryTo) ?? 0;\n\n        component.toEntryCoordinateAndDimentions = {\n          x: toEntryX,\n          y: yPixelForToArrow,\n          length: toEntryWidth,\n          height: toEntryHeight - toCutOffHeight,\n        };\n      } else if (this.#lastMouseOffsetX && this.#lastMouseOffsetY) {\n        // The second coordinate for in progress link gets updated on mousemove\n        this.#entriesLinkInProgress = overlay;\n      }\n    }\n  }\n\n  /**\n   *  Return Y coordinate for an arrow connecting 2 entries to attach to if the entry is not visible.\n   *  For example, if the entry is scrolled up from the visible area , return the y index of the edge of the track:\n   *  --\n   * |  | - entry off the visible chart\n   *  --\n   *\n   * --Y---------------  -- Y is the returned coordinate that the arrow should point to\n   *\n   * flamechart data     -- visible flamechart data between the 2 lines\n   * ------------------\n   *\n   * On the contrary, if the entry is scrolled off the bottom, get the coordinate of the top of the visible canvas.\n   */\n  #yCoordinateForNotVisibleEntry(entry: OverlayEntry): number {\n    const chartName = chartForEntry(entry);\n\n    const y = this.yPixelForEventOnChart(entry);\n    if (y === null) {\n      return 0;\n    }\n\n    if (chartName === 'main') {\n      if (!this.#dimensions.charts.main?.heightPixels) {\n        // Shouldn't happen, but if the main chart has no height, nothing on it is visible.\n        return 0;\n      }\n\n      const yWithoutNetwork = y - this.networkChartOffsetHeight();\n      // Check if the y position is less than 0. If it, the entry is off the top of the track canvas.\n      // In that case, return the height of network track, which is also the top of main track.\n      if (yWithoutNetwork < 0) {\n        return this.networkChartOffsetHeight();\n      }\n    }\n\n    if (chartName === 'network') {\n      if (!this.#dimensions.charts.network) {\n        return 0;\n      }\n\n      // The event is off the bottom of the network chart. In this case return the bottom of the network chart.\n      if (y > this.#dimensions.charts.network.heightPixels) {\n        return this.#dimensions.charts.network.heightPixels;\n      }\n    }\n\n    // In other cases, return the y of the entry\n    return y;\n  }\n\n  #positionTimeRangeOverlay(overlay: TimeRangeLabel, element: HTMLElement): void {\n    // Time ranges span both charts, it doesn't matter which one we pass here.\n    // It's used to get the width of the container, and both charts have the\n    // same width.\n    const leftEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.min);\n    const rightEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.max);\n    if (leftEdgePixel === null || rightEdgePixel === null) {\n      return;\n    }\n\n    const rangeWidth = rightEdgePixel - leftEdgePixel;\n\n    element.style.left = `${leftEdgePixel}px`;\n    element.style.width = `${rangeWidth}px`;\n  }\n\n  /**\n   * Positions an EntryLabel overlay\n   * @param overlay - the EntrySelected overlay that we need to position.\n   * @param element - the DOM element representing the overlay\n   */\n  #positionEntryLabelOverlay(overlay: EntryLabel, element: HTMLElement): number|null {\n    // Because the entry outline is a common Overlay pattern, get the wrapper of the entry\n    // that comes with the EntryLabel Overlay and pass it into the `positionEntryBorderOutlineType`\n    // to draw and position it. The other parts of EntryLabel are drawn by the `EntryLabelOverlay` class.\n    const component = element.querySelector('devtools-entry-label-overlay');\n    if (!component) {\n      return null;\n    }\n    const entryWrapper = component.entryHighlightWrapper();\n\n    if (!entryWrapper) {\n      return null;\n    }\n\n    const {entryHeight, entryWidth, cutOffHeight = 0, x, y} =\n        this.#positionEntryBorderOutlineType(overlay.entry, entryWrapper) || {};\n\n    if (!entryHeight || !entryWidth || x === null || !y) {\n      return null;\n    }\n\n    // Position the start of label overlay at the start of the entry + length of connector + legth of the label element\n    element.style.top = `${y - Components.EntryLabelOverlay.EntryLabelOverlay.LABEL_AND_CONNECTOR_HEIGHT}px`;\n    element.style.left = `${x}px`;\n    element.style.width = `${entryWidth}px`;\n\n    return entryHeight - cutOffHeight;\n  }\n\n  #positionCandyStripedTimeRange(overlay: CandyStripedTimeRange, element: HTMLElement): void {\n    const chartName = chartForEntry(overlay.entry);\n\n    const startX = this.#xPixelForMicroSeconds(chartName, overlay.bounds.min);\n    const endX = this.#xPixelForMicroSeconds(chartName, overlay.bounds.max);\n    if (startX === null || endX === null) {\n      return;\n    }\n\n    const widthPixels = endX - startX;\n    // The entry selected overlay is always at least 2px wide.\n    const finalWidth = Math.max(2, widthPixels);\n    element.style.width = `${finalWidth}px`;\n    element.style.left = `${startX}px`;\n\n    let y = this.yPixelForEventOnChart(overlay.entry);\n    if (y === null) {\n      return;\n    }\n\n    const totalHeight = this.pixelHeightForEventOnChart(overlay.entry) ?? 0;\n\n    // We might modify the height we use when drawing the overlay, hence copying the totalHeight.\n    let height = totalHeight;\n    if (height === null) {\n      return;\n    }\n\n    // If the event is on the main chart, we need to adjust its selected border\n    // if the event is cut off the top of the screen, because we need to ensure\n    // that it does not overlap the resize element. Unfortunately we cannot\n    // z-index our way out of this, so instead we calculate if the event is cut\n    // off, and if it is, we draw the partial selected outline and do not draw\n    // the top border, making it appear like it is going behind the resizer.\n    // We don't need to worry about it going off the bottom, because in that\n    // case we don't draw the overlay anyway.\n    if (chartName === 'main') {\n      const chartTopPadding = this.networkChartOffsetHeight();\n      // We now calculate the available height: if the entry is cut off we don't\n      // show the border for the part that is cut off.\n      const cutOffTop = y < chartTopPadding;\n\n      height = cutOffTop ? Math.abs(y + height - chartTopPadding) : height;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      if (cutOffTop) {\n        // Adjust the y position: we need to move it down from the top Y\n        // position to the Y position of the first visible pixel. The\n        // adjustment is totalHeight - height because if the totalHeight is 17,\n        // and the visibleHeight is 5, we need to draw the overay at 17-5=12px\n        // vertically from the top of the event.\n        y = y + totalHeight - height;\n      }\n    } else {\n      // If the event is on the network chart, we use the same logic as above\n      // for the main chart, but to check if the event is cut off the bottom of\n      // the network track and only part of the overlay is visible.\n      // We don't need to worry about the event going off the top of the panel\n      // as we can show the full overlay and it gets cut off by the minimap UI.\n      const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n      const lastVisibleY = y + totalHeight;\n      const cutOffBottom = lastVisibleY > networkHeight;\n      const cutOffTop = y > networkHeight;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      element.classList.toggle('cut-off-bottom', cutOffBottom);\n      if (cutOffBottom) {\n        // Adjust the height of the overlay to be the amount of visible pixels.\n        height = networkHeight - y;\n      }\n    }\n\n    element.style.height = `${height}px`;\n    element.style.top = `${y}px`;\n  }\n\n  /**\n   * Draw and position borders around an entry. Multiple overlays either fully consist\n   * of a border around an entry of have an entry border as a part of the overlay.\n   * Positions an EntrySelected or EntryOutline overlay and a part of the EntryLabel.\n   * @param overlay - the EntrySelected/EntryOutline/EntryLabel overlay that we need to position.\n   * @param element - the DOM element representing the overlay\n   */\n  #positionEntryBorderOutlineType(entry: OverlayEntry, element: HTMLElement):\n      {entryHeight: number, entryWidth: number, cutOffHeight: number, x: number, y: number}|null {\n    const chartName = chartForEntry(entry);\n    let x = this.xPixelForEventStartOnChart(entry);\n    let y = this.yPixelForEventOnChart(entry);\n    const chartWidth = (chartName === 'main') ? this.#dimensions.charts.main?.widthPixels :\n                                                this.#dimensions.charts.network?.widthPixels;\n\n    if (x === null || y === null || !chartWidth) {\n      return null;\n    }\n\n    const {endTime} = timingsForOverlayEntry(entry);\n    const endX = this.#xPixelForMicroSeconds(chartName, endTime);\n    if (endX === null) {\n      return null;\n    }\n\n    const totalHeight = this.pixelHeightForEventOnChart(entry) ?? 0;\n\n    // We might modify the height we use when drawing the overlay, hence copying the totalHeight.\n    let height = totalHeight;\n    if (height === null) {\n      return null;\n    }\n\n    // The width of the overlay is by default the width of the entry. However\n    // we modify that for instant events like LCP markers, and also ensure a\n    // minimum width.\n    let widthPixels = endX - x;\n\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const index = provider.indexForEvent?.(entry);\n    const customPos = chart.getCustomDrawnPositionForEntryIndex(index ?? -1);\n    if (customPos) {\n      // Some events like markers and layout shifts define their exact coordinates explicitly.\n      // If this is one of those events we should change the overlay coordinates to match.\n      x = customPos.x;\n      widthPixels = customPos.width;\n    }\n\n    // Calculate the visible overlay width by substracting the entry width that is outside of the flamechart width\n    const cutOffRight = (x + widthPixels > chartWidth) ? (x + widthPixels) - chartWidth : null;\n    const cutOffLeft = (x < 0) ? Math.abs(x) : null;\n    element.classList.toggle('cut-off-right', cutOffRight !== null);\n\n    if (cutOffRight) {\n      widthPixels = widthPixels - cutOffRight;\n    }\n\n    if (cutOffLeft) {\n      // If the entry is cut off from the left, move its beginning to the left most part of the flamechart\n      x = 0;\n      widthPixels = widthPixels - cutOffLeft;\n    }\n\n    // The entry selected overlay is always at least 2px wide.\n    const finalWidth = Math.max(2, widthPixels);\n    element.style.width = `${finalWidth}px`;\n\n    // If the event is on the main chart, we need to adjust its selected border\n    // if the event is cut off the top of the screen, because we need to ensure\n    // that it does not overlap the resize element. Unfortunately we cannot\n    // z-index our way out of this, so instead we calculate if the event is cut\n    // off, and if it is, we draw the partial selected outline and do not draw\n    // the top border, making it appear like it is going behind the resizer.\n    // We don't need to worry about it going off the bottom, because in that\n    // case we don't draw the overlay anyway.\n    if (chartName === 'main') {\n      const chartTopPadding = this.networkChartOffsetHeight();\n      // We now calculate the available height: if the entry is cut off we don't\n      // show the border for the part that is cut off.\n      const cutOffTop = y < chartTopPadding;\n\n      height = cutOffTop ? Math.abs(y + height - chartTopPadding) : height;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      if (cutOffTop) {\n        // Adjust the y position: we need to move it down from the top Y\n        // position to the Y position of the first visible pixel. The\n        // adjustment is totalHeight - height because if the totalHeight is 17,\n        // and the visibleHeight is 5, we need to draw the overay at 17-5=12px\n        // vertically from the top of the event.\n        y = y + totalHeight - height;\n      }\n    } else {\n      // If the event is on the network chart, we use the same logic as above\n      // for the main chart, but to check if the event is cut off the bottom of\n      // the network track and only part of the overlay is visible.\n      // We don't need to worry about the even going off the top of the panel\n      // as we can show the full overlay and it gets cut off by the minimap UI.\n      const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n      const lastVisibleY = y + totalHeight;\n      const cutOffBottom = lastVisibleY > networkHeight;\n      element.classList.toggle('cut-off-bottom', cutOffBottom);\n      if (cutOffBottom) {\n        // Adjust the height of the overlay to be the amount of visible pixels.\n        height = networkHeight - y;\n      }\n    }\n\n    element.style.height = `${height}px`;\n    element.style.top = `${y}px`;\n    element.style.left = `${x}px`;\n\n    return {entryHeight: totalHeight, entryWidth: finalWidth, cutOffHeight: totalHeight - height, x, y};\n  }\n\n  /**\n   * We draw an arrow between connected entries but this can get complicated\n   * depending on if the entries are visible or not. For example, the user might\n   * draw a connection to an entry in the main thread but then collapse the\n   * parent of that entry. In this case the entry we want to draw to is the\n   * first visible parent of that entry rather than the (invisible) entry.\n   */\n  #calculateFromAndToForEntriesLink(overlay: EntriesLink): EntriesLinkVisibleEntries|null {\n    if (!overlay.entryTo) {\n      // This case is where the user has clicked on the first entry and needs\n      // to pick a second. In this case they can only pick from visible\n      // entries, so we don't need to do any checks and can just return.\n      return {\n        entryFrom: overlay.entryFrom,\n        entryTo: overlay.entryTo,\n        entryFromIsSource: true,\n        entryToIsSource: true,\n      };\n    }\n\n    let entryFrom: OverlayEntry|null = overlay.entryFrom;\n    let entryTo: OverlayEntry|null = overlay.entryTo ?? null;\n\n    if (this.#queries.isEntryCollapsedByUser(overlay.entryFrom)) {\n      entryFrom = this.#queries.firstVisibleParentForEntry(overlay.entryFrom);\n    }\n    if (overlay.entryTo && this.#queries.isEntryCollapsedByUser(overlay.entryTo)) {\n      entryTo = this.#queries.firstVisibleParentForEntry(overlay.entryTo);\n    }\n\n    if (entryFrom === null || entryTo === null) {\n      // We cannot draw this overlay; so return null;\n      // The only valid case of entryTo being null/undefined has been dealt\n      // with already at the start of this function.\n      return null;\n    }\n\n    return {\n      entryFrom,\n      entryFromIsSource: entryFrom === overlay.entryFrom,\n      entryTo,\n      entryToIsSource: entryTo === overlay.entryTo,\n    };\n  }\n\n  #createElementForNewOverlay(overlay: TimelineOverlay): HTMLElement {\n    const div = document.createElement('div');\n    div.classList.add('overlay-item', `overlay-type-${overlay.type}`);\n\n    const jslogContext = jsLogContext(overlay);\n    if (jslogContext) {\n      div.setAttribute('jslog', `${VisualLogging.item(jslogContext)}`);\n    }\n\n    switch (overlay.type) {\n      case 'ENTRY_LABEL': {\n        const shouldDrawLabelBelowEntry = Trace.Types.Events.isLegacyTimelineFrame(overlay.entry);\n        const component = new Components.EntryLabelOverlay.EntryLabelOverlay(overlay.label, shouldDrawLabelBelowEntry);\n        component.addEventListener(Components.EntryLabelOverlay.EmptyEntryLabelRemoveEvent.eventName, () => {\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n        });\n        component.addEventListener(Components.EntryLabelOverlay.EntryLabelChangeEvent.eventName, event => {\n          const newLabel = (event as Components.EntryLabelOverlay.EntryLabelChangeEvent).newLabel;\n          overlay.label = newLabel;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        div.appendChild(component);\n        return div;\n      }\n      case 'ENTRIES_LINK': {\n        const entries = this.#calculateFromAndToForEntriesLink(overlay);\n        if (entries === null) {\n          // For some reason, we don't have two entries we can draw between\n          // (can happen if the user has collapsed an icicle in the flame\n          // chart, or a track), so just draw an empty div.\n          return div;\n        }\n        const entryEndX = this.xPixelForEventEndOnChart(entries.entryFrom) ?? 0;\n        const entryStartX = this.xPixelForEventEndOnChart(entries.entryFrom) ?? 0;\n        const entryStartY = (this.yPixelForEventOnChart(entries.entryFrom) ?? 0);\n        const entryWidth = entryEndX - entryStartX;\n        const entryHeight = this.pixelHeightForEventOnChart(entries.entryFrom) ?? 0;\n\n        const component = new Components.EntriesLinkOverlay.EntriesLinkOverlay(\n            {x: entryEndX, y: entryStartY, width: entryWidth, height: entryHeight}, overlay.state);\n\n        component.addEventListener(Components.EntriesLinkOverlay.EntryLinkStartCreating.eventName, () => {\n          overlay.state = Trace.Types.File.EntriesLinkState.PENDING_TO_EVENT;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        div.appendChild(component);\n        return div;\n      }\n      case 'ENTRY_OUTLINE': {\n        div.classList.add(`outline-reason-${overlay.outlineReason}`);\n        return div;\n      }\n      case 'TIME_RANGE': {\n        const component = new Components.TimeRangeOverlay.TimeRangeOverlay(overlay.label);\n        component.duration = overlay.showDuration ? overlay.bounds.range : null;\n        component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        component.addEventListener(Components.TimeRangeOverlay.TimeRangeLabelChangeEvent.eventName, event => {\n          const newLabel = (event as Components.TimeRangeOverlay.TimeRangeLabelChangeEvent).newLabel;\n          overlay.label = newLabel;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        component.addEventListener(Components.TimeRangeOverlay.TimeRangeRemoveEvent.eventName, () => {\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n        });\n        component.addEventListener('mouseover', () => {\n          this.dispatchEvent(new TimeRangeMouseOverEvent(overlay));\n        });\n        component.addEventListener('mouseout', () => {\n          this.dispatchEvent(new TimeRangeMouseOutEvent());\n        });\n        div.appendChild(component);\n        return div;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = new Components.TimespanBreakdownOverlay.TimespanBreakdownOverlay();\n        component.sections = overlay.sections;\n        component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        component.isBelowEntry = overlay.renderLocation === 'BELOW_EVENT';\n        div.appendChild(component);\n        return div;\n      }\n      case 'TIMINGS_MARKER': {\n        const {color} = EntryStyles.markerDetailsForEvent(overlay.entries[0]);\n        const markersComponent = this.#createTimingsMarkerElement(overlay);\n        div.appendChild(markersComponent);\n        div.style.backgroundColor = color;\n        return div;\n      }\n      default: {\n        return div;\n      }\n    }\n  }\n\n  #clickEvent(event: Trace.Types.Events.Event): void {\n    this.dispatchEvent(new EventReferenceClick(event));\n  }\n\n  #createOverlayPopover(adjustedTimestamp: Trace.Types.Timing.MicroSeconds, name: string): HTMLElement {\n    const popoverElement = document.createElement('div');\n    const popoverContents = popoverElement.createChild('div', 'overlay-popover');\n    popoverContents.createChild('span', 'overlay-popover-time').textContent =\n        i18n.TimeUtilities.formatMicroSecondsTime(adjustedTimestamp);\n    popoverContents.createChild('span', 'overlay-popover-title').textContent = name;\n    return popoverElement;\n  }\n\n  #mouseMoveOverlay(event: MouseEvent, name: string, overlay: TimingsMarker, markers: HTMLElement, marker: HTMLElement):\n      void {\n    const popoverElement = this.#createOverlayPopover(overlay.adjustedTimestamp, name);\n    this.#lastMouseOffsetX = event.offsetX + (markers.offsetLeft || 0) + (marker.offsetLeft || 0);\n    this.#lastMouseOffsetY = event.offsetY + markers.offsetTop || 0;\n    this.#charts.mainChart.updateMouseOffset(this.#lastMouseOffsetX, this.#lastMouseOffsetY);\n    this.#charts.mainChart.updatePopoverContents(popoverElement);\n  }\n\n  #mouseOutOverlay(): void {\n    this.#lastMouseOffsetX = -1;\n    this.#lastMouseOffsetY = -1;\n    this.#charts.mainChart.updateMouseOffset(this.#lastMouseOffsetX, this.#lastMouseOffsetY);\n    this.#charts.mainChart.hideHighlight();\n  }\n\n  #createTimingsMarkerElement(overlay: TimingsMarker): HTMLElement {\n    const markers = document.createElement('div');\n    markers.classList.add('markers');\n    for (const entry of overlay.entries) {\n      const {color, title} = EntryStyles.markerDetailsForEvent(entry);\n      const marker = document.createElement('div');\n      marker.classList.add('marker-title');\n      marker.textContent = title;\n      marker.style.backgroundColor = color;\n      markers.appendChild(marker);\n\n      marker.addEventListener('click', () => this.#clickEvent(entry));\n      // Popover.\n      marker.addEventListener('mousemove', event => this.#mouseMoveOverlay(event, title, overlay, markers, marker));\n      marker.addEventListener('mouseout', () => this.#mouseOutOverlay());\n    }\n    return markers;\n  }\n\n  /**\n   * Some overlays store data in their components that needs to be updated\n   * before we position an overlay. Else, we might position an overlay based on\n   * stale data. This method is used to update an overlay BEFORE it is then\n   * positioned onto the canvas. It is the right place to ensure an overlay has\n   * the latest data it needs.\n   */\n  #updateOverlayBeforePositioning(overlay: TimelineOverlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED':\n        break;\n      case 'TIME_RANGE': {\n        const component = element.querySelector('devtools-time-range-overlay');\n        if (component) {\n          component.duration = overlay.showDuration ? overlay.bounds.range : null;\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'ENTRY_LABEL':\n      case 'ENTRY_OUTLINE':\n      case 'ENTRIES_LINK': {\n        const component = element.querySelector('devtools-entries-link-overlay');\n        if (component) {\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = element.querySelector('devtools-timespan-breakdown-overlay');\n        if (component) {\n          component.sections = overlay.sections;\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'TIMESTAMP_MARKER':\n        break;\n      case 'CANDY_STRIPED_TIME_RANGE':\n        break;\n      case 'TIMINGS_MARKER':\n        break;\n      default:\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n    }\n  }\n  /**\n   * Some overlays have custom logic within them to manage visibility of\n   * labels/etc that can be impacted if the positioning or size of the overlay\n   * has changed. This method can be used to run code after an overlay has\n   * been updated + repositioned on the timeline.\n   */\n  #updateOverlayAfterPositioning(overlay: TimelineOverlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED':\n        break;\n      case 'TIME_RANGE': {\n        const component = element.querySelector('devtools-time-range-overlay');\n        component?.updateLabelPositioning();\n        break;\n      }\n      case 'ENTRY_LABEL':\n        break;\n      case 'ENTRY_OUTLINE':\n        break;\n      case 'ENTRIES_LINK':\n        break;\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = element.querySelector('devtools-timespan-breakdown-overlay');\n        component?.checkSectionLabelPositioning();\n        break;\n      }\n      case 'TIMESTAMP_MARKER':\n        break;\n      case 'CANDY_STRIPED_TIME_RANGE':\n        break;\n      case 'TIMINGS_MARKER':\n        break;\n      default:\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n    }\n  }\n\n  /**\n   * @returns true if the entry is visible on chart, which means that both\n   * horizontally and vertically it is at least partially in view.\n   */\n  entryIsVisibleOnChart(entry: OverlayEntry): boolean {\n    const verticallyVisible = this.#entryIsVerticallyVisibleOnChart(entry);\n    const horiziontallyVisible = this.#entryIsHorizontallyVisibleOnChart(entry);\n    return verticallyVisible && horiziontallyVisible;\n  }\n\n  /**\n   * Calculates if an entry is visible horizontally. This is easy because we\n   * don't have to consider any pixels and can instead check that its start and\n   * end times intersect with the visible window.\n   */\n  #entryIsHorizontallyVisibleOnChart(entry: OverlayEntry): boolean {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      return false;\n    }\n    const {startTime, endTime} = timingsForOverlayEntry(entry);\n\n    const entryTimeRange = Trace.Helpers.Timing.traceWindowFromMicroSeconds(startTime, endTime);\n\n    return Trace.Helpers.Timing.boundsIncludeTimeRange({\n      bounds: this.#dimensions.trace.visibleWindow,\n      timeRange: entryTimeRange,\n    });\n  }\n\n  #entryIsInCollapsedTrack(entry: OverlayEntry): boolean {\n    const chartName = chartForEntry(entry);\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const entryIndex = provider.indexForEvent?.(entry) ?? null;\n    if (entryIndex === null) {\n      return false;\n    }\n\n    const group = provider.groupForEvent?.(entryIndex) ?? null;\n    if (!group) {\n      return false;\n    }\n\n    return Boolean(group.expanded) === false;\n  }\n\n  /**\n   * Calculate if an entry is visible vertically on the chart. A bit fiddly as\n   * we have to figure out its pixel offset and go on that. Unlike horizontal\n   * visibility, we can't work soley from its microsecond values.\n   */\n  #entryIsVerticallyVisibleOnChart(entry: OverlayEntry): boolean {\n    const chartName = chartForEntry(entry);\n\n    const y = this.yPixelForEventOnChart(entry);\n    if (y === null) {\n      return false;\n    }\n\n    const eventHeight = this.pixelHeightForEventOnChart(entry);\n    if (!eventHeight) {\n      return false;\n    }\n\n    if (chartName === 'main') {\n      if (!this.#dimensions.charts.main?.heightPixels) {\n        // Shouldn't happen, but if the main chart has no height, nothing on it is visible.\n        return false;\n      }\n\n      // The yPixelForEventOnChart method returns the y pixel including an adjustment for the network track.\n      // To see if an entry on the main flame chart is visible, we can check\n      // its y value without the network track adjustment. If it is < 0, then\n      // it's off the top of the screen.\n      //\n      const yWithoutNetwork = y - this.networkChartOffsetHeight();\n      // Check if the y position + the height is less than 0. We add height so\n      // that we correctly consider an event only partially scrolled off to be\n      // visible.\n      if (yWithoutNetwork + eventHeight < 0) {\n        return false;\n      }\n\n      if (yWithoutNetwork > this.#dimensions.charts.main.heightPixels) {\n        // The event is off the bottom of the screen.\n        return false;\n      }\n    }\n\n    if (chartName === 'network') {\n      if (!this.#dimensions.charts.network) {\n        // The network chart can be hidden if there are no requests in the trace.\n        return false;\n      }\n      if (y <= -14) {\n        // Weird value, but the network chart has the header row with\n        // timestamps on it: events stay visible behind those timestamps, so we\n        // want any overlays to treat themselves as visible too.\n        return false;\n      }\n\n      if (y > this.#dimensions.charts.network.heightPixels) {\n        // The event is off the bottom of the network chart.\n        return false;\n      }\n    }\n    // If we got here, none of the conditions to mark an event as invisible got\n    // triggered, so the event must be visible.\n    return true;\n  }\n\n  /**\n   * Calculate the X pixel position for an event start on the timeline.\n   * @param chartName - the chart that the event is on. It is expected that both\n   * charts have the same width so this doesn't make a difference - but it might\n   * in the future if the UI changes, hence asking for it.\n   *\n   * @param event - the trace event you want to get the pixel position of\n   */\n  xPixelForEventStartOnChart(event: OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const {startTime} = timingsForOverlayEntry(event);\n    return this.#xPixelForMicroSeconds(chartName, startTime);\n  }\n\n  /**\n   * Calculate the X pixel position for an event end on the timeline.\n   * @param chartName - the chart that the event is on. It is expected that both\n   * charts have the same width so this doesn't make a difference - but it might\n   * in the future if the UI changes, hence asking for it.\n   *\n   * @param event - the trace event you want to get the pixel position of\n   */\n  xPixelForEventEndOnChart(event: OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const {endTime} = timingsForOverlayEntry(event);\n    return this.#xPixelForMicroSeconds(chartName, endTime);\n  }\n\n  /**\n   * Calculate the xPixel for a given timestamp. To do this we calculate how\n   * far in microseconds from the left of the visible window an event is, and\n   * divide that by the total time span. This gives us a fraction representing\n   * how far along the timeline the event is. We can then multiply that by the\n   * width of the canvas to get its pixel position.\n   */\n  #xPixelForMicroSeconds(chart: EntryChartLocation, timestamp: Trace.Types.Timing.MicroSeconds): number|null {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      console.error('Cannot calculate xPixel without visible trace window.');\n      return null;\n    }\n    const canvasWidthPixels = this.#dimensions.charts[chart]?.widthPixels ?? null;\n    if (canvasWidthPixels === null) {\n      console.error(`Cannot calculate xPixel without ${chart} dimensions.`);\n      return null;\n    }\n\n    const timeFromLeft = timestamp - this.#dimensions.trace.visibleWindow.min;\n    const totalTimeSpan = this.#dimensions.trace.visibleWindow.range;\n    return Math.floor(\n        timeFromLeft / totalTimeSpan * canvasWidthPixels,\n    );\n  }\n\n  /**\n   * Calculate the Y pixel position for the event on the timeline relative to\n   * the entire window.\n   * This means if the event is in the main flame chart and below the network,\n   * we add the height of the network chart to the Y value to position it\n   * correctly.\n   * This can return null if any data was missing, or if the event is not\n   * visible (if the level it's on is hidden because the track is collapsed,\n   * for example)\n   */\n  yPixelForEventOnChart(event: OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent?.(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n\n    if (!chart.levelIsVisible(level)) {\n      return null;\n    }\n\n    const pixelOffsetForLevel = chart.levelToOffset(level);\n    // Now we have the offset for the level, we need to adjust it by the user's scroll offset.\n    let pixelAdjustedForScroll = pixelOffsetForLevel - (this.#dimensions.charts[chartName]?.scrollOffsetPixels ?? 0);\n\n    // Now if the event is in the main chart, we need to pad its Y position\n    // down by the height of the network chart + the network resize element.\n    if (chartName === 'main') {\n      pixelAdjustedForScroll += this.networkChartOffsetHeight();\n    }\n\n    return pixelAdjustedForScroll;\n  }\n\n  /**\n   * Calculate the height of the event on the timeline.\n   */\n  pixelHeightForEventOnChart(event: OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent?.(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n    return chart.levelHeight(level);\n  }\n\n  /**\n   * Calculate the height of the network chart. If the network chart has\n   * height, we also allow for the size of the resize handle shown between the\n   * two charts.\n   *\n   * Note that it is possible for the chart to have 0 height if the user is\n   * looking at a trace with no network requests.\n   */\n  networkChartOffsetHeight(): number {\n    if (this.#dimensions.charts.network === null) {\n      return 0;\n    }\n\n    if (this.#dimensions.charts.network.heightPixels === 0) {\n      return 0;\n    }\n\n    // At this point we know the network track exists and has height. But we\n    // need to check if it is collapsed, because if it is collapsed there is no\n    // resizer shown.\n    if (this.#dimensions.charts.network.allGroupsCollapsed) {\n      return this.#dimensions.charts.network.heightPixels;\n    }\n\n    return this.#dimensions.charts.network.heightPixels + NETWORK_RESIZE_ELEM_HEIGHT_PX;\n  }\n\n  /**\n   * Hides or shows an element. We used to use visibility rather than display,\n   * but a child of an element with visibility: hidden may still be visible if\n   * its own `display` property is set.\n   */\n  #setOverlayElementVisibility(element: HTMLElement, isVisible: boolean): void {\n    element.style.display = isVisible ? 'block' : 'none';\n  }\n}\n\n/**\n * Because entries can be a TimelineFrame, which is not a trace event, this\n * helper exists to return a consistent set of timings regardless of the type\n * of entry.\n */\nexport function timingsForOverlayEntry(entry: OverlayEntry):\n    Trace.Helpers.Timing.EventTimingsData<Trace.Types.Timing.MicroSeconds> {\n  if (Trace.Types.Events.isLegacyTimelineFrame(entry)) {\n    return {\n      startTime: entry.startTime,\n      endTime: entry.endTime,\n      duration: entry.duration,\n    };\n  }\n  return Trace.Helpers.Timing.eventTimingsMicroSeconds(entry);\n}\n\n/**\n * Defines if the overlay container `div` should have a jslog context attached.\n * Note that despite some of the overlays being used currently exclusively\n * for annotations, we log here with `overlays` to be generic as overlays can\n * be used for insights, annotations or in the future, who knows...\n */\nexport function jsLogContext(overlay: TimelineOverlay): string|null {\n  switch (overlay.type) {\n    case 'ENTRY_SELECTED': {\n      // No jslog for this; it would be very noisy and not very useful.\n      return null;\n    }\n    case 'ENTRY_OUTLINE': {\n      return `timeline.overlays.entry-outline-${Platform.StringUtilities.toKebabCase(overlay.outlineReason)}`;\n    }\n    case 'ENTRY_LABEL': {\n      return 'timeline.overlays.entry-label';\n    }\n    case 'ENTRIES_LINK': {\n      // do not log impressions for incomplete entry links\n      if (overlay.state !== Trace.Types.File.EntriesLinkState.CONNECTED) {\n        return null;\n      }\n      return 'timeline.overlays.entries-link';\n    }\n    case 'TIME_RANGE': {\n      return 'timeline.overlays.time-range';\n    }\n    case 'TIMESPAN_BREAKDOWN': {\n      return 'timeline.overlays.timespan-breakdown';\n    }\n    case 'TIMESTAMP_MARKER': {\n      return 'timeline.overlays.cursor-timestamp-marker';\n    }\n    case 'CANDY_STRIPED_TIME_RANGE': {\n      return 'timeline.overlays.candy-striped-time-range';\n    }\n    case 'TIMINGS_MARKER': {\n      return 'timeline.overlays.timings-marker';\n    }\n    default:\n      Platform.assertNever(overlay, 'Unknown overlay type');\n  }\n}\n"],
  "mappings": "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",
  "names": ["element", "rangeWidth"]
}
