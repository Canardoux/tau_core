{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/linear_memory_inspector/components/LinearMemoryInspector.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\n\nimport linearMemoryInspectorStyles from './linearMemoryInspector.css.js';\n\nconst {render, html} = LitHtml;\n\nimport {\n  Mode,\n  Navigation,\n  type AddressInputChangedEvent,\n  type HistoryNavigationEvent,\n  type PageNavigationEvent,\n} from './LinearMemoryNavigator.js';\n\nimport './LinearMemoryValueInterpreter.js';\nimport type {EndiannessChangedEvent, ValueTypeToggledEvent} from './LinearMemoryValueInterpreter.js';\n\nimport './LinearMemoryHighlightChipList.js';\nimport type {DeleteMemoryHighlightEvent, JumpToHighlightedMemoryEvent} from './LinearMemoryHighlightChipList.js';\nimport {formatAddress, parseAddress} from './LinearMemoryInspectorUtils.js';\nimport './LinearMemoryViewer.js';\nimport type {ByteSelectedEvent, ResizeEvent} from './LinearMemoryViewer.js';\nimport type {HighlightInfo} from './LinearMemoryViewerUtils.js';\nimport type {JumpToPointerAddressEvent, ValueTypeModeChangedEvent} from './ValueInterpreterDisplay.js';\nimport {\n  Endianness,\n  VALUE_INTEPRETER_MAX_NUM_BYTES,\n  getDefaultValueTypeMapping,\n  type ValueType,\n  type ValueTypeMode,\n} from './ValueInterpreterDisplayUtils.js';\n\nconst UIStrings = {\n  /**\n   *@description Tooltip text that appears when hovering over an invalid address in the address line in the Linear memory inspector\n   *@example {0x00000000} PH1\n   *@example {0x00400000} PH2\n   */\n  addressHasToBeANumberBetweenSAnd: 'Address has to be a number between {PH1} and {PH2}',\n};\nconst str_ =\n    i18n.i18n.registerUIStrings('panels/linear_memory_inspector/components/LinearMemoryInspector.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n// If the LinearMemoryInspector only receives a portion\n// of the original Uint8Array to show, it requires information\n// on the 1. memoryOffset (at which index this portion starts),\n// and on the 2. outerMemoryLength (length of the original Uint8Array).\nexport interface LinearMemoryInspectorData {\n  memory: Uint8Array;\n  address: number;\n  memoryOffset: number;\n  outerMemoryLength: number;\n  valueTypes?: Set<ValueType>;\n  valueTypeModes?: Map<ValueType, ValueTypeMode>;\n  endianness?: Endianness;\n  highlightInfo?: HighlightInfo;\n  hideValueInspector?: boolean;\n}\n\nexport type Settings = {\n  valueTypes: Set<ValueType>,\n  modes: Map<ValueType, ValueTypeMode>,\n  endianness: Endianness,\n};\n\nexport class MemoryRequestEvent extends Event {\n  static readonly eventName = 'memoryrequest';\n  data: {start: number, end: number, address: number};\n\n  constructor(start: number, end: number, address: number) {\n    super(MemoryRequestEvent.eventName);\n    this.data = {start, end, address};\n  }\n}\n\nexport class AddressChangedEvent extends Event {\n  static readonly eventName = 'addresschanged';\n  data: number;\n\n  constructor(address: number) {\n    super(AddressChangedEvent.eventName);\n    this.data = address;\n  }\n}\n\nexport class SettingsChangedEvent extends Event {\n  static readonly eventName = 'settingschanged';\n  data: Settings;\n\n  constructor(settings: Settings) {\n    super(SettingsChangedEvent.eventName);\n    this.data = settings;\n  }\n}\n\nclass AddressHistoryEntry implements Common.SimpleHistoryManager.HistoryEntry {\n  #address = 0;\n  #callback;\n\n  constructor(address: number, callback: (x: number) => void) {\n    if (address < 0) {\n      throw new Error('Address should be a greater or equal to zero');\n    }\n    this.#address = address;\n    this.#callback = callback;\n  }\n\n  valid(): boolean {\n    return true;\n  }\n\n  reveal(): void {\n    this.#callback(this.#address);\n  }\n}\n\nexport class LinearMemoryInspector extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  readonly #history = new Common.SimpleHistoryManager.SimpleHistoryManager(10);\n\n  #memory = new Uint8Array();\n  #memoryOffset = 0;\n  #outerMemoryLength = 0;\n\n  #address = -1;\n  #highlightInfo?: HighlightInfo;\n\n  #currentNavigatorMode = Mode.SUBMITTED;\n  #currentNavigatorAddressLine = `${this.#address}`;\n\n  #numBytesPerPage = 4;\n\n  #valueTypeModes = getDefaultValueTypeMapping();\n  #valueTypes = new Set(this.#valueTypeModes.keys());\n  #endianness = Endianness.LITTLE;\n\n  #hideValueInspector = false;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [linearMemoryInspectorStyles];\n  }\n\n  set data(data: LinearMemoryInspectorData) {\n    if (data.address < data.memoryOffset || data.address > data.memoryOffset + data.memory.length || data.address < 0) {\n      throw new Error('Address is out of bounds.');\n    }\n\n    if (data.memoryOffset < 0) {\n      throw new Error('Memory offset has to be greater or equal to zero.');\n    }\n\n    if (data.highlightInfo) {\n      if (data.highlightInfo.size < 0) {\n        throw new Error('Object size has to be greater than or equal to zero');\n      }\n      if (data.highlightInfo.startAddress < 0 || data.highlightInfo.startAddress >= data.outerMemoryLength) {\n        throw new Error('Object start address is out of bounds.');\n      }\n    }\n\n    this.#memory = data.memory;\n    this.#memoryOffset = data.memoryOffset;\n    this.#outerMemoryLength = data.outerMemoryLength;\n    this.#valueTypeModes = data.valueTypeModes || this.#valueTypeModes;\n    this.#valueTypes = data.valueTypes || this.#valueTypes;\n    this.#endianness = data.endianness || this.#endianness;\n    this.#highlightInfo = data.highlightInfo;\n    this.#hideValueInspector = data.hideValueInspector ?? this.#hideValueInspector;\n    this.#setAddress(data.address);\n    this.#render();\n  }\n\n  #render(): void {\n    const {start, end} = this.#getPageRangeForAddress(this.#address, this.#numBytesPerPage);\n\n    const navigatorAddressToShow = this.#currentNavigatorMode === Mode.SUBMITTED ? formatAddress(this.#address) :\n                                                                                   this.#currentNavigatorAddressLine;\n    const navigatorAddressIsValid = this.#isValidAddress(navigatorAddressToShow);\n\n    const invalidAddressMsg = i18nString(\n        UIStrings.addressHasToBeANumberBetweenSAnd,\n        {PH1: formatAddress(0), PH2: formatAddress(this.#outerMemoryLength)});\n\n    const errorMsg = navigatorAddressIsValid ? undefined : invalidAddressMsg;\n\n    const canGoBackInHistory = this.#history.canRollback();\n    const canGoForwardInHistory = this.#history.canRollover();\n\n    const highlightedMemoryAreas = this.#highlightInfo ? [this.#highlightInfo] : [];\n    const focusedMemoryHighlight = this.#getSmallestEnclosingMemoryHighlight(highlightedMemoryAreas, this.#address);\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    render(html`\n      <div class=\"view\">\n        <devtools-linear-memory-inspector-navigator\n          .data=${{address: navigatorAddressToShow, valid: navigatorAddressIsValid, mode: this.#currentNavigatorMode, error: errorMsg, canGoBackInHistory, canGoForwardInHistory}}\n          @refreshrequested=${this.#onRefreshRequest}\n          @addressinputchanged=${this.#onAddressChange}\n          @pagenavigation=${this.#navigatePage}\n          @historynavigation=${this.#navigateHistory}></devtools-linear-memory-inspector-navigator>\n          <devtools-linear-memory-highlight-chip-list\n          .data=${{highlightInfos: highlightedMemoryAreas, focusedMemoryHighlight }}\n          @jumptohighlightedmemory=${this.#onJumpToAddress}>\n          </devtools-linear-memory-highlight-chip-list>\n        <devtools-linear-memory-inspector-viewer\n          .data=${{\n            memory: this.#memory.slice(start - this.#memoryOffset,\n            end - this.#memoryOffset),\n            address: this.#address, memoryOffset: start,\n            focus: this.#currentNavigatorMode === Mode.SUBMITTED,\n            highlightInfo: this.#highlightInfo,\n            focusedMemoryHighlight }}\n          @byteselected=${this.#onByteSelected}\n          @resize=${this.#resize}>\n        </devtools-linear-memory-inspector-viewer>\n      </div>\n      ${this.#hideValueInspector ? LitHtml.nothing : html`\n      <div class=\"value-interpreter\">\n        <devtools-linear-memory-inspector-interpreter\n          .data=${{\n            value: this.#memory.slice(this.#address - this.#memoryOffset, this.#address + VALUE_INTEPRETER_MAX_NUM_BYTES).buffer,\n            valueTypes: this.#valueTypes,\n            valueTypeModes: this.#valueTypeModes,\n            endianness: this.#endianness,\n            memoryLength: this.#outerMemoryLength }}\n          @valuetypetoggled=${this.#onValueTypeToggled}\n          @valuetypemodechanged=${this.#onValueTypeModeChanged}\n          @endiannesschanged=${this.#onEndiannessChanged}\n          @jumptopointeraddress=${this.#onJumpToAddress}\n          >\n        </devtools-linear-memory-inspector-interpreter/>\n      </div>`}\n      `, this.#shadow, {\n      host: this,\n    });\n    // clang-format on\n  }\n\n  #onJumpToAddress(e: JumpToPointerAddressEvent|JumpToHighlightedMemoryEvent): void {\n    // Stop event from bubbling up, since no element further up needs the event.\n    e.stopPropagation();\n    this.#currentNavigatorMode = Mode.SUBMITTED;\n    const addressInRange = Math.max(0, Math.min(e.data, this.#outerMemoryLength - 1));\n    this.#jumpToAddress(addressInRange);\n  }\n\n  #onRefreshRequest(): void {\n    const {start, end} = this.#getPageRangeForAddress(this.#address, this.#numBytesPerPage);\n    this.dispatchEvent(new MemoryRequestEvent(start, end, this.#address));\n  }\n\n  #onByteSelected(e: ByteSelectedEvent): void {\n    this.#currentNavigatorMode = Mode.SUBMITTED;\n    const addressInRange = Math.max(0, Math.min(e.data, this.#outerMemoryLength - 1));\n    this.#jumpToAddress(addressInRange);\n  }\n\n  #createSettings(): Settings {\n    return {valueTypes: this.#valueTypes, modes: this.#valueTypeModes, endianness: this.#endianness};\n  }\n\n  #onEndiannessChanged(e: EndiannessChangedEvent): void {\n    this.#endianness = e.data;\n    this.dispatchEvent(new SettingsChangedEvent(this.#createSettings()));\n    this.#render();\n  }\n\n  #isValidAddress(address: string): boolean {\n    const newAddress = parseAddress(address);\n    return newAddress !== undefined && newAddress >= 0 && newAddress < this.#outerMemoryLength;\n  }\n\n  #onAddressChange(e: AddressInputChangedEvent): void {\n    const {address, mode} = e.data;\n    const isValid = this.#isValidAddress(address);\n    const newAddress = parseAddress(address);\n    this.#currentNavigatorAddressLine = address;\n\n    if (newAddress !== undefined && isValid) {\n      this.#currentNavigatorMode = mode;\n      this.#jumpToAddress(newAddress);\n      return;\n    }\n\n    if (mode === Mode.SUBMITTED && !isValid) {\n      this.#currentNavigatorMode = Mode.INVALID_SUBMIT;\n    } else {\n      this.#currentNavigatorMode = Mode.EDIT;\n    }\n\n    this.#render();\n  }\n\n  #onValueTypeToggled(e: ValueTypeToggledEvent): void {\n    const {type, checked} = e.data;\n    if (checked) {\n      this.#valueTypes.add(type);\n    } else {\n      this.#valueTypes.delete(type);\n    }\n    this.dispatchEvent(new SettingsChangedEvent(this.#createSettings()));\n    this.#render();\n  }\n\n  #onValueTypeModeChanged(e: ValueTypeModeChangedEvent): void {\n    e.stopImmediatePropagation();\n    const {type, mode} = e.data;\n    this.#valueTypeModes.set(type, mode);\n    this.dispatchEvent(new SettingsChangedEvent(this.#createSettings()));\n    this.#render();\n  }\n\n  #navigateHistory(e: HistoryNavigationEvent): boolean {\n    return e.data === Navigation.FORWARD ? this.#history.rollover() : this.#history.rollback();\n  }\n\n  #navigatePage(e: PageNavigationEvent): void {\n    const newAddress =\n        e.data === Navigation.FORWARD ? this.#address + this.#numBytesPerPage : this.#address - this.#numBytesPerPage;\n    const addressInRange = Math.max(0, Math.min(newAddress, this.#outerMemoryLength - 1));\n    this.#jumpToAddress(addressInRange);\n  }\n\n  #jumpToAddress(address: number): void {\n    if (address < 0 || address >= this.#outerMemoryLength) {\n      console.warn(`Specified address is out of bounds: ${address}`);\n      return;\n    }\n    this.#setAddress(address);\n    this.#update();\n  }\n\n  #getPageRangeForAddress(address: number, numBytesPerPage: number): {start: number, end: number} {\n    const pageNumber = Math.floor(address / numBytesPerPage);\n    const pageStartAddress = pageNumber * numBytesPerPage;\n    const pageEndAddress = Math.min(pageStartAddress + numBytesPerPage, this.#outerMemoryLength);\n    return {start: pageStartAddress, end: pageEndAddress};\n  }\n\n  #resize(event: ResizeEvent): void {\n    this.#numBytesPerPage = event.data;\n    this.#update();\n  }\n\n  #update(): void {\n    const {start, end} = this.#getPageRangeForAddress(this.#address, this.#numBytesPerPage);\n    if (start < this.#memoryOffset || end > this.#memoryOffset + this.#memory.length) {\n      this.dispatchEvent(new MemoryRequestEvent(start, end, this.#address));\n    } else {\n      this.#render();\n    }\n  }\n\n  #setAddress(address: number): void {\n    // If we are already showing the address that is requested, no need to act upon it.\n    if (this.#address === address) {\n      return;\n    }\n    const historyEntry = new AddressHistoryEntry(address, () => this.#jumpToAddress(address));\n    this.#history.push(historyEntry);\n    this.#address = address;\n    this.dispatchEvent(new AddressChangedEvent(this.#address));\n  }\n\n  // Returns the highlightInfo with the smallest size property that encloses the provided address.\n  // If there are multiple smallest enclosing highlights, we pick the one appearing the earliest in highlightedMemoryAreas.\n  // If no such highlightInfo exists, it returns undefined.\n  //\n  // Selecting the smallest enclosing memory highlight is a heuristic that aims to pick the\n  // most specific highlight given a provided address. This way, objects contained in other objects are\n  // potentially still accessible.\n  #getSmallestEnclosingMemoryHighlight(highlightedMemoryAreas: HighlightInfo[], address: number): HighlightInfo\n      |undefined {\n    let smallestEnclosingHighlight;\n    for (const highlightedMemory of highlightedMemoryAreas) {\n      if (highlightedMemory.startAddress <= address &&\n          address < highlightedMemory.startAddress + highlightedMemory.size) {\n        if (!smallestEnclosingHighlight) {\n          smallestEnclosingHighlight = highlightedMemory;\n        } else if (highlightedMemory.size < smallestEnclosingHighlight.size) {\n          smallestEnclosingHighlight = highlightedMemory;\n        }\n      }\n    }\n    return smallestEnclosingHighlight;\n  }\n}\n\ncustomElements.define('devtools-linear-memory-inspector-inspector', LinearMemoryInspector);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-linear-memory-inspector-inspector': LinearMemoryInspector;\n  }\n\n  interface HTMLElementEventMap {\n    'memoryrequest': MemoryRequestEvent;\n    'addresschanged': AddressChangedEvent;\n    'settingschanged': SettingsChangedEvent;\n    'deletememoryhighlight': DeleteMemoryHighlightEvent;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
