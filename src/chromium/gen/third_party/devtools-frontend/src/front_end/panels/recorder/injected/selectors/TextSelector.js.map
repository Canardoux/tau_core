{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/recorder/injected/selectors/TextSelector.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {\n  createTextContent,\n} from '../../../../third_party/puppeteer/package/lib/esm/puppeteer/injected/TextContent.js';\nimport {\n  textQuerySelectorAll,\n} from '../../../../third_party/puppeteer/package/lib/esm/puppeteer/injected/TextQuerySelector.js';\n\nimport type {Selector} from './Selector.js';\n\nconst MINIMUM_TEXT_LENGTH = 12;\nconst MAXIMUM_TEXT_LENGTH = 64;\n\nconst collect = <T>(iter: Iterable<T>, max = Infinity): T[] => {\n  const results = [];\n  for (const value of iter) {\n    if (max <= 0) {\n      break;\n    }\n    results.push(value);\n    --max;\n  }\n  return results;\n};\n\n/**\n * Computes the text selector for a node.\n *\n * @param node - The node to compute.\n * @returns The computed text selector.\n *\n * @internal\n */\nexport const computeTextSelector = (node: Node): Selector|undefined => {\n  const content = createTextContent(node).full.trim();\n  if (!content) {\n    return;\n  }\n\n  // If it's short, just return it.\n  if (content.length <= MINIMUM_TEXT_LENGTH) {\n    const elements = collect(textQuerySelectorAll(document, content), 2);\n    if (elements.length !== 1 || elements[0] !== node) {\n      return;\n    }\n    return [content];\n  }\n\n  // If it's too long, it's probably irrelevant.\n  if (content.length > MAXIMUM_TEXT_LENGTH) {\n    return;\n  }\n\n  // We do a binary search for the optimal length of a substring starting at 0.\n  let left = MINIMUM_TEXT_LENGTH;\n  let right = content.length;\n  while (left <= right) {\n    const center = left + ((right - left) >> 2);\n    const elements = collect(\n        textQuerySelectorAll(document, content.slice(0, center)),\n        2,\n    );\n    if (elements.length !== 1 || elements[0] !== node) {\n      left = center + 1;\n    } else {\n      right = center - 1;\n    }\n  }\n\n  // Never matched.\n  if (right === content.length) {\n    return;\n  }\n\n  // We attempt to round the word in the event we are in the middle of a word.\n  const length = right + 1;\n  const remainder = content.slice(length, length + MAXIMUM_TEXT_LENGTH);\n  return [content.slice(0, length + remainder.search(/ |$/))];\n};\n"],
  "mappings": ";AAIA;AAAA,EACE;AAAA,OACK;AACP;AAAA,EACE;AAAA,OACK;AAIP,MAAM,sBAAsB;AAC5B,MAAM,sBAAsB;AAE5B,MAAM,UAAU,CAAI,MAAmB,MAAM,aAAkB;AAC7D,QAAM,UAAU,CAAC;AACjB,aAAW,SAAS,MAAM;AACxB,QAAI,OAAO,GAAG;AACZ;AAAA,IACF;AACA,YAAQ,KAAK,KAAK;AAClB,MAAE;AAAA,EACJ;AACA,SAAO;AACT;AAUO,aAAM,sBAAsB,CAAC,SAAmC;AACrE,QAAM,UAAU,kBAAkB,IAAI,EAAE,KAAK,KAAK;AAClD,MAAI,CAAC,SAAS;AACZ;AAAA,EACF;AAGA,MAAI,QAAQ,UAAU,qBAAqB;AACzC,UAAM,WAAW,QAAQ,qBAAqB,UAAU,OAAO,GAAG,CAAC;AACnE,QAAI,SAAS,WAAW,KAAK,SAAS,CAAC,MAAM,MAAM;AACjD;AAAA,IACF;AACA,WAAO,CAAC,OAAO;AAAA,EACjB;AAGA,MAAI,QAAQ,SAAS,qBAAqB;AACxC;AAAA,EACF;AAGA,MAAI,OAAO;AACX,MAAI,QAAQ,QAAQ;AACpB,SAAO,QAAQ,OAAO;AACpB,UAAM,SAAS,QAAS,QAAQ,QAAS;AACzC,UAAM,WAAW;AAAA,MACb,qBAAqB,UAAU,QAAQ,MAAM,GAAG,MAAM,CAAC;AAAA,MACvD;AAAA,IACJ;AACA,QAAI,SAAS,WAAW,KAAK,SAAS,CAAC,MAAM,MAAM;AACjD,aAAO,SAAS;AAAA,IAClB,OAAO;AACL,cAAQ,SAAS;AAAA,IACnB;AAAA,EACF;AAGA,MAAI,UAAU,QAAQ,QAAQ;AAC5B;AAAA,EACF;AAGA,QAAM,SAAS,QAAQ;AACvB,QAAM,YAAY,QAAQ,MAAM,QAAQ,SAAS,mBAAmB;AACpE,SAAO,CAAC,QAAQ,MAAM,GAAG,SAAS,UAAU,OAAO,KAAK,CAAC,CAAC;AAC5D;",
  "names": []
}
