{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/linear_memory_inspector/components/ValueInterpreterDisplayUtils.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Platform from '../../../core/platform/platform.js';\n\nconst UIStrings = {\n  /**\n   *@description Text that is shown in the LinearMemoryInspector if a value could not be correctly formatted\n   *             for the requested mode (e.g. we do not floats to be represented as hexadecimal numbers).\n   *             Abbreviation stands for 'not applicable'.\n   */\n  notApplicable: 'N/A',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/linear_memory_inspector/components/ValueInterpreterDisplayUtils.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport const VALUE_INTEPRETER_MAX_NUM_BYTES = 8;\n\nexport const enum ValueType {\n  INT8 = 'Integer 8-bit',\n  INT16 = 'Integer 16-bit',\n  INT32 = 'Integer 32-bit',\n  INT64 = 'Integer 64-bit',\n  FLOAT32 = 'Float 32-bit',\n  FLOAT64 = 'Float 64-bit',\n  POINTER32 = 'Pointer 32-bit',\n  POINTER64 = 'Pointer 64-bit',\n}\n\nexport const enum Endianness {\n  LITTLE = 'Little Endian',\n  BIG = 'Big Endian',\n}\n\nexport const enum ValueTypeMode {\n  DECIMAL = 'dec',\n  HEXADECIMAL = 'hex',\n  OCTAL = 'oct',\n  SCIENTIFIC = 'sci',\n}\n\nexport function getDefaultValueTypeMapping(): Map<ValueType, ValueTypeMode> {\n  return new Map(DEFAULT_MODE_MAPPING);\n}\n\nconst DEFAULT_MODE_MAPPING = new Map([\n  [ValueType.INT8, ValueTypeMode.DECIMAL],\n  [ValueType.INT16, ValueTypeMode.DECIMAL],\n  [ValueType.INT32, ValueTypeMode.DECIMAL],\n  [ValueType.INT64, ValueTypeMode.DECIMAL],\n  [ValueType.FLOAT32, ValueTypeMode.DECIMAL],\n  [ValueType.FLOAT64, ValueTypeMode.DECIMAL],\n  [ValueType.POINTER32, ValueTypeMode.HEXADECIMAL],\n  [ValueType.POINTER64, ValueTypeMode.HEXADECIMAL],\n]);\n\nexport const VALUE_TYPE_MODE_LIST = [\n  ValueTypeMode.DECIMAL,\n  ValueTypeMode.HEXADECIMAL,\n  ValueTypeMode.OCTAL,\n  ValueTypeMode.SCIENTIFIC,\n];\n\nexport function valueTypeToLocalizedString(valueType: ValueType): string {\n  return i18n.i18n.lockedString(valueType);\n}\n\nexport function isValidMode(type: ValueType, mode: ValueTypeMode): boolean {\n  switch (type) {\n    case ValueType.INT8:\n    case ValueType.INT16:\n    case ValueType.INT32:\n    case ValueType.INT64:\n      return mode === ValueTypeMode.DECIMAL || mode === ValueTypeMode.HEXADECIMAL || mode === ValueTypeMode.OCTAL;\n    case ValueType.FLOAT32:\n    case ValueType.FLOAT64:\n      return mode === ValueTypeMode.SCIENTIFIC || mode === ValueTypeMode.DECIMAL;\n    case ValueType.POINTER32:  // fallthrough\n    case ValueType.POINTER64:\n      return mode === ValueTypeMode.HEXADECIMAL;\n    default:\n      return Platform.assertNever(type, `Unknown value type: ${type}`);\n  }\n}\n\nexport function isNumber(type: ValueType): boolean {\n  switch (type) {\n    case ValueType.INT8:\n    case ValueType.INT16:\n    case ValueType.INT32:\n    case ValueType.INT64:\n    case ValueType.FLOAT32:\n    case ValueType.FLOAT64:\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport function getPointerAddress(type: ValueType, buffer: ArrayBuffer, endianness: Endianness): number|bigint {\n  if (!isPointer(type)) {\n    console.error(`Requesting address of a non-pointer type: ${type}.\\n`);\n    return NaN;\n  }\n  try {\n    const dataView = new DataView(buffer);\n    const isLittleEndian = endianness === Endianness.LITTLE;\n    return type === ValueType.POINTER32 ? dataView.getUint32(0, isLittleEndian) :\n                                          dataView.getBigUint64(0, isLittleEndian);\n  } catch (e) {\n    return NaN;\n  }\n}\n\nexport function isPointer(type: ValueType): boolean {\n  return type === ValueType.POINTER32 || type === ValueType.POINTER64;\n}\nexport interface FormatData {\n  buffer: ArrayBuffer;\n  type: ValueType;\n  endianness: Endianness;\n  signed: boolean;\n  mode?: ValueTypeMode;\n}\n\nexport function format(formatData: FormatData): string {\n  if (!formatData.mode) {\n    console.error(`No known way of showing value for ${formatData.type}`);\n    return i18nString(UIStrings.notApplicable);\n  }\n  const valueView = new DataView(formatData.buffer);\n  const isLittleEndian = formatData.endianness === Endianness.LITTLE;\n  let value;\n\n  try {\n    switch (formatData.type) {\n      case ValueType.INT8:\n        value = formatData.signed ? valueView.getInt8(0) : valueView.getUint8(0);\n        return formatInteger(value, formatData.mode);\n      case ValueType.INT16:\n        value = formatData.signed ? valueView.getInt16(0, isLittleEndian) : valueView.getUint16(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.INT32:\n        value = formatData.signed ? valueView.getInt32(0, isLittleEndian) : valueView.getUint32(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.INT64:\n        value =\n            formatData.signed ? valueView.getBigInt64(0, isLittleEndian) : valueView.getBigUint64(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.FLOAT32:\n        value = valueView.getFloat32(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.FLOAT64:\n        value = valueView.getFloat64(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.POINTER32:\n        value = valueView.getUint32(0, isLittleEndian);\n        return formatInteger(value, ValueTypeMode.HEXADECIMAL);\n      case ValueType.POINTER64:\n        value = valueView.getBigUint64(0, isLittleEndian);\n        return formatInteger(value, ValueTypeMode.HEXADECIMAL);\n      default:\n        return Platform.assertNever(formatData.type, `Unknown value type: ${formatData.type}`);\n    }\n  } catch (e) {\n    return i18nString(UIStrings.notApplicable);\n  }\n}\n\nexport function formatFloat(value: number, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.DECIMAL:\n      return value.toFixed(2).toString();\n    case ValueTypeMode.SCIENTIFIC:\n      return value.toExponential(2).toString();\n    default:\n      throw new Error(`Unknown mode for floats: ${mode}.`);\n  }\n}\n\nexport function formatInteger(value: number|bigint, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.DECIMAL:\n      return value.toString();\n    case ValueTypeMode.HEXADECIMAL:\n      if (value < 0) {\n        return i18nString(UIStrings.notApplicable);\n      }\n      return '0x' + value.toString(16).toUpperCase();\n    case ValueTypeMode.OCTAL:\n      if (value < 0) {\n        return i18nString(UIStrings.notApplicable);\n      }\n      return value.toString(8);\n    default:\n      throw new Error(`Unknown mode for integers: ${mode}.`);\n  }\n}\n"],
  "mappings": "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",
  "names": ["ValueType", "Endianness", "ValueTypeMode"]
}
