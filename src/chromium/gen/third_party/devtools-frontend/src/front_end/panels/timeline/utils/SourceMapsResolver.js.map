{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/timeline/utils/SourceMapsResolver.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../../core/platform/platform.js';\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Bindings from '../../../models/bindings/bindings.js';\nimport * as SourceMapScopes from '../../../models/source_map_scopes/source_map_scopes.js';\nimport * as Trace from '../../../models/trace/trace.js';\nimport * as Workspace from '../../../models/workspace/workspace.js';\n\ntype ResolvedCodeLocationData = {\n  name: string|null,\n  devtoolsLocation: Workspace.UISourceCode.UILocation|null,\n  script: SDK.Script.Script|null,\n};\nexport class SourceMappingsUpdated extends Event {\n  static readonly eventName = 'sourcemappingsupdated';\n\n  constructor() {\n    super(SourceMappingsUpdated.eventName, {\n      composed: true,\n      bubbles: true,\n    });\n  }\n}\n\n// Resolved code location data is keyed based on\n// ProcessID=>ThreadID=> Call frame key.\n// The code location key is created as a concatenation of its fields.\nexport const resolvedCodeLocationDataNames:\n    Map<Trace.Types.Events.ProcessID, Map<Trace.Types.Events.ThreadID, Map<string, ResolvedCodeLocationData|null>>> =\n        new Map();\n\nexport class SourceMapsResolver extends EventTarget {\n  #parsedTrace: Trace.Handlers.Types.ParsedTrace;\n\n  #isResolving = false;\n\n  // We need to gather up a list of all the DebuggerModels that we should\n  // listen to for source map attached events. For most pages this will be\n  // the debugger model for the primary page target, but if a trace has\n  // workers, we would also need to gather up the DebuggerModel instances for\n  // those workers too.\n  #debuggerModelsToListen = new Set<SDK.DebuggerModel.DebuggerModel>();\n\n  constructor(parsedTrace: Trace.Handlers.Types.ParsedTrace) {\n    super();\n    this.#parsedTrace = parsedTrace;\n  }\n\n  static clearResolvedNodeNames(): void {\n    resolvedCodeLocationDataNames.clear();\n  }\n  static keyForCodeLocation(callFrame: Protocol.Runtime.CallFrame): string {\n    return `${callFrame.url}$$$${callFrame.scriptId}$$$${callFrame.functionName}$$$${callFrame.lineNumber}$$$${\n        callFrame.columnNumber}`;\n  }\n\n  /**\n   * For trace events containing a call frame / source location\n   * (f.e. a stack trace), attempts to obtain the resolved source\n   * location based on the those that have been resolved so far from\n   * listened source maps.\n   *\n   * Note that a single deployed URL can map to multiple authored URLs\n   * (f.e. if an app is bundled). Thus, beyond a URL we can use code\n   * location data like line and column numbers to obtain the specific\n   * authored code according to the source mappings.\n   *\n   * TODO(andoli): This can return incorrect scripts if the target page has been reloaded since the trace.\n   */\n  static resolvedCodeLocationForEntry(entry: Trace.Types.Events.Event): ResolvedCodeLocationData|null {\n    let callFrame = null;\n    if (Trace.Types.Events.isProfileCall(entry)) {\n      callFrame = entry.callFrame;\n    } else {\n      const stackTrace = Trace.Helpers.Trace.getZeroIndexedStackTraceForEvent(entry);\n      if (stackTrace === null || stackTrace.length < 1) {\n        return null;\n      }\n      callFrame = stackTrace[0];\n    }\n    const codeLocationKey = this.keyForCodeLocation(callFrame as Protocol.Runtime.CallFrame);\n    return resolvedCodeLocationDataNames.get(entry.pid)?.get(entry.tid)?.get(codeLocationKey) ?? null;\n  }\n\n  static resolvedURLForEntry(parsedTrace: Trace.Handlers.Types.ParsedTrace, entry: Trace.Types.Events.Event):\n      Platform.DevToolsPath.UrlString|null {\n    const resolvedCallFrameURL =\n        SourceMapsResolver.resolvedCodeLocationForEntry(entry)?.devtoolsLocation?.uiSourceCode.url();\n    if (resolvedCallFrameURL) {\n      return resolvedCallFrameURL;\n    }\n    // If no source mapping was found for an entry's URL, then default\n    // to the URL value contained in the event itself, if any.\n    const url = Trace.Extras.URLForEntry.getNonResolved(parsedTrace, entry);\n    if (url) {\n      return Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURL(url)?.url() ?? url;\n    }\n    return null;\n  }\n\n  static storeResolvedNodeDataForEntry(\n      pid: Trace.Types.Events.ProcessID, tid: Trace.Types.Events.ThreadID, callFrame: Protocol.Runtime.CallFrame,\n      resolvedCodeLocationData: ResolvedCodeLocationData): void {\n    const resolvedForPid = resolvedCodeLocationDataNames.get(pid) ||\n        new Map<Trace.Types.Events.ThreadID, Map<string, ResolvedCodeLocationData|null>>();\n    const resolvedForTid = resolvedForPid.get(tid) || new Map<string, ResolvedCodeLocationData|null>();\n    const keyForCallFrame = this.keyForCodeLocation(callFrame);\n    resolvedForTid.set(keyForCallFrame, resolvedCodeLocationData);\n    resolvedForPid.set(tid, resolvedForTid);\n    resolvedCodeLocationDataNames.set(pid, resolvedForPid);\n  }\n\n  async install(): Promise<void> {\n    for (const threadToProfileMap of this.#parsedTrace.Samples.profilesInProcess.values()) {\n      for (const [tid, profile] of threadToProfileMap) {\n        const nodes = profile.parsedProfile.nodes();\n        if (!nodes || nodes.length === 0) {\n          continue;\n        }\n\n        const target = this.#targetForThread(tid);\n        const debuggerModel = target?.model(SDK.DebuggerModel.DebuggerModel);\n        if (!debuggerModel) {\n          continue;\n        }\n        for (const node of nodes) {\n          const script = debuggerModel.scriptForId(String(node.callFrame.scriptId));\n          const shouldListenToSourceMap = !script || script.sourceMapURL;\n          if (!shouldListenToSourceMap) {\n            continue;\n          }\n          this.#debuggerModelsToListen.add(debuggerModel);\n        }\n      }\n    }\n\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().addEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, this.#onAttachedSourceMap, this);\n    }\n\n    // Although we have added listeners for SourceMapAttached events, we also\n    // immediately try to resolve function names. This ensures we use any\n    // sourcemaps that were attached before we bound our event listener.\n    await this.#resolveMappingsForProfileNodes();\n  }\n\n  /**\n   * Removes the event listeners and stops tracking newly added sourcemaps.\n   * Should be called before destroying an instance of this class to avoid leaks\n   * with listeners.\n   */\n  uninstall(): void {\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().removeEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, this.#onAttachedSourceMap, this);\n    }\n    this.#debuggerModelsToListen.clear();\n  }\n\n  async #resolveMappingsForProfileNodes(): Promise<void> {\n    // Used to track if source mappings were updated when a source map\n    // is attach. If not, we do not notify the flamechart that mappings\n    // were updated, since that would trigger a rerender.\n    let updatedMappings = false;\n    for (const [pid, threadsInProcess] of this.#parsedTrace.Samples.profilesInProcess) {\n      for (const [tid, threadProfile] of threadsInProcess) {\n        const nodes = threadProfile.parsedProfile.nodes() ?? [];\n        const target = this.#targetForThread(tid);\n        if (!target) {\n          continue;\n        }\n        for (const node of nodes) {\n          const resolvedFunctionName =\n              await SourceMapScopes.NamesResolver.resolveProfileFrameFunctionName(node.callFrame, target);\n          updatedMappings ||= Boolean(resolvedFunctionName);\n          node.setFunctionName(resolvedFunctionName);\n\n          const debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n          const script = debuggerModel?.scriptForId(node.scriptId) || null;\n          const location = debuggerModel &&\n              new SDK.DebuggerModel.Location(\n                  debuggerModel, node.callFrame.scriptId, node.callFrame.lineNumber, node.callFrame.columnNumber);\n          const uiLocation = location &&\n              await Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().rawLocationToUILocation(\n                  location);\n          updatedMappings ||= Boolean(uiLocation);\n\n          SourceMapsResolver.storeResolvedNodeDataForEntry(\n              pid, tid, node.callFrame, {name: resolvedFunctionName, devtoolsLocation: uiLocation, script});\n        }\n      }\n    }\n    if (!updatedMappings) {\n      return;\n    }\n    this.dispatchEvent(new SourceMappingsUpdated());\n  }\n\n  #onAttachedSourceMap(): void {\n    // Exit if we are already resolving so that we batch requests; if pages\n    // have a lot of sourcemaps we can get a lot of events at once.\n    if (this.#isResolving) {\n      return;\n    }\n\n    this.#isResolving = true;\n    // Resolving names triggers a repaint of the flame chart. Instead of attempting to resolve\n    // names every time a source map is attached, wait for some time once the first source map is\n    // attached. This way we allow for other source maps to be parsed before attempting a name\n    // resolving using the available source maps. Otherwise the UI is blocked when the number\n    // of source maps is particularly large.\n    setTimeout(async () => {\n      this.#isResolving = false;\n      await this.#resolveMappingsForProfileNodes();\n    }, 500);\n  }\n\n  // Figure out the target for the node. If it is in a worker thread,\n  // that is the target, otherwise we use the primary page target.\n  #targetForThread(tid: Trace.Types.Events.ThreadID): SDK.Target.Target|null {\n    const maybeWorkerId = this.#parsedTrace.Workers.workerIdByThread.get(tid);\n    if (maybeWorkerId) {\n      return SDK.TargetManager.TargetManager.instance().targetById(maybeWorkerId);\n    }\n    return SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  }\n}\n"],
  "mappings": ";AAKA,YAAY,SAAS;AAErB,YAAY,cAAc;AAC1B,YAAY,qBAAqB;AACjC,YAAY,WAAW;AACvB,YAAY,eAAe;AAOpB,aAAM,8BAA8B,MAAM;AAAA,EAC/C,OAAgB,YAAY;AAAA,EAE5B,cAAc;AACZ,UAAM,sBAAsB,WAAW;AAAA,MACrC,UAAU;AAAA,MACV,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACF;AAKO,aAAM,gCAEL,oBAAI,IAAI;AAET,aAAM,2BAA2B,YAAY;AAAA,EAClD;AAAA,EAEA,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOf,0BAA0B,oBAAI,IAAqC;AAAA,EAEnE,YAAY,aAA+C;AACzD,UAAM;AACN,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,OAAO,yBAA+B;AACpC,kCAA8B,MAAM;AAAA,EACtC;AAAA,EACA,OAAO,mBAAmB,WAA+C;AACvE,WAAO,GAAG,UAAU,GAAG,MAAM,UAAU,QAAQ,MAAM,UAAU,YAAY,MAAM,UAAU,UAAU,MACjG,UAAU,YAAY;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,OAAO,6BAA6B,OAAgE;AAClG,QAAI,YAAY;AAChB,QAAI,MAAM,MAAM,OAAO,cAAc,KAAK,GAAG;AAC3C,kBAAY,MAAM;AAAA,IACpB,OAAO;AACL,YAAM,aAAa,MAAM,QAAQ,MAAM,iCAAiC,KAAK;AAC7E,UAAI,eAAe,QAAQ,WAAW,SAAS,GAAG;AAChD,eAAO;AAAA,MACT;AACA,kBAAY,WAAW,CAAC;AAAA,IAC1B;AACA,UAAM,kBAAkB,KAAK,mBAAmB,SAAuC;AACvF,WAAO,8BAA8B,IAAI,MAAM,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,IAAI,eAAe,KAAK;AAAA,EAC/F;AAAA,EAEA,OAAO,oBAAoB,aAA+C,OACjC;AACvC,UAAM,uBACF,mBAAmB,6BAA6B,KAAK,GAAG,kBAAkB,aAAa,IAAI;AAC/F,QAAI,sBAAsB;AACxB,aAAO;AAAA,IACT;AAGA,UAAM,MAAM,MAAM,OAAO,YAAY,eAAe,aAAa,KAAK;AACtE,QAAI,KAAK;AACP,aAAO,UAAU,UAAU,cAAc,SAAS,EAAE,mBAAmB,GAAG,GAAG,IAAI,KAAK;AAAA,IACxF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,8BACH,KAAmC,KAAkC,WACrE,0BAA0D;AAC5D,UAAM,iBAAiB,8BAA8B,IAAI,GAAG,KACxD,oBAAI,IAA6E;AACrF,UAAM,iBAAiB,eAAe,IAAI,GAAG,KAAK,oBAAI,IAA2C;AACjG,UAAM,kBAAkB,KAAK,mBAAmB,SAAS;AACzD,mBAAe,IAAI,iBAAiB,wBAAwB;AAC5D,mBAAe,IAAI,KAAK,cAAc;AACtC,kCAA8B,IAAI,KAAK,cAAc;AAAA,EACvD;AAAA,EAEA,MAAM,UAAyB;AAC7B,eAAW,sBAAsB,KAAK,aAAa,QAAQ,kBAAkB,OAAO,GAAG;AACrF,iBAAW,CAAC,KAAK,OAAO,KAAK,oBAAoB;AAC/C,cAAM,QAAQ,QAAQ,cAAc,MAAM;AAC1C,YAAI,CAAC,SAAS,MAAM,WAAW,GAAG;AAChC;AAAA,QACF;AAEA,cAAM,SAAS,KAAK,iBAAiB,GAAG;AACxC,cAAM,gBAAgB,QAAQ,MAAM,IAAI,cAAc,aAAa;AACnE,YAAI,CAAC,eAAe;AAClB;AAAA,QACF;AACA,mBAAW,QAAQ,OAAO;AACxB,gBAAM,SAAS,cAAc,YAAY,OAAO,KAAK,UAAU,QAAQ,CAAC;AACxE,gBAAM,0BAA0B,CAAC,UAAU,OAAO;AAClD,cAAI,CAAC,yBAAyB;AAC5B;AAAA,UACF;AACA,eAAK,wBAAwB,IAAI,aAAa;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAEA,eAAW,iBAAiB,KAAK,yBAAyB;AACxD,oBAAc,iBAAiB,EAAE;AAAA,QAC7B,IAAI,iBAAiB,OAAO;AAAA,QAAmB,KAAK;AAAA,QAAsB;AAAA,MAAI;AAAA,IACpF;AAKA,UAAM,KAAK,gCAAgC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAkB;AAChB,eAAW,iBAAiB,KAAK,yBAAyB;AACxD,oBAAc,iBAAiB,EAAE;AAAA,QAC7B,IAAI,iBAAiB,OAAO;AAAA,QAAmB,KAAK;AAAA,QAAsB;AAAA,MAAI;AAAA,IACpF;AACA,SAAK,wBAAwB,MAAM;AAAA,EACrC;AAAA,EAEA,MAAM,kCAAiD;AAIrD,QAAI,kBAAkB;AACtB,eAAW,CAAC,KAAK,gBAAgB,KAAK,KAAK,aAAa,QAAQ,mBAAmB;AACjF,iBAAW,CAAC,KAAK,aAAa,KAAK,kBAAkB;AACnD,cAAM,QAAQ,cAAc,cAAc,MAAM,KAAK,CAAC;AACtD,cAAM,SAAS,KAAK,iBAAiB,GAAG;AACxC,YAAI,CAAC,QAAQ;AACX;AAAA,QACF;AACA,mBAAW,QAAQ,OAAO;AACxB,gBAAM,uBACF,MAAM,gBAAgB,cAAc,gCAAgC,KAAK,WAAW,MAAM;AAC9F,8BAAoB,QAAQ,oBAAoB;AAChD,eAAK,gBAAgB,oBAAoB;AAEzC,gBAAM,gBAAgB,OAAO,MAAM,IAAI,cAAc,aAAa;AAClE,gBAAM,SAAS,eAAe,YAAY,KAAK,QAAQ,KAAK;AAC5D,gBAAM,WAAW,iBACb,IAAI,IAAI,cAAc;AAAA,YAClB;AAAA,YAAe,KAAK,UAAU;AAAA,YAAU,KAAK,UAAU;AAAA,YAAY,KAAK,UAAU;AAAA,UAAY;AACtG,gBAAM,aAAa,YACf,MAAM,SAAS,yBAAyB,yBAAyB,SAAS,EAAE;AAAA,YACxE;AAAA,UAAQ;AAChB,8BAAoB,QAAQ,UAAU;AAEtC,6BAAmB;AAAA,YACf;AAAA,YAAK;AAAA,YAAK,KAAK;AAAA,YAAW,EAAC,MAAM,sBAAsB,kBAAkB,YAAY,OAAM;AAAA,UAAC;AAAA,QAClG;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,iBAAiB;AACpB;AAAA,IACF;AACA,SAAK,cAAc,IAAI,sBAAsB,CAAC;AAAA,EAChD;AAAA,EAEA,uBAA6B;AAG3B,QAAI,KAAK,cAAc;AACrB;AAAA,IACF;AAEA,SAAK,eAAe;AAMpB,eAAW,YAAY;AACrB,WAAK,eAAe;AACpB,YAAM,KAAK,gCAAgC;AAAA,IAC7C,GAAG,GAAG;AAAA,EACR;AAAA;AAAA;AAAA,EAIA,iBAAiB,KAA0D;AACzE,UAAM,gBAAgB,KAAK,aAAa,QAAQ,iBAAiB,IAAI,GAAG;AACxE,QAAI,eAAe;AACjB,aAAO,IAAI,cAAc,cAAc,SAAS,EAAE,WAAW,aAAa;AAAA,IAC5E;AACA,WAAO,IAAI,cAAc,cAAc,SAAS,EAAE,kBAAkB;AAAA,EACtE;AACF;",
  "names": []
}
