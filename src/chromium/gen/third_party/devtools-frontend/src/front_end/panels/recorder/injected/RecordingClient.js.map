{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/recorder/injected/RecordingClient.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Schema, SelectorType, StepType} from '../../../third_party/puppeteer-replay/puppeteer-replay.js';\n\nimport {Logger} from './Logger.js';\nimport {SelectorComputer} from './SelectorComputer.js';\nimport type {AccessibilityBindings} from './selectors/ARIASelector.js';\nimport {queryCSSSelectorAll} from './selectors/CSSSelector.js';\nimport type {Selector} from './selectors/Selector.js';\nimport type {Step} from './Step.js';\nimport {\n  assert,\n  createClickAttributes,\n  getClickableTargetFromEvent,\n  haultImmediateEvent,\n} from './util.js';\n\ndeclare global {\n  interface Window {\n    stopShortcut(payload: string): void;\n    addStep(step: string): void;\n  }\n}\n\ninterface Shortcut {\n  meta: boolean;\n  ctrl: boolean;\n  shift: boolean;\n  alt: boolean;\n  keyCode: number;\n}\n\nexport interface RecordingClientOptions {\n  debug: boolean;\n  allowUntrustedEvents: boolean;\n  selectorAttribute?: string;\n  selectorTypesToRecord: SelectorType[];\n  stopShortcuts?: Shortcut[];\n}\n\n/**\n * Determines whether an element is ignorable as an input.\n *\n * This is only called on input-like elements (elements that emit the `input`\n * event).\n *\n * With every `if` statement, please write a comment above explaining your\n * reasoning for ignoring the event.\n */\nconst isIgnorableInputElement = (element: Element): boolean => {\n  if (element instanceof HTMLInputElement) {\n    switch (element.type) {\n      // Checkboxes are always changed as a consequence of another type of action\n      // such as the keyboard or mouse. As such, we can safely ignore these\n      // elements.\n      case 'checkbox':\n        return true;\n        // Radios are always changed as a consequence of another type of action\n        // such as the keyboard or mouse. As such, we can safely ignore these\n        // elements.\n      case 'radio':\n        return true;\n    }\n  }\n  return false;\n};\n\nconst getShortcutLength = (shortcut: Shortcut): string => {\n  return Object.values(shortcut).filter(key => Boolean(key)).length.toString();\n};\n\nclass RecordingClient {\n  static readonly defaultSetupOptions: Readonly<RecordingClientOptions> = Object.freeze({\n    debug: false,\n    allowUntrustedEvents: false,\n    selectorTypesToRecord:\n                             [\n                               'aria',\n                               'css',\n                               'text',\n                               'xpath',\n                               'pierce',\n                             ] as SelectorType[],\n  });\n\n  #computer: SelectorComputer;\n\n  #isTrustedEvent = (event: Event): boolean => event.isTrusted;\n  #stopShortcuts: Shortcut[] = [];\n  #logger: Logger;\n\n  constructor(\n      bindings: AccessibilityBindings,\n      options = RecordingClient.defaultSetupOptions,\n  ) {\n    this.#logger = new Logger(options.debug ? 'debug' : 'silent');\n    this.#logger.log('creating a RecordingClient');\n    this.#computer = new SelectorComputer(\n        bindings,\n        this.#logger,\n        options.selectorAttribute,\n        options.selectorTypesToRecord,\n    );\n\n    if (options.allowUntrustedEvents) {\n      this.#isTrustedEvent = (): boolean => true;\n    }\n\n    this.#stopShortcuts = options.stopShortcuts ?? [];\n  }\n\n  start = (): void => {\n    this.#logger.log('Setting up recording listeners');\n\n    window.addEventListener('keydown', this.#onKeyDown, true);\n    window.addEventListener('beforeinput', this.#onBeforeInput, true);\n    window.addEventListener('input', this.#onInput, true);\n    window.addEventListener('keyup', this.#onKeyUp, true);\n\n    window.addEventListener('pointerdown', this.#onPointerDown, true);\n    window.addEventListener('click', this.#onClick, true);\n    window.addEventListener('auxclick', this.#onClick, true);\n\n    window.addEventListener('beforeunload', this.#onBeforeUnload, true);\n  };\n\n  stop = (): void => {\n    this.#logger.log('Tearing down client listeners');\n\n    window.removeEventListener('keydown', this.#onKeyDown, true);\n    window.removeEventListener('beforeinput', this.#onBeforeInput, true);\n    window.removeEventListener('input', this.#onInput, true);\n    window.removeEventListener('keyup', this.#onKeyUp, true);\n\n    window.removeEventListener('pointerdown', this.#onPointerDown, true);\n    window.removeEventListener('click', this.#onClick, true);\n    window.removeEventListener('auxclick', this.#onClick, true);\n\n    window.removeEventListener('beforeunload', this.#onBeforeUnload, true);\n  };\n\n  getSelectors = (node: Node): Selector[] => {\n    return this.#computer.getSelectors(node);\n  };\n\n  getCSSSelector = (node: Node): Selector|undefined => {\n    return this.#computer.getCSSSelector(node);\n  };\n\n  getTextSelector = (node: Node): Selector|undefined => {\n    return this.#computer.getTextSelector(node);\n  };\n\n  queryCSSSelectorAllForTesting = (selector: Selector): Element[] => {\n    return queryCSSSelectorAll(selector);\n  };\n\n  #wasStopShortcutPress = (event: KeyboardEvent): boolean => {\n    for (const shortcut of this.#stopShortcuts ?? []) {\n      if (event.shiftKey === shortcut.shift && event.ctrlKey === shortcut.ctrl && event.metaKey === shortcut.meta &&\n          event.keyCode === shortcut.keyCode) {\n        this.stop();\n        haultImmediateEvent(event);\n        window.stopShortcut(getShortcutLength(shortcut));\n        return true;\n      }\n    }\n    return false;\n  };\n\n  #initialInputTarget: {element: Element, selectors: Selector[]} = {element: document.documentElement, selectors: []};\n\n  /**\n   * Sets the current input target and computes the selector.\n   *\n   * This needs to be called before any input-related events (keydown, keyup,\n   * input, change, etc) occur so the precise selector is known. Since we\n   * capture on the `Window`, it suffices to call this on the first event in any\n   * given input sequence. This will always be either `keydown`, `beforeinput`,\n   * or `input`.\n   */\n  #setInitialInputTarget = (event: Event): void => {\n    const element = event.composedPath()[0];\n    assert(element instanceof Element);\n    if (this.#initialInputTarget.element === element) {\n      return;\n    }\n    this.#initialInputTarget = {element, selectors: this.getSelectors(element)};\n  };\n\n  #onKeyDown = (event: KeyboardEvent): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    if (this.#wasStopShortcutPress(event)) {\n      return;\n    }\n    this.#setInitialInputTarget(event);\n    this.#addStep({\n      type: 'keyDown' as StepType.KeyDown,\n      key: event.key as Schema.Key,\n    });\n  };\n\n  #onBeforeInput = (event: Event): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#setInitialInputTarget(event);\n  };\n\n  #onInput = (event: Event): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#setInitialInputTarget(event);\n    if (isIgnorableInputElement(this.#initialInputTarget.element)) {\n      return;\n    }\n    const {element, selectors} = this.#initialInputTarget;\n    this.#addStep({\n      type: 'change' as StepType.Change,\n      selectors,\n      value: 'value' in element ? element.value as string : element.textContent as string,\n    });\n  };\n\n  #onKeyUp = (event: KeyboardEvent): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#addStep({\n      type: 'keyUp' as StepType.KeyUp,\n      key: event.key as Schema.Key,\n    });\n  };\n\n  #initialPointerTarget: {element: Element, selectors: Selector[]} = {\n    element: document.documentElement,\n    selectors: [],\n  };\n  #setInitialPointerTarget = (event: Event): void => {\n    const element = getClickableTargetFromEvent(event);\n    if (this.#initialPointerTarget.element === element) {\n      return;\n    }\n    this.#initialPointerTarget = {\n      element,\n      selectors: this.#computer.getSelectors(element),\n    };\n  };\n\n  #pointerDownTimestamp = 0;\n  #onPointerDown = (event: MouseEvent): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#pointerDownTimestamp = event.timeStamp;\n    this.#setInitialPointerTarget(event);\n  };\n\n  #onClick = (event: MouseEvent): void => {\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#setInitialPointerTarget(event);\n    const attributes = createClickAttributes(event, this.#initialPointerTarget.element);\n    if (!attributes) {\n      return;\n    }\n    const duration = event.timeStamp - this.#pointerDownTimestamp;\n    this.#addStep({\n      type: event.detail === 2 ? 'doubleClick' as StepType.DoubleClick : 'click' as StepType.Click,\n      selectors: this.#initialPointerTarget.selectors,\n      duration: duration > 350 ? duration : undefined,\n      ...attributes,\n    });\n  };\n\n  #onBeforeUnload = (event: Event): void => {\n    this.#logger.log('Unloading...');\n    if (!this.#isTrustedEvent(event)) {\n      return;\n    }\n    this.#addStep({type: 'beforeUnload'});\n  };\n\n  #addStep = (step: Step): void => {\n    const payload = JSON.stringify(step);\n    this.#logger.log(`Adding step: ${payload}`);\n    window.addStep(payload);\n  };\n}\n\nexport {RecordingClient};\n"],
  "mappings": "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",
  "names": []
}
