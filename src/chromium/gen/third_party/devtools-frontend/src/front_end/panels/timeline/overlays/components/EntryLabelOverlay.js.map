{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/timeline/overlays/components/EntryLabelOverlay.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as ComponentHelpers from '../../../../ui/components/helpers/helpers.js';\nimport * as ThemeSupport from '../../../../ui/legacy/theme_support/theme_support.js';\nimport * as LitHtml from '../../../../ui/lit-html/lit-html.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\n\nimport styles from './entryLabelOverlay.css.js';\n\nconst {html} = LitHtml;\n\nconst UIStrings = {\n  /**\n   * @description Accessible label used to explain to a user that they are viewing an entry label.\n   */\n  entryLabel: 'Entry label',\n  /**\n   *@description Accessible label used to prompt the user to input text into the field.\n   */\n  inputTextPrompt: 'Enter an annotation label',\n\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/EntryLabelOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class EmptyEntryLabelRemoveEvent extends Event {\n  static readonly eventName = 'emptyentrylabelremoveevent';\n\n  constructor() {\n    super(EmptyEntryLabelRemoveEvent.eventName);\n  }\n}\n\nexport class EntryLabelChangeEvent extends Event {\n  static readonly eventName = 'entrylabelchangeevent';\n\n  constructor(public newLabel: string) {\n    super(EntryLabelChangeEvent.eventName);\n  }\n}\n\nexport class EntryLabelOverlay extends HTMLElement {\n  // The label is angled on the left from the centre of the entry it belongs to.\n  // `LABEL_AND_CONNECTOR_SHIFT_LENGTH` specifies how many pixels to the left it is shifted.\n  static readonly LABEL_AND_CONNECTOR_SHIFT_LENGTH = 8;\n  // Length of the line that connects the label to the entry.\n  static readonly LABEL_CONNECTOR_HEIGHT = 7;\n  static readonly LABEL_HEIGHT = 17;\n  static readonly LABEL_PADDING = 4;\n  static readonly LABEL_AND_CONNECTOR_HEIGHT =\n      EntryLabelOverlay.LABEL_HEIGHT + EntryLabelOverlay.LABEL_PADDING * 2 + EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT;\n  // Set the max label length to avoid labels that could signicantly increase the file size.\n  static readonly MAX_LABEL_LENGTH = 100;\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  readonly #boundRender = this.#render.bind(this);\n\n  // Once a label is bound for deletion, we remove it from the DOM via events\n  // that are dispatched. But in the meantime the blur event of the input box\n  // can fire, and that triggers a second removal. So we set this flag after\n  // the first removal to avoid a duplicate event firing which is a no-op but\n  // causes errors when we try to delete an already deleted annotation.\n  #isPendingRemoval: boolean = false;\n\n  // The label is set to editable when it is double clicked. If the user clicks away from the label box\n  // element, the lable is set to not editable until it double clicked.s\n  #isLabelEditable: boolean = true;\n  #entryLabelVisibleHeight: number|null = null;\n\n  #labelPartsWrapper: HTMLElement|null = null;\n  #entryHighlightWrapper: HTMLElement|null = null;\n  #inputField: HTMLElement|null = null;\n  #connectorLineContainer: SVGAElement|null = null;\n  #label: string;\n  #shouldDrawBelowEntry: boolean;\n  /**\n   * The entry label overlay consists of 3 parts - the label part with the label string inside,\n   * the line connecting the label to the entry, and a black box around an entry to highlight the entry with a label.\n   * ________\n   * |_label__|                <-- label part with the label string inside\n   *     \\\n   *      \\                   <-- line connecting the label to the entry with a circle at the end\n   *       \\\n   * _______\u25EF_________\n   * |_____entry______|         <--- box around an entry\n   *\n   * `drawLabel` method below draws the first part.\n   * `drawConnector` method below draws the second part - the connector line with a circle and the svg container for them.\n   * `drawEntryHighlightWrapper` draws the third part.\n   * We only rerender the first part if the label changes and the third part if the size of the entry changes.\n   * The connector and circle shapes never change so we only draw the second part when the component is created.\n   *\n   * Otherwise, the entry label overlay object only gets repositioned.\n   */\n\n  constructor(label: string, shouldDrawBelowEntry: boolean = false) {\n    super();\n    this.#render();\n    this.#shouldDrawBelowEntry = shouldDrawBelowEntry;\n    this.#labelPartsWrapper = this.#shadow.querySelector<HTMLElement>('.label-parts-wrapper');\n    this.#inputField = this.#labelPartsWrapper?.querySelector<HTMLElement>('.input-field') ?? null;\n    this.#connectorLineContainer = this.#labelPartsWrapper?.querySelector<SVGAElement>('.connectorContainer') ?? null;\n    this.#entryHighlightWrapper =\n        this.#labelPartsWrapper?.querySelector<HTMLElement>('.entry-highlight-wrapper') ?? null;\n    this.#label = label;\n    this.#drawLabel(label);\n    // If the label is not empty, it was loaded from the trace file.\n    // In that case, do not auto-focus it as if the user were creating it for the first time\n    if (label !== '') {\n      this.setLabelEditabilityAndRemoveEmptyLabel(false);\n    }\n    const ariaLabel = label === '' ? i18nString(UIStrings.inputTextPrompt) : label;\n    this.#inputField?.setAttribute('aria-label', ariaLabel);\n\n    this.#drawConnector();\n  }\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [styles];\n  }\n\n  entryHighlightWrapper(): HTMLElement|null {\n    return this.#entryHighlightWrapper;\n  }\n\n  #handleLabelInputKeyUp(): void {\n    // If the label changed on key up, dispatch label changed event.\n    const labelBoxTextContent = this.#inputField?.textContent?.trim() ?? '';\n    if (labelBoxTextContent !== this.#label) {\n      this.#label = labelBoxTextContent;\n      this.dispatchEvent(new EntryLabelChangeEvent(this.#label));\n    }\n    this.#inputField?.setAttribute('aria-label', labelBoxTextContent);\n  }\n\n  #handleLabelInputKeyDown(event: KeyboardEvent): boolean {\n    if (!this.#inputField) {\n      return false;\n    }\n\n    const allowedKeysAfterReachingLenLimit = [\n      'Backspace',\n      'Delete',\n      'ArrowLeft',\n      'ArrowRight',\n    ];\n\n    // We do not want to create multi-line labels.\n    // Therefore, if the new key is `Enter` key, treat it\n    // as the end of the label input and blur the input field.\n    if (event.key === 'Enter' || event.key === 'Escape') {\n      // Note that we do not stop the event propagating here; this is on\n      // purpose because we need it to bubble up into TimelineFlameChartView's\n      // handler. That updates the state and deals with the keydown.\n      this.#inputField.dispatchEvent(new FocusEvent('blur', {bubbles: true}));\n      return false;\n    }\n\n    // If the max limit is not reached, return true\n    if (this.#inputField.textContent !== null &&\n        this.#inputField.textContent.length <= EntryLabelOverlay.MAX_LABEL_LENGTH) {\n      return true;\n    }\n\n    if (allowedKeysAfterReachingLenLimit.includes(event.key)) {\n      return true;\n    }\n\n    if (event.key.length === 1 && event.ctrlKey /* Ctrl + A for selecting all */) {\n      return true;\n    }\n\n    event.preventDefault();\n    return false;\n  }\n\n  #handleLabelInputPaste(event: ClipboardEvent): void {\n    event.preventDefault();\n\n    const clipboardData = event.clipboardData;\n    if (!clipboardData || !this.#inputField) {\n      return;\n    }\n\n    const pastedText = clipboardData.getData('text');\n\n    const newText = this.#inputField.textContent + pastedText;\n    const trimmedText = newText.slice(0, EntryLabelOverlay.MAX_LABEL_LENGTH + 1);\n\n    this.#inputField.textContent = trimmedText;\n\n    // Reset the selection to the end\n    const selection = window.getSelection();\n    const range = document.createRange();\n    range.selectNodeContents(this.#inputField);\n    range.collapse(false);\n    selection?.removeAllRanges();\n    selection?.addRange(range);\n  }\n\n  set entryLabelVisibleHeight(entryLabelVisibleHeight: number) {\n    if (entryLabelVisibleHeight === this.#entryLabelVisibleHeight) {\n      // Even the position is not changed, the theme color might change, so we need to redraw the connector here.\n      this.#drawConnector();\n      return;\n    }\n\n    this.#entryLabelVisibleHeight = entryLabelVisibleHeight;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n    // If the label is editable, focus cursor on it.\n    // This method needs to be called after rendering the wrapper because it is the last label overlay element to render.\n    // By doing this, the cursor focuses when the label is created.\n    if (this.#isLabelEditable) {\n      this.#focusInputBox();\n    }\n    // The label and connector can move depending on the height of the entry\n    this.#drawLabel();\n    this.#drawConnector();\n  }\n\n  #drawConnector(): void {\n    if (!this.#connectorLineContainer) {\n      console.error('`connectorLineContainer` element is missing.');\n      return;\n    }\n\n    if (this.#shouldDrawBelowEntry && this.#entryLabelVisibleHeight) {\n      const translation = this.#entryLabelVisibleHeight + EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT;\n\n      this.#connectorLineContainer.style.transform = `translateY(${translation}px) rotate(180deg)`;\n    }\n\n    const connector = this.#connectorLineContainer.querySelector('line');\n    const circle = this.#connectorLineContainer.querySelector('circle');\n    if (!connector || !circle) {\n      console.error('Some entry label elements are missing.');\n      return;\n    }\n    // PART 2: draw the connector from label to the entry\n    // Set the width of the canvas that draws the connector to be equal to the length of the shift multiplied by two.\n    // That way, we can draw the connector from its corner to its middle. Since all elements are alligned in the middle, the connector\n    // will end in the middle of the entry.\n    this.#connectorLineContainer.setAttribute(\n        'width', (EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH * 2).toString());\n    this.#connectorLineContainer.setAttribute('height', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    // Start drawing the top right corner.\n    connector.setAttribute('x1', '0');\n    connector.setAttribute('y1', '0');\n    // Finish drawing in middle of the connector container.\n    connector.setAttribute('x2', EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH.toString());\n    connector.setAttribute('y2', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    const connectorColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n    connector.setAttribute('stroke', connectorColor);\n    connector.setAttribute('stroke-width', '2');\n\n    // Draw the circle at the bottom of the connector\n    circle.setAttribute('cx', EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH.toString());\n    circle.setAttribute('cy', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    circle.setAttribute('r', '3');\n    circle.setAttribute('fill', connectorColor);\n  }\n\n  #drawLabel(initialLabel?: string): void {\n    if (!this.#inputField) {\n      console.error('`labelBox`element is missing.');\n      return;\n    }\n\n    if (typeof initialLabel === 'string') {\n      this.#inputField.innerText = initialLabel;\n    }\n\n    let xTranslation: number|null = null;\n    let yTranslation: number|null = null;\n    // PART 1: draw the label box\n    if (this.#shouldDrawBelowEntry) {\n      // Label is drawn below and slightly to the right.\n      xTranslation = EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH;\n    } else {\n      // If the label is drawn above, the connector goes up and to the left, so\n      // we pull the label back slightly to align it nicely.\n      xTranslation = EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH * -1;\n    }\n\n    if (this.#shouldDrawBelowEntry && this.#entryLabelVisibleHeight) {\n      // Move the label down from above the entry to below it. The label is positioned by default quite far above the entry, hence why we add:\n      // 1. the height of the entry + of the label (inc its padding)\n      // 2. the height of the connector (*2), so we have room to draw it\n      const verticalTransform = this.#entryLabelVisibleHeight + EntryLabelOverlay.LABEL_HEIGHT +\n          EntryLabelOverlay.LABEL_PADDING * 2 + EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT * 2;\n\n      yTranslation = verticalTransform;\n    }\n\n    let transformString = '';\n    if (xTranslation) {\n      transformString += `translateX(${xTranslation}px) `;\n    }\n    if (yTranslation) {\n      transformString += `translateY(${yTranslation}px)`;\n    }\n\n    if (transformString.length) {\n      this.#inputField.style.transform = transformString;\n    }\n  }\n\n  #focusInputBox(): void {\n    if (!this.#inputField) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#inputField.focus();\n  }\n\n  setLabelEditabilityAndRemoveEmptyLabel(editable: boolean): void {\n    this.#isLabelEditable = editable;\n    this.#render();\n    // If the label is editable, focus cursor on it\n    if (editable) {\n      this.#focusInputBox();\n    }\n    // On MacOS when clearing the input box it is left with a new line, so we\n    // trim the string to remove any accidental trailing whitespace.\n    const newLabelText = this.#inputField?.textContent?.trim() ?? '';\n    // If the label is empty when it is being navigated away from, dispatch an event to remove this entry overlay\n    if (!editable && newLabelText.length === 0 && !this.#isPendingRemoval) {\n      this.#isPendingRemoval = true;\n      this.dispatchEvent(new EmptyEntryLabelRemoveEvent());\n    }\n  }\n\n  #render(): void {\n    // clang-format off\n    LitHtml.render(\n        html`\n        <span class=\"label-parts-wrapper\" role=\"region\" aria-label=${i18nString(UIStrings.entryLabel)}>\n          <span\n            class=\"input-field\"\n            role=\"textbox\"\n            @dblclick=${() => this.setLabelEditabilityAndRemoveEmptyLabel(true)}\n            @blur=${() => this.setLabelEditabilityAndRemoveEmptyLabel(false)}\n            @keydown=${this.#handleLabelInputKeyDown}\n            @paste=${this.#handleLabelInputPaste}\n            @keyup=${this.#handleLabelInputKeyUp}\n            contenteditable=${this.#isLabelEditable ? 'plaintext-only' : false}\n            jslog=${VisualLogging.textField('timeline.annotations.entry-label-input').track({keydown: true, click: true})}\n          ></span>\n          <svg class=\"connectorContainer\">\n            <line/>\n            <circle/>\n          </svg>\n          <div class=\"entry-highlight-wrapper\"></div>\n        </span>`,\n        this.#shadow, {host: this});\n    // clang-format on\n  }\n}\n\ncustomElements.define('devtools-entry-label-overlay', EntryLabelOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-entry-label-overlay': EntryLabelOverlay;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
