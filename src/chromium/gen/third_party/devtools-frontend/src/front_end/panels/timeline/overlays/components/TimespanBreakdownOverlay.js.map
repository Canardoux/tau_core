{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/timeline/overlays/components/TimespanBreakdownOverlay.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport type * as Trace from '../../../../models/trace/trace.js';\nimport * as LitHtml from '../../../../ui/lit-html/lit-html.js';\n\nimport styles from './timespanBreakdownOverlay.css.js';\n\nconst {html} = LitHtml;\n\n/**\n * An EntryBreakdown, or section, that makes up a TimespanBreakdown.\n */\nexport type EntryBreakdown = {\n  bounds: Trace.Types.Timing.TraceWindowMicroSeconds,\n  label: string|LitHtml.LitTemplate,\n  showDuration: boolean,\n};\n\nexport class TimespanBreakdownOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #canvasRect: DOMRect|null = null;\n  #sections: Array<EntryBreakdown>|null = null;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [styles];\n  }\n\n  set isBelowEntry(isBelow: boolean) {\n    this.classList.toggle('is-below', isBelow);\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (this.#canvasRect && rect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  set sections(sections: Array<EntryBreakdown>|null) {\n    if (sections === this.#sections) {\n      return;\n    }\n    this.#sections = sections;\n    this.#render();\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the section label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  checkSectionLabelPositioning(): void {\n    const sections = this.#shadow.querySelectorAll<HTMLElement>('.timespan-breakdown-overlay-section');\n    if (!sections) {\n      return;\n    }\n\n    if (!this.#canvasRect) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n\n    // Fetch the rects for each section and label now, rather than in the loop,\n    // to avoid causing a bunch of recalcStyles\n    const sectionLayoutData = new Map<HTMLElement, {sectionRect: DOMRect, labelRect: DOMRect, label: HTMLElement}>();\n    for (const section of sections) {\n      const label = section.querySelector<HTMLElement>('.timespan-breakdown-overlay-label');\n      if (!label) {\n        continue;\n      }\n      const sectionRect = section.getBoundingClientRect();\n      const labelRect = label.getBoundingClientRect();\n      sectionLayoutData.set(section, {sectionRect, labelRect, label});\n    }\n\n    const minSectionWidthToShowAnyLabel = 30;\n\n    // Align the labels for all the breakdown sections.\n    for (const section of sections) {\n      const layoutData = sectionLayoutData.get(section);\n      if (!layoutData) {\n        break;\n      }\n      const {labelRect, sectionRect, label} = layoutData;\n\n      const labelHidden = sectionRect.width < minSectionWidthToShowAnyLabel;\n      // Subtract 5 from the section width to allow a tiny bit of padding.\n      const labelTruncated = sectionRect.width - 5 <= labelRect.width;\n      // We differentiate between hidden + truncated; if it is truncated we\n      // will show the text with ellipsis for overflow, but if the section is\n      // really small we just hide the label entirely.\n      label.classList.toggle('labelHidden', labelHidden);\n      label.classList.toggle('labelTruncated', labelTruncated);\n\n      if (labelHidden || labelTruncated) {\n        // Label is hidden or doesn't fully fit, so we don't need to do the\n        // logic to left/right align if it needs it.\n        continue;\n      }\n\n      // Check if label is off the LHS of the screen.\n      const labelLeftMarginToCenter = (sectionRect.width - labelRect.width) / 2;\n      const newLabelX = sectionRect.x + labelLeftMarginToCenter;\n\n      const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n      label.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n      // Check if label is off the RHS of the screen\n      const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n      // The label's right hand edge is the gap from the left of the range to the\n      // label, and then the width of the label.\n      const labelRightEdge = sectionRect.x + labelLeftMarginToCenter + labelRect.width;\n      const labelOffRightOfScreen = labelRightEdge > rightBound;\n      label.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n      if (labelOffLeftOfScreen) {\n        // If the label is off the left of the screen, we adjust by the\n        // difference between the X that represents the start of the cavnas, and\n        // the X that represents the start of the overlay.\n        // We then take the absolute value of this - because if the canvas starts\n        // at 0, and the overlay is -200px, we have to adjust the label by +200.\n        // Add on 9 pixels to pad from the left; this is the width of the sidebar\n        // on the RHS so we match it so the label is equally padded on either\n        // side.\n        label.style.marginLeft = `${Math.abs(this.#canvasRect.x - sectionRect.x) + paddingForScrollbar}px`;\n\n      } else if (labelOffRightOfScreen) {\n        // To calculate how far left to push the label, we take the right hand\n        // bound (the canvas width and subtract the label's width).\n        // Finally, we subtract the X position of the overlay (if the overlay is\n        // 200px within the view, we don't need to push the label that 200px too\n        // otherwise it will be off-screen)\n        const leftMargin = rightBound - labelRect.width - sectionRect.x;\n\n        label.style.marginLeft = `${leftMargin}px`;\n\n      } else {\n        // Keep the label central.\n        label.style.marginLeft = `${labelLeftMarginToCenter}px`;\n      }\n    }\n  }\n\n  renderedSections(): HTMLElement[] {\n    return Array.from(this.#shadow.querySelectorAll('.timespan-breakdown-overlay-section'));\n  }\n\n  #renderSection(section: EntryBreakdown): LitHtml.TemplateResult {\n    // clang-format off\n    return html`\n      <div class=\"timespan-breakdown-overlay-section\">\n        <div class=\"timespan-breakdown-overlay-label\">\n        ${section.showDuration ?\n          html`\n            <span class=\"duration-text\">${i18n.TimeUtilities.formatMicroSecondsAsMillisFixed(section.bounds.range)}</span>\n          ` : LitHtml.nothing}\n          <span class=\"section-label-text\">\n            ${section.label}\n          </span>\n        </div>\n      </div>`;\n    // clang-format on\n  }\n\n  #render(): void {\n    if (this.#sections) {\n      this.classList.toggle('odd-number-of-sections', this.#sections.length % 2 === 1);\n      this.classList.toggle('even-number-of-sections', this.#sections.length % 2 === 0);\n    }\n    LitHtml.render(html`${this.#sections?.map(this.#renderSection)}`, this.#shadow, {host: this});\n    this.checkSectionLabelPositioning();\n  }\n}\n\ncustomElements.define('devtools-timespan-breakdown-overlay', TimespanBreakdownOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-timespan-breakdown-overlay': TimespanBreakdownOverlay;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
