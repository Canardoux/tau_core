{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/timeline/overlays/components/EntriesLinkOverlay.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport '../../../../ui/components/icon_button/icon_button.js';\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Trace from '../../../../models/trace/trace.js';\nimport * as ThemeSupport from '../../../../ui/legacy/theme_support/theme_support.js';\nimport * as LitHtml from '../../../../ui/lit-html/lit-html.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\n\nconst UIStrings = {\n  /**\n   *@description Accessible label used to explain to a user that they are viewing an arrow representing a link between two entries.\n   */\n  diagram: 'Links bteween entries',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/EntriesLinkOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nimport styles from './entriesLinkOverlay.css.js';\n\nconst {html} = LitHtml;\n\nexport class EntryLinkStartCreating extends Event {\n  static readonly eventName = 'entrylinkstartcreating';\n\n  constructor() {\n    super(EntryLinkStartCreating.eventName, {bubbles: true, composed: true});\n  }\n}\n\nexport class EntriesLinkOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #coordinateFrom: {x: number, y: number};\n  #fromEntryDimentions: {width: number, height: number};\n  #coordinateTo: {x: number, y: number};\n  #toEntryDimentions: {width: number, height: number}|null = null;\n  #connectorLineContainer: SVGAElement|null = null;\n  #connector: SVGLineElement|null = null;\n  #entryFromWrapper: HTMLElement|null = null;\n  #entryToWrapper: HTMLElement|null = null;\n  #entryFromConnector: SVGCircleElement|null = null;\n  #entryToConnector: SVGCircleElement|null = null;\n  #entryFromVisible: boolean = true;\n  #entryToVisible: boolean = true;\n  #canvasRect: DOMRect|null = null;\n\n  // These flags let us know if the entry we are drawing from/to are the\n  // originals, or if they are the parent, which can happen if an entry is\n  // collapsed. We care about this because if the entry is not the source, we\n  // draw the border as dashed, not solid.\n  #fromEntryIsSource: boolean = true;\n  #toEntryIsSource: boolean = true;\n  #arrowHidden: boolean = false;\n  #linkState: Trace.Types.File.EntriesLinkState;\n\n  constructor(\n      initialFromEntryCoordinateAndDimentions: {x: number, y: number, width: number, height: number},\n      linkCreationNotStartedState: Trace.Types.File.EntriesLinkState) {\n    super();\n    this.#render();\n    this.#coordinateFrom = {x: initialFromEntryCoordinateAndDimentions.x, y: initialFromEntryCoordinateAndDimentions.y};\n    this.#fromEntryDimentions = {\n      width: initialFromEntryCoordinateAndDimentions.width,\n      height: initialFromEntryCoordinateAndDimentions.height,\n    };\n    this.#coordinateTo = {x: initialFromEntryCoordinateAndDimentions.x, y: initialFromEntryCoordinateAndDimentions.y};\n    this.#connectorLineContainer = this.#shadow.querySelector<SVGAElement>('.connectorContainer') ?? null;\n    this.#connector = this.#connectorLineContainer?.querySelector('line') ?? null;\n    this.#entryFromWrapper = this.#shadow.querySelector('.from-highlight-wrapper') ?? null;\n    this.#entryToWrapper = this.#shadow.querySelector('.to-highlight-wrapper') ?? null;\n    this.#entryFromConnector = this.#connectorLineContainer?.querySelector('.entryFromConnector') ?? null;\n    this.#entryToConnector = this.#connectorLineContainer?.querySelector('.entryToConnector') ?? null;\n    this.#linkState = linkCreationNotStartedState;\n    this.#render();\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (rect === null) {\n      return;\n    }\n    if (this.#canvasRect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  entryFromWrapper(): HTMLElement|null {\n    return this.#entryFromWrapper;\n  }\n\n  entryToWrapper(): HTMLElement|null {\n    return this.#entryToWrapper;\n  }\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [styles];\n  }\n\n  /**\n   * If one entry that is linked is in a collapsed track, we show the outlines\n   * but hide only the arrow.\n   */\n  set hideArrow(shouldHide: boolean) {\n    this.#arrowHidden = shouldHide;\n    if (this.#connector) {\n      this.#connector.style.display = shouldHide ? 'none' : 'block';\n    }\n  }\n\n  set fromEntryCoordinateAndDimentions(fromEntryParams: {x: number, y: number, length: number, height: number}) {\n    this.#coordinateFrom = {x: fromEntryParams.x, y: fromEntryParams.y};\n    this.#fromEntryDimentions = {width: fromEntryParams.length, height: fromEntryParams.height};\n    this.#updateCreateLinkBox();\n    this.#redrawConnectionArrow();\n  }\n\n  set entriesVisibility(entriesVisibility: {fromEntryVisibility: boolean, toEntryVisibility: boolean}) {\n    this.#entryFromVisible = entriesVisibility.fromEntryVisibility;\n    this.#entryToVisible = entriesVisibility.toEntryVisibility;\n  }\n\n  // The arrow might be pointing either to an entry or an empty space.\n  // If the dimensions are not passed, it is pointing at an empty space.\n  set toEntryCoordinateAndDimentions(toEntryParams: {x: number, y: number, length?: number, height?: number}) {\n    this.#coordinateTo = {x: toEntryParams.x, y: toEntryParams.y};\n    if (toEntryParams.length && toEntryParams.height) {\n      this.#toEntryDimentions = {width: toEntryParams.length, height: toEntryParams.height};\n    } else {\n      this.#toEntryDimentions = null;\n    }\n\n    this.#updateCreateLinkBox();\n    this.#redrawConnectionArrow();\n  }\n\n  set fromEntryIsSource(x: boolean) {\n    if (x === this.#fromEntryIsSource) {\n      return;\n    }\n    this.#fromEntryIsSource = x;\n    this.#render();\n  }\n\n  set toEntryIsSource(x: boolean) {\n    if (x === this.#toEntryIsSource) {\n      return;\n    }\n    this.#toEntryIsSource = x;\n    this.#render();\n  }\n\n  #redrawConnectionArrow(): void {\n    if (!this.#connector || !this.#entryFromWrapper || !this.#entryToWrapper || !this.#entryFromConnector ||\n        !this.#entryToConnector) {\n      console.error('`connector` element is missing.');\n      return;\n    }\n\n    if (this.#linkState === Trace.Types.File.EntriesLinkState.CREATION_NOT_STARTED) {\n      this.#entryFromConnector.setAttribute('visibility', 'hidden');\n      this.#entryToConnector.setAttribute('visibility', 'hidden');\n      return;\n    }\n\n    // If the user is zoomed out, the connector circles can be as large as the\n    // event itself. So if the rectangle for this entry is too small, we\n    // don't draw the circles.\n    const minWidthToDrawConnectorCircles = 8;\n\n    // We do not draw the connectors if the entry is not visible, or if the\n    // entry we are connecting to isn't the actual source entry.\n    // We also don't draw them if an entry is completely hidden, in which case\n    // we aren't drawing the arrows, so it doesn't make sense to draw the\n    // connectors.\n    const drawFromEntryConnectorCircle = this.#entryFromVisible && !this.#arrowHidden && this.#fromEntryIsSource &&\n        this.#fromEntryDimentions.width >= minWidthToDrawConnectorCircles;\n\n    const widthOfToEntry = this.#toEntryDimentions?.width ?? 0;\n    const drawToEntryConnectorCircle = !this.#arrowHidden && this.#entryToVisible && this.#toEntryIsSource &&\n        widthOfToEntry >= minWidthToDrawConnectorCircles && !this.#arrowHidden;\n\n    this.#entryFromConnector.setAttribute('visibility', drawFromEntryConnectorCircle ? 'visible' : 'hidden');\n    this.#entryToConnector.setAttribute('visibility', drawToEntryConnectorCircle ? 'visible' : 'hidden');\n\n    // If the entry is visible, the entry arrow starts from the end on the X axis and middle of the Y axis.\n    // If not, draw it to the same y point without the entry height offset and the box around the entry.\n    // This way it will be attached to the track edge.\n    if (this.#entryFromVisible) {\n      const halfEntryHeight = this.#fromEntryDimentions.height / 2;\n      const endConnectionPointX = String(this.#coordinateFrom.x + this.#fromEntryDimentions.width);\n      const endConnectionPointY = String(this.#coordinateFrom.y + halfEntryHeight);\n\n      this.#connector.setAttribute('x1', endConnectionPointX);\n      this.#connector.setAttribute('y1', endConnectionPointY);\n\n      this.#entryFromConnector.setAttribute('cx', endConnectionPointX);\n      this.#entryFromConnector.setAttribute('cy', endConnectionPointY);\n      this.#entryFromWrapper.style.visibility = 'visible';\n    } else {\n      this.#connector.setAttribute('x1', (this.#coordinateFrom.x + this.#fromEntryDimentions.width).toString());\n      this.#connector.setAttribute('y1', this.#coordinateFrom.y.toString());\n      this.#entryFromWrapper.style.visibility = 'hidden';\n    }\n\n    // If the arrow is pointing to the entry, point it to the middle of the entry.\n    // Otherwise, the arrow is following the mouse so we assign it to the provided coordinates.\n    if (this.#toEntryDimentions && this.#entryToVisible) {\n      const connectionPointX = String(this.#coordinateTo.x);\n      const connectionPointY = String(this.#coordinateTo.y + this.#toEntryDimentions.height / 2);\n\n      this.#connector.setAttribute('x2', connectionPointX);\n      this.#connector.setAttribute('y2', connectionPointY);\n\n      this.#entryToConnector.setAttribute('cx', connectionPointX);\n      this.#entryToConnector.setAttribute('cy', connectionPointY);\n\n      this.#entryToWrapper.style.visibility = 'visible';\n    } else {\n      this.#entryToWrapper.style.visibility = 'hidden';\n      this.#connector.setAttribute('x2', this.#coordinateTo.x.toString());\n      this.#connector.setAttribute('y2', this.#coordinateTo.y.toString());\n    }\n\n    this.#connector.setAttribute('stroke-width', '2');\n\n    if (this.#toEntryDimentions && this.#entryFromVisible && !this.#entryToVisible) {\n      this.#connector.setAttribute('stroke', 'url(#fromVisibleLineGradient)');\n    } else if (this.#toEntryDimentions && this.#entryToVisible && !this.#entryFromVisible) {\n      this.#connector.setAttribute('stroke', 'url(#toVisibleLineGradient)');\n    } else {\n      const arrowColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n      this.#connector.setAttribute('stroke', arrowColor);\n    }\n\n    this.#render();\n  }\n\n  /*\n   * When only one entry from the connection is visible, the connection\n   * line becomes a gradient from the visible entry to the edge of\n   * the screen towards the entry that is not visible.\n   *\n   * To achieve this, we need to calculate what percentage of the\n   * visible screen the connection is currently occupying and apply\n   * that gradient to the visible connection part.\n   */\n  #partlyVisibleConnectionLinePercentage(): number {\n    if (!this.#canvasRect) {\n      return 100;\n    }\n\n    const lineLength = this.#coordinateTo.x - (this.#coordinateFrom.x + this.#fromEntryDimentions.width);\n    let visibleLineLength = 0;\n\n    // If the visible entry is the 'From' entry, find the length of the visible arrow by\n    // substracting the point where the arrow starts from the whole canvas length.\n    // If the 'to' entry is visible, the coordinate of the entry will be equal to\n    // the visible arrow length.\n    if (this.#entryFromVisible && !this.#entryToVisible) {\n      visibleLineLength = this.#canvasRect.width - (this.#coordinateFrom.x + this.#fromEntryDimentions.width);\n    } else if (!this.#entryFromVisible && this.#entryToVisible) {\n      visibleLineLength = this.#coordinateTo.x;\n    }\n\n    const visibleLineFromTotalPercentage = (visibleLineLength * 100) / lineLength;\n\n    return (visibleLineFromTotalPercentage < 100) ? visibleLineFromTotalPercentage : 100;\n  }\n\n  #updateCreateLinkBox(): void {\n    const createLinkBox = this.#shadow.querySelector<HTMLElement>('.create-link-box');\n    const createLinkIcon = createLinkBox?.querySelector<HTMLElement>('.create-link-icon') ?? null;\n\n    if (!createLinkBox || !createLinkIcon) {\n      console.error('creating element is missing.');\n      return;\n    }\n\n    if (this.#linkState !== Trace.Types.File.EntriesLinkState.CREATION_NOT_STARTED) {\n      createLinkIcon.style.display = 'none';\n      return;\n    }\n\n    createLinkIcon.style.left = `${this.#coordinateFrom.x + this.#fromEntryDimentions.width}px`;\n    createLinkIcon.style.top = `${this.#coordinateFrom.y}px`;\n  }\n\n  #startCreatingConnection(): void {\n    this.#linkState = Trace.Types.File.EntriesLinkState.PENDING_TO_EVENT;\n    this.dispatchEvent(new EntryLinkStartCreating());\n  }\n\n  /*\n  The entries link overlay is an arrow connecting 2 entries.\n  The Entries are drawn by Flamechart and this Overlay is only drawing the arrow between them.\n   _________\n  |__entry__|\\\n              \\\n               \\          <-- arrow connecting the sides of entries drawn by this overlay\n                \\   ________________\n                 \u2798 |_____entry______|\n  */\n  #render(): void {\n    const arrowColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n    // clang-format off\n    LitHtml.render(\n        html`\n          <svg class=\"connectorContainer\" width=\"100%\" height=\"100%\" role=\"region\" aria-label=${i18nString(UIStrings.diagram)}>\n            <defs>\n              <linearGradient\n                id=\"fromVisibleLineGradient\"\n                x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n                <stop\n                  offset=\"0%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"1\" />\n                <stop\n                  offset=\"${this.#partlyVisibleConnectionLinePercentage()}%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"0\" />\n              </linearGradient>\n\n              <linearGradient\n                id=\"toVisibleLineGradient\"\n                x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n                <stop\n                  offset=\"${100 - this.#partlyVisibleConnectionLinePercentage()}%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"0\" />\n                <stop\n                  offset=\"100%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"1\" />\n              </linearGradient>\n              <marker\n                id=\"arrow\"\n                orient=\"auto\"\n                markerWidth=\"3\"\n                markerHeight=\"4\"\n                fill-opacity=\"1\"\n                refX=\"4\"\n                refY=\"2\"\n                visibility=${this.#entryToVisible || !this.#toEntryDimentions ? 'visible' : 'hidden'}>\n                <path d=\"M0,0 V4 L4,2 Z\" fill=${arrowColor} />\n              </marker>\n            </defs>\n            <line\n              marker-end=\"url(#arrow)\"\n              stroke-dasharray=${!this.#fromEntryIsSource || !this.#toEntryIsSource ? DASHED_STROKE_AMOUNT : 'none'}\n              visibility=${!this.#entryFromVisible && !this.#entryToVisible ? 'hidden' : 'visible'}\n              />\n            <circle class=\"entryFromConnector\" fill=\"none\" stroke=${arrowColor} stroke-width=${CONNECTOR_CIRCLE_STROKE_WIDTH} r=${CONNECTOR_CIRCLE_RADIUS} />\n            <circle class=\"entryToConnector\" fill=\"none\" stroke=${arrowColor} stroke-width=${CONNECTOR_CIRCLE_STROKE_WIDTH} r=${CONNECTOR_CIRCLE_RADIUS} />\n          </svg>\n          <div class=\"entry-wrapper from-highlight-wrapper ${this.#fromEntryIsSource ? '' : 'entry-is-not-source'}\"></div>\n          <div class=\"entry-wrapper to-highlight-wrapper ${this.#toEntryIsSource ? '' : 'entry-is-not-source'}\"></div>\n          <div class=\"create-link-box ${this.#linkState ? 'visible' : 'hidden'}\">\n            <devtools-icon\n              class='create-link-icon'\n              jslog=${VisualLogging.action('timeline.annotations.create-entry-link').track({click: true})}\n              @click=${this.#startCreatingConnection}\n              name='arrow-right-circle'>\n            </devtools-icon>\n          </div>\n        `,\n        this.#shadow, {host: this});\n    // clang-format on\n  }\n}\n\nconst CONNECTOR_CIRCLE_RADIUS = 2;\nconst CONNECTOR_CIRCLE_STROKE_WIDTH = 1;\n\n// Defines the gap in the border when we are drawing a dashed outline.\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray\nconst DASHED_STROKE_AMOUNT = 4;\n\ncustomElements.define('devtools-entries-link-overlay', EntriesLinkOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-entries-link-overlay': EntriesLinkOverlay;\n  }\n}\n"],
  "mappings": ";AAGA,OAAO;AAEP,YAAY,UAAU;AACtB,YAAY,WAAW;AACvB,YAAY,kBAAkB;AAC9B,YAAY,aAAa;AACzB,YAAY,mBAAmB;AAE/B,MAAM,YAAY;AAAA;AAAA;AAAA;AAAA,EAIhB,SAAS;AACX;AACA,MAAM,OAAO,KAAK,KAAK,kBAAkB,6DAA6D,SAAS;AAC/G,MAAM,aAAa,KAAK,KAAK,mBAAmB,KAAK,QAAW,IAAI;AAEpE,OAAO,YAAY;AAEnB,MAAM,EAAC,KAAI,IAAI;AAER,aAAM,+BAA+B,MAAM;AAAA,EAChD,OAAgB,YAAY;AAAA,EAE5B,cAAc;AACZ,UAAM,uBAAuB,WAAW,EAAC,SAAS,MAAM,UAAU,KAAI,CAAC;AAAA,EACzE;AACF;AAEO,aAAM,2BAA2B,YAAY;AAAA,EACzC,UAAU,KAAK,aAAa,EAAC,MAAM,OAAM,CAAC;AAAA,EACnD;AAAA,EACA;AAAA,EACA;AAAA,EACA,qBAA2D;AAAA,EAC3D,0BAA4C;AAAA,EAC5C,aAAkC;AAAA,EAClC,oBAAsC;AAAA,EACtC,kBAAoC;AAAA,EACpC,sBAA6C;AAAA,EAC7C,oBAA2C;AAAA,EAC3C,oBAA6B;AAAA,EAC7B,kBAA2B;AAAA,EAC3B,cAA4B;AAAA;AAAA;AAAA;AAAA;AAAA,EAM5B,qBAA8B;AAAA,EAC9B,mBAA4B;AAAA,EAC5B,eAAwB;AAAA,EACxB;AAAA,EAEA,YACI,yCACA,6BAAgE;AAClE,UAAM;AACN,SAAK,QAAQ;AACb,SAAK,kBAAkB,EAAC,GAAG,wCAAwC,GAAG,GAAG,wCAAwC,EAAC;AAClH,SAAK,uBAAuB;AAAA,MAC1B,OAAO,wCAAwC;AAAA,MAC/C,QAAQ,wCAAwC;AAAA,IAClD;AACA,SAAK,gBAAgB,EAAC,GAAG,wCAAwC,GAAG,GAAG,wCAAwC,EAAC;AAChH,SAAK,0BAA0B,KAAK,QAAQ,cAA2B,qBAAqB,KAAK;AACjG,SAAK,aAAa,KAAK,yBAAyB,cAAc,MAAM,KAAK;AACzE,SAAK,oBAAoB,KAAK,QAAQ,cAAc,yBAAyB,KAAK;AAClF,SAAK,kBAAkB,KAAK,QAAQ,cAAc,uBAAuB,KAAK;AAC9E,SAAK,sBAAsB,KAAK,yBAAyB,cAAc,qBAAqB,KAAK;AACjG,SAAK,oBAAoB,KAAK,yBAAyB,cAAc,mBAAmB,KAAK;AAC7F,SAAK,aAAa;AAClB,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,IAAI,WAAW,MAAoB;AACjC,QAAI,SAAS,MAAM;AACjB;AAAA,IACF;AACA,QAAI,KAAK,eAAe,KAAK,YAAY,UAAU,KAAK,SAAS,KAAK,YAAY,WAAW,KAAK,QAAQ;AACxG;AAAA,IACF;AACA,SAAK,cAAc;AACnB,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,mBAAqC;AACnC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,iBAAmC;AACjC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,oBAA0B;AACxB,SAAK,QAAQ,qBAAqB,CAAC,MAAM;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,UAAU,YAAqB;AACjC,SAAK,eAAe;AACpB,QAAI,KAAK,YAAY;AACnB,WAAK,WAAW,MAAM,UAAU,aAAa,SAAS;AAAA,IACxD;AAAA,EACF;AAAA,EAEA,IAAI,iCAAiC,iBAAyE;AAC5G,SAAK,kBAAkB,EAAC,GAAG,gBAAgB,GAAG,GAAG,gBAAgB,EAAC;AAClE,SAAK,uBAAuB,EAAC,OAAO,gBAAgB,QAAQ,QAAQ,gBAAgB,OAAM;AAC1F,SAAK,qBAAqB;AAC1B,SAAK,uBAAuB;AAAA,EAC9B;AAAA,EAEA,IAAI,kBAAkB,mBAA+E;AACnG,SAAK,oBAAoB,kBAAkB;AAC3C,SAAK,kBAAkB,kBAAkB;AAAA,EAC3C;AAAA;AAAA;AAAA,EAIA,IAAI,+BAA+B,eAAyE;AAC1G,SAAK,gBAAgB,EAAC,GAAG,cAAc,GAAG,GAAG,cAAc,EAAC;AAC5D,QAAI,cAAc,UAAU,cAAc,QAAQ;AAChD,WAAK,qBAAqB,EAAC,OAAO,cAAc,QAAQ,QAAQ,cAAc,OAAM;AAAA,IACtF,OAAO;AACL,WAAK,qBAAqB;AAAA,IAC5B;AAEA,SAAK,qBAAqB;AAC1B,SAAK,uBAAuB;AAAA,EAC9B;AAAA,EAEA,IAAI,kBAAkB,GAAY;AAChC,QAAI,MAAM,KAAK,oBAAoB;AACjC;AAAA,IACF;AACA,SAAK,qBAAqB;AAC1B,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,IAAI,gBAAgB,GAAY;AAC9B,QAAI,MAAM,KAAK,kBAAkB;AAC/B;AAAA,IACF;AACA,SAAK,mBAAmB;AACxB,SAAK,QAAQ;AAAA,EACf;AAAA,EAEA,yBAA+B;AAC7B,QAAI,CAAC,KAAK,cAAc,CAAC,KAAK,qBAAqB,CAAC,KAAK,mBAAmB,CAAC,KAAK,uBAC9E,CAAC,KAAK,mBAAmB;AAC3B,cAAQ,MAAM,iCAAiC;AAC/C;AAAA,IACF;AAEA,QAAI,KAAK,eAAe,MAAM,MAAM,KAAK,iBAAiB,sBAAsB;AAC9E,WAAK,oBAAoB,aAAa,cAAc,QAAQ;AAC5D,WAAK,kBAAkB,aAAa,cAAc,QAAQ;AAC1D;AAAA,IACF;AAKA,UAAM,iCAAiC;AAOvC,UAAM,+BAA+B,KAAK,qBAAqB,CAAC,KAAK,gBAAgB,KAAK,sBACtF,KAAK,qBAAqB,SAAS;AAEvC,UAAM,iBAAiB,KAAK,oBAAoB,SAAS;AACzD,UAAM,6BAA6B,CAAC,KAAK,gBAAgB,KAAK,mBAAmB,KAAK,oBAClF,kBAAkB,kCAAkC,CAAC,KAAK;AAE9D,SAAK,oBAAoB,aAAa,cAAc,+BAA+B,YAAY,QAAQ;AACvG,SAAK,kBAAkB,aAAa,cAAc,6BAA6B,YAAY,QAAQ;AAKnG,QAAI,KAAK,mBAAmB;AAC1B,YAAM,kBAAkB,KAAK,qBAAqB,SAAS;AAC3D,YAAM,sBAAsB,OAAO,KAAK,gBAAgB,IAAI,KAAK,qBAAqB,KAAK;AAC3F,YAAM,sBAAsB,OAAO,KAAK,gBAAgB,IAAI,eAAe;AAE3E,WAAK,WAAW,aAAa,MAAM,mBAAmB;AACtD,WAAK,WAAW,aAAa,MAAM,mBAAmB;AAEtD,WAAK,oBAAoB,aAAa,MAAM,mBAAmB;AAC/D,WAAK,oBAAoB,aAAa,MAAM,mBAAmB;AAC/D,WAAK,kBAAkB,MAAM,aAAa;AAAA,IAC5C,OAAO;AACL,WAAK,WAAW,aAAa,OAAO,KAAK,gBAAgB,IAAI,KAAK,qBAAqB,OAAO,SAAS,CAAC;AACxG,WAAK,WAAW,aAAa,MAAM,KAAK,gBAAgB,EAAE,SAAS,CAAC;AACpE,WAAK,kBAAkB,MAAM,aAAa;AAAA,IAC5C;AAIA,QAAI,KAAK,sBAAsB,KAAK,iBAAiB;AACnD,YAAM,mBAAmB,OAAO,KAAK,cAAc,CAAC;AACpD,YAAM,mBAAmB,OAAO,KAAK,cAAc,IAAI,KAAK,mBAAmB,SAAS,CAAC;AAEzF,WAAK,WAAW,aAAa,MAAM,gBAAgB;AACnD,WAAK,WAAW,aAAa,MAAM,gBAAgB;AAEnD,WAAK,kBAAkB,aAAa,MAAM,gBAAgB;AAC1D,WAAK,kBAAkB,aAAa,MAAM,gBAAgB;AAE1D,WAAK,gBAAgB,MAAM,aAAa;AAAA,IAC1C,OAAO;AACL,WAAK,gBAAgB,MAAM,aAAa;AACxC,WAAK,WAAW,aAAa,MAAM,KAAK,cAAc,EAAE,SAAS,CAAC;AAClE,WAAK,WAAW,aAAa,MAAM,KAAK,cAAc,EAAE,SAAS,CAAC;AAAA,IACpE;AAEA,SAAK,WAAW,aAAa,gBAAgB,GAAG;AAEhD,QAAI,KAAK,sBAAsB,KAAK,qBAAqB,CAAC,KAAK,iBAAiB;AAC9E,WAAK,WAAW,aAAa,UAAU,+BAA+B;AAAA,IACxE,WAAW,KAAK,sBAAsB,KAAK,mBAAmB,CAAC,KAAK,mBAAmB;AACrF,WAAK,WAAW,aAAa,UAAU,6BAA6B;AAAA,IACtE,OAAO;AACL,YAAM,aAAa,aAAa,aAAa,SAAS,EAAE,iBAAiB,sBAAsB;AAC/F,WAAK,WAAW,aAAa,UAAU,UAAU;AAAA,IACnD;AAEA,SAAK,QAAQ;AAAA,EACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,yCAAiD;AAC/C,QAAI,CAAC,KAAK,aAAa;AACrB,aAAO;AAAA,IACT;AAEA,UAAM,aAAa,KAAK,cAAc,KAAK,KAAK,gBAAgB,IAAI,KAAK,qBAAqB;AAC9F,QAAI,oBAAoB;AAMxB,QAAI,KAAK,qBAAqB,CAAC,KAAK,iBAAiB;AACnD,0BAAoB,KAAK,YAAY,SAAS,KAAK,gBAAgB,IAAI,KAAK,qBAAqB;AAAA,IACnG,WAAW,CAAC,KAAK,qBAAqB,KAAK,iBAAiB;AAC1D,0BAAoB,KAAK,cAAc;AAAA,IACzC;AAEA,UAAM,iCAAkC,oBAAoB,MAAO;AAEnE,WAAQ,iCAAiC,MAAO,iCAAiC;AAAA,EACnF;AAAA,EAEA,uBAA6B;AAC3B,UAAM,gBAAgB,KAAK,QAAQ,cAA2B,kBAAkB;AAChF,UAAM,iBAAiB,eAAe,cAA2B,mBAAmB,KAAK;AAEzF,QAAI,CAAC,iBAAiB,CAAC,gBAAgB;AACrC,cAAQ,MAAM,8BAA8B;AAC5C;AAAA,IACF;AAEA,QAAI,KAAK,eAAe,MAAM,MAAM,KAAK,iBAAiB,sBAAsB;AAC9E,qBAAe,MAAM,UAAU;AAC/B;AAAA,IACF;AAEA,mBAAe,MAAM,OAAO,GAAG,KAAK,gBAAgB,IAAI,KAAK,qBAAqB,KAAK;AACvF,mBAAe,MAAM,MAAM,GAAG,KAAK,gBAAgB,CAAC;AAAA,EACtD;AAAA,EAEA,2BAAiC;AAC/B,SAAK,aAAa,MAAM,MAAM,KAAK,iBAAiB;AACpD,SAAK,cAAc,IAAI,uBAAuB,CAAC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,UAAgB;AACd,UAAM,aAAa,aAAa,aAAa,SAAS,EAAE,iBAAiB,sBAAsB;AAE/F,YAAQ;AAAA,MACJ;AAAA,gGACwF,WAAW,UAAU,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAO9F,UAAU;AAAA;AAAA;AAAA,4BAGb,KAAK,uCAAuC,CAAC;AAAA,+BAC1C,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4BAQb,MAAM,KAAK,uCAAuC,CAAC;AAAA,+BAChD,UAAU;AAAA;AAAA;AAAA;AAAA,+BAIV,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAWZ,KAAK,mBAAmB,CAAC,KAAK,qBAAqB,YAAY,QAAQ;AAAA,gDACpD,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,iCAKzB,CAAC,KAAK,sBAAsB,CAAC,KAAK,mBAAmB,uBAAuB,MAAM;AAAA,2BACxF,CAAC,KAAK,qBAAqB,CAAC,KAAK,kBAAkB,WAAW,SAAS;AAAA;AAAA,oEAE9B,UAAU,iBAAiB,6BAA6B,MAAM,uBAAuB;AAAA,kEACvF,UAAU,iBAAiB,6BAA6B,MAAM,uBAAuB;AAAA;AAAA,6DAE1F,KAAK,qBAAqB,KAAK,qBAAqB;AAAA,2DACtD,KAAK,mBAAmB,KAAK,qBAAqB;AAAA,wCACrE,KAAK,aAAa,YAAY,QAAQ;AAAA;AAAA;AAAA,sBAGxD,cAAc,OAAO,wCAAwC,EAAE,MAAM,EAAC,OAAO,KAAI,CAAC,CAAC;AAAA,uBAClF,KAAK,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA,MAK5C,KAAK;AAAA,MAAS,EAAC,MAAM,KAAI;AAAA,IAAC;AAAA,EAEhC;AACF;AAEA,MAAM,0BAA0B;AAChC,MAAM,gCAAgC;AAItC,MAAM,uBAAuB;AAE7B,eAAe,OAAO,iCAAiC,kBAAkB;",
  "names": []
}
