{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/timeline/utils/ImageCache.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Trace from '../../../models/trace/trace.js';\n\nconst imageCache: WeakMap<Trace.Types.Events.SyntheticScreenshot, HTMLImageElement|null> = new WeakMap();\nexport const emitter = new EventTarget();\n\n/**\n * Synchronously returns an image, or return `null` while queuing up an async load of that image.\n * If the image load fails, we cache a null to avoid reattempts.\n */\nexport function getOrQueue(screenshot: Trace.Types.Events.SyntheticScreenshot): HTMLImageElement|null {\n  if (imageCache.has(screenshot)) {\n    return imageCache.get(screenshot) ?? null;\n  }\n\n  const data = screenshot.args.dataUri;\n\n  loadImage(data)\n      .then(imageOrNull => {\n        imageCache.set(screenshot, imageOrNull);\n        emitter.dispatchEvent(new CustomEvent('screenshot-loaded', {detail: {screenshot, image: imageOrNull}}));\n      })\n      .catch(() => {});\n  return null;\n}\n\n/** Load an image (probably data URI). If it fails, resolve with null. */\nfunction loadImage(url: string): Promise<HTMLImageElement|null> {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.addEventListener('load', () => resolve(image));\n    image.addEventListener('error', () => resolve(null));\n    image.src = url;\n  });\n}\n\n/** Populate the cache ahead of use, to allow for getOrQueue to synchronously return images. */\nexport function preload(screenshots: Trace.Types.Events.SyntheticScreenshot[]): Promise<void[]> {\n  const promises = screenshots.map(screenshot => {\n    if (imageCache.has(screenshot)) {\n      return;\n    }\n    return loadImage(screenshot.args.dataUri).then(image => {\n      imageCache.set(screenshot, image);\n      return;\n    });\n  });\n  return Promise.all(promises);\n}\n\nexport const cacheForTesting = imageCache;\nexport const loadImageForTesting = loadImage;\n"],
  "mappings": ";AAMA,MAAM,aAAqF,oBAAI,QAAQ;AAChG,aAAM,UAAU,IAAI,YAAY;AAMhC,gBAAS,WAAW,YAA2E;AACpG,MAAI,WAAW,IAAI,UAAU,GAAG;AAC9B,WAAO,WAAW,IAAI,UAAU,KAAK;AAAA,EACvC;AAEA,QAAM,OAAO,WAAW,KAAK;AAE7B,YAAU,IAAI,EACT,KAAK,iBAAe;AACnB,eAAW,IAAI,YAAY,WAAW;AACtC,YAAQ,cAAc,IAAI,YAAY,qBAAqB,EAAC,QAAQ,EAAC,YAAY,OAAO,YAAW,EAAC,CAAC,CAAC;AAAA,EACxG,CAAC,EACA,MAAM,MAAM;AAAA,EAAC,CAAC;AACnB,SAAO;AACT;AAGA,SAAS,UAAU,KAA6C;AAC9D,SAAO,IAAI,QAAQ,aAAW;AAC5B,UAAM,QAAQ,IAAI,MAAM;AACxB,UAAM,iBAAiB,QAAQ,MAAM,QAAQ,KAAK,CAAC;AACnD,UAAM,iBAAiB,SAAS,MAAM,QAAQ,IAAI,CAAC;AACnD,UAAM,MAAM;AAAA,EACd,CAAC;AACH;AAGO,gBAAS,QAAQ,aAAwE;AAC9F,QAAM,WAAW,YAAY,IAAI,gBAAc;AAC7C,QAAI,WAAW,IAAI,UAAU,GAAG;AAC9B;AAAA,IACF;AACA,WAAO,UAAU,WAAW,KAAK,OAAO,EAAE,KAAK,WAAS;AACtD,iBAAW,IAAI,YAAY,KAAK;AAChC;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACD,SAAO,QAAQ,IAAI,QAAQ;AAC7B;AAEO,aAAM,kBAAkB;AACxB,aAAM,sBAAsB;",
  "names": []
}
