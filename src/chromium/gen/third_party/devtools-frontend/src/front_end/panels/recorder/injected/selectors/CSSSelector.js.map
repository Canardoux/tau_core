{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/recorder/injected/selectors/CSSSelector.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {SelectorPart, type Selector} from './Selector.js';\n\nexport interface QueryableNode extends Node {\n  querySelectorAll(selectors: string): NodeListOf<Element>;\n}\n\nconst idSelector = (id: string): string => {\n  return `#${CSS.escape(id)}`;\n};\n\nconst attributeSelector = (name: string, value: string): string => {\n  return `[${name}='${CSS.escape(value)}']`;\n};\n\nconst classSelector = (selector: string, className: string): string => {\n  return `${selector}.${CSS.escape(className)}`;\n};\n\nconst nthTypeSelector = (selector: string, index: number): string => {\n  return `${selector}:nth-of-type(${index + 1})`;\n};\n\nconst typeSelector = (selector: string, type: string): string => {\n  return `${selector}${attributeSelector('type', type)}`;\n};\n\nconst hasUniqueId = (node: Element): boolean => {\n  return (Boolean(node.id) && (node.getRootNode() as QueryableNode).querySelectorAll(idSelector(node.id)).length === 1);\n};\n\nconst isUniqueAmongTagNames = (\n    node: Element,\n    children: Iterable<Element>,\n    ): boolean => {\n  for (const child of children) {\n    if (child !== node && child.tagName === node.tagName) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isUniqueAmongInputTypes = (\n    node: HTMLInputElement,\n    children: Iterable<Element>,\n    ): boolean => {\n  for (const child of children) {\n    if (child !== node && child instanceof HTMLInputElement && child.type === node.type) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst getUniqueClassName = (\n    node: Element,\n    children: Iterable<Element>,\n    ): string|undefined => {\n  const classNames = new Set(node.classList);\n  for (const child of children) {\n    if (child !== node) {\n      for (const className of child.classList) {\n        classNames.delete(className);\n      }\n      if (classNames.size === 0) {\n        break;\n      }\n    }\n  }\n  if (classNames.size > 0) {\n    return classNames.values().next().value;\n  }\n  return undefined;\n};\n\nconst getTypeIndex = (node: Element, children: Iterable<Element>): number => {\n  let nthTypeIndex = 0;\n  for (const child of children) {\n    if (child === node) {\n      return nthTypeIndex;\n    }\n    if (child.tagName === node.tagName) {\n      ++nthTypeIndex;\n    }\n  }\n  throw new Error('Node not found in children');\n};\n\nexport const getSelectorPart = (\n    node: Node,\n    attributes: string[] = [],\n    ): SelectorPart|undefined => {\n  if (!(node instanceof Element)) {\n    return;\n  }\n\n  // Declared attibutes have the greatest priority.\n  for (const attribute of attributes) {\n    const value = node.getAttribute(attribute);\n    if (value) {\n      return new SelectorPart(attributeSelector(attribute, value), true);\n    }\n  }\n\n  // IDs are supposed to be globally unique, so this has second priority.\n  if (hasUniqueId(node)) {\n    return new SelectorPart(idSelector(node.id), true);\n  }\n\n  // All selectors will be prefixed with the tag name starting here.\n  const selector = node.tagName.toLowerCase();\n\n  // These can only appear once in the entire document, so handle this fast.\n  switch (node.tagName) {\n    case 'BODY':\n    case 'HEAD':\n    case 'HTML':\n      return new SelectorPart(selector, true);\n  }\n\n  const parent = node.parentNode;\n  // If the node has no parent, then the node must be detached. We handle this\n  // gracefully.\n  if (!parent) {\n    return new SelectorPart(selector, true);\n  }\n\n  const children = parent.children;\n\n  // Determine if the child has a unique node name among all children.\n  if (isUniqueAmongTagNames(node, children)) {\n    return new SelectorPart(selector, true);\n  }\n\n  // If it's an input, check uniqueness among types.\n  if (node instanceof HTMLInputElement && isUniqueAmongInputTypes(node, children)) {\n    return new SelectorPart(typeSelector(selector, node.type), true);\n  }\n\n  // Determine if the child has a unique class name.\n  const className = getUniqueClassName(node, children);\n  if (className !== undefined) {\n    return new SelectorPart(classSelector(selector, className), true);\n  }\n\n  // Last resort. Just use the nth-type index. A priori, this will always exists.\n  return new SelectorPart(\n      nthTypeSelector(selector, getTypeIndex(node, children)),\n      false,\n  );\n};\n\n/**\n * This interface represents operations on an ordered range of indices of type\n * `I`. Implementations must have the following assumptions:\n *\n *  1. `self(self(i)) = self(i)`, i.e. `self` must be idempotent.\n *  2. `inc(i) > i`.\n *  3. `j >= i` implies `gte(valueOf(j), i)`, i.e. `gte` preserves the order of\n *     the range.\n *\n */\nexport interface RangeOps<I, V> {\n  // Returns a suitable version of an index (e.g. ShadowRoot.host instead of\n  // ShadowRoot).\n  self?(index: I): I;\n\n  // Increments the given index by 1.\n  inc(index: I): I;\n\n  // Gets the value at the given index.\n  valueOf(index: I): V;\n\n  // Must preserve `j >= i` if `value === valueOf(j)`.\n  gte(value: V, index: I): boolean;\n}\n\n/**\n * The goal of this function is to find the smallest index `i` that makes\n * `gte(valueOf(i), j)` true for all `j` in `[min, max)`. We do not use binary\n * search because\n *\n *  1. We expect the min-max to be concentrated towards the minimum (< 10\n *     iterations).\n *  2. We expect `valueOf` to be `O(n)`, so together with (1), the average will\n *     be around `O(n)` which is significantly faster than binary search in this\n *     case.\n */\nexport const findMinMax = <I, V>(\n    [min, max]: [I, I],\n    fns: RangeOps<I, V>,\n    ): V => {\n  fns.self ??= (i): I => i;\n\n  let index = fns.inc(min);\n  let value: V;\n  let isMax: boolean;\n  do {\n    value = fns.valueOf(min);\n    isMax = true;\n    while (index !== max) {\n      min = fns.self(index);\n      index = fns.inc(min);\n      if (!fns.gte(value, index)) {\n        isMax = false;\n        break;\n      }\n    }\n  } while (!isMax);\n  return value;\n};\n\nexport class SelectorRangeOps implements RangeOps<QueryableNode, string> {\n  // Close chains (using `>`) are stored in inner arrays.\n  #buffer: SelectorPart[][] = [[]];\n  #attributes: string[];\n  #depth = 0;\n\n  constructor(attributes: string[] = []) {\n    this.#attributes = attributes;\n  }\n\n  inc(node: Node): QueryableNode {\n    return node.parentNode ?? (node.getRootNode() as QueryableNode);\n  }\n  valueOf(node: Node): string {\n    const part = getSelectorPart(node, this.#attributes);\n    if (!part) {\n      throw new Error('Node is not an element');\n    }\n    if (this.#depth > 1) {\n      // Implies this selector is for a distant ancestor.\n      this.#buffer.unshift([part]);\n    } else {\n      // Implies this selector is for a parent.\n      this.#buffer[0].unshift(part);\n    }\n    this.#depth = 0;\n    return this.#buffer.map(parts => parts.join(' > ')).join(' ');\n  }\n  gte(selector: string, node: QueryableNode): boolean {\n    ++this.#depth;\n    return node.querySelectorAll(selector).length === 1;\n  }\n}\n\n/**\n * Computes the CSS selector for a node.\n *\n * @param node - The node to compute.\n * @returns The computed CSS selector.\n *\n * @internal\n */\nexport const computeCSSSelector = (\n    node: Node,\n    attributes?: string[],\n    ): Selector|undefined => {\n  const selectors = [];\n\n  // We want to find the minimal selector that is unique within a document. We\n  // are slightly restricted since selectors cannot cross ShadowRoot borders, so\n  // the actual goal is to find the minimal selector that is unique within a\n  // root node. We then need to repeat this for each shadow root.\n  try {\n    let root: Document|ShadowRoot;\n    while (node instanceof Element) {\n      root = node.getRootNode() as Document | ShadowRoot;\n      selectors.unshift(\n          findMinMax(\n              [node as QueryableNode, root],\n              new SelectorRangeOps(attributes),\n              ),\n      );\n      node = root instanceof ShadowRoot ? root.host : root;\n    }\n  } catch {\n    return undefined;\n  }\n\n  return selectors;\n};\n\nexport const queryCSSSelectorAll = (selectors: Selector): Element[] => {\n  if (typeof selectors === 'string') {\n    selectors = [selectors];\n  } else if (selectors.length === 0) {\n    return [];\n  }\n  let lists: NodeListOf<Element>[] = [\n    [document.documentElement] as unknown as NodeListOf<Element>,\n  ];\n  do {\n    const selector = selectors.shift() as string;\n    const roots: NodeListOf<Element>[] = [];\n    for (const nodes of lists) {\n      for (const node of nodes) {\n        const list = (node.shadowRoot ?? node).querySelectorAll(selector);\n        if (list.length > 0) {\n          roots.push(list);\n        }\n      }\n    }\n    lists = roots;\n  } while (selectors.length > 0 && lists.length > 0);\n  return lists.flatMap(list => [...list]);\n};\n"],
  "mappings": "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",
  "names": []
}
