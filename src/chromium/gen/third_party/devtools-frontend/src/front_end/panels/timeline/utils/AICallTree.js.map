{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/panels/timeline/utils/AICallTree.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../../models/trace/trace.js';\n\nimport {nameForEntry} from './EntryName.js';\nimport {visibleTypes} from './EntryStyles.js';\nimport {SourceMapsResolver} from './SourceMapsResolver.js';\n\n/** Iterates from a node down through its descendents. If the callback returns true, the loop stops. */\nfunction depthFirstWalk(\n    nodes: MapIterator<Trace.Extras.TraceTree.Node>, callback: (arg0: Trace.Extras.TraceTree.Node) => void|true): void {\n  for (const node of nodes) {\n    if (callback?.(node)) {\n      break;\n    }\n    depthFirstWalk(node.children().values(), callback);  // Go deeper.\n  }\n}\n\nexport class AICallTree {\n  constructor(\n      public selectedNode: Trace.Extras.TraceTree.Node,\n      public rootNode: Trace.Extras.TraceTree.TopDownRootNode,\n      // TODO: see if we can avoid passing around this entire thing.\n      public parsedTrace: Trace.Handlers.Types.ParsedTrace,\n  ) {\n  }\n\n  static from(\n      selectedEvent: Trace.Types.Events.Event, events: Trace.Types.Events.Event[],\n      parsedTrace: Trace.Handlers.Types.ParsedTrace): AICallTree {\n    const {startTime, endTime} = Trace.Helpers.Timing.eventTimingsMilliSeconds(selectedEvent);\n\n    const selectedEventBounds = Trace.Helpers.Timing.traceWindowFromMicroSeconds(\n        Trace.Helpers.Timing.millisecondsToMicroseconds(startTime),\n        Trace.Helpers.Timing.millisecondsToMicroseconds(endTime));\n    const threadEvents = parsedTrace.Renderer.processes.get(selectedEvent.pid)?.threads.get(selectedEvent.tid)?.entries;\n    if (!threadEvents) {\n      throw new Error('Cannot locate thread');\n    }\n    const overlappingEvents = threadEvents.filter(e => Trace.Helpers.Timing.eventIsInBounds(e, selectedEventBounds));\n\n    const visibleEventsFilter = new Trace.Extras.TraceFilter.VisibleEventsFilter(visibleTypes());\n    const customFilter = new AITreeFilter(selectedEvent);\n    // Build a tree bounded by the selected event's timestamps, and our other filters applied\n    const rootNode = new Trace.Extras.TraceTree.TopDownRootNode(\n        overlappingEvents, [visibleEventsFilter, customFilter], startTime, endTime, false, null, true);\n\n    // Walk the tree to find selectedNode\n    let selectedNode: Trace.Extras.TraceTree.Node|null = null;\n    depthFirstWalk([rootNode].values(), node => {\n      if (node.event === selectedEvent) {\n        selectedNode = node;\n        return true;\n      }\n      return;\n    });\n\n    if (selectedNode === null) {\n      throw new Error('Node not within its own tree. Unexpected.');\n    }\n    const instance = new AICallTree(selectedNode, rootNode, parsedTrace);\n    // instance.logDebug();\n    return instance;\n  }\n\n  /** Define precisely how the call tree is serialized. Typically called from within `DrJonesPerformanceAgent` */\n  serialize(): string {\n    const nodeToIdMap = new Map<Trace.Extras.TraceTree.Node, number>();\n    // Keep a map of URLs. We'll output a LUT to keep size down.\n    const allUrls: string[] = [];\n\n    let nodesStr = '';\n    depthFirstWalk(this.rootNode.children().values(), node => {\n      nodesStr += AICallTree.stringifyNode(node, this.parsedTrace, this.selectedNode, nodeToIdMap, allUrls);\n    });\n\n    let output = '';\n    if (allUrls.length) {\n      // Output lookup table of URLs within this tree\n      output += '\\n# All URL #s:\\n\\n' + allUrls.map((url, index) => `  * ${index}: ${url}`).join('\\n');\n    }\n    output += '\\n\\n# Call tree:' + nodesStr;\n    return output;\n  }\n\n  /* This custom YAML-like format with an adjacency list for children is 35% more token efficient than JSON */\n  static stringifyNode(\n      node: Trace.Extras.TraceTree.Node, parsedTrace: Trace.Handlers.Types.ParsedTrace,\n      selectedNode: Trace.Extras.TraceTree.Node, nodeToIdMap: Map<Trace.Extras.TraceTree.Node, number>,\n      allUrls: string[]): string {\n    const event = node.event;\n    if (!event) {\n      throw new Error('Event required');\n    }\n\n    const url = SourceMapsResolver.resolvedURLForEntry(parsedTrace, event);\n    // Get the index of the URL within allUrls, and push if needed. Set to -1 if there's no URL here.\n    const urlIndex = !url ? -1 : allUrls.indexOf(url) === -1 ? allUrls.push(url) - 1 : allUrls.indexOf(url);\n    const children = Array.from(node.children().values());\n\n    // Identifier string includes an id and name:\n    //   eg \"[13] Parse HTML\" or \"[45] parseCPUProfileFormatFromFile\"\n    const getIdentifier = (node: Trace.Extras.TraceTree.Node): string => {\n      if (!node.event || typeof node.id !== 'string') {\n        throw new Error('ok');\n      }\n      if (!nodeToIdMap.has(node)) {\n        nodeToIdMap.set(node, nodeToIdMap.size + 1);\n      }\n      return `${nodeToIdMap.get(node)} \u2013 ${nameForEntry(node.event, parsedTrace)}`;\n    };\n\n    // Round milliseconds because we don't need the precision\n    const roundToTenths = (num: number): number => Math.round(num * 10) / 10;\n\n    // Build a multiline string describing this callframe node\n    const lines = [\n      `\\n\\nNode: ${getIdentifier(node)}`,\n      selectedNode === node && 'Selected: true',\n      node.totalTime && `dur: ${roundToTenths(node.totalTime)}`,\n      // node.functionSource && `snippet: ${node.functionSource.slice(0, 250)}`,\n      node.selfTime && `self: ${roundToTenths(node.selfTime)}`,\n      urlIndex !== -1 && `URL #: ${urlIndex}`,\n    ];\n    if (children.length) {\n      lines.push('Children:');\n      lines.push(...children.map(node => `  * ${getIdentifier(node)}`));\n    }\n    return lines.filter(Boolean).join('\\n');\n  }\n\n  // Only used for debugging.\n  logDebug(): void {\n    const str = this.serialize();\n    // eslint-disable-next-line no-console\n    console.log('\uD83C\uDF86', str);\n    if (str.length > 45_000) {\n      // Manual testing shows 45k fits. 50k doesnt.\n      // Max is 32k _tokens_, but tokens to bytes is wishywashy, so... hard to know for sure.\n      console.warn('Output will likely not fit in the context window. Expect an AIDA error.');\n    }\n  }\n}\n\nexport class AITreeFilter extends Trace.Extras.TraceFilter.TraceFilter {\n  #minDuration: Trace.Types.Timing.MicroSeconds;\n  #selectedEvent: Trace.Types.Events.Event;\n  constructor(selectedEvent: Trace.Types.Events.Event) {\n    super();\n    // The larger the selected event is, the less small ones matter. We'll exclude items under \u00BD% of the selected event's size\n    this.#minDuration = Trace.Types.Timing.MicroSeconds((selectedEvent.dur ?? 1) * 0.005);\n    this.#selectedEvent = selectedEvent;\n  }\n  accept(event: Trace.Types.Events.Event): boolean {\n    if (event === this.#selectedEvent) {\n      return true;\n    }\n    if (event.name === Trace.Types.Events.Name.COMPILE_CODE) {\n      return false;\n    }\n    return event.dur ? event.dur >= this.#minDuration : false;\n  }\n}\n"],
  "mappings": "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",
  "names": ["node"]
}
