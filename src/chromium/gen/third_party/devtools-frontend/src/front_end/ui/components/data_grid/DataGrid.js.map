{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/components/data_grid/DataGrid.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Host from '../../../core/host/host.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as UI from '../../legacy/legacy.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as VisualLogging from '../../visual_logging/visual_logging.js';\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\n\nimport dataGridStyles from './dataGrid.css.js';\nimport {\n  BodyCellFocusedEvent,\n  ColumnHeaderClickEvent,\n  ContextMenuHeaderResetClickEvent,\n  RowMouseEnterEvent,\n  RowMouseLeaveEvent,\n} from './DataGridEvents.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nimport {addColumnVisibilityCheckboxes, addSortableColumnItems} from './DataGridContextMenuUtils.js';\n\nimport {\n  calculateColumnWidthPercentageFromWeighting,\n  calculateFirstFocusableCell,\n  getCellTitleFromCellContent,\n  getRowEntryForColumnId,\n  handleArrowKeyNavigation,\n  renderCellValue,\n  SortDirection,\n  type CellPosition,\n  type Column,\n  type Row,\n  type SortState,\n} from './DataGridUtils.js';\n\nimport * as i18n from '../../../core/i18n/i18n.js';\n\nconst {html, Directives: {ifDefined, classMap, styleMap, repeat}} = LitHtml;\nconst UIStrings = {\n  /**\n   *@description A context menu item in the Data Grid of a data grid\n   */\n  sortBy: 'Sort By',\n  /**\n   *@description A context menu item in data grids to reset the columns to their default weight\n   */\n  resetColumns: 'Reset Columns',\n  /**\n   *@description A context menu item in data grids to list header options.\n   */\n  headerOptions: 'Header Options',\n  /**\n   *@description Text for screen reader to announce when focusing on a sortable column in data grid.\n   *@example {ascending} PH1\n   */\n  enterToSort: 'Column sort state: {PH1}. Press enter to apply sorting filter',\n  /**\n   *@description The current sort state of a column in data grid\n   */\n  sortAsc: 'ascending',\n  /**\n   *@description The current sort state of a column in data grid\n   */\n  sortDesc: 'descending',\n  /**\n   *@description The current sort state of a column in data grid\n   */\n  sortNone: 'none',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/components/data_grid/DataGrid.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport interface DataGridContextMenusConfiguration {\n  headerRow?: (menu: UI.ContextMenu.ContextMenu, columns: readonly Column[]) => void;\n  bodyRow?:\n      (menu: UI.ContextMenu.ContextMenu, columns: readonly Column[], row: Readonly<Row>, rows: readonly Row[]) => void;\n}\n\nexport interface DataGridData {\n  columns: Column[];\n  rows: Row[];\n  activeSort: SortState|null;\n  contextMenus?: DataGridContextMenusConfiguration;\n  label?: string;\n  paddingRowsCount?: number;\n  showScrollbar?: boolean;\n  striped?: boolean;\n  /**\n   * Disable the auto-scroll on new data feature. This is enabled by default.\n   */\n  autoScrollToBottom?: boolean;\n}\n\nconst enum UserScrollState {\n  NOT_SCROLLED = 'NOT_SCROLLED',\n  MANUAL_SCROLL_NOT_BOTTOM = 'MANUAL_SCROLL_NOT_BOTTOM',\n  SCROLLED_TO_BOTTOM = 'SCROLLED_TO_BOTTOM',\n}\n\nconst KEYS_TREATED_AS_CLICKS = new Set([' ', 'Enter']);\n\nconst ROW_HEIGHT_PIXELS = 20;\n\nexport class DataGrid extends HTMLElement {\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #columns: readonly Column[] = [];\n  #rows: readonly Row[] = [];\n  #sortState: Readonly<SortState>|null = null;\n  #isRendering = false;\n  #userScrollState: UserScrollState = UserScrollState.NOT_SCROLLED;\n  #contextMenus?: DataGridContextMenusConfiguration = undefined;\n  #label?: string = undefined;\n  #paddingRowsCount = 10;\n  #showScrollbar?: boolean = false;\n  #striped?: boolean = false;\n  #autoScrollToBottom: boolean = true;\n\n  #currentResize: {\n    rightCellCol: HTMLTableColElement,\n    leftCellCol: HTMLTableColElement,\n    leftCellColInitialPercentageWidth: number,\n    rightCellColInitialPercentageWidth: number,\n    initialLeftCellWidth: number,\n    initialRightCellWidth: number,\n    initialMouseX: number,\n    documentForCursorChange: Document,\n    cursorToRestore: string,\n  }|null = null;\n  // Because we only render a subset of rows, we need a way to look up the\n  // actual row index from the original dataset. We could use this.rows[index]\n  // but that's O(n) and will slow as the dataset grows. A weakmap makes the\n  // lookup constant.\n  readonly #rowIndexMap = new WeakMap<Row, number>();\n  readonly #resizeObserver = new ResizeObserver(() => {\n    void this.#alignScrollHandlers();\n  });\n\n  // Thie have to be bound as they are put onto the global document, not onto\n  // this element, so LitHtml does not bind them for us.\n  #boundOnResizePointerMove = this.#onResizePointerMove.bind(this);\n\n  /**\n   * Following guidance from\n   * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html, we\n   * allow a single cell inside the table to be focusable, such that when a user\n   * tabs in they select that cell. IMPORTANT: if the data-grid has sortable\n   * columns, the user has to be able to navigate to the headers to toggle the\n   * sort. [0,0] is considered the first cell INCLUDING the column header\n   * Therefore if a user is on the first header cell, the position is considered [0, 0],\n   * and if a user is on the first body cell, the position is considered [0, 1].\n   *\n   * We set the selectable cell to the first tbody value by default, but then on the\n   * first render if any of the columns are sortable we'll set the active cell\n   * to [0, 0].\n   */\n  #cellToFocusIfUserTabsIn: CellPosition = [0, 1];\n  #cellUserHasFocused: CellPosition|null = null;\n\n  #hasRenderedAtLeastOnce = false;\n  #userHasFocusInDataGrid = false;\n  #scheduleRender = false;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [dataGridStyles];\n    this.style.setProperty('--table-row-height', `${ROW_HEIGHT_PIXELS}px`);\n    void this.#render();\n  }\n\n  get data(): DataGridData {\n    return {\n      columns: this.#columns as Column[],\n      rows: this.#rows as Row[],\n      activeSort: this.#sortState,\n      contextMenus: this.#contextMenus,\n      autoScrollToBottom: this.#autoScrollToBottom,\n      label: this.#label,\n      paddingRowsCount: this.#paddingRowsCount,\n      showScrollbar: this.#showScrollbar,\n      striped: this.#striped,\n    };\n  }\n\n  set data(data: DataGridData) {\n    this.#columns = data.columns;\n    this.#rows = data.rows;\n    this.#rows.forEach((row, index) => {\n      this.#rowIndexMap.set(row, index);\n    });\n    this.#sortState = data.activeSort;\n    this.#contextMenus = data.contextMenus;\n    this.#label = data.label;\n    this.#showScrollbar = data.showScrollbar;\n    this.#striped = data.striped;\n    if (typeof data.autoScrollToBottom === 'boolean') {\n      this.#autoScrollToBottom = data.autoScrollToBottom;\n    }\n\n    /**\n     * On first render, now we have data, we can figure out which cell is the\n     * focusable cell for the table.\n     *\n     * If any columns are sortable, we pick [0, 0], which is the first cell of\n     * the columns row. However, if any columns are hidden, we adjust\n     * accordingly. e.g., if the first column is hidden, we'll set the starting\n     * index as [1, 0].\n     *\n     * If the columns aren't sortable, we pick the first visible body row as the\n     * index.\n     *\n     * We only do this on the first render; otherwise if we re-render and the\n     * user has focused a cell, this logic will reset it.\n     */\n    if (!this.#hasRenderedAtLeastOnce) {\n      this.#cellToFocusIfUserTabsIn = calculateFirstFocusableCell({columns: this.#columns, rows: this.#rows});\n    }\n\n    if (data.paddingRowsCount !== undefined) {\n      this.#paddingRowsCount = data.paddingRowsCount;\n    }\n\n    if (this.#hasRenderedAtLeastOnce && this.#userHasCellFocused()) {\n      const [selectedColIndex, selectedRowIndex] = this.#tabbableCell();\n      const columnOutOfBounds = selectedColIndex > this.#columns.length;\n      const rowOutOfBounds = selectedRowIndex > this.#rows.length;\n\n      /** If the row or column was removed, so the user is out of bounds, we\n       * move them to the last focusable cell, which should be close to where\n       * they were. */\n      if (columnOutOfBounds || rowOutOfBounds) {\n        this.#cellUserHasFocused = [\n          columnOutOfBounds ? this.#columns.length : selectedColIndex,\n          rowOutOfBounds ? this.#rows.length : selectedRowIndex,\n        ];\n      }\n    }\n\n    void this.#render();\n  }\n\n  #shouldAutoScrollToBottom(): boolean {\n    if (!this.#autoScrollToBottom) {\n      return false;\n    }\n\n    /**\n     * If the user's last scroll took them to the bottom, then we assume they\n     * want to automatically scroll.\n     */\n    if (this.#userScrollState === UserScrollState.SCROLLED_TO_BOTTOM) {\n      return true;\n    }\n\n    /**\n     * If the user does not have focus in the data grid (e.g. they haven't\n     * selected a cell), we automatically scroll, as long as the user hasn't\n     * manually scrolled the data-grid to somewhere that isn't the bottom.\n     */\n    if (!this.#userHasFocusInDataGrid && this.#userScrollState !== UserScrollState.MANUAL_SCROLL_NOT_BOTTOM) {\n      return true;\n    }\n\n    /**\n     * Else, the user has focused a cell, or their last scroll action took them\n     * not to the bottom, so we assume that they don't want to be auto-scrolled.\n     */\n    return false;\n  }\n\n  #scrollToBottomIfRequired(): void {\n    if (this.#hasRenderedAtLeastOnce === false || !this.#shouldAutoScrollToBottom()) {\n      return;\n    }\n\n    const wrapper = this.#shadow.querySelector('.wrapping-container');\n    if (!wrapper) {\n      return;\n    }\n\n    void coordinator.scroll(() => {\n      const scrollHeight = wrapper.scrollHeight;\n      wrapper.scrollTo(0, scrollHeight);\n    });\n  }\n\n  #engageResizeObserver(): void {\n    if (!this.#hasRenderedAtLeastOnce) {\n      this.#resizeObserver.observe(this.#shadow.host);\n    }\n  }\n\n  #userHasCellFocused(): boolean {\n    return this.#cellUserHasFocused !== null;\n  }\n\n  #getTableElementForCellUserHasFocused(): HTMLTableCellElement|null {\n    if (!this.#cellUserHasFocused) {\n      return null;\n    }\n    const [columnIndex, rowIndex] = this.#cellUserHasFocused;\n    const cell = this.#shadow.querySelector<HTMLTableCellElement>(\n        `[data-row-index=\"${rowIndex}\"][data-col-index=\"${columnIndex}\"]`);\n    return cell;\n  }\n\n  #focusTableCellInDOM(cell: HTMLTableCellElement): void {\n    cell.focus();\n  }\n\n  #focusCellIfRequired([newColumnIndex, newRowIndex]: CellPosition): void {\n    this.#userHasFocusInDataGrid = true;\n\n    if (this.#cellUserHasFocused && this.#cellUserHasFocused[0] === newColumnIndex &&\n        this.#cellUserHasFocused[1] === newRowIndex) {\n      // The cell is already active and focused so we don't need to do anything.\n      return;\n    }\n\n    this.#cellUserHasFocused = [newColumnIndex, newRowIndex];\n    void this.#render();\n    const tableCell = this.#getTableElementForCellUserHasFocused();\n    if (!tableCell) {\n      // Return in case the cell is out of bounds and we do nothing\n      return;\n    }\n    /* The cell may already be focused if the user clicked into it, but we also\n     * add arrow key support, so in the case where we're programatically moving the\n     * focus, ensure we actually focus the cell.\n     */\n    this.#focusTableCellInDOM(tableCell);\n    // If it's a sortable column header, screen reader announce the information for sorting\n    if (newRowIndex === 0 && this.#columns[newColumnIndex].sortable) {\n      const localizedSortState = this.#getLocalizedSortState(this.#columns[newColumnIndex]);\n      UI.ARIAUtils.alert(i18nString(UIStrings.enterToSort, {PH1: localizedSortState || ''}));\n    }\n  }\n\n  #getLocalizedSortState(col: Column): string|undefined {\n    const currentSortLabel = this.#ariaSortForHeader(col);\n    switch (currentSortLabel) {\n      case 'ascending':\n        return UIStrings.sortAsc;\n      case 'descending':\n        return UIStrings.sortDesc;\n      case 'none':\n        return UIStrings.sortNone;\n    }\n    return undefined;\n  }\n\n  #onTableKeyDown(event: KeyboardEvent): void {\n    const key = event.key;\n\n    if (!this.#cellUserHasFocused) {\n      return;\n    }\n\n    if (KEYS_TREATED_AS_CLICKS.has(key)) {\n      const [focusedColumnIndex, focusedRowIndex] = this.#cellUserHasFocused;\n      const activeColumn = this.#columns[focusedColumnIndex];\n      if (focusedRowIndex === 0 && activeColumn && activeColumn.sortable) {\n        this.#onColumnHeaderClick(activeColumn, focusedColumnIndex);\n      }\n    }\n\n    if (!Platform.KeyboardUtilities.keyIsArrowKey(key)) {\n      return;\n    }\n\n    const nextFocusedCell = handleArrowKeyNavigation({\n      key,\n      currentFocusedCell: this.#cellUserHasFocused,\n      columns: this.#columns,\n      rows: this.#rows,\n    });\n    event.preventDefault();\n    this.#focusCellIfRequired(nextFocusedCell);\n  }\n\n  #onColumnHeaderClick(col: Column, index: number): void {\n    this.dispatchEvent(new ColumnHeaderClickEvent(col, index));\n  }\n\n  /**\n   * Applies the aria-sort label to a column's th.\n   * Guidance on values of attribute taken from\n   * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html.\n   */\n  #ariaSortForHeader(col: Column): 'none'|'ascending'|'descending'|undefined {\n    if (col.sortable && (!this.#sortState || this.#sortState.columnId !== col.id)) {\n      // Column is sortable but is not currently sorted\n      return 'none';\n    }\n\n    if (this.#sortState && this.#sortState.columnId === col.id) {\n      return this.#sortState.direction === SortDirection.ASC ? 'ascending' : 'descending';\n    }\n\n    // Column is not sortable, so don't apply any label\n    return undefined;\n  }\n\n  #renderEmptyFillerRow(numberOfVisibleRows: number): LitHtml.TemplateResult {\n    const emptyCells = this.#columns.map((col, colIndex) => {\n      if (!col.visible) {\n        return LitHtml.nothing;\n      }\n      const emptyCellClasses = LitHtml.Directives.classMap({\n        firstVisibleColumn: colIndex === 0,\n      });\n      return html`<td aria-hidden=\"true\" class=${emptyCellClasses} data-filler-row-column-index=${colIndex}></td>`;\n    });\n    const emptyRowClasses = LitHtml.Directives.classMap({\n      'filler-row': true,\n      'padding-row': true,\n      'empty-table': numberOfVisibleRows === 0,\n    });\n    return html`<tr aria-hidden=\"true\" class=${emptyRowClasses}>${emptyCells}</tr>`;\n  }\n\n  #cleanUpAfterResizeColumnComplete(): void {\n    if (!this.#currentResize) {\n      return;\n    }\n    this.#currentResize.documentForCursorChange.body.style.cursor = this.#currentResize.cursorToRestore;\n    this.#currentResize = null;\n    // Realign the scroll handlers now the table columns have been resized.\n    void this.#alignScrollHandlers();\n  }\n\n  #onResizePointerDown(event: PointerEvent): void {\n    if (event.buttons !== 1 || (Host.Platform.isMac() && event.ctrlKey)) {\n      // Ensure we only react to a left click drag mouse down event.\n      // On Mac we ignore Ctrl-click which can be used to bring up context menus, etc.\n      return;\n    }\n    event.preventDefault();\n    const resizerElement = event.target as HTMLElement;\n    if (!resizerElement) {\n      return;\n    }\n    const leftColumnIndex = resizerElement.dataset.columnIndex;\n    if (!leftColumnIndex) {\n      return;\n    }\n    const leftColumnIndexAsNumber = globalThis.parseInt(leftColumnIndex, 10);\n    /* To find the cell to the right we can't just go +1 as it might be hidden,\n     * so find the next index that is visible.\n     */\n    const rightColumnIndexAsNumber = this.#columns.findIndex((column, index) => {\n      return index > leftColumnIndexAsNumber && column.visible === true;\n    });\n\n    const leftCell = this.#shadow.querySelector(`td[data-filler-row-column-index=\"${leftColumnIndexAsNumber}\"]`);\n    const rightCell = this.#shadow.querySelector(`td[data-filler-row-column-index=\"${rightColumnIndexAsNumber}\"]`);\n    if (!leftCell || !rightCell) {\n      return;\n    }\n    // We query for the <col> elements as they are the elements that we put the actual width on.\n    const leftCellCol =\n        this.#shadow.querySelector<HTMLTableColElement>(`col[data-col-column-index=\"${leftColumnIndexAsNumber}\"]`);\n    const rightCellCol =\n        this.#shadow.querySelector<HTMLTableColElement>(`col[data-col-column-index=\"${rightColumnIndexAsNumber}\"]`);\n    if (!leftCellCol || !rightCellCol) {\n      return;\n    }\n\n    const targetDocumentForCursorChange = (event.target as Node).ownerDocument;\n    if (!targetDocumentForCursorChange) {\n      return;\n    }\n    // We now store values that we'll make use of in the mousemouse event to calculate how much to resize the table by.\n    this.#currentResize = {\n      leftCellCol,\n      rightCellCol,\n      leftCellColInitialPercentageWidth: globalThis.parseInt(leftCellCol.style.width, 10),\n      rightCellColInitialPercentageWidth: globalThis.parseInt(rightCellCol.style.width, 10),\n      initialLeftCellWidth: leftCell.clientWidth,\n      initialRightCellWidth: rightCell.clientWidth,\n      initialMouseX: event.x,\n      documentForCursorChange: targetDocumentForCursorChange,\n      cursorToRestore: resizerElement.style.cursor,\n    };\n\n    targetDocumentForCursorChange.body.style.cursor = 'col-resize';\n    resizerElement.setPointerCapture(event.pointerId);\n    resizerElement.addEventListener('pointermove', this.#boundOnResizePointerMove);\n  }\n\n  #onResizePointerMove(event: PointerEvent): void {\n    event.preventDefault();\n    if (!this.#currentResize) {\n      return;\n    }\n\n    const MIN_CELL_WIDTH_PERCENTAGE = 10;\n    const MAX_CELL_WIDTH_PERCENTAGE = (this.#currentResize.leftCellColInitialPercentageWidth +\n                                       this.#currentResize.rightCellColInitialPercentageWidth) -\n        MIN_CELL_WIDTH_PERCENTAGE;\n    const deltaOfMouseMove = event.x - this.#currentResize.initialMouseX;\n    const absoluteDelta = Math.abs(deltaOfMouseMove);\n    const percentageDelta =\n        (absoluteDelta / (this.#currentResize.initialLeftCellWidth + this.#currentResize.initialRightCellWidth)) * 100;\n\n    let newLeftColumnPercentage;\n    let newRightColumnPercentage;\n    if (deltaOfMouseMove > 0) {\n      /**\n       * A positive delta means the user moved their mouse to the right, so we\n       * want to make the right column smaller, and the left column larger.\n       */\n      newLeftColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.leftCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n      newRightColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.rightCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n    } else if (deltaOfMouseMove < 0) {\n      /**\n       * Negative delta means the user moved their mouse to the left, which\n       * means we want to make the right column larger, and the left column\n       * smaller.\n       */\n      newLeftColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.leftCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n      newRightColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.rightCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n    }\n\n    if (!newLeftColumnPercentage || !newRightColumnPercentage) {\n      // The delta was 0, so nothing to do.\n      return;\n    }\n\n    // We limit the values to two decimal places to not work with huge decimals.\n    // It also prevents stuttering if the user barely moves the mouse, as the\n    // browser won't try to move the column by 0.0000001% or similar.\n    this.#currentResize.leftCellCol.style.width = newLeftColumnPercentage.toFixed(2) + '%';\n    this.#currentResize.rightCellCol.style.width = newRightColumnPercentage.toFixed(2) + '%';\n  }\n\n  #onResizePointerUp(event: PointerEvent): void {\n    event.preventDefault();\n    const resizer = event.target as HTMLElement;\n    if (!resizer) {\n      return;\n    }\n    resizer.releasePointerCapture(event.pointerId);\n    resizer.removeEventListener('pointermove', this.#boundOnResizePointerMove);\n    this.#cleanUpAfterResizeColumnComplete();\n  }\n\n  #renderResizeForCell(column: Column, position: CellPosition): LitHtml.LitTemplate {\n    /**\n     * A resizer for a column is placed at the far right of the _previous column\n     * cell_. So when we get called with [1, 0] that means this dragger is\n     * resizing column 1, but the dragger itself is located within column 0. We\n     * need the column to the left because when you resize a column you're not\n     * only resizing it but also the column to its left.\n     */\n    const [columnIndex] = position;\n    const lastVisibleColumnIndex = this.#getIndexOfLastVisibleColumn();\n    // If we are in the very last column, there is no column to the right to resize, so don't render a resizer.\n    if (columnIndex === lastVisibleColumnIndex || !column.visible) {\n      return LitHtml.nothing;\n    }\n\n    return html`<span class=\"cell-resize-handle\"\n     @pointerdown=${this.#onResizePointerDown}\n     @pointerup=${this.#onResizePointerUp}\n     data-column-index=${columnIndex}\n    ></span>`;\n  }\n\n  #getIndexOfLastVisibleColumn(): number {\n    let index = this.#columns.length - 1;\n    for (; index > -1; index--) {\n      const col = this.#columns[index];\n      if (col.visible) {\n        break;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * This function is called when the user right clicks on the header row of the\n   * data grid.\n   */\n  #onHeaderContextMenu(event: MouseEvent): void {\n    if (event.button !== 2 && event.button !== -1) {\n      // -1 = right click invoked by keyboard, for example 'Shift + F10'.\n      // 2 = secondary button = right click. We only show context menus if the\n      // user has right clicked.\n      return;\n    }\n\n    const menu = new UI.ContextMenu.ContextMenu(event);\n    addColumnVisibilityCheckboxes(this, menu);\n    const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy), false, 'sort-by');\n    addSortableColumnItems(this, sortMenu);\n\n    menu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n      this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n    }, {jslogContext: 'reset-columns'});\n\n    if (this.#contextMenus && this.#contextMenus.headerRow) {\n      // Let the user append things to the menu\n      this.#contextMenus.headerRow(menu, this.#columns);\n    }\n    void menu.show();\n  }\n\n  #onBodyRowContextMenu(event: MouseEvent): void {\n    if (event.button !== 2 && event.button !== -1) {\n      // -1 = right click invoked by keyboard, for example 'Shift + F10'.\n      // 2 = secondary button = right click. We only show context menus if the\n      // user has right clicked.\n      return;\n    }\n    /**\n     * We now make sure that the event came from an HTML element with a\n     * data-row-index attribute, else we bail.\n     */\n    if (!event.target || !(event.target instanceof HTMLElement)) {\n      return;\n    }\n    const rowIndexAttribute = event.target.dataset.rowIndex;\n    if (!rowIndexAttribute) {\n      return;\n    }\n\n    const rowIndex = parseInt(rowIndexAttribute, 10);\n    // rowIndex - 1 here because in the UI the 0th row is the column headers.\n    const rowThatWasClicked = this.#rows[rowIndex - 1];\n\n    const menu = new UI.ContextMenu.ContextMenu(event);\n    const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy), false, 'sort-by');\n    addSortableColumnItems(this, sortMenu);\n\n    const headerOptionsMenu =\n        menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.headerOptions), false, 'header-options');\n    addColumnVisibilityCheckboxes(this, headerOptionsMenu);\n    headerOptionsMenu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n      this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n    }, {jslogContext: 'reset-columns'});\n\n    if (this.#contextMenus && this.#contextMenus.bodyRow) {\n      this.#contextMenus.bodyRow(menu, this.#columns, rowThatWasClicked, this.#rows);\n    }\n    void menu.show();\n  }\n\n  #onScroll(event: Event): void {\n    const wrapper = event.target as HTMLElement;\n    if (!wrapper) {\n      return;\n    }\n\n    // Need to Math.round because on high res screens we can end up with decimal\n    // point numbers for scroll positions.\n    const userIsAtBottom = Math.round(wrapper.scrollTop + wrapper.clientHeight) === Math.round(wrapper.scrollHeight);\n    this.#userScrollState =\n        userIsAtBottom ? UserScrollState.SCROLLED_TO_BOTTOM : UserScrollState.MANUAL_SCROLL_NOT_BOTTOM;\n\n    void this.#render();\n  }\n\n  #alignScrollHandlers(): Promise<void> {\n    return coordinator.read(() => {\n      const columnHeaders = this.#shadow.querySelectorAll<HTMLElement>('th:not(.hidden)');\n      const handlers = this.#shadow.querySelectorAll<HTMLElement>('.cell-resize-handle');\n      const table = this.#shadow.querySelector<HTMLTableElement>('table');\n      if (!table) {\n        return;\n      }\n\n      columnHeaders.forEach(async (header, index) => {\n        const columnWidth = header.clientWidth;\n        const columnLeftOffset = header.offsetLeft;\n        if (handlers[index]) {\n          const handlerWidth = handlers[index].clientWidth;\n          void coordinator.write(() => {\n            /**\n             * Render the resizer at the far right of the column; we subtract\n             * its width so it sits on the inner edge of the column.\n             */\n            handlers[index].style.left = `${columnLeftOffset + columnWidth - handlerWidth}px`;\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Calculates the index of the first row we want to render, and the last row we want to render.\n   * Pads in each direction by PADDING_ROWS_COUNT so we render some rows that are off scren.\n   */\n  #calculateTopAndBottomRowIndexes(): Promise<{topVisibleRow: number, bottomVisibleRow: number}> {\n    return coordinator.read(() => {\n      const wrapper = this.#shadow.querySelector('.wrapping-container');\n\n      // On first render we don't have a wrapper, so we can't get at its\n      // scroll/height values. So we default to the inner height of the window as\n      // the limit for rendering. This means we may over-render by a few rows, but\n      // better that than either render everything, or rendering too few rows.\n      let scrollTop = 0;\n      let clientHeight = window.innerHeight;\n      if (wrapper) {\n        scrollTop = wrapper.scrollTop;\n        clientHeight = wrapper.clientHeight;\n      }\n      const padding = ROW_HEIGHT_PIXELS * this.#paddingRowsCount;\n      let topVisibleRow = Math.floor((scrollTop - padding) / ROW_HEIGHT_PIXELS);\n      let bottomVisibleRow = Math.ceil((scrollTop + clientHeight + padding) / ROW_HEIGHT_PIXELS);\n\n      topVisibleRow = Math.max(0, topVisibleRow);\n      bottomVisibleRow = Math.min(this.#rows.filter(r => !r.hidden).length, bottomVisibleRow);\n\n      return {\n        topVisibleRow,\n        bottomVisibleRow,\n      };\n    });\n  }\n\n  #onFocusOut(): void {\n    /**\n     * When any element in the data-grid loses focus, we set this to false. If\n     * the user then focuses another cell, that code will set the focus to true.\n     * We need to know if the user is focused because if they are and they've\n     * scrolled their focused cell out of rendering view and back in, we want to\n     * refocus it. But if they aren't focused and that happens, we don't, else\n     * we can steal focus away from the user if they are typing into an input\n     * box to filter the data-grid, for example.\n     */\n    this.#userHasFocusInDataGrid = false;\n  }\n\n  #tabbableCell(): CellPosition {\n    /**\n     * If the user has selected a cell, this is the cell that should be\n     * \"tabbable\" if the user tabs out and into the data-grid. If the user\n     * hasn't selected a cell, we fallback to the default cell that we set as\n     * tabbable when we render.\n     */\n    return this.#cellUserHasFocused || this.#cellToFocusIfUserTabsIn;\n  }\n\n  /**\n   * Renders the data-grid table. Note that we do not render all rows; the\n   * performance cost are too high once you have a large enough table. Instead\n   * we calculate the size of the container we are rendering into, and then\n   * render only the rows required to fill that table (plus a bit extra for\n   * padding).\n   */\n  async #render(): Promise<void> {\n    if (!this.isConnected) {\n      return;\n    }\n    if (this.#isRendering) {\n      // If we receive a request to render during a previous render call, we block\n      // the newly requested render (since we could receive a lot of them in quick\n      // succession), but we do ensure that at the end of the current render we\n      // go again with the latest data.\n      this.#scheduleRender = true;\n      return;\n    }\n    this.#isRendering = true;\n\n    const {topVisibleRow, bottomVisibleRow} = await this.#calculateTopAndBottomRowIndexes();\n    const nonHiddenRows = this.#rows.filter(row => !row.hidden);\n    const renderableRows = nonHiddenRows.filter((_, idx) => idx >= topVisibleRow && idx <= bottomVisibleRow);\n    const indexOfFirstVisibleColumn = this.#columns.findIndex(col => col.visible);\n    const anyColumnsSortable = this.#columns.some(col => col.sortable === true);\n    const containerClassMap = {\n      'wrapping-container': true,\n      'show-scrollbar': this.#showScrollbar === true,\n      striped: this.#striped === true,\n    };\n\n    await coordinator.write(() => {\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      LitHtml.render(html`\n      ${this.#columns.map((col, columnIndex) => {\n        /**\n         * We render the resizers outside of the table. One is rendered for each\n         * column, and they are positioned absolutely at the right position. They\n         * have 100% height so they sit over the entire table and can be grabbed\n         * by the user.\n         */\n        return this.#renderResizeForCell(col, [columnIndex, 0]);\n      })}\n      <div class=${classMap(containerClassMap)} @scroll=${this.#onScroll} @focusout=${this.#onFocusOut}>\n        <table\n          aria-label=${ifDefined(this.#label)}\n          aria-rowcount=${this.#rows.length}\n          aria-colcount=${this.#columns.length}\n          @keydown=${this.#onTableKeyDown}\n        >\n          <!-- @ts-ignore -->\n          <colgroup>\n            ${this.#columns.map((col, colIndex) => {\n              const width = calculateColumnWidthPercentageFromWeighting(this.#columns, col.id);\n              const style = `width: ${width}%`;\n              if (!col.visible) {\n                return LitHtml.nothing;\n              }\n              return html`<col style=${style} data-col-column-index=${colIndex}>`;\n            })}\n          </colgroup>\n          <thead>\n            <tr @contextmenu=${this.#onHeaderContextMenu}>\n              ${this.#columns.map((col, columnIndex) => {\n                const thClasses = classMap({\n                  hidden: !col.visible,\n                  firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                  sortable: anyColumnsSortable,\n                });\n                const tabbableCell = this.#tabbableCell();\n                const cellIsFocusableCell = anyColumnsSortable && columnIndex === tabbableCell[0] && tabbableCell[1] === 0;\n\n                return html`<th class=${thClasses}\n                  jslog=${VisualLogging.tableHeader().track({click: anyColumnsSortable, resize: true}).context(col.id)}\n                  style=${ifDefined(col.styles ? styleMap(col.styles) : undefined)}\n                  data-grid-header-cell=${col.id}\n                  @focus=${() => {\n                    this.#focusCellIfRequired([columnIndex, 0]);\n                  }}\n                  @click=${() => {\n                    /**\n                     * We use click here rather than focus because if you've\n                     * clicked on the header to sort, you've also focused it. If\n                     * you then click it again to change the sorting, this\n                     * doesn't emit a focus event as the cell is already\n                     * focused.\n                     */\n                    this.#onColumnHeaderClick(col, columnIndex);\n                  }}\n                  title=${col.title}\n                  aria-sort=${ifDefined(this.#ariaSortForHeader(col))}\n                  aria-colindex=${columnIndex + 1}\n                  data-row-index='0'\n                  data-col-index=${columnIndex}\n                  tabindex=${ifDefined(anyColumnsSortable ? (cellIsFocusableCell ? '0' : '-1') : undefined)}\n                >${col.titleElement || col.title}</th>`;\n              })}\n            </tr>\n          </thead>\n          <tbody>\n            <tr class=\"filler-row-top padding-row\" style=${styleMap({\n              height: `${topVisibleRow * ROW_HEIGHT_PIXELS}px`,\n            })} aria-hidden=\"true\"></tr>\n            ${repeat(renderableRows, row => this.#rowIndexMap.get(row), row => {\n              const rowIndex = this.#rowIndexMap.get(row);\n              if (rowIndex === undefined) {\n                throw new Error('Trying to render a row that has no index in the rowIndexMap');\n              }\n              const tabbableCell = this.#tabbableCell();\n              // Remember that row 0 is considered the header row, so the first tbody row is row 1.\n              const tableRowIndex = rowIndex + 1;\n\n              // Check for cellUserHasFocused instead of tabbableCell so that we\n              // don't highlight the active cell before they've even clicked it.\n              const rowIsSelected = this.#cellUserHasFocused ? tableRowIndex === this.#cellUserHasFocused[1] : false;\n\n              const rowClasses = LitHtml.Directives.classMap({\n                selected: rowIsSelected,\n                hidden: row.hidden === true,\n              });\n              return html`\n                <tr\n                  aria-rowindex=${rowIndex + 1}\n                  class=${rowClasses}\n                  style=${ifDefined(row.styles ? styleMap(row.styles) : undefined)}\n                  jslog=${VisualLogging.tableRow().track({keydown: 'ArrowUp|ArrowDown|ArrowLeft|ArrowRight|Enter|Space'})}\n                  @contextmenu=${this.#onBodyRowContextMenu}\n                  @mouseenter=${() => {\n                    this.dispatchEvent(new RowMouseEnterEvent(row));\n                  }}\n                  @mouseleave=${() => {\n                    this.dispatchEvent(new RowMouseLeaveEvent(row));\n                  }}\n                >${this.#columns.map((col, columnIndex) => {\n                  const cell = getRowEntryForColumnId(row, col.id);\n                  const cellClasses = classMap({\n                    hidden: !col.visible,\n                    firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                  });\n                  const cellIsFocusableCell = columnIndex === tabbableCell[0] && tableRowIndex === tabbableCell[1];\n                  const cellOutput = col.visible ? renderCellValue(cell) : null;\n                  return html`<td\n                    class=${cellClasses}\n                    jslog=${VisualLogging.tableCell().track({click: true})}).context(col.id)}\n                    style=${ifDefined(col.styles ? styleMap(col.styles) : undefined)}\n                    tabindex=${cellIsFocusableCell ? '0' : '-1'}\n                    aria-colindex=${columnIndex + 1}\n                    title=${cell.title || getCellTitleFromCellContent(String(cell.value))}\n                    data-row-index=${tableRowIndex}\n                    data-col-index=${columnIndex}\n                    data-grid-value-cell-for-column=${col.id}\n                    @focus=${() => {\n                      this.#focusCellIfRequired([columnIndex, tableRowIndex]);\n                      this.dispatchEvent(new BodyCellFocusedEvent(cell, row));\n                    }}\n                  >${cellOutput}</td>`;\n                })}\n              </tr>`;\n            })}\n            ${this.#renderEmptyFillerRow(renderableRows.length)}\n            <tr class=\"filler-row-bottom padding-row\" style=${styleMap({\n              height: `${Math.max(0, nonHiddenRows.length - bottomVisibleRow) * ROW_HEIGHT_PIXELS}px`,\n            })} aria-hidden=\"true\"></tr>\n          </tbody>\n        </table>\n      </div>\n      `, this.#shadow, {\n        host: this,\n      });\n    });\n    // clang-format on\n\n    // This ensures if the user has a cell focused, but then scrolls so that\n    // the focused cell is now not rendered, that when it then gets scrolled\n    // back in, that it becomes rendered.\n    // However, if the cell is a column header, we don't do this, as that\n    // can never be not-rendered.\n    const tabbableCell = this.#tabbableCell();\n    const currentlyFocusedRowIndex = tabbableCell[1];\n    const tabbableCellElement = this.#getTableElementForCellUserHasFocused();\n    if (this.#userHasFocusInDataGrid && currentlyFocusedRowIndex > 0 && tabbableCellElement) {\n      this.#focusTableCellInDOM(tabbableCellElement);\n    }\n    this.#scrollToBottomIfRequired();\n    this.#engageResizeObserver();\n    if (this.#hasRenderedAtLeastOnce) {\n      // We may have had a cell's width change on a re-render, or it may have\n      // been hidden entirely, so we need to ensure that the resize handlers are\n      // re-positioned correctly if so.\n\n      // We don't have to do this on first render as it will fire when the resize observer is engaged.\n      void this.#alignScrollHandlers();\n    }\n\n    this.#isRendering = false;\n    this.#hasRenderedAtLeastOnce = true;\n\n    // If we've received more data mid-render we will do one extra render at\n    // the end with the most recent data.\n    if (this.#scheduleRender) {\n      this.#scheduleRender = false;\n      void this.#render();\n    }\n  }\n}\n\ncustomElements.define('devtools-data-grid', DataGrid);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-data-grid': DataGrid;\n  }\n}\n"],
  "mappings": "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",
  "names": ["UserScrollState", "tabbableCell"]
}
