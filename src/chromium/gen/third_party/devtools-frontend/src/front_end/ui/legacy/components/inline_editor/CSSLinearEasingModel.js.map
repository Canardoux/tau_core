{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/legacy/components/inline_editor/CSSLinearEasingModel.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as CodeMirror from '../../../../third_party/codemirror.next/codemirror.next.js';\n\nconst cssParser = CodeMirror.css.cssLanguage.parser;\n\nexport type Point = {\n  input: number,\n  output: number,\n};\n\ntype LinearStop = {\n  number: number,\n  lengthA?: number,\n  lengthB?: number,\n};\n\nconst numberFormatter = new Intl.NumberFormat('en', {\n  maximumFractionDigits: 2,\n});\n\nfunction findNextDefinedInputIndex(points: Point[], currentIndex: number): number {\n  for (let i = currentIndex; i < points.length; i++) {\n    if (!isNaN(points[i].input)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction consumeLinearStop(cursor: CodeMirror.TreeCursor, referenceText: string): LinearStop|null {\n  const tokens = [];\n  while (cursor.type.name !== ',' && cursor.type.name !== ')') {\n    const token = referenceText.substring(cursor.from, cursor.to);\n    if (cursor.type.name !== 'NumberLiteral') {\n      // There is something that is not a number inside the argument.\n      return null;\n    }\n\n    tokens.push(token);\n    cursor.next(false);\n  }\n\n  // Invalid syntax `linear(0 50% 60% 40%, 1)`.\n  if (tokens.length > 3) {\n    return null;\n  }\n\n  const percentages = tokens.filter(token => token.includes('%'));\n  // There can't be more than 2 percentages.\n  if (percentages.length > 2) {\n    return null;\n  }\n\n  const numbers = tokens.filter(token => !token.includes('%'));\n  // There must only be 1 number.\n  if (numbers.length !== 1) {\n    return null;\n  }\n\n  return {\n    number: Number(numbers[0]),\n    lengthA: percentages[0] ? Number(percentages[0].substring(0, percentages[0].length - 1)) : undefined,\n    lengthB: percentages[1] ? Number(percentages[1].substring(0, percentages[1].length - 1)) : undefined,\n  };\n}\n\nfunction consumeLinearFunction(text: string): LinearStop[]|null {\n  const textToParse = `*{--a: ${text}}`;\n  const parsed = cssParser.parse(textToParse);\n  // Take the cursor from declaration\n  const cursor = parsed.cursorAt(textToParse.indexOf(':') + 1);\n\n  // Move until the `ArgList`\n  while (cursor.name !== 'ArgList' && cursor.next(true)) {\n    // If the callee is not the `linear` function, return null\n    if (cursor.name === 'Callee' && textToParse.substring(cursor.from, cursor.to) !== 'linear') {\n      return null;\n    }\n  }\n\n  if (cursor.name !== 'ArgList') {\n    return null;\n  }\n\n  // We're on the `ArgList`, enter into it\n  cursor.firstChild();\n  const stops = [];\n  while (cursor.type.name !== ')' && cursor.next(false)) {\n    const linearStop = consumeLinearStop(cursor, textToParse);\n    if (!linearStop) {\n      // Parsing a `linearStop` was invalid; abort.\n      return null;\n    }\n\n    stops.push(linearStop);\n  }\n  return stops;\n}\n\nconst KeywordToValue: Record<string, string> = {\n  linear: 'linear(0 0%, 1 100%)',\n};\n\nexport class CSSLinearEasingModel {\n  #points: Point[];\n\n  constructor(points: Point[]) {\n    this.#points = points;\n  }\n\n  // https://w3c.github.io/csswg-drafts/css-easing/#linear-easing-function-parsing\n  static parse(text: string): CSSLinearEasingModel|null {\n    // Parse `linear` keyword as `linear(0 0%, 1 100%)` function.\n    if (KeywordToValue[text]) {\n      return CSSLinearEasingModel.parse(KeywordToValue[text]);\n    }\n\n    const stops = consumeLinearFunction(text);\n    // 1. Let function be a new linear easing function.\n    // 2. Let largestInput be negative infinity.\n    // 3. If there are less than two items in stopList, then return failure.\n    if (!stops || stops.length < 2) {\n      return null;\n    }\n\n    // 4. For each stop in stopList:\n    let largestInput = -Infinity;\n    const points: Point[] = [];\n    for (let i = 0; i < stops.length; i++) {\n      const stop = stops[i];\n      // 4.1. Let point be a new linear easing point with its output set\n      // to stop\u2019s <number> as a number.\n      const point: Point = {input: NaN, output: stop.number};\n      // 4.2. Append point to function\u2019s points.\n      points.push(point);\n\n      // 4.3. If stop has a <linear-stop-length>, then:\n      if (stop.lengthA !== undefined) {\n        // 4.3.1. Set point\u2019s input to whichever is greater:\n        // stop\u2019s <linear-stop-length>'s first <percentage> as a number,\n        // or largestInput.\n        point.input = Math.max(stop.lengthA, largestInput);\n        // 4.3.2. Set largestInput to point\u2019s input.\n        largestInput = point.input;\n\n        // 4.3.3. If stop\u2019s <linear-stop-length> has a second <percentage>, then:\n        if (stop.lengthB !== undefined) {\n          // 4.3.3.1. Let extraPoint be a new linear easing point with its output\n          // set to stop\u2019s <number> as a number.\n          const extraPoint: Point = {input: NaN, output: point.output};\n          // 4.3.3.2. Append extraPoint to function\u2019s points.\n          points.push(extraPoint);\n          // 4.3.3.3. Set extraPoint\u2019s input to whichever is greater:\n          // stop\u2019s <linear-stop-length>'s second <percentage>\n          // as a number, or largestInput.\n          extraPoint.input = Math.max(stop.lengthB, largestInput);\n          // 4.3.3.4. Set largestInput to extraPoint\u2019s input.\n          largestInput = extraPoint.input;\n        }\n        // 4.4. Otherwise, if stop is the first item in stopList, then:\n      } else if (i === 0) {\n        // 4.4.1. Set point\u2019s input to 0.\n        point.input = 0;\n        // 4.4.2. Set largestInput to 0.\n        largestInput = 0;\n        // 4.5. Otherwise, if stop is the last item in stopList,\n        // then set point\u2019s input to whichever is greater: 1 or largestInput.\n      } else if (i === stops.length - 1) {\n        point.input = Math.max(100, largestInput);\n      }\n    }\n\n    // 5. For runs of items in function\u2019s points that have a null input, assign a\n    // number to the input by linearly interpolating between the closest previous\n    // and next points that have a non-null input.\n    let upperIndex = 0;\n    for (let i = 1; i < points.length; i++) {\n      if (isNaN(points[i].input)) {\n        if (i > upperIndex) {\n          // Since the last point's input is always defined\n          // we know that `upperIndex` cannot be `-1`.\n          upperIndex = findNextDefinedInputIndex(points, i);\n        }\n\n        points[i].input =\n            points[i - 1].input + (points[upperIndex].input - points[i - 1].input) / (upperIndex - (i - 1));\n      }\n    }\n\n    return new CSSLinearEasingModel(points);\n  }\n\n  addPoint(point: Point, index?: number): void {\n    if (index !== undefined) {\n      this.#points.splice(index, 0, point);\n      return;\n    }\n\n    this.#points.push(point);\n  }\n\n  removePoint(index: number): void {\n    this.#points.splice(index, 1);\n  }\n\n  setPoint(index: number, point: Point): void {\n    this.#points[index] = point;\n  }\n\n  points(): Point[] {\n    return this.#points;\n  }\n\n  asCSSText(): string {\n    const args =\n        this.#points.map(point => `${numberFormatter.format(point.output)} ${numberFormatter.format(point.input)}%`)\n            .join(', ');\n    const text = `linear(${args})`;\n\n    // If a keyword matches to this function, return the keyword value of it.\n    for (const [keyword, value] of Object.entries(KeywordToValue)) {\n      if (value === text) {\n        return keyword;\n      }\n    }\n\n    return text;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
