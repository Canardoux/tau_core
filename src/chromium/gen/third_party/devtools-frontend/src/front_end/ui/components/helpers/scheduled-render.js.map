{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/components/helpers/scheduled-render.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\nconst pendingRenders = new WeakSet<HTMLElement>();\nconst activeRenders = new WeakSet<HTMLElement>();\nconst subsequentRender = new WeakMap<HTMLElement, () => void>();\nconst wrappedCallbacks = new WeakMap<() => void, () => void>();\nexport async function scheduleRender(component: HTMLElement, callback: () => void): Promise<void> {\n  // If scheduleRender is called when there is already a render scheduled for this\n  // component, store the callback against the renderer for after the current\n  // call has finished.\n  if (activeRenders.has(component)) {\n    subsequentRender.set(component, callback);\n    return;\n  }\n\n  // If this render was already scheduled but hasn't started yet, just return.\n  if (pendingRenders.has(component)) {\n    return;\n  }\n\n  pendingRenders.add(component);\n\n  // Create a wrapper around the callback so that we know that it has moved from\n  // pending to active. When it has completed we remove it from the active renderers.\n  let wrappedCallback = wrappedCallbacks.get(callback);\n  if (!wrappedCallback) {\n    wrappedCallback = async () => {\n      pendingRenders.delete(component);\n      activeRenders.add(component);\n      try {\n        await callback.call(component);\n      } catch (error: unknown) {\n        console.error(`ScheduledRender: rendering ${component.nodeName.toLowerCase()}:`);\n        console.error(error);\n        throw error;\n      } finally {\n        activeRenders.delete(component);\n      }\n    };\n\n    // Store it for next time so we aren't creating wrappers unnecessarily.\n    wrappedCallbacks.set(callback, wrappedCallback);\n  }\n\n  // Track that there is render rendering, wait for it to finish, and stop tracking.\n  await coordinator.write(wrappedCallback);\n\n  // If during the render there was another schedule render call, get\n  // the callback and schedule it to happen now.\n  if (subsequentRender.has(component)) {\n    const newCallback = subsequentRender.get(component);\n    subsequentRender.delete(component);\n    if (!newCallback) {\n      return;\n    }\n\n    void scheduleRender(component, newCallback);\n  }\n}\n\nexport function isScheduledRender(component: HTMLElement): boolean {\n  return activeRenders.has(component);\n}\n"],
  "mappings": ";AAGA,YAAY,iBAAiB;AAE7B,MAAM,cAAc,YAAY,kBAAkB,kBAAkB,SAAS;AAC7E,MAAM,iBAAiB,oBAAI,QAAqB;AAChD,MAAM,gBAAgB,oBAAI,QAAqB;AAC/C,MAAM,mBAAmB,oBAAI,QAAiC;AAC9D,MAAM,mBAAmB,oBAAI,QAAgC;AAC7D,sBAAsB,eAAe,WAAwB,UAAqC;AAIhG,MAAI,cAAc,IAAI,SAAS,GAAG;AAChC,qBAAiB,IAAI,WAAW,QAAQ;AACxC;AAAA,EACF;AAGA,MAAI,eAAe,IAAI,SAAS,GAAG;AACjC;AAAA,EACF;AAEA,iBAAe,IAAI,SAAS;AAI5B,MAAI,kBAAkB,iBAAiB,IAAI,QAAQ;AACnD,MAAI,CAAC,iBAAiB;AACpB,sBAAkB,YAAY;AAC5B,qBAAe,OAAO,SAAS;AAC/B,oBAAc,IAAI,SAAS;AAC3B,UAAI;AACF,cAAM,SAAS,KAAK,SAAS;AAAA,MAC/B,SAAS,OAAgB;AACvB,gBAAQ,MAAM,8BAA8B,UAAU,SAAS,YAAY,CAAC,GAAG;AAC/E,gBAAQ,MAAM,KAAK;AACnB,cAAM;AAAA,MACR,UAAE;AACA,sBAAc,OAAO,SAAS;AAAA,MAChC;AAAA,IACF;AAGA,qBAAiB,IAAI,UAAU,eAAe;AAAA,EAChD;AAGA,QAAM,YAAY,MAAM,eAAe;AAIvC,MAAI,iBAAiB,IAAI,SAAS,GAAG;AACnC,UAAM,cAAc,iBAAiB,IAAI,SAAS;AAClD,qBAAiB,OAAO,SAAS;AACjC,QAAI,CAAC,aAAa;AAChB;AAAA,IACF;AAEA,SAAK,eAAe,WAAW,WAAW;AAAA,EAC5C;AACF;AAEO,gBAAS,kBAAkB,WAAiC;AACjE,SAAO,cAAc,IAAI,SAAS;AACpC;",
  "names": []
}
