{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/legacy/components/data_grid/DataGrid.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *        notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *        notice, this list of conditions and the following disclaimer in the\n *        documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.         IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable rulesdir/check_license_header */\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as VisualLogging from '../../../visual_logging/visual_logging.js';\nimport * as UI from '../../legacy.js';\n\nimport dataGridStyles from './dataGrid.css.js';\n\nconst UIStrings = {\n  /**\n   *@description Accessible text label for expandible nodes in datagrids\n   */\n  expanded: 'expanded',\n  /**\n   *@description accessible name for expandible nodes in datagrids\n   */\n  collapsed: 'collapsed',\n  /**\n   *@description Accessible text for datagrid\n   *@example {Coverage grid} PH1\n   *@example {expanded} PH2\n   */\n  sRowS: '{PH1} Row {PH2}',\n  /**\n   *@description Number of rows in a grid\n   *@example {1} PH1\n   */\n  rowsS: 'Rows: {PH1}',\n  /**\n   * @description Default Accessible Text for a Datagrid. This text is read to the user by a\n   * screenreader when they navigate to a table structure. The placeholders tell the user something\n   * brief about the table contents i.e. the topic and how much data is in it.\n   * @example {Network} PH1\n   * @example {Rows: 27} PH2\n   */\n  sSUseTheUpAndDownArrowKeysTo:\n      '{PH1} {PH2}, use the up and down arrow keys to navigate and interact with the rows of the table; Use browse mode to read cell by cell.',\n  /**\n   *@description A context menu item in the Data Grid of a data grid\n   */\n  sortByString: 'Sort By',\n  /**\n   *@description A context menu item in data grids to reset the columns to their default weight\n   */\n  resetColumns: 'Reset Columns',\n  /**\n   *@description A context menu item in data grids to list header options.\n   */\n  headerOptions: 'Header Options',\n  /**\n   *@description Text to refresh the page\n   */\n  refresh: 'Refresh',\n  /**\n   *@description A context menu item in the Data Grid of a data grid\n   */\n  addNew: 'Add new',\n  /**\n   *@description A context menu item in the Data Grid of a data grid\n   *@example {pattern} PH1\n   */\n  editS: 'Edit \"{PH1}\"',\n  /**\n   *@description Text to delete something\n   */\n  delete: 'Delete',\n  /**\n   *@description Depth of a node in the datagrid\n   *@example {1} PH1\n   */\n  levelS: 'level {PH1}',\n  /**\n   *@description Text exposed to screen readers on checked items.\n   */\n  checked: 'checked',\n  /**\n   *@description Accessible text indicating an empty row is created.\n   */\n  emptyRowCreated: 'An empty table row has been created. You may double click or use context menu to edit.',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/data_grid/DataGrid.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nconst elementToLongTextMap = new WeakMap<Element, string>();\n\nconst nodeToColumnIdMap = new WeakMap<Node, string>();\n\nconst elementToPreferedWidthMap = new WeakMap<Element, number>();\n\nconst elementToPositionMap = new WeakMap<Element, number>();\n\nconst elementToIndexMap = new WeakMap<Element, number>();\n\nexport class DataGridImpl<T> extends Common.ObjectWrapper.ObjectWrapper<EventTypes<T>> {\n  element: HTMLDivElement;\n  displayName: string;\n  private editCallback: ((arg0: any, arg1: string, arg2: any, arg3: any) => void)|undefined;\n  private readonly deleteCallback: ((arg0: any) => void)|undefined;\n  private readonly refreshCallback: (() => void)|undefined;\n  private dataTableHeaders: {\n    [x: string]: Element,\n  };\n  scrollContainerInternal: Element;\n  private dataContainerInternal: Element;\n  private readonly dataTable: Element;\n  protected inline: boolean;\n  private columnsArray: ColumnDescriptor[];\n  columns: {\n    [x: string]: ColumnDescriptor,\n  };\n  visibleColumnsArray: ColumnDescriptor[];\n  cellClass: string|null;\n  private dataTableHeadInternal: HTMLTableSectionElement;\n  private readonly headerRow: Element;\n  private readonly dataTableColumnGroup: Element;\n  dataTableBody: Element;\n  topFillerRow: HTMLElement;\n  private bottomFillerRow: HTMLElement;\n  private editing: boolean;\n  selectedNode: DataGridNode<T>|null;\n  expandNodesWhenArrowing: boolean;\n  indentWidth: number;\n  private resizers: HTMLElement[];\n  private columnWidthsInitialized: boolean;\n  private cornerWidth: number;\n  private resizeMethod: ResizeMethod;\n  private headerContextMenuCallback: ((arg0: UI.ContextMenu.SubMenu) => void)|null;\n  private rowContextMenuCallback: ((arg0: UI.ContextMenu.ContextMenu, arg1: DataGridNode<T>) => void)|null;\n  elementToDataGridNode: WeakMap<Node, DataGridNode<T>>;\n  disclosureColumnId?: string;\n  private sortColumnCell?: Element;\n  private rootNodeInternal?: DataGridNode<T>;\n  private editingNode?: DataGridNode<T>|null;\n  private columnWeightsSetting?: Common.Settings.Setting<any>;\n  creationNode?: CreationDataGridNode<any>;\n  private currentResizer?: EventTarget|null;\n  private dataGridWidget?: any;\n\n  constructor(dataGridParameters: Parameters) {\n    super();\n    const {displayName, columns: columnsArray, editCallback, deleteCallback, refreshCallback} = dataGridParameters;\n    this.element = document.createElement('div');\n    this.element.classList.add('data-grid');\n    this.element.tabIndex = 0;\n    this.element.addEventListener('keydown', this.keyDown.bind(this), false);\n    this.element.addEventListener('contextmenu', this.contextMenu.bind(this), true);\n    this.element.addEventListener('focusin', event => {\n      this.updateGridAccessibleNameOnFocus();\n      event.consume(true);\n    });\n    this.element.addEventListener('focusout', event => {\n      event.consume(true);\n    });\n\n    UI.ARIAUtils.markAsApplication(this.element);\n    this.displayName = displayName;\n\n    this.editCallback = editCallback;\n    this.deleteCallback = deleteCallback;\n    this.refreshCallback = refreshCallback;\n\n    this.dataTableHeaders = {};\n\n    this.dataContainerInternal = this.element.createChild('div', 'data-container');\n    this.dataTable = this.dataContainerInternal.createChild('table', 'data');\n    this.scrollContainerInternal = this.dataContainerInternal;\n\n    // FIXME: Add a createCallback which is different from editCallback and has different\n    // behavior when creating a new node.\n    if (editCallback) {\n      this.dataTable.addEventListener('dblclick', this.ondblclick.bind(this), false);\n    }\n    this.dataTable.addEventListener('mousedown', this.mouseDownInDataTable.bind(this));\n    this.dataTable.addEventListener('click', this.clickInDataTable.bind(this), true);\n\n    this.inline = false;\n\n    this.columnsArray = [];\n    this.columns = {};\n    this.visibleColumnsArray = columnsArray;\n\n    columnsArray.forEach(column => this.innerAddColumn(column));\n\n    this.cellClass = null;\n\n    this.dataTableColumnGroup = this.dataTable.createChild('colgroup');\n\n    this.dataTableHeadInternal = this.dataTable.createChild('thead') as HTMLTableSectionElement;\n    this.headerRow = this.dataTableHeadInternal.createChild('tr');\n\n    this.dataTableBody = this.dataTable.createChild('tbody');\n    this.topFillerRow = (this.dataTableBody.createChild('tr', 'data-grid-filler-row revealed') as HTMLElement);\n    UI.ARIAUtils.setHidden(this.topFillerRow, true);\n    this.bottomFillerRow = (this.dataTableBody.createChild('tr', 'data-grid-filler-row revealed') as HTMLElement);\n    UI.ARIAUtils.setHidden(this.bottomFillerRow, true);\n\n    this.setVerticalPadding(0, 0, true);\n    this.refreshHeader();\n\n    this.editing = false;\n    this.selectedNode = null;\n    this.expandNodesWhenArrowing = false;\n    this.setRootNode(new DataGridNode<T>());\n\n    this.setHasSelection(false);\n\n    this.indentWidth = 15;\n    this.resizers = [];\n    this.columnWidthsInitialized = false;\n    this.cornerWidth = CornerWidth;\n    this.resizeMethod = ResizeMethod.NEAREST;\n\n    this.headerContextMenuCallback = null;\n    this.rowContextMenuCallback = null;\n\n    this.elementToDataGridNode = new WeakMap();\n  }\n\n  private firstSelectableNode(): DataGridNode<T>|null|undefined {\n    let firstSelectableNode: (DataGridNode<T>|undefined) = this.rootNodeInternal;\n    while (firstSelectableNode && !firstSelectableNode.selectable) {\n      firstSelectableNode = firstSelectableNode.traverseNextNode(true) || undefined;\n    }\n    return firstSelectableNode;\n  }\n\n  private lastSelectableNode(): DataGridNode<T>|undefined {\n    let lastSelectableNode: DataGridNode<T>|(DataGridNode<T>| undefined) = this.rootNodeInternal;\n    let iterator: (DataGridNode<T>|undefined) = this.rootNodeInternal;\n    while (iterator) {\n      if (iterator.selectable) {\n        lastSelectableNode = iterator;\n      }\n      iterator = iterator.traverseNextNode(true) || undefined;\n    }\n    return lastSelectableNode;\n  }\n\n  setElementContent(element: Element, value: string): void {\n    const columnId = this.columnIdFromNode(element);\n    if (!columnId) {\n      return;\n    }\n    const column = this.columns[columnId];\n    const parentElement = element.parentElement;\n    let gridNode;\n    if (parentElement) {\n      gridNode = this.elementToDataGridNode.get(parentElement);\n    }\n    if (column.dataType === DataType.BOOLEAN) {\n      DataGridImpl.setElementBoolean(element, Boolean(value), gridNode);\n    } else if (value !== null) {\n      DataGridImpl.setElementText(element, value, Boolean(column.longText), gridNode);\n    }\n  }\n\n  static setElementText(element: Element, newText: string, longText: boolean, gridNode?: DataGridNode<string>): void {\n    if (longText && newText.length > 1000) {\n      element.textContent = Platform.StringUtilities.trimEndWithMaxLength(newText, 1000);\n      UI.Tooltip.Tooltip.install(element as HTMLElement, newText);\n      elementToLongTextMap.set(element, newText);\n    } else {\n      element.textContent = newText;\n      UI.Tooltip.Tooltip.install(element as HTMLElement, '');\n      elementToLongTextMap.delete(element);\n    }\n    if (gridNode) {\n      DataGridImpl.updateNodeAccessibleText(gridNode);\n    }\n  }\n\n  static setElementBoolean(element: Element, value: boolean, gridNode?: DataGridNode<string>): void {\n    element.textContent = value ? '\\u2713' : '';\n    UI.Tooltip.Tooltip.install(element as HTMLElement, '');\n    if (gridNode) {\n      DataGridImpl.updateNodeAccessibleText(gridNode);\n    }\n  }\n\n  static updateNodeAccessibleText(gridNode: DataGridNode<string>): void {\n    let accessibleText = '';\n    let colElement: Element|null = gridNode.elementInternal?.children[0] || null;\n    if (!colElement) {\n      return;\n    }\n\n    while (colElement && !colElement.classList.contains('corner')) {\n      let columnClass = null;\n      for (const cssClass of colElement.classList) {\n        if (cssClass.includes('-column')) {\n          columnClass = cssClass.substring(0, cssClass.indexOf('-column'));\n          break;\n        }\n      }\n      if (columnClass && gridNode.dataGrid) {\n        const colName = gridNode.dataGrid.columns[columnClass];\n        if (colName) {\n          accessibleText += `${colName.title}: ${colElement.textContent}, `;\n        }\n      }\n      colElement = colElement.nextElementSibling;\n    }\n\n    if (accessibleText.length > 0) {\n      // Trim off comma and space at the end.\n      accessibleText = accessibleText.substring(0, accessibleText.length - 2);\n    }\n    gridNode.nodeAccessibleText = accessibleText;\n  }\n\n  setStriped(isStriped: boolean): void {\n    this.element.classList.toggle('striped-data-grid', isStriped);\n  }\n\n  setFocusable(focusable: boolean): void {\n    this.element.tabIndex = focusable ? 0 : -1;\n    if (focusable === false) {\n      UI.ARIAUtils.removeRole(this.element);\n    }\n  }\n\n  setHasSelection(hasSelected: boolean): void {\n    // 'no-selection' class causes datagrid to have a focus-indicator border\n    this.element.classList.toggle('no-selection', !hasSelected);\n  }\n\n  announceSelectedGridNode(): void {\n    // Only alert if the datagrid has focus\n    if (this.element === Platform.DOMUtilities.deepActiveElement(this.element.ownerDocument) && this.selectedNode &&\n        this.selectedNode.existingElement()) {\n      // Update the expand/collapse state for the current selected node\n      let expandText;\n      if (this.selectedNode.hasChildren()) {\n        expandText = this.selectedNode.expanded ? i18nString(UIStrings.expanded) : i18nString(UIStrings.collapsed);\n      }\n      const accessibleText =\n          expandText ? `${this.selectedNode.nodeAccessibleText}, ${expandText}` : this.selectedNode.nodeAccessibleText;\n      UI.ARIAUtils.alert(accessibleText);\n    }\n  }\n\n  updateGridAccessibleNameOnFocus(): void {\n    // When a grid gets focus\n    // 1) If an item is selected - Read the content of the row\n    let accessibleText;\n    if (this.selectedNode && this.selectedNode.existingElement()) {\n      // TODO(l10n): Don't concatenate strings.\n      let expandText = '';\n      if (this.selectedNode.hasChildren()) {\n        expandText = this.selectedNode.expanded ? i18nString(UIStrings.expanded) : i18nString(UIStrings.collapsed);\n      }\n      const rowHeader = i18nString(UIStrings.sRowS, {PH1: this.displayName, PH2: expandText});\n      accessibleText = `${rowHeader} ${this.selectedNode.nodeAccessibleText}`;\n    } else {\n      // 2) If there is no selected item - Read the name of the grid and give instructions\n      if (!this.rootNodeInternal) {\n        return;\n      }\n      const children = this.enumerateChildren(this.rootNodeInternal, [], 1);\n      const items = i18nString(UIStrings.rowsS, {PH1: children.length});\n      accessibleText = i18nString(UIStrings.sSUseTheUpAndDownArrowKeysTo, {PH1: this.displayName, PH2: items});\n    }\n    UI.ARIAUtils.alert(accessibleText);\n  }\n\n  private innerAddColumn(column: ColumnDescriptor, position?: number): void {\n    column.defaultWeight = column.weight;\n\n    const columnId = column.id;\n    if (columnId in this.columns) {\n      this.innerRemoveColumn(columnId);\n    }\n\n    if (position === undefined) {\n      position = this.columnsArray.length;\n    }\n\n    this.columnsArray.splice(position, 0, column);\n    this.columns[columnId] = column;\n    if (column.disclosure) {\n      this.disclosureColumnId = columnId;\n    }\n\n    const cell = document.createElement('th');\n    cell.setAttribute(\n        'jslog',\n        `${\n            VisualLogging.tableHeader()\n                .track({click: column.sortable, resize: true})\n                .context(Platform.StringUtilities.toKebabCase(columnId))}`);\n    cell.className = columnId + '-column';\n    nodeToColumnIdMap.set(cell, columnId);\n    this.dataTableHeaders[columnId] = cell;\n\n    const div = document.createElement('div');\n    if (column.titleDOMFragment) {\n      div.appendChild(column.titleDOMFragment);\n    } else {\n      div.textContent = column.title || null;\n    }\n    cell.appendChild(div);\n\n    if (column.sort) {\n      cell.classList.add(column.sort);\n      this.sortColumnCell = cell;\n    }\n\n    if (column.sortable) {\n      cell.addEventListener('click', this.clickInHeaderCell.bind(this), false);\n      cell.classList.add('sortable');\n      const icon = document.createElement('span');\n      icon.className = 'sort-order-icon';\n      cell.createChild('div', 'sort-order-icon-container').appendChild(icon);\n    }\n  }\n\n  addColumn(column: ColumnDescriptor, position?: number): void {\n    this.innerAddColumn(column, position);\n  }\n\n  private innerRemoveColumn(columnId: string): void {\n    const column = this.columns[columnId];\n    if (!column) {\n      return;\n    }\n    delete this.columns[columnId];\n    const index = this.columnsArray.findIndex(columnConfig => columnConfig.id === columnId);\n    this.columnsArray.splice(index, 1);\n    const cell = this.dataTableHeaders[columnId];\n    if (cell.parentElement) {\n      cell.parentElement.removeChild(cell);\n    }\n    delete this.dataTableHeaders[columnId];\n  }\n\n  removeColumn(columnId: string): void {\n    this.innerRemoveColumn(columnId);\n  }\n\n  setCellClass(cellClass: string): void {\n    this.cellClass = cellClass;\n  }\n\n  private refreshHeader(): void {\n    this.dataTableColumnGroup.removeChildren();\n    this.headerRow.removeChildren();\n    this.topFillerRow.removeChildren();\n    this.bottomFillerRow.removeChildren();\n\n    for (let i = 0; i < this.visibleColumnsArray.length; ++i) {\n      const column = this.visibleColumnsArray[i];\n      const columnId = column.id;\n      const dataColumn = (this.dataTableColumnGroup.createChild('col') as HTMLElement);\n      if (column.width) {\n        dataColumn.style.width = column.width;\n      }\n      this.headerRow.appendChild(this.dataTableHeaders[columnId]);\n      const topFillerRowCell = (this.topFillerRow.createChild('th', 'top-filler-td') as HTMLTableCellElement);\n      topFillerRowCell.textContent = column.title || null;\n      topFillerRowCell.scope = 'col';\n      const bottomFillerRowChild = this.bottomFillerRow.createChild('td', 'bottom-filler-td');\n      nodeToColumnIdMap.set(bottomFillerRowChild, columnId);\n    }\n\n    const headerCorner = this.headerRow.createChild('th', 'corner');\n    UI.ARIAUtils.setHidden(headerCorner, true);\n\n    const topFillerRowCornerCell = (this.topFillerRow.createChild('th', 'corner') as HTMLTableCellElement);\n    topFillerRowCornerCell.classList.add('top-filler-td');\n    topFillerRowCornerCell.scope = 'col';\n\n    this.bottomFillerRow.createChild('td', 'corner').classList.add('bottom-filler-td');\n\n    this.dataTableColumnGroup.createChild('col', 'corner');\n  }\n\n  protected setVerticalPadding(top: number, bottom: number, isConstructorTime: boolean = false): void {\n    const topPx = top + 'px';\n    const bottomPx = (top || bottom) ? bottom + 'px' : 'auto';\n    if (this.topFillerRow.style.height === topPx && this.bottomFillerRow.style.height === bottomPx) {\n      return;\n    }\n    this.topFillerRow.style.height = topPx;\n    this.bottomFillerRow.style.height = bottomPx;\n    if (!isConstructorTime) {\n      this.dispatchEventToListeners(Events.PADDING_CHANGED);\n    }\n  }\n\n  protected setRootNode(rootNode: DataGridNode<T>): void {\n    if (this.rootNodeInternal) {\n      this.rootNodeInternal.removeChildren();\n      this.rootNodeInternal.dataGrid = null;\n      this.rootNodeInternal.isRoot = false;\n    }\n    this.rootNodeInternal = rootNode;\n    rootNode.isRoot = true;\n    rootNode.setHasChildren(false);\n    rootNode.expandedInternal = true;\n    rootNode.revealedInternal = true;\n    rootNode.selectable = false;\n    rootNode.dataGrid = this;\n  }\n\n  rootNode(): DataGridNode<T> {\n    let rootNode: DataGridNode<T>|(DataGridNode<T>| undefined) = this.rootNodeInternal;\n    if (!rootNode) {\n      rootNode = new DataGridNode();\n      this.setRootNode(rootNode);\n    }\n    return rootNode;\n  }\n\n  private ondblclick(event: Event): void {\n    if (this.editing || this.editingNode) {\n      return;\n    }\n\n    const columnId = this.columnIdFromNode((event.target as Node));\n    if (!columnId || !this.columns[columnId].editable) {\n      return;\n    }\n    this.startEditing((event.target as Node));\n  }\n\n  private startEditingColumnOfDataGridNode(node: DataGridNode<T>, cellIndex: number): void {\n    this.editing = true;\n    this.editingNode = node;\n    this.editingNode.select();\n\n    const editingNodeElement = this.editingNode.element();\n    if (!editingNodeElement) {\n      return;\n    }\n    const element = editingNodeElement.children[cellIndex];\n    const elementLongText = elementToLongTextMap.get(element);\n    if (elementLongText) {\n      element.textContent = elementLongText;\n    }\n    const column = this.visibleColumnsArray[cellIndex];\n    if (column.dataType === DataType.BOOLEAN) {\n      const checkboxLabel = UI.UIUtils.CheckboxLabel.create(undefined, (node.data[column.id] as boolean));\n      UI.ARIAUtils.setLabel(checkboxLabel, column.title || '');\n\n      let hasChanged = false;\n      checkboxLabel.style.height = '100%';\n      const checkboxElement = checkboxLabel.checkboxElement;\n      checkboxElement.classList.add('inside-datagrid');\n      const initialValue = checkboxElement.checked;\n\n      checkboxElement.addEventListener('change', () => {\n        hasChanged = true;\n        this.editingCommitted(element, checkboxElement.checked, initialValue, undefined, 'forward');\n      }, false);\n\n      checkboxElement.addEventListener('keydown', event => {\n        if (event.key === 'Tab') {\n          event.consume(true);\n          hasChanged = true;\n          return this.editingCommitted(\n              element, checkboxElement.checked, initialValue, undefined, event.shiftKey ? 'backward' : 'forward');\n        }\n        if (event.key === ' ') {\n          event.consume(true);\n          checkboxElement.checked = !checkboxElement.checked;\n        } else if (event.key === 'Enter') {\n          event.consume(true);\n          hasChanged = true;\n          this.editingCommitted(element, checkboxElement.checked, initialValue, undefined, 'forward');\n        }\n      }, false);\n\n      checkboxElement.addEventListener('blur', () => {\n        if (hasChanged) {\n          return;\n        }\n        this.editingCommitted(element, checkboxElement.checked, checkboxElement.checked, undefined, 'next');\n      }, false);\n\n      element.innerHTML = '';\n      element.appendChild(checkboxLabel);\n      checkboxElement.focus();\n    } else {\n      UI.InplaceEditor.InplaceEditor.startEditing(element, this.startEditingConfig(element));\n      const componentSelection = element.getComponentSelection();\n      if (componentSelection) {\n        componentSelection.selectAllChildren(element);\n      }\n    }\n  }\n\n  startEditingNextEditableColumnOfDataGridNode(node: DataGridNode<T>, columnIdentifier: string, inclusive?: boolean):\n      void {\n    const column = this.columns[columnIdentifier];\n    const cellIndex = this.visibleColumnsArray.indexOf(column);\n    const nextEditableColumn = this.nextEditableColumn(cellIndex, false, inclusive);\n    if (nextEditableColumn !== -1) {\n      this.startEditingColumnOfDataGridNode(node, nextEditableColumn);\n    }\n  }\n\n  private startEditing(target: Node): void {\n    const element = (UI.UIUtils.enclosingNodeOrSelfWithNodeName(target, 'td') as Element | null);\n    if (!element) {\n      return;\n    }\n\n    this.editingNode = this.dataGridNodeFromNode(target);\n    if (!this.editingNode) {\n      if (!this.creationNode) {\n        return;\n      }\n      this.editingNode = this.creationNode;\n    }\n\n    // Force editing the 1st column when editing the creation node\n    if (this.editingNode instanceof CreationDataGridNode && this.editingNode.isCreationNode) {\n      this.startEditingColumnOfDataGridNode(this.editingNode, this.nextEditableColumn(-1));\n      return;\n    }\n\n    const columnId = this.columnIdFromNode(target);\n    if (!columnId) {\n      return;\n    }\n    const column = this.columns[columnId];\n    const cellIndex = this.visibleColumnsArray.indexOf(column);\n    if (this.editingNode) {\n      this.startEditingColumnOfDataGridNode(this.editingNode, cellIndex);\n    }\n  }\n\n  renderInline(): void {\n    this.element.classList.add('inline');\n    this.cornerWidth = 0;\n    this.inline = true;\n    this.updateWidths();\n  }\n\n  private startEditingConfig(_element: Element): UI.InplaceEditor.Config<any> {\n    return new UI.InplaceEditor.Config(this.editingCommitted.bind(this), this.editingCancelled.bind(this), undefined);\n  }\n\n  private editingCommitted(\n      element: Element,\n      newText: any,\n      _oldText: string|boolean|null,\n      _context: string|undefined,\n      moveDirection: string,\n      ): void {\n    const columnId = this.columnIdFromNode(element);\n    if (!columnId) {\n      this.editingCancelled(element);\n      return;\n    }\n    const column = this.columns[columnId];\n    const cellIndex = this.visibleColumnsArray.indexOf(column);\n    if (!this.editingNode) {\n      return;\n    }\n    const valueBeforeEditing = this.editingNode.data[columnId];\n    const currentEditingNode = this.editingNode;\n\n    function moveToNextIfNeeded(this: DataGridImpl<T>, wasChange: boolean): void {\n      if (!moveDirection) {\n        return;\n      }\n\n      if (moveDirection === 'forward') {\n        const firstEditableColumn = this.nextEditableColumn(-1);\n        const isCreationNode = currentEditingNode instanceof CreationDataGridNode && currentEditingNode.isCreationNode;\n        if (isCreationNode && cellIndex === firstEditableColumn && !wasChange) {\n          return;\n        }\n\n        const nextEditableColumn = this.nextEditableColumn(cellIndex);\n        if (nextEditableColumn !== -1) {\n          this.startEditingColumnOfDataGridNode(currentEditingNode, nextEditableColumn);\n          return;\n        }\n\n        const nextDataGridNode = currentEditingNode.traverseNextNode(true, null, true);\n        if (nextDataGridNode) {\n          this.startEditingColumnOfDataGridNode(nextDataGridNode, firstEditableColumn);\n          return;\n        }\n        if (isCreationNode && wasChange && this.creationNode) {\n          this.addCreationNode(false);\n          this.startEditingColumnOfDataGridNode(this.creationNode, firstEditableColumn);\n          return;\n        }\n        return;\n      }\n\n      if (moveDirection === 'backward') {\n        const prevEditableColumn = this.nextEditableColumn(cellIndex, true);\n        if (prevEditableColumn !== -1) {\n          this.startEditingColumnOfDataGridNode(currentEditingNode, prevEditableColumn);\n          return;\n        }\n\n        const lastEditableColumn = this.nextEditableColumn(this.visibleColumnsArray.length, true);\n        const nextDataGridNode = currentEditingNode.traversePreviousNode(true, true);\n        if (nextDataGridNode) {\n          this.startEditingColumnOfDataGridNode(nextDataGridNode, lastEditableColumn);\n        }\n        return;\n      }\n    }\n\n    // Show trimmed text after editing.\n    this.setElementContent(element, newText);\n\n    if (valueBeforeEditing === newText) {\n      this.editingCancelled(element);\n      moveToNextIfNeeded.call(this, false);\n      return;\n    }\n\n    // Update the text in the datagrid that we typed\n    this.editingNode.data[columnId] = newText;\n    if (!this.editCallback) {\n      return;\n    }\n    // Make the callback - expects an editing node (table row), the column number that is being edited,\n    // the text that used to be there, and the new text.\n    this.editCallback(this.editingNode, columnId, valueBeforeEditing, newText);\n\n    if (this.editingNode instanceof CreationDataGridNode && this.editingNode.isCreationNode) {\n      this.addCreationNode(false);\n    }\n\n    this.editingCancelled(element);\n    moveToNextIfNeeded.call(this, true);\n  }\n\n  private editingCancelled(_element: Element): void {\n    this.editing = false;\n    this.editingNode = null;\n  }\n\n  private nextEditableColumn(cellIndex: number, moveBackward?: boolean, inclusive?: boolean): number {\n    const increment = moveBackward ? -1 : 1;\n    const start = inclusive ? cellIndex : cellIndex + increment;\n    const columns = this.visibleColumnsArray;\n    for (let i = start; (i >= 0) && (i < columns.length); i += increment) {\n      if (columns[i].editable) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  sortColumnId(): string|null {\n    if (!this.sortColumnCell) {\n      return null;\n    }\n    return nodeToColumnIdMap.get(this.sortColumnCell) || null;\n  }\n\n  sortOrder(): string|null {\n    if (!this.sortColumnCell || this.sortColumnCell.classList.contains(Order.Ascending)) {\n      return Order.Ascending;\n    }\n    if (this.sortColumnCell.classList.contains(Order.Descending)) {\n      return Order.Descending;\n    }\n    return null;\n  }\n\n  isSortOrderAscending(): boolean {\n    return !this.sortColumnCell || this.sortColumnCell.classList.contains(Order.Ascending);\n  }\n\n  private autoSizeWidths(widths: number[], minPercent: number, maxPercent?: number): number[] {\n    if (minPercent) {\n      minPercent = Math.min(minPercent, Math.floor(100 / widths.length));\n    }\n    let totalWidth = 0;\n    for (let i = 0; i < widths.length; ++i) {\n      totalWidth += widths[i];\n    }\n    let totalPercentWidth = 0;\n    for (let i = 0; i < widths.length; ++i) {\n      let width = Math.round(100 * widths[i] / totalWidth);\n      if (minPercent && width < minPercent) {\n        width = minPercent;\n      } else if (maxPercent && width > maxPercent) {\n        width = maxPercent;\n      }\n      totalPercentWidth += width;\n      widths[i] = width;\n    }\n    let recoupPercent = totalPercentWidth - 100;\n\n    while (minPercent && recoupPercent > 0) {\n      for (let i = 0; i < widths.length; ++i) {\n        if (widths[i] > minPercent) {\n          --widths[i];\n          --recoupPercent;\n          if (!recoupPercent) {\n            break;\n          }\n        }\n      }\n    }\n\n    while (maxPercent && recoupPercent < 0) {\n      for (let i = 0; i < widths.length; ++i) {\n        if (widths[i] < maxPercent) {\n          ++widths[i];\n          ++recoupPercent;\n          if (!recoupPercent) {\n            break;\n          }\n        }\n      }\n    }\n\n    return widths;\n  }\n\n  /**\n   * The range of |minPercent| and |maxPercent| is [0, 100].\n   */\n  autoSizeColumns(minPercent: number, maxPercent?: number, maxDescentLevel?: number): void {\n    let widths: number[] = [];\n    for (let i = 0; i < this.columnsArray.length; ++i) {\n      widths.push((this.columnsArray[i].title || '').length);\n    }\n\n    maxDescentLevel = maxDescentLevel || 0;\n    if (!this.rootNodeInternal) {\n      return;\n    }\n    const children = this.enumerateChildren(this.rootNodeInternal, [], maxDescentLevel + 1);\n    for (let i = 0; i < children.length; ++i) {\n      const node = children[i];\n      for (let j = 0; j < this.columnsArray.length; ++j) {\n        const text = String(node.data[this.columnsArray[j].id]);\n        if (text.length > widths[j]) {\n          widths[j] = text.length;\n        }\n      }\n    }\n\n    widths = this.autoSizeWidths(widths, minPercent, maxPercent);\n\n    for (let i = 0; i < this.columnsArray.length; ++i) {\n      this.columnsArray[i].weight = widths[i];\n    }\n    this.columnWidthsInitialized = false;\n    this.updateWidths();\n  }\n\n  private enumerateChildren(rootNode: DataGridNode<T>, result: DataGridNode<T>[], maxLevel: number): DataGridNode<T>[] {\n    if (!rootNode.isRoot) {\n      result.push(rootNode);\n    }\n    if (!maxLevel) {\n      return [];\n    }\n    for (let i = 0; i < rootNode.children.length; ++i) {\n      this.enumerateChildren(rootNode.children[i], result, maxLevel - 1);\n    }\n    return result;\n  }\n\n  onResize(): void {\n    this.updateWidths();\n  }\n\n  // Updates the widths of the table, including the positions of the column\n  // resizers.\n  //\n  // IMPORTANT: This function MUST be called once after the element of the\n  // DataGrid is attached to its parent element and every subsequent time the\n  // width of the parent element is changed in order to make it possible to\n  // resize the columns.\n  //\n  // If this function is not called after the DataGrid is attached to its\n  // parent element, then the DataGrid's columns will not be resizable.\n  updateWidths(): void {\n    // Do not attempt to use offsetes if we're not attached to the document tree yet.\n    if (!this.columnWidthsInitialized && this.element.offsetWidth) {\n      // Give all the columns initial widths now so that during a resize,\n      // when the two columns that get resized get a percent value for\n      // their widths, all the other columns already have percent values\n      // for their widths.\n\n      // Use container size to avoid changes of table width caused by change of column widths.\n      const tableWidth = this.element.offsetWidth - this.cornerWidth;\n      const cells = this.dataTableHeadInternal.rows[0].cells;\n      const numColumns = cells.length - 1;  // Do not process corner column.\n      for (let i = 0; i < numColumns; i++) {\n        const column = this.visibleColumnsArray[i];\n        if (!column.weight) {\n          column.weight = 100 * this.getPreferredWidth(i) / tableWidth || 10;\n        }\n      }\n      this.columnWidthsInitialized = true;\n    }\n    this.applyColumnWeights();\n  }\n\n  indexOfVisibleColumn(columnId: string): number {\n    return this.visibleColumnsArray.findIndex(column => column.id === columnId);\n  }\n\n  setName(name: string): void {\n    this.columnWeightsSetting =\n        Common.Settings.Settings.instance().createSetting('data-grid-' + name + '-column-weights', {});\n    this.loadColumnWeights();\n  }\n\n  private resetColumnWeights(): void {\n    for (const column of this.columnsArray) {\n      if (!column.defaultWeight) {\n        continue;\n      }\n      column.weight = column.defaultWeight;\n    }\n    this.applyColumnWeights();\n    this.saveColumnWeights();\n  }\n\n  private loadColumnWeights(): void {\n    if (!this.columnWeightsSetting) {\n      return;\n    }\n    const weights = this.columnWeightsSetting.get();\n    for (let i = 0; i < this.columnsArray.length; ++i) {\n      const column = this.columnsArray[i];\n      const weight = weights[column.id];\n      if (weight) {\n        column.weight = weight;\n      }\n    }\n    this.applyColumnWeights();\n  }\n\n  private saveColumnWeights(): void {\n    if (!this.columnWeightsSetting) {\n      return;\n    }\n    const weights: {\n      [x: string]: any,\n    } = {};\n    for (let i = 0; i < this.columnsArray.length; ++i) {\n      const column = this.columnsArray[i];\n      weights[column.id] = column.weight;\n    }\n    this.columnWeightsSetting.set(weights);\n  }\n\n  wasShown(): void {\n    this.loadColumnWeights();\n  }\n\n  willHide(): void {\n  }\n\n  private getPreferredWidth(columnIndex: number): number {\n    return elementToPreferedWidthMap.get(this.dataTableColumnGroup.children[columnIndex]) ||\n        this.dataTableHeadInternal.rows[0].cells[columnIndex].offsetWidth;\n  }\n\n  private applyColumnWeights(): void {\n    let tableWidth = this.element.offsetWidth - this.cornerWidth;\n    if (tableWidth <= 0) {\n      return;\n    }\n\n    let sumOfWeights = 0.0;\n    const fixedColumnWidths = [];\n    for (let i = 0; i < this.visibleColumnsArray.length; ++i) {\n      const column = this.visibleColumnsArray[i];\n      if (column.fixedWidth) {\n        const width = this.getPreferredWidth(i);\n        fixedColumnWidths[i] = width;\n        tableWidth -= width;\n      } else {\n        sumOfWeights += (this.visibleColumnsArray[i].weight || 0);\n      }\n    }\n    let sum = 0;\n    let lastOffset = 0;\n    const minColumnWidth = 14;  // px\n\n    for (let i = 0; i < this.visibleColumnsArray.length; ++i) {\n      const column = this.visibleColumnsArray[i];\n      let width;\n      if (column.fixedWidth) {\n        width = fixedColumnWidths[i];\n      } else {\n        sum += (column.weight || 0);\n        const offset = (sum * tableWidth / sumOfWeights) | 0;\n        width = Math.max(offset - lastOffset, minColumnWidth);\n        lastOffset = offset;\n      }\n      this.setPreferredWidth(i, width);\n    }\n\n    this.positionResizers();\n  }\n\n  setColumnsVisibility(columnsVisibility: Set<string>): void {\n    this.visibleColumnsArray = [];\n    for (const column of this.columnsArray) {\n      if (columnsVisibility.has(column.id)) {\n        this.visibleColumnsArray.push(column);\n      }\n    }\n    this.refreshHeader();\n    this.applyColumnWeights();\n    const nodes = this.enumerateChildren(this.rootNode(), [], -1);\n    for (const node of nodes) {\n      node.refresh();\n    }\n  }\n\n  get scrollContainer(): HTMLElement {\n    return this.scrollContainerInternal as HTMLElement;\n  }\n\n  private positionResizers(): void {\n    const headerTableColumns = this.dataTableColumnGroup.children;\n    const numColumns = headerTableColumns.length - 1;  // Do not process corner column.\n    const left: number[] = [];\n    const resizers = this.resizers;\n\n    while (resizers.length > numColumns - 1) {\n      const resizer = resizers.pop();\n      if (resizer) {\n        resizer.remove();\n      }\n    }\n\n    for (let i = 0; i < numColumns - 1; i++) {\n      // Get the width of the cell in the first (and only) row of the\n      // header table in order to determine the width of the column, since\n      // it is not possible to query a column for its width.\n      left[i] = (left[i - 1] || 0) + this.dataTableHeadInternal.rows[0].cells[i].offsetWidth;\n    }\n\n    // Make n - 1 resizers for n columns.\n    for (let i = 0; i < numColumns - 1; i++) {\n      let resizer: HTMLDivElement|HTMLElement = resizers[i];\n      if (!resizer) {\n        // This is the first call to updateWidth, so the resizers need\n        // to be created.\n        resizer = document.createElement('div');\n        elementToIndexMap.set(resizer, i);\n        resizer.classList.add('data-grid-resizer');\n        // This resizer is associated with the column to its right.\n        UI.UIUtils.installDragHandle(\n            resizer, this.startResizerDragging.bind(this), this.resizerDragging.bind(this),\n            this.endResizerDragging.bind(this), 'col-resize');\n        this.element.appendChild(resizer);\n        resizers.push((resizer as HTMLElement));\n      }\n      if (elementToPositionMap.get(resizer) !== left[i]) {\n        elementToPositionMap.set(resizer, left[i]);\n        resizer.style.left = left[i] + 'px';\n      }\n    }\n  }\n\n  addCreationNode(hasChildren?: boolean): void {\n    if (this.creationNode) {\n      this.creationNode.makeNormal();\n    }\n    const emptyData: {\n      [x: string]: any,\n    } = {};\n    for (const column in this.columns) {\n      emptyData[column] = null;\n    }\n    this.creationNode = new CreationDataGridNode(emptyData, hasChildren);\n    UI.ARIAUtils.alert(i18nString(UIStrings.emptyRowCreated));\n    this.rootNode().appendChild(this.creationNode);\n  }\n\n  private keyDown(event: Event): void {\n    if (!(event instanceof KeyboardEvent)) {\n      return;\n    }\n    if (this.selectedNode) {\n      if ((this.selectedNode.element() as HTMLElement).tabIndex < 0) {\n        void VisualLogging.logKeyDown(this.selectedNode.element(), event);\n      }\n    }\n\n    if (event.shiftKey || event.metaKey || event.ctrlKey || this.editing || UI.UIUtils.isEditing()) {\n      return;\n    }\n\n    let handled = false;\n    let nextSelectedNode;\n    if (!this.selectedNode) {\n      // Select the first or last node based on the arrow key direction\n      if (event.key === 'ArrowUp' && !event.altKey) {\n        nextSelectedNode = this.lastSelectableNode();\n      } else if (event.key === 'ArrowDown' && !event.altKey) {\n        nextSelectedNode = this.firstSelectableNode();\n      }\n      handled = nextSelectedNode ? true : false;\n    } else if (event.key === 'ArrowUp' && !event.altKey) {\n      nextSelectedNode = this.selectedNode.traversePreviousNode(true);\n      while (nextSelectedNode && !nextSelectedNode.selectable) {\n        nextSelectedNode = nextSelectedNode.traversePreviousNode(true);\n      }\n      handled = nextSelectedNode ? true : false;\n    } else if (event.key === 'ArrowDown' && !event.altKey) {\n      nextSelectedNode = this.selectedNode.traverseNextNode(true);\n      while (nextSelectedNode && !nextSelectedNode.selectable) {\n        nextSelectedNode = nextSelectedNode.traverseNextNode(true);\n      }\n      handled = nextSelectedNode ? true : false;\n    } else if (event.key === 'ArrowLeft') {\n      if (this.selectedNode.expanded) {\n        if (event.altKey) {\n          this.selectedNode.collapseRecursively();\n        } else {\n          this.selectedNode.collapse();\n        }\n        handled = true;\n      } else if (this.selectedNode.parent && !this.selectedNode.parent.isRoot) {\n        handled = true;\n        if (this.selectedNode.parent.selectable) {\n          nextSelectedNode = this.selectedNode.parent;\n          handled = nextSelectedNode ? true : false;\n        } else if (this.selectedNode.parent) {\n          this.selectedNode.parent.collapse();\n        }\n      }\n    } else if (event.key === 'ArrowRight') {\n      if (!this.selectedNode.revealed) {\n        this.selectedNode.reveal();\n        handled = true;\n      } else if (this.selectedNode.hasChildren()) {\n        handled = true;\n        if (this.selectedNode.expanded) {\n          nextSelectedNode = this.selectedNode.children[0];\n          handled = nextSelectedNode ? true : false;\n        } else {\n          if (event.altKey) {\n            this.selectedNode.expandRecursively();\n          } else {\n            this.selectedNode.expand();\n          }\n        }\n      }\n    } else if (event.keyCode === 8 || event.keyCode === 46) {\n      if (this.deleteCallback) {\n        handled = true;\n        this.deleteCallback(this.selectedNode);\n      }\n    } else if (event.key === 'Enter') {\n      if (this.editCallback) {\n        handled = true;\n        const selectedNodeElement = this.selectedNode.element();\n        if (!selectedNodeElement) {\n          return;\n        }\n        this.startEditing(selectedNodeElement.children[this.nextEditableColumn(-1)]);\n      } else {\n        this.dispatchEventToListeners(Events.OPENED_NODE, this.selectedNode);\n      }\n    }\n\n    if (nextSelectedNode) {\n      nextSelectedNode.reveal();\n      nextSelectedNode.select();\n    }\n\n    if (handled && this.element !== document.activeElement && !this.element.contains(document.activeElement)) {\n      // crbug.com/1005449, crbug.com/1329956\n      // navigational or delete keys pressed but current DataGrid panel has lost focus;\n      // re-focus to ensure subsequent keydowns can be registered within this DataGrid\n      this.element.focus();\n    }\n\n    if (handled) {\n      event.consume(true);\n    }\n  }\n\n  updateSelectionBeforeRemoval(root: DataGridNode<T>|null, _onlyAffectsSubtree: boolean): void {\n    let ancestor: (DataGridNode<T>|null) = this.selectedNode;\n    while (ancestor && ancestor !== root) {\n      ancestor = ancestor.parent;\n    }\n    // Selection is not in the subtree being deleted.\n    if (!ancestor) {\n      return;\n    }\n\n    let nextSelectedNode;\n    // Skip subtree being deleted when looking for the next selectable node.\n    for (ancestor = root; ancestor && !ancestor.nextSibling; ancestor = ancestor.parent) {\n    }\n    if (ancestor) {\n      nextSelectedNode = ancestor.nextSibling;\n    }\n    while (nextSelectedNode && !nextSelectedNode.selectable) {\n      nextSelectedNode = nextSelectedNode.traverseNextNode(true);\n    }\n    const isCreationNode = nextSelectedNode instanceof CreationDataGridNode && nextSelectedNode.isCreationNode;\n    if (!nextSelectedNode || isCreationNode) {\n      if (!root) {\n        return;\n      }\n      nextSelectedNode = root.traversePreviousNode(true);\n      while (nextSelectedNode && !nextSelectedNode.selectable) {\n        nextSelectedNode = nextSelectedNode.traversePreviousNode(true);\n      }\n    }\n    if (nextSelectedNode) {\n      nextSelectedNode.reveal();\n      nextSelectedNode.select();\n    } else if (this.selectedNode) {\n      this.selectedNode.deselect();\n    }\n  }\n\n  dataGridNodeFromNode(target: Node): DataGridNode<T>|null {\n    const rowElement = UI.UIUtils.enclosingNodeOrSelfWithNodeName(target, 'tr');\n    return (rowElement && this.elementToDataGridNode.get(rowElement)) || null;\n  }\n\n  columnIdFromNode(target: Node): string|null {\n    const cellElement = UI.UIUtils.enclosingNodeOrSelfWithNodeName(target, 'td');\n    return (cellElement && nodeToColumnIdMap.get(cellElement)) || null;\n  }\n\n  private clickInHeaderCell(event: Event): void {\n    const cell = UI.UIUtils.enclosingNodeOrSelfWithNodeName((event.target as Node), 'th');\n    if (!cell) {\n      return;\n    }\n    this.sortByColumnHeaderCell((cell as HTMLElement));\n  }\n\n  private sortByColumnHeaderCell(cell: Element): void {\n    if (!nodeToColumnIdMap.has(cell) || !cell.classList.contains('sortable')) {\n      return;\n    }\n\n    let sortOrder = Order.Ascending;\n    if ((cell === this.sortColumnCell) && this.isSortOrderAscending()) {\n      sortOrder = Order.Descending;\n    }\n\n    if (this.sortColumnCell) {\n      this.sortColumnCell.classList.remove(Order.Ascending, Order.Descending);\n    }\n    this.sortColumnCell = cell;\n\n    cell.classList.add(sortOrder);\n\n    this.dispatchEventToListeners(Events.SORTING_CHANGED);\n  }\n\n  markColumnAsSortedBy(columnId: string, sortOrder: Order): void {\n    if (this.sortColumnCell) {\n      this.sortColumnCell.classList.remove(Order.Ascending, Order.Descending);\n    }\n    this.sortColumnCell = this.dataTableHeaders[columnId];\n    this.sortColumnCell.classList.add(sortOrder);\n  }\n\n  headerTableHeader(columnId: string): Element {\n    return this.dataTableHeaders[columnId];\n  }\n\n  private mouseDownInDataTable(event: Event): void {\n    const target = (event.target as Node);\n    const gridNode = this.dataGridNodeFromNode(target);\n    if (!gridNode || !gridNode.selectable || gridNode.isEventWithinDisclosureTriangle((event as MouseEvent))) {\n      return;\n    }\n\n    const columnId = this.columnIdFromNode(target);\n    if (columnId && this.columns[columnId].nonSelectable) {\n      return;\n    }\n\n    if ((event as MouseEvent).metaKey) {\n      if (gridNode.selected) {\n        gridNode.deselect();\n      } else {\n        gridNode.select();\n      }\n    } else {\n      gridNode.select();\n      this.dispatchEventToListeners(Events.OPENED_NODE, gridNode);\n    }\n  }\n\n  setHeaderContextMenuCallback(callback: ((arg0: UI.ContextMenu.SubMenu) => void)|null): void {\n    this.headerContextMenuCallback = callback;\n  }\n\n  setRowContextMenuCallback(callback: ((arg0: UI.ContextMenu.ContextMenu, arg1: DataGridNode<T>) => void)|null): void {\n    this.rowContextMenuCallback = callback;\n  }\n\n  private contextMenu(event: Event): void {\n    if (!(event instanceof MouseEvent)) {\n      return;\n    }\n    const contextMenu = new UI.ContextMenu.ContextMenu(event);\n    const target = (event.target as Node);\n\n    const sortableVisibleColumns = this.visibleColumnsArray.filter(column => {\n      return (column.sortable && column.title);\n    });\n\n    const sortableHiddenColumns = this.columnsArray.filter(\n        column => sortableVisibleColumns.indexOf(column) === -1 && column.allowInSortByEvenWhenHidden);\n\n    const sortableColumns = [...sortableVisibleColumns, ...sortableHiddenColumns];\n    if (sortableColumns.length > 0) {\n      const sortMenu =\n          contextMenu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortByString), false, 'sort-by');\n      for (const column of sortableColumns) {\n        const headerCell = this.dataTableHeaders[column.id];\n        sortMenu.defaultSection().appendItem(\n            (column.title as string), this.sortByColumnHeaderCell.bind(this, headerCell), {\n              jslogContext: Platform.StringUtilities.toKebabCase(column.id),\n            });\n      }\n    }\n\n    if (target.isSelfOrDescendant(this.dataTableHeadInternal)) {\n      if (this.headerContextMenuCallback) {\n        this.headerContextMenuCallback(contextMenu);\n      }\n      contextMenu.defaultSection().appendItem(\n          i18nString(UIStrings.resetColumns), this.resetColumnWeights.bind(this), {jslogContext: 'reset-columns'});\n      void contextMenu.show();\n      return;\n    }\n\n    // Add header context menu to a subsection available from the body\n    const headerSubMenu =\n        contextMenu.defaultSection().appendSubMenuItem(i18nString(UIStrings.headerOptions), false, 'header-options');\n    if (this.headerContextMenuCallback) {\n      this.headerContextMenuCallback(headerSubMenu);\n    }\n    headerSubMenu.defaultSection().appendItem(\n        i18nString(UIStrings.resetColumns), this.resetColumnWeights.bind(this), {jslogContext: 'reset-columns'});\n\n    const isContextMenuKey = (event.button === 0);\n    const gridNode = isContextMenuKey ? this.selectedNode : this.dataGridNodeFromNode(target);\n    const selectedNodeElement = this.selectedNode && this.selectedNode.existingElement();\n    if (isContextMenuKey && selectedNodeElement) {\n      const boundingRowRect = selectedNodeElement.getBoundingClientRect();\n      if (boundingRowRect) {\n        const x = (boundingRowRect.right + boundingRowRect.left) / 2;\n        const y = (boundingRowRect.bottom + boundingRowRect.top) / 2;\n        contextMenu.setX(x);\n        contextMenu.setY(y);\n      }\n    }\n    if (this.refreshCallback && (!gridNode || gridNode !== this.creationNode)) {\n      contextMenu.defaultSection().appendItem(\n          i18nString(UIStrings.refresh), this.refreshCallback.bind(this), {jslogContext: 'refresh'});\n    }\n\n    if (gridNode && gridNode.selectable && !gridNode.isEventWithinDisclosureTriangle(event)) {\n      if (this.editCallback) {\n        if (gridNode === this.creationNode) {\n          const firstEditColumnIndex = this.nextEditableColumn(-1);\n          const tableCellElement = gridNode.element().children[firstEditColumnIndex];\n          contextMenu.defaultSection().appendItem(\n              i18nString(UIStrings.addNew), this.startEditing.bind(this, tableCellElement), {jslogContext: 'add-new'});\n        } else if (isContextMenuKey) {\n          const firstEditColumnIndex = this.nextEditableColumn(-1);\n          if (firstEditColumnIndex > -1) {\n            const firstColumn = this.visibleColumnsArray[firstEditColumnIndex];\n            if (firstColumn && firstColumn.editable) {\n              contextMenu.defaultSection().appendItem(\n                  i18nString(UIStrings.editS, {PH1: String(firstColumn.title)}),\n                  this.startEditingColumnOfDataGridNode.bind(this, gridNode, firstEditColumnIndex),\n                  {jslogContext: 'edit'});\n            }\n          }\n        } else {\n          const columnId = this.columnIdFromNode(target);\n          if (columnId && this.columns[columnId].editable) {\n            contextMenu.defaultSection().appendItem(\n                i18nString(UIStrings.editS, {PH1: String(this.columns[columnId].title)}),\n                this.startEditing.bind(this, target), {jslogContext: 'edit'});\n          }\n        }\n      }\n      if (this.deleteCallback && gridNode !== this.creationNode) {\n        contextMenu.defaultSection().appendItem(\n            i18nString(UIStrings.delete), this.deleteCallback.bind(this, gridNode), {jslogContext: 'delete'});\n      }\n      if (this.rowContextMenuCallback) {\n        this.rowContextMenuCallback(contextMenu, gridNode);\n      }\n    }\n\n    void contextMenu.show();\n  }\n\n  private clickInDataTable(event: Event): void {\n    const gridNode = this.dataGridNodeFromNode((event.target as Node));\n    if (!gridNode || !gridNode.hasChildren() || !gridNode.isEventWithinDisclosureTriangle((event as MouseEvent))) {\n      return;\n    }\n\n    if (gridNode.expanded) {\n      if ((event as MouseEvent).altKey) {\n        gridNode.collapseRecursively();\n      } else {\n        gridNode.collapse();\n      }\n    } else {\n      if ((event as MouseEvent).altKey) {\n        gridNode.expandRecursively();\n      } else {\n        gridNode.expand();\n      }\n    }\n  }\n\n  setResizeMethod(method: ResizeMethod): void {\n    this.resizeMethod = method;\n  }\n\n  private startResizerDragging(event: Event): boolean {\n    this.currentResizer = event.target;\n    return true;\n  }\n\n  private endResizerDragging(): void {\n    this.currentResizer = null;\n    this.saveColumnWeights();\n  }\n\n  private resizerDragging(event: MouseEvent): void {\n    const resizer = (this.currentResizer as HTMLElement);\n    if (!resizer) {\n      return;\n    }\n\n    // Constrain the dragpoint to be within the containing div of the\n    // datagrid.\n    let dragPoint: number = event.clientX - this.element.getBoundingClientRect().left;\n    let leftEdgeOfPreviousColumn = 0;\n    // Constrain the dragpoint to be within the space made up by the\n    // column directly to the left and the column directly to the right.\n    let leftCellIndex = elementToIndexMap.get(resizer);\n    if (leftCellIndex === undefined) {\n      return;\n    }\n    let rightCellIndex: number = leftCellIndex + 1;\n    for (let i = 0; i < leftCellIndex; i++) {\n      leftEdgeOfPreviousColumn += this.getPreferredWidth(i);\n    }\n\n    // Differences for other resize methods\n    if (this.resizeMethod === ResizeMethod.LAST) {\n      rightCellIndex = this.resizers.length;\n    } else if (this.resizeMethod === ResizeMethod.FIRST) {\n      leftEdgeOfPreviousColumn += this.getPreferredWidth(leftCellIndex) - this.getPreferredWidth(0);\n      leftCellIndex = 0;\n    }\n\n    const rightEdgeOfNextColumn =\n        leftEdgeOfPreviousColumn + this.getPreferredWidth(leftCellIndex) + this.getPreferredWidth(rightCellIndex);\n\n    // Give each column some padding so that they don't disappear.\n    const leftMinimum = leftEdgeOfPreviousColumn + ColumnResizePadding;\n    const rightMaximum = rightEdgeOfNextColumn - ColumnResizePadding;\n    if (leftMinimum > rightMaximum) {\n      return;\n    }\n\n    dragPoint = Platform.NumberUtilities.clamp(dragPoint, leftMinimum, rightMaximum);\n\n    const position = (dragPoint - CenterResizerOverBorderAdjustment);\n    elementToPositionMap.set(resizer, position);\n    resizer.style.left = position + 'px';\n\n    this.setPreferredWidth(leftCellIndex, dragPoint - leftEdgeOfPreviousColumn);\n    this.setPreferredWidth(rightCellIndex, rightEdgeOfNextColumn - dragPoint);\n\n    const leftColumn = this.visibleColumnsArray[leftCellIndex];\n    const rightColumn = this.visibleColumnsArray[rightCellIndex];\n    if (leftColumn.weight && rightColumn.weight) {\n      const sumOfWeights = leftColumn.weight + rightColumn.weight;\n      const delta = rightEdgeOfNextColumn - leftEdgeOfPreviousColumn;\n      leftColumn.weight = (dragPoint - leftEdgeOfPreviousColumn) * sumOfWeights / delta;\n      rightColumn.weight = (rightEdgeOfNextColumn - dragPoint) * sumOfWeights / delta;\n    }\n\n    this.positionResizers();\n    this.updateWidths();\n    event.preventDefault();\n  }\n\n  private setPreferredWidth(columnIndex: number, width: number): void {\n    const dataTableChildElement = (this.dataTableColumnGroup.children[columnIndex] as HTMLElement);\n    elementToPreferedWidthMap.set(dataTableChildElement, width);\n    dataTableChildElement.style.width = width + 'px';\n  }\n\n  columnOffset(columnId: string): number {\n    if (!this.element.offsetWidth) {\n      return 0;\n    }\n    for (let i = 1; i < this.visibleColumnsArray.length; ++i) {\n      if (columnId === this.visibleColumnsArray[i].id) {\n        if (this.resizers[i - 1]) {\n          return elementToPositionMap.get(this.resizers[i - 1]) || 0;\n        }\n      }\n    }\n    return 0;\n  }\n\n  asWidget(element?: HTMLElement): DataGridWidget<T> {\n    if (!this.dataGridWidget) {\n      this.dataGridWidget = new DataGridWidget(this, element);\n    }\n    return this.dataGridWidget;\n  }\n\n  topFillerRowElement(): HTMLElement {\n    return this.topFillerRow;\n  }\n\n  // Note on the following methods:\n  // The header row is a child of the scrollable container, and uses position: sticky\n  // so it can visually obscure other elements below it in the grid. We need to manually\n  // subtract the header's height when calculating the actual client area in which\n  // data rows are visible. However, if a caller has set a different scroll container\n  // then we report 0 height and the caller is expected to ensure their chosen scroll\n  // container's height matches the visible scrollable data area as seen by the user.\n\n  protected headerHeightInScroller(): number {\n    return this.scrollContainer === this.dataContainerInternal ? this.headerHeight() : 0;\n  }\n\n  headerHeight(): number {\n    return this.dataTableHeadInternal.offsetHeight;\n  }\n\n  revealNode(element: HTMLElement): void {\n    element.scrollIntoViewIfNeeded(false);\n    // The header row is a child of the scrollable container, and uses position: sticky\n    // so scrollIntoViewIfNeeded may place the element behind it. If the element is\n    // obscured by the header, adjust the scrollTop so that the element is fully revealed.\n    if (element.offsetTop - this.scrollContainer.scrollTop < this.headerHeight()) {\n      this.scrollContainer.scrollTop = element.offsetTop - this.headerHeight();\n    }\n  }\n}\n\n// Keep in sync with .data-grid col.corner style rule.\nexport const CornerWidth = 14;\n\nexport const enum Events {\n  SELECTED_NODE = 'SelectedNode',\n  DESELECTED_NODE = 'DeselectedNode',\n  OPENED_NODE = 'OpenedNode',\n  SORTING_CHANGED = 'SortingChanged',\n  PADDING_CHANGED = 'PaddingChanged',\n}\n\nexport type EventTypes<T> = {\n  [Events.SELECTED_NODE]: DataGridNode<T>,\n  [Events.DESELECTED_NODE]: void,\n  [Events.OPENED_NODE]: DataGridNode<T>,\n  [Events.SORTING_CHANGED]: void,\n  [Events.PADDING_CHANGED]: void,\n};\n\nexport enum Order {\n  /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n  Ascending = 'sort-ascending',\n  Descending = 'sort-descending',\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport const enum Align {\n  CENTER = 'center',\n  RIGHT = 'right',\n}\n\nexport const enum DataType {\n  STRING = 'String',\n  BOOLEAN = 'Boolean',\n}\n\nexport const ColumnResizePadding = 34;\nexport const CenterResizerOverBorderAdjustment = 3;\n\nexport const enum ResizeMethod {\n  NEAREST = 'nearest',\n  FIRST = 'first',\n  LAST = 'last',\n}\n\nexport type DataGridData = {\n  [key: string]: any,\n};\n\nexport class DataGridNode<T> {\n  elementInternal: HTMLElement|null;\n  expandedInternal: boolean;\n  private selectedInternal: boolean;\n  private dirty: boolean;\n  private inactive: boolean;\n  key!: string;\n  private depthInternal!: number|undefined;\n  revealedInternal!: boolean|undefined;\n  protected attachedInternal: boolean;\n  private savedPosition: {\n    parent: DataGridNode<T>,\n    index: number,\n  }|null;\n  private shouldRefreshChildrenInternal: boolean;\n  private dataInternal: DataGridData;\n  private hasChildrenInternal: boolean;\n  children: DataGridNode<T>[];\n  dataGrid: DataGridImpl<T>|null;\n  parent: DataGridNode<T>|null;\n  previousSibling: DataGridNode<T>|null;\n  nextSibling: DataGridNode<T>|null;\n  #disclosureToggleHitBoxWidth: number = 20;\n  selectable: boolean;\n  isRoot: boolean;\n  nodeAccessibleText: string;\n  cellAccessibleTextMap: Map<string, string>;\n  isCreationNode: boolean;\n\n  constructor(data?: DataGridData|null, hasChildren?: boolean) {\n    this.elementInternal = null;\n    this.expandedInternal = false;\n    this.selectedInternal = false;\n    this.dirty = false;\n    this.inactive = false;\n    this.attachedInternal = false;\n    this.savedPosition = null;\n    this.shouldRefreshChildrenInternal = true;\n    this.dataInternal = data || {};\n    this.hasChildrenInternal = hasChildren || false;\n    this.children = [];\n    this.dataGrid = null;\n    this.parent = null;\n    this.previousSibling = null;\n    this.nextSibling = null;\n\n    this.selectable = true;\n\n    this.isRoot = false;\n\n    this.nodeAccessibleText = '';\n    this.cellAccessibleTextMap = new Map();\n    this.isCreationNode = false;\n  }\n\n  element(): Element {\n    if (!this.elementInternal) {\n      const element = this.createElement();\n      this.createCells(element);\n    }\n    return this.elementInternal as Element;\n  }\n\n  protected createElement(): HTMLElement {\n    this.elementInternal = document.createElement('tr');\n    this.elementInternal.setAttribute(\n        'jslog', `${VisualLogging.tableRow().track({keydown: 'ArrowUp|ArrowDown|ArrowLeft|ArrowRight|Enter|Space'})}`);\n    this.elementInternal.classList.add('data-grid-data-grid-node');\n    if (this.dataGrid) {\n      this.dataGrid.elementToDataGridNode.set(this.elementInternal, this);\n    }\n\n    if (this.hasChildrenInternal) {\n      this.elementInternal.classList.add('parent');\n    }\n    if (this.expanded) {\n      this.elementInternal.classList.add('expanded');\n    }\n    if (this.selected) {\n      this.elementInternal.classList.add('selected');\n    }\n    if (this.revealed) {\n      this.elementInternal.classList.add('revealed');\n    }\n    if (this.dirty) {\n      this.elementInternal.classList.add('dirty');\n    }\n    if (this.inactive) {\n      this.elementInternal.classList.add('inactive');\n    }\n    if (this.isCreationNode) {\n      this.elementInternal.classList.add('creation-node');\n    }\n    return this.elementInternal;\n  }\n\n  existingElement(): HTMLElement|null {\n    return this.elementInternal || null;\n  }\n\n  protected resetElement(): void {\n    this.elementInternal = null;\n  }\n\n  protected createCells(element: Element): void {\n    element.removeChildren();\n    if (!this.dataGrid || !this.parent) {\n      return;\n    }\n    const columnsArray = this.dataGrid.visibleColumnsArray;\n    const accessibleTextArray = [];\n    // Add depth if node is part of a tree\n    if (this.hasChildrenInternal || !this.parent.isRoot) {\n      accessibleTextArray.push(i18nString(UIStrings.levelS, {PH1: this.depth + 1}));\n    }\n    for (let i = 0; i < columnsArray.length; ++i) {\n      const column = columnsArray[i];\n      const cell = element.appendChild(this.createCell(column.id));\n      // Add each visibile cell to the node's accessible text by gathering 'Column Title: content'\n\n      if (column.dataType === DataType.BOOLEAN && this.data[column.id] === true) {\n        this.setCellAccessibleName(i18nString(UIStrings.checked), cell, column.id);\n      }\n\n      accessibleTextArray.push(`${column.title}: ${this.cellAccessibleTextMap.get(column.id) || cell.textContent}`);\n    }\n    this.nodeAccessibleText = accessibleTextArray.join(', ');\n\n    const cornerCell = this.createTDWithClass('corner');\n    UI.ARIAUtils.setHidden(cornerCell, true);\n    element.appendChild(cornerCell);\n  }\n\n  get data(): DataGridData {\n    return this.dataInternal;\n  }\n\n  set data(x: DataGridData) {\n    this.dataInternal = x || {};\n    this.refresh();\n  }\n\n  get revealed(): boolean {\n    if (this.revealedInternal !== undefined) {\n      return this.revealedInternal;\n    }\n\n    let currentAncestor: (DataGridNode<T>|null) = this.parent;\n    while (currentAncestor && !currentAncestor.isRoot) {\n      if (!currentAncestor.expanded) {\n        this.revealedInternal = false;\n        return false;\n      }\n\n      currentAncestor = currentAncestor.parent;\n    }\n\n    this.revealed = true;\n    return true;\n  }\n\n  set revealed(x: boolean) {\n    if (this.revealedInternal === x) {\n      return;\n    }\n\n    this.revealedInternal = x;\n\n    if (this.elementInternal) {\n      this.elementInternal.classList.toggle('revealed', this.revealedInternal);\n    }\n\n    for (let i = 0; i < this.children.length; ++i) {\n      this.children[i].revealed = x && this.expanded;\n    }\n  }\n\n  isDirty(): boolean {\n    return this.dirty;\n  }\n\n  setDirty(dirty: boolean): void {\n    if (this.dirty === dirty) {\n      return;\n    }\n    this.dirty = dirty;\n    if (!this.elementInternal) {\n      return;\n    }\n    if (dirty) {\n      this.elementInternal.classList.add('dirty');\n    } else {\n      this.elementInternal.classList.remove('dirty');\n    }\n  }\n\n  isInactive(): boolean {\n    return this.inactive;\n  }\n\n  setInactive(inactive: boolean): void {\n    if (this.inactive === inactive) {\n      return;\n    }\n    this.inactive = inactive;\n    if (!this.elementInternal) {\n      return;\n    }\n    if (inactive) {\n      this.elementInternal.classList.add('inactive');\n    } else {\n      this.elementInternal.classList.remove('inactive');\n    }\n  }\n\n  hasChildren(): boolean {\n    return this.hasChildrenInternal;\n  }\n\n  setHasChildren(x: boolean): void {\n    if (this.hasChildrenInternal === x) {\n      return;\n    }\n\n    this.hasChildrenInternal = x;\n\n    if (!this.elementInternal) {\n      return;\n    }\n\n    this.elementInternal.classList.toggle('parent', this.hasChildrenInternal);\n    this.elementInternal.classList.toggle('expanded', this.hasChildrenInternal && this.expanded);\n  }\n\n  get depth(): number {\n    if (this.depthInternal !== undefined) {\n      return this.depthInternal;\n    }\n    if (this.parent && !this.parent.isRoot) {\n      this.depthInternal = this.parent.depth + 1;\n    } else {\n      this.depthInternal = 0;\n    }\n    return this.depthInternal;\n  }\n\n  get leftPadding(): number {\n    return this.depth * (this.dataGrid ? this.dataGrid.indentWidth : 1);\n  }\n\n  get shouldRefreshChildren(): boolean {\n    return this.shouldRefreshChildrenInternal;\n  }\n\n  set shouldRefreshChildren(x: boolean) {\n    this.shouldRefreshChildrenInternal = x;\n    if (x && this.expanded) {\n      this.expand();\n    }\n  }\n\n  get selected(): boolean {\n    return this.selectedInternal;\n  }\n\n  set selected(x: boolean) {\n    if (x) {\n      this.select();\n    } else {\n      this.deselect();\n    }\n  }\n\n  get expanded(): boolean {\n    return this.expandedInternal;\n  }\n\n  set expanded(x: boolean) {\n    if (x) {\n      this.expand();\n    } else {\n      this.collapse();\n    }\n  }\n\n  refresh(): void {\n    if (!this.dataGrid) {\n      this.elementInternal = null;\n    }\n    if (!this.elementInternal) {\n      return;\n    }\n    this.createCells(this.elementInternal);\n  }\n\n  createTDWithClass(className: string): HTMLElement {\n    const cell = document.createElement('td');\n    if (className) {\n      cell.className = className;\n    }\n    const cellClass = this.dataGrid ? this.dataGrid.cellClass : null;\n    if (cellClass) {\n      cell.classList.add(cellClass);\n    }\n    return cell;\n  }\n\n  createTD(columnId: string): HTMLElement {\n    const cell = this.createTDWithClass(columnId + '-column');\n    nodeToColumnIdMap.set(cell, columnId);\n\n    if (this.dataGrid) {\n      const editableCell = this.dataGrid.columns[columnId].editable;\n\n      cell.setAttribute(\n          'jslog',\n          `${\n              VisualLogging.tableCell()\n                  .track({\n                    click: true,\n                    keydown: editableCell ? 'Enter|Space|Escape' : false,\n                    dblclick: editableCell,\n                    change: editableCell,\n                  })\n                  .context(Platform.StringUtilities.toKebabCase(columnId))}`);\n      const alignment = this.dataGrid.columns[columnId].align;\n      if (alignment) {\n        cell.classList.add(alignment);\n      }\n\n      if (columnId === this.dataGrid.disclosureColumnId) {\n        cell.classList.add('disclosure');\n        if (this.leftPadding) {\n          cell.style.setProperty('padding-left', this.leftPadding + 'px');\n        }\n      }\n\n      // Allow accessibility tool to identify the editable cell and display context menu\n      if (editableCell) {\n        cell.tabIndex = 0;\n        cell.ariaHasPopup = 'true';\n      }\n    }\n\n    return cell;\n  }\n\n  createCell(columnId: string): HTMLElement {\n    const cell = this.createTD(columnId);\n    const data = this.data[columnId];\n    if (data instanceof Node) {\n      cell.appendChild(data);\n    } else if (data !== null && this.dataGrid) {\n      this.dataGrid.setElementContent(cell, (data as string));\n    }\n\n    return cell;\n  }\n\n  setCellAccessibleName(name: string, cell: Element, columnId: string): void {\n    this.cellAccessibleTextMap.set(columnId, name);\n    // Mark all direct children of cell as hidden so cell name is properly announced\n    for (let i = 0; i < cell.children.length; i++) {\n      UI.ARIAUtils.markAsHidden(cell.children[i]);\n    }\n    UI.ARIAUtils.setLabel(cell, name);\n  }\n\n  nodeSelfHeight(): number {\n    return 20;\n  }\n\n  appendChild(child: DataGridNode<T>): void {\n    this.insertChild(child, this.children.length);\n  }\n\n  resetNode(onlyCaches?: boolean): void {\n    // @TODO(allada) This is a hack to make sure ViewportDataGrid can clean up these caches. Try Not To Use.\n    delete this.depthInternal;\n    delete this.revealedInternal;\n    if (onlyCaches) {\n      return;\n    }\n    if (this.previousSibling) {\n      this.previousSibling.nextSibling = this.nextSibling;\n    }\n    if (this.nextSibling) {\n      this.nextSibling.previousSibling = this.previousSibling;\n    }\n    this.dataGrid = null;\n    this.parent = null;\n    this.nextSibling = null;\n    this.previousSibling = null;\n    this.attachedInternal = false;\n  }\n\n  insertChild(child: DataGridNode<T>, index: number): void {\n    if (!child) {\n      throw 'insertChild: Node can\\'t be undefined or null.';\n    }\n    if (child.parent === this) {\n      const currentIndex = this.children.indexOf(child);\n      if (currentIndex < 0) {\n        console.assert(false, 'Inconsistent DataGrid state');\n      }\n      if (currentIndex === index) {\n        return;\n      }\n      if (currentIndex < index) {\n        --index;\n      }\n    }\n\n    child.remove();\n\n    this.children.splice(index, 0, child);\n    this.setHasChildren(true);\n\n    child.parent = this;\n    child.dataGrid = this.dataGrid;\n    child.recalculateSiblings(index);\n\n    child.shouldRefreshChildrenInternal = true;\n\n    let current: (DataGridNode<T>|null)|DataGridNode<T> = child.children[0];\n    while (current) {\n      current.resetNode(true);\n      current.dataGrid = this.dataGrid;\n      current.attachedInternal = false;\n      current.shouldRefreshChildrenInternal = true;\n      current = current.traverseNextNode(false, child, true);\n    }\n\n    if (this.expanded) {\n      child.attach();\n    }\n    if (!this.revealed) {\n      child.revealed = false;\n    }\n  }\n\n  remove(): void {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n  }\n\n  removeChild(child: DataGridNode<T>): void {\n    if (!child) {\n      throw 'removeChild: Node can\\'t be undefined or null.';\n    }\n    if (child.parent !== this) {\n      throw 'removeChild: Node is not a child of this node.';\n    }\n\n    if (this.dataGrid) {\n      this.dataGrid.updateSelectionBeforeRemoval(child, false);\n    }\n\n    child.detach();\n    child.resetNode();\n    Platform.ArrayUtilities.removeElement(this.children, child, true);\n\n    if (this.children.length <= 0) {\n      this.setHasChildren(false);\n    }\n  }\n\n  removeChildren(): void {\n    if (this.dataGrid) {\n      this.dataGrid.updateSelectionBeforeRemoval(this, true);\n    }\n    for (let i = 0; i < this.children.length; ++i) {\n      const child = this.children[i];\n      child.detach();\n      child.resetNode();\n    }\n\n    this.children = [];\n    this.setHasChildren(false);\n  }\n\n  recalculateSiblings(myIndex: number): void {\n    if (!this.parent) {\n      return;\n    }\n\n    const previousChild = this.parent.children[myIndex - 1] || null;\n    if (previousChild) {\n      previousChild.nextSibling = this;\n    }\n    this.previousSibling = previousChild;\n\n    const nextChild = this.parent.children[myIndex + 1] || null;\n    if (nextChild) {\n      nextChild.previousSibling = this;\n    }\n    this.nextSibling = nextChild;\n  }\n\n  collapse(): void {\n    if (this.isRoot) {\n      return;\n    }\n    if (this.elementInternal) {\n      this.elementInternal.classList.remove('expanded');\n    }\n\n    this.expandedInternal = false;\n    if (this.selected && this.dataGrid) {\n      this.dataGrid.announceSelectedGridNode();\n    }\n\n    for (let i = 0; i < this.children.length; ++i) {\n      this.children[i].revealed = false;\n    }\n  }\n\n  collapseRecursively(): void {\n    let item: (DataGridNode<T>|null)|this = this;\n    while (item) {\n      if (item.expanded) {\n        item.collapse();\n      }\n      item = item.traverseNextNode(false, this, true);\n    }\n  }\n\n  populate(): void {\n  }\n\n  expand(): void {\n    if (!this.hasChildrenInternal || this.expandedInternal) {\n      return;\n    }\n    if (this.isRoot) {\n      return;\n    }\n\n    if (this.revealed && !this.shouldRefreshChildrenInternal) {\n      for (let i = 0; i < this.children.length; ++i) {\n        this.children[i].revealed = true;\n      }\n    }\n\n    if (this.shouldRefreshChildrenInternal) {\n      for (let i = 0; i < this.children.length; ++i) {\n        this.children[i].detach();\n      }\n\n      this.populate();\n\n      if (this.attachedInternal) {\n        for (let i = 0; i < this.children.length; ++i) {\n          const child = this.children[i];\n          if (this.revealed) {\n            child.revealed = true;\n          }\n          child.attach();\n        }\n      }\n\n      this.shouldRefreshChildrenInternal = false;\n    }\n\n    if (this.elementInternal) {\n      this.elementInternal.classList.add('expanded');\n    }\n    if (this.selected && this.dataGrid) {\n      this.dataGrid.announceSelectedGridNode();\n    }\n\n    this.expandedInternal = true;\n  }\n\n  expandRecursively(): void {\n    let item: (DataGridNode<T>|null)|this = this;\n    while (item) {\n      item.expand();\n      item = item.traverseNextNode(false, this);\n    }\n  }\n\n  reveal(): void {\n    if (this.isRoot || !this.dataGrid) {\n      return;\n    }\n    let currentAncestor: (DataGridNode<T>|null) = this.parent;\n    while (currentAncestor && !currentAncestor.isRoot) {\n      if (!currentAncestor.expanded) {\n        currentAncestor.expand();\n      }\n      currentAncestor = currentAncestor.parent;\n    }\n\n    this.dataGrid.revealNode(this.element() as HTMLElement);\n  }\n\n  select(supressSelectedEvent?: boolean): void {\n    if (!this.dataGrid || !this.selectable || this.selected) {\n      return;\n    }\n\n    if (this.dataGrid.selectedNode) {\n      this.dataGrid.selectedNode.deselect();\n    }\n\n    this.selectedInternal = true;\n    this.dataGrid.selectedNode = this;\n\n    if (this.elementInternal) {\n      this.elementInternal.classList.add('selected');\n      this.elementInternal.focus();\n      this.dataGrid.setHasSelection(true);\n      this.dataGrid.announceSelectedGridNode();\n    }\n\n    if (!supressSelectedEvent) {\n      this.dataGrid.dispatchEventToListeners(Events.SELECTED_NODE, this);\n    }\n  }\n\n  revealAndSelect(): void {\n    if (this.isRoot) {\n      return;\n    }\n    this.reveal();\n    this.select();\n  }\n\n  deselect(supressDeselectedEvent?: boolean): void {\n    if (!this.dataGrid || this.dataGrid.selectedNode !== this || !this.selected) {\n      return;\n    }\n\n    this.selectedInternal = false;\n    this.dataGrid.selectedNode = null;\n\n    if (this.elementInternal) {\n      this.elementInternal.classList.remove('selected');\n      this.dataGrid.setHasSelection(false);\n    }\n\n    if (!supressDeselectedEvent) {\n      this.dataGrid.dispatchEventToListeners(Events.DESELECTED_NODE);\n    }\n  }\n\n  traverseNextNode(skipHidden: boolean, stayWithin?: DataGridNode<T>|null, dontPopulate?: boolean, info?: {\n    depthChange: number,\n  }): DataGridNode<T>|null {\n    if (!dontPopulate && this.hasChildrenInternal) {\n      this.populate();\n    }\n\n    if (info) {\n      info.depthChange = 0;\n    }\n\n    let node: (DataGridNode<T>|null)|this = (!skipHidden || this.revealed) ? this.children[0] : null;\n    if (node && (!skipHidden || this.expanded)) {\n      if (info) {\n        info.depthChange = 1;\n      }\n      return node;\n    }\n\n    if (this === stayWithin) {\n      return null;\n    }\n\n    node = (!skipHidden || this.revealed) ? this.nextSibling : null;\n    if (node) {\n      return node;\n    }\n\n    node = this;\n    while (node && !node.isRoot && !((!skipHidden || node.revealed) ? node.nextSibling : null) &&\n           node.parent !== stayWithin) {\n      if (info) {\n        info.depthChange -= 1;\n      }\n      node = node.parent;\n    }\n\n    if (!node) {\n      return null;\n    }\n\n    return (!skipHidden || node.revealed) ? node.nextSibling : null;\n  }\n\n  traversePreviousNode(skipHidden: boolean, dontPopulate?: boolean): DataGridNode<T>|null {\n    let node: (DataGridNode<T>|null) = (!skipHidden || this.revealed) ? this.previousSibling : null;\n    if (!dontPopulate && node && node.hasChildrenInternal) {\n      node.populate();\n    }\n\n    while (node &&\n           ((!skipHidden || (node.revealed && node.expanded)) ? node.children[node.children.length - 1] : null)) {\n      if (!dontPopulate && node.hasChildrenInternal) {\n        node.populate();\n      }\n      node = ((!skipHidden || (node.revealed && node.expanded)) ? node.children[node.children.length - 1] : null);\n    }\n\n    if (node) {\n      return node;\n    }\n\n    if (!this.parent || this.parent.isRoot) {\n      return null;\n    }\n\n    return this.parent;\n  }\n\n  isEventWithinDisclosureTriangle(event: MouseEvent): boolean {\n    if (!this.hasChildrenInternal) {\n      return false;\n    }\n    const cell = UI.UIUtils.enclosingNodeOrSelfWithNodeName((event.target as Node), 'td');\n    if (!cell || !(cell instanceof HTMLElement) || !cell.classList.contains('disclosure')) {\n      return false;\n    }\n\n    const left = cell.getBoundingClientRect().left + this.leftPadding;\n    return event.pageX >= left && event.pageX <= left + this.#disclosureToggleHitBoxWidth;\n  }\n\n  private attach(): void {\n    if (!this.dataGrid || this.attachedInternal) {\n      return;\n    }\n\n    this.attachedInternal = true;\n\n    const previousNode = this.traversePreviousNode(true, true);\n    const previousElement = previousNode ? previousNode.element() : this.dataGrid.topFillerRow;\n    this.dataGrid.dataTableBody.insertBefore(this.element(), previousElement.nextSibling);\n\n    if (this.expandedInternal) {\n      for (let i = 0; i < this.children.length; ++i) {\n        this.children[i].attach();\n      }\n    }\n  }\n\n  private detach(): void {\n    if (!this.attachedInternal) {\n      return;\n    }\n\n    this.attachedInternal = false;\n\n    if (this.elementInternal) {\n      this.elementInternal.remove();\n    }\n\n    for (let i = 0; i < this.children.length; ++i) {\n      this.children[i].detach();\n    }\n  }\n\n  savePosition(): void {\n    if (this.savedPosition) {\n      return;\n    }\n\n    if (!this.parent) {\n      throw 'savePosition: Node must have a parent.';\n    }\n    this.savedPosition = {parent: this.parent, index: this.parent.children.indexOf(this)};\n  }\n\n  restorePosition(): void {\n    if (!this.savedPosition) {\n      return;\n    }\n\n    if (this.parent !== this.savedPosition.parent) {\n      this.savedPosition.parent.insertChild(this, this.savedPosition.index);\n    }\n\n    this.savedPosition = null;\n  }\n}\n\nexport class CreationDataGridNode<T> extends DataGridNode<T> {\n  override isCreationNode: boolean;\n  constructor(\n      data?: {\n        [x: string]: any,\n      }|null,\n      hasChildren?: boolean) {\n    super(data, hasChildren);\n    this.isCreationNode = true;\n  }\n\n  makeNormal(): void {\n    this.isCreationNode = false;\n  }\n}\n\nexport class DataGridWidget<T> extends UI.Widget.VBox {\n  readonly dataGrid: DataGridImpl<T>;\n  constructor(dataGrid: DataGridImpl<T>, element?: HTMLElement) {\n    super(undefined, undefined, element);\n    this.dataGrid = dataGrid;\n    this.element.appendChild(dataGrid.element);\n    this.setDefaultFocusedElement(dataGrid.element);\n  }\n\n  override wasShown(): void {\n    this.registerCSSFiles([dataGridStyles]);\n    this.dataGrid.wasShown();\n  }\n\n  override willHide(): void {\n    this.dataGrid.willHide();\n  }\n\n  override onResize(): void {\n    this.dataGrid.onResize();\n  }\n\n  override elementsToRestoreScrollPositionsFor(): Element[] {\n    return [this.dataGrid.scrollContainer];\n  }\n}\n\nexport type DataGridWidgetOptions<T> = Parameters&{\n  markAsRoot?: boolean,\n  striped?: boolean, nodes: DataGridNode<T>[],\n};\n\nexport class DataGridWidgetElement<T> extends UI.Widget.WidgetElement<DataGridWidget<T>> {\n  #options: DataGridWidgetOptions<T>;\n  widget?: DataGridWidget<T>;\n\n  constructor() {\n    super();\n    // default values for options\n    this.#options = {\n      displayName: 'dataGrid',\n      columns: [],\n      nodes: [],\n    };\n  }\n\n  set options(options: DataGridWidgetOptions<T>) {\n    this.#options = options;\n    this.#updateGrid();\n  }\n\n  override createWidget(): DataGridWidget<T> {\n    const dataGridImpl = new DataGridImpl<T>(this.#options);\n\n    // Translate existing DataGridImpl (\"ObjectWrapper\") events to DOM CustomEvents so clients can\n    // use lit templates to bind listeners.\n    dataGridImpl.addEventListener(Events.SELECTED_NODE, this.#selectedNode.bind(this));\n    dataGridImpl.addEventListener(Events.DESELECTED_NODE, this.#deselectedNode.bind(this));\n    dataGridImpl.addEventListener(Events.OPENED_NODE, this.#openedNode.bind(this));\n    dataGridImpl.addEventListener(Events.SORTING_CHANGED, this.#sortingChanged.bind(this));\n    dataGridImpl.addEventListener(Events.PADDING_CHANGED, this.#paddingChanged.bind(this));\n    this.widget = dataGridImpl.asWidget(this);\n\n    if (this.#options.markAsRoot) {\n      this.widget.markAsRoot();\n    }\n\n    this.#updateGrid();\n\n    return this.widget;\n  }\n\n  #updateGrid(): void {\n    if (this.widget) {\n      this.widget.dataGrid.rootNode().removeChildren();\n      for (const node of this.#options.nodes) {\n        this.widget.dataGrid.rootNode().appendChild(node);\n      }\n\n      if (this.#options.striped) {\n        this.widget.dataGrid.setStriped(true);\n      }\n    }\n  }\n\n  #selectedNode(event: Common.EventTarget.EventTargetEvent<DataGridNode<T>>): void {\n    const domEvent = new CustomEvent('selectedNode', {detail: event.data});\n    this.dispatchEvent(domEvent);\n  }\n\n  #deselectedNode(): void {\n    const domEvent = new CustomEvent('deselectedNode');\n    this.dispatchEvent(domEvent);\n  }\n\n  #openedNode(event: Common.EventTarget.EventTargetEvent<DataGridNode<T>>): void {\n    const domEvent = new CustomEvent('openedNode', {detail: event.data});\n    this.dispatchEvent(domEvent);\n  }\n\n  #sortingChanged(): void {\n    const domEvent = new CustomEvent('sortingChanged');\n    this.dispatchEvent(domEvent);\n  }\n\n  #paddingChanged(): void {\n    const domEvent = new CustomEvent('paddingChanged');\n    this.dispatchEvent(domEvent);\n  }\n}\n\ncustomElements.define('devtools-data-grid-widget', DataGridWidgetElement);\n\nexport interface Parameters {\n  displayName: string;\n  columns: ColumnDescriptor[];\n  editCallback?: ((arg0: any, arg1: string, arg2: any, arg3: any) => void);\n  deleteCallback?: ((arg0: any) => void);\n  refreshCallback?: (() => void);\n}\nexport interface ColumnDescriptor {\n  id: Lowercase<string>;\n  title?: Common.UIString.LocalizedString;\n  titleDOMFragment?: DocumentFragment|null;\n  sortable: boolean;\n  sort?: Order|null;\n  align?: Align|null;\n  width?: string;\n  fixedWidth?: boolean;\n  editable?: boolean;\n  nonSelectable?: boolean;\n  longText?: boolean;\n  disclosure?: boolean;\n  weight?: number;\n  allowInSortByEvenWhenHidden?: boolean;\n  dataType?: DataType|null;\n  defaultWeight?: number;\n}\n"],
  "mappings": "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",
  "names": ["Events", "Order", "Align", "DataType", "ResizeMethod"]
}
