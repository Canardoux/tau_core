{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/components/text_editor/ExecutionPositionHighlighter.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as CodeMirror from '../../../third_party/codemirror.next/codemirror.next.js';\n\n/**\n * The CodeMirror effect used to change the highlighted execution position.\n *\n * Usage:\n * ```js\n * view.dispatch({effects: setHighlightedPosition.of(position)});\n * ```\n */\nexport const setHighlightedPosition = CodeMirror.StateEffect.define<number>();\n\n/**\n * The CodeMirror effect used to clear the highlighted execution position.\n *\n * Usage:\n * ```js\n * view.dispatch({effects: clearHighlightedPosition.of()});\n * ```\n */\nexport const clearHighlightedPosition = CodeMirror.StateEffect.define<void>();\n\n/**\n * Constructs a CodeMirror extension that can be used to decorate the current execution\n * line (and token), for example when the debugger is paused, with specific CSS classes.\n *\n * @param executionLineClassName The CSS class name to use for decorating the execution line (e.g. `'cm-executionLine'`).\n * @param executionTokenClassName The CSS class name to use for decorating the execution token (e.g. `'cm-executionToken'`).\n *\n * @returns a CodeMirror extension that highlights the current execution line and token when set.\n */\nexport function positionHighlighter(\n    executionLineClassName: string,\n    executionTokenClassName: string,\n    ): CodeMirror.Extension {\n  const executionLine = CodeMirror.Decoration.line({attributes: {class: executionLineClassName}});\n  const executionToken = CodeMirror.Decoration.mark({attributes: {class: executionTokenClassName}});\n\n  const positionHighlightedState = CodeMirror.StateField.define<null|number>({\n    create() {\n      return null;\n    },\n\n    update(pos, tr) {\n      if (pos) {\n        pos = tr.changes.mapPos(pos, -1, CodeMirror.MapMode.TrackDel);\n      }\n      for (const effect of tr.effects) {\n        if (effect.is(clearHighlightedPosition)) {\n          pos = null;\n        } else if (effect.is(setHighlightedPosition)) {\n          pos = Math.max(0, Math.min(effect.value, tr.newDoc.length - 1));\n        }\n      }\n      return pos;\n    },\n  });\n\n  function getHighlightedPosition(state: CodeMirror.EditorState): null|number {\n    return state.field(positionHighlightedState);\n  }\n\n  class PositionHighlighter {\n    tree: CodeMirror.Tree;\n    decorations: CodeMirror.DecorationSet;\n\n    constructor({state}: CodeMirror.EditorView) {\n      this.tree = CodeMirror.syntaxTree(state);\n      this.decorations = this.#computeDecorations(state, getHighlightedPosition(state));\n    }\n\n    update(update: CodeMirror.ViewUpdate): void {\n      const tree = CodeMirror.syntaxTree(update.state);\n      const position = getHighlightedPosition(update.state);\n      const positionChanged = position !== getHighlightedPosition(update.startState);\n      if (tree.length !== this.tree.length || positionChanged) {\n        this.tree = tree;\n        this.decorations = this.#computeDecorations(update.state, position);\n      } else {\n        this.decorations = this.decorations.map(update.changes);\n      }\n    }\n\n    #computeDecorations(state: CodeMirror.EditorState, position: null|number): CodeMirror.DecorationSet {\n      const builder = new CodeMirror.RangeSetBuilder<CodeMirror.Decoration>();\n      if (position !== null) {\n        const {doc} = state;\n        const line = doc.lineAt(position);\n        builder.add(line.from, line.from, executionLine);\n        const syntaxTree = CodeMirror.syntaxTree(state);\n        const syntaxNode = syntaxTree.resolveInner(position, 1);\n        const tokenEnd = Math.min(line.to, syntaxNode.to);\n        if (tokenEnd > position) {\n          builder.add(position, tokenEnd, executionToken);\n        }\n      }\n      return builder.finish();\n    }\n  }\n\n  const positionHighlighterSpec = {\n    decorations: ({decorations}: PositionHighlighter) => decorations,\n  };\n\n  return [\n    positionHighlightedState,\n    CodeMirror.ViewPlugin.fromClass(PositionHighlighter, positionHighlighterSpec),\n  ];\n}\n"],
  "mappings": ";AAIA,YAAY,gBAAgB;AAUrB,aAAM,yBAAyB,WAAW,YAAY,OAAe;AAUrE,aAAM,2BAA2B,WAAW,YAAY,OAAa;AAWrE,gBAAS,oBACZ,wBACA,yBACwB;AAC1B,QAAM,gBAAgB,WAAW,WAAW,KAAK,EAAC,YAAY,EAAC,OAAO,uBAAsB,EAAC,CAAC;AAC9F,QAAM,iBAAiB,WAAW,WAAW,KAAK,EAAC,YAAY,EAAC,OAAO,wBAAuB,EAAC,CAAC;AAEhG,QAAM,2BAA2B,WAAW,WAAW,OAAoB;AAAA,IACzE,SAAS;AACP,aAAO;AAAA,IACT;AAAA,IAEA,OAAO,KAAK,IAAI;AACd,UAAI,KAAK;AACP,cAAM,GAAG,QAAQ,OAAO,KAAK,IAAI,WAAW,QAAQ,QAAQ;AAAA,MAC9D;AACA,iBAAW,UAAU,GAAG,SAAS;AAC/B,YAAI,OAAO,GAAG,wBAAwB,GAAG;AACvC,gBAAM;AAAA,QACR,WAAW,OAAO,GAAG,sBAAsB,GAAG;AAC5C,gBAAM,KAAK,IAAI,GAAG,KAAK,IAAI,OAAO,OAAO,GAAG,OAAO,SAAS,CAAC,CAAC;AAAA,QAChE;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AAED,WAAS,uBAAuB,OAA4C;AAC1E,WAAO,MAAM,MAAM,wBAAwB;AAAA,EAC7C;AAAA,EAEA,MAAM,oBAAoB;AAAA,IACxB;AAAA,IACA;AAAA,IAEA,YAAY,EAAC,MAAK,GAA0B;AAC1C,WAAK,OAAO,WAAW,WAAW,KAAK;AACvC,WAAK,cAAc,KAAK,oBAAoB,OAAO,uBAAuB,KAAK,CAAC;AAAA,IAClF;AAAA,IAEA,OAAO,QAAqC;AAC1C,YAAM,OAAO,WAAW,WAAW,OAAO,KAAK;AAC/C,YAAM,WAAW,uBAAuB,OAAO,KAAK;AACpD,YAAM,kBAAkB,aAAa,uBAAuB,OAAO,UAAU;AAC7E,UAAI,KAAK,WAAW,KAAK,KAAK,UAAU,iBAAiB;AACvD,aAAK,OAAO;AACZ,aAAK,cAAc,KAAK,oBAAoB,OAAO,OAAO,QAAQ;AAAA,MACpE,OAAO;AACL,aAAK,cAAc,KAAK,YAAY,IAAI,OAAO,OAAO;AAAA,MACxD;AAAA,IACF;AAAA,IAEA,oBAAoB,OAA+B,UAAiD;AAClG,YAAM,UAAU,IAAI,WAAW,gBAAuC;AACtE,UAAI,aAAa,MAAM;AACrB,cAAM,EAAC,IAAG,IAAI;AACd,cAAM,OAAO,IAAI,OAAO,QAAQ;AAChC,gBAAQ,IAAI,KAAK,MAAM,KAAK,MAAM,aAAa;AAC/C,cAAM,aAAa,WAAW,WAAW,KAAK;AAC9C,cAAM,aAAa,WAAW,aAAa,UAAU,CAAC;AACtD,cAAM,WAAW,KAAK,IAAI,KAAK,IAAI,WAAW,EAAE;AAChD,YAAI,WAAW,UAAU;AACvB,kBAAQ,IAAI,UAAU,UAAU,cAAc;AAAA,QAChD;AAAA,MACF;AACA,aAAO,QAAQ,OAAO;AAAA,IACxB;AAAA,EACF;AAEA,QAAM,0BAA0B;AAAA,IAC9B,aAAa,CAAC,EAAC,YAAW,MAA2B;AAAA,EACvD;AAEA,SAAO;AAAA,IACL;AAAA,IACA,WAAW,WAAW,UAAU,qBAAqB,uBAAuB;AAAA,EAC9E;AACF;",
  "names": []
}
