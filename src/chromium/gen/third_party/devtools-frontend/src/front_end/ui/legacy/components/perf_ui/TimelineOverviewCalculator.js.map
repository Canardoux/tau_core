{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/legacy/components/perf_ui/TimelineOverviewCalculator.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Trace from '../../../../models/trace/trace.js';\n\nimport type {Calculator} from './TimelineGrid.js';\n\nexport class TimelineOverviewCalculator implements Calculator {\n  #minimumBoundary: Trace.Types.Timing.MilliSeconds = Trace.Types.Timing.MilliSeconds(0);\n  #maximumBoundary: Trace.Types.Timing.MilliSeconds = Trace.Types.Timing.MilliSeconds(100);\n\n  #displayWidth: number = 0;\n  private navStartTimes?: readonly Trace.Types.Events.NavigationStart[];\n\n  /**\n   * Given a timestamp, returns its x position in the minimap.\n   *\n   * @param time\n   * @returns position in pixel\n   */\n  computePosition(time: Trace.Types.Timing.MilliSeconds): number {\n    return (time - this.#minimumBoundary) / this.boundarySpan() * this.#displayWidth;\n  }\n\n  positionToTime(position: number): Trace.Types.Timing.MilliSeconds {\n    if (this.#displayWidth === 0) {\n      return Trace.Types.Timing.MilliSeconds(0);\n    }\n    return Trace.Types.Timing.MilliSeconds(position / this.#displayWidth * this.boundarySpan() + this.#minimumBoundary);\n  }\n\n  setBounds(minimumBoundary: Trace.Types.Timing.MilliSeconds, maximumBoundary: Trace.Types.Timing.MilliSeconds): void {\n    this.#minimumBoundary = minimumBoundary;\n    this.#maximumBoundary = maximumBoundary;\n  }\n\n  setNavStartTimes(navStartTimes: readonly Trace.Types.Events.NavigationStart[]): void {\n    this.navStartTimes = navStartTimes;\n  }\n\n  setDisplayWidth(clientWidth: number): void {\n    this.#displayWidth = clientWidth;\n  }\n\n  reset(): void {\n    this.setBounds(\n        Trace.Types.Timing.MilliSeconds(0),\n        Trace.Types.Timing.MilliSeconds(100),\n    );\n  }\n\n  formatValue(time: Trace.Types.Timing.MilliSeconds, precision?: number): string {\n    // If there are nav start times the value needs to be remapped.\n    if (this.navStartTimes) {\n      // Find the latest possible nav start time which is considered earlier\n      // than the value passed through.\n      for (let i = this.navStartTimes.length - 1; i >= 0; i--) {\n        const startTimeMilliseconds = Trace.Helpers.Timing.microSecondsToMilliseconds(\n            this.navStartTimes[i].ts,\n        );\n\n        if (time > startTimeMilliseconds) {\n          time = Trace.Types.Timing.MilliSeconds(time - (startTimeMilliseconds - this.zeroTime()));\n          break;\n        }\n      }\n    }\n\n    return i18n.TimeUtilities.preciseMillisToString(time - this.zeroTime(), precision);\n  }\n\n  maximumBoundary(): Trace.Types.Timing.MilliSeconds {\n    return this.#maximumBoundary;\n  }\n\n  minimumBoundary(): Trace.Types.Timing.MilliSeconds {\n    return this.#minimumBoundary;\n  }\n\n  zeroTime(): Trace.Types.Timing.MilliSeconds {\n    return this.#minimumBoundary;\n  }\n\n  /**\n   * This function returns the time different between min time and max time of current minimap.\n   *\n   * @returns the time range in milliseconds\n   */\n  boundarySpan(): Trace.Types.Timing.MilliSeconds {\n    return Trace.Types.Timing.MilliSeconds(this.#maximumBoundary - this.#minimumBoundary);\n  }\n}\n"],
  "mappings": ";AAGA,YAAY,UAAU;AACtB,YAAY,WAAW;AAIhB,aAAM,2BAAiD;AAAA,EAC5D,mBAAoD,MAAM,MAAM,OAAO,aAAa,CAAC;AAAA,EACrF,mBAAoD,MAAM,MAAM,OAAO,aAAa,GAAG;AAAA,EAEvF,gBAAwB;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQR,gBAAgB,MAA+C;AAC7D,YAAQ,OAAO,KAAK,oBAAoB,KAAK,aAAa,IAAI,KAAK;AAAA,EACrE;AAAA,EAEA,eAAe,UAAmD;AAChE,QAAI,KAAK,kBAAkB,GAAG;AAC5B,aAAO,MAAM,MAAM,OAAO,aAAa,CAAC;AAAA,IAC1C;AACA,WAAO,MAAM,MAAM,OAAO,aAAa,WAAW,KAAK,gBAAgB,KAAK,aAAa,IAAI,KAAK,gBAAgB;AAAA,EACpH;AAAA,EAEA,UAAU,iBAAkD,iBAAwD;AAClH,SAAK,mBAAmB;AACxB,SAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEA,iBAAiB,eAAoE;AACnF,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,gBAAgB,aAA2B;AACzC,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,QAAc;AACZ,SAAK;AAAA,MACD,MAAM,MAAM,OAAO,aAAa,CAAC;AAAA,MACjC,MAAM,MAAM,OAAO,aAAa,GAAG;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,YAAY,MAAuC,WAA4B;AAE7E,QAAI,KAAK,eAAe;AAGtB,eAAS,IAAI,KAAK,cAAc,SAAS,GAAG,KAAK,GAAG,KAAK;AACvD,cAAM,wBAAwB,MAAM,QAAQ,OAAO;AAAA,UAC/C,KAAK,cAAc,CAAC,EAAE;AAAA,QAC1B;AAEA,YAAI,OAAO,uBAAuB;AAChC,iBAAO,MAAM,MAAM,OAAO,aAAa,QAAQ,wBAAwB,KAAK,SAAS,EAAE;AACvF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,KAAK,cAAc,sBAAsB,OAAO,KAAK,SAAS,GAAG,SAAS;AAAA,EACnF;AAAA,EAEA,kBAAmD;AACjD,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,kBAAmD;AACjD,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,WAA4C;AAC1C,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAgD;AAC9C,WAAO,MAAM,MAAM,OAAO,aAAa,KAAK,mBAAmB,KAAK,gBAAgB;AAAA,EACtF;AACF;",
  "names": []
}
