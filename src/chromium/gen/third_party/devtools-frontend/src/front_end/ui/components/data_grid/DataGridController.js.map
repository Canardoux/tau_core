{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/components/data_grid/DataGridController.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport './DataGrid.js';\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport type * as TextUtils from '../../../models/text_utils/text_utils.js';\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\nimport * as UI from '../../legacy/legacy.js';\n\nimport type {DataGridContextMenusConfiguration} from './DataGrid.js';\nimport dataGridControllerStyles from './dataGridController.css.js';\nimport type {ColumnHeaderClickEvent, ContextMenuColumnSortClickEvent} from './DataGridEvents.js';\nimport {\n  type Column,\n  getRowEntryForColumnId,\n  getStringifiedCellValues,\n  type Row,\n  SortDirection,\n  type SortState,\n} from './DataGridUtils.js';\n\nconst {html} = LitHtml;\n\nconst UIStrings = {\n  /**\n   *@description Text announced when the column is sorted in ascending order\n   *@example {title} PH1\n   */\n  sortInAscendingOrder: '{PH1} sorted in ascending order',\n  /**\n   *@description Text announced when the column is sorted in descending order\n   *@example {title} PH1\n   */\n  sortInDescendingOrder: '{PH1} sorted in descending order',\n  /**\n   *@description Text announced when the column sorting canceled\n   *@example {title} PH1\n   */\n  sortingCanceled: '{PH1} sorting canceled',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/components/data_grid/DataGridController.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport interface DataGridControllerData {\n  columns: Column[];\n  rows: Row[];\n  filters?: readonly TextUtils.TextUtils.ParsedFilter[];\n  /**\n   * Sets an initial sort state for the data grid. Is only used if the component\n   * hasn't rendered yet. If you pass this in on subsequent renders, it is\n   * ignored.\n   */\n  initialSort?: SortState;\n  contextMenus?: DataGridContextMenusConfiguration;\n  label?: string;\n  paddingRowsCount?: number;\n  showScrollbar?: boolean;\n  striped?: boolean;\n  /**\n   * Disable the auto-scroll on new data feature. This is enabled by default.\n   */\n  autoScrollToBottom?: boolean;\n}\n\nexport class DataGridController extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n\n  #hasRenderedAtLeastOnce = false;\n  #columns: readonly Column[] = [];\n  #rows: Row[] = [];\n  #contextMenus?: DataGridContextMenusConfiguration = undefined;\n  #label?: string = undefined;\n  #showScrollbar?: boolean = false;\n  #striped?: boolean = false;\n\n  /**\n   * Because the controller will sort data in place (e.g. mutate it) when we get\n   * new data in we store the original data separately. This is so we don't\n   * mutate the data we're given, but a copy of the data. If our `get data` is\n   * called, we'll return the original, not the sorted data.\n   */\n  #originalColumns: readonly Column[] = [];\n  #originalRows: Row[] = [];\n\n  #sortState: Readonly<SortState>|null = null;\n  #filters: readonly TextUtils.TextUtils.ParsedFilter[] = [];\n\n  #autoScrollToBottom = true;\n\n  #paddingRowsCount?: number;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [dataGridControllerStyles];\n  }\n\n  get data(): DataGridControllerData {\n    return {\n      columns: this.#originalColumns as Column[],\n      rows: this.#originalRows as Row[],\n      filters: this.#filters,\n      autoScrollToBottom: this.#autoScrollToBottom,\n      contextMenus: this.#contextMenus,\n      label: this.#label,\n      paddingRowsCount: this.#paddingRowsCount,\n      showScrollbar: this.#showScrollbar,\n      striped: this.#striped,\n    };\n  }\n\n  set data(data: DataGridControllerData) {\n    this.#originalColumns = data.columns;\n    this.#originalRows = data.rows;\n    this.#contextMenus = data.contextMenus;\n    this.#filters = data.filters || [];\n    this.#contextMenus = data.contextMenus;\n    this.#label = data.label;\n    this.#showScrollbar = data.showScrollbar;\n    this.#striped = data.striped;\n    if (typeof data.autoScrollToBottom === 'boolean') {\n      this.#autoScrollToBottom = data.autoScrollToBottom;\n    }\n\n    this.#columns = [...this.#originalColumns];\n    this.#rows = this.#cloneAndFilterRows(data.rows, this.#filters);\n\n    if (!this.#hasRenderedAtLeastOnce && data.initialSort) {\n      this.#sortState = data.initialSort;\n    }\n\n    if (this.#sortState) {\n      this.#sortRows(this.#sortState);\n    }\n\n    this.#paddingRowsCount = data.paddingRowsCount;\n\n    this.#render();\n  }\n\n  #testRowWithFilter(row: Row, filter: TextUtils.TextUtils.ParsedFilter, visibleColumnIds: Set<string>): boolean {\n    let rowMatchesFilter = false;\n\n    const {key, text, negative, regex} = filter;\n\n    let dataToTest;\n    if (key) {\n      dataToTest = getStringifiedCellValues([getRowEntryForColumnId(row, key)]);\n    } else {\n      dataToTest = getStringifiedCellValues(row.cells.filter(cell => visibleColumnIds.has(cell.columnId)));\n    }\n\n    if (regex) {\n      rowMatchesFilter = regex.test(dataToTest);\n    } else if (text) {\n      rowMatchesFilter = dataToTest.includes(text.toLowerCase());\n    }\n\n    // If `negative` is set to `true`, that means we have to flip the final\n    // result, because the filter is matching anything that doesn't match. e.g.\n    // {text: 'foo', negative: false} matches rows that contain the text `foo`\n    // but {text: 'foo', negative: true} matches rows that do NOT contain the\n    // text `foo` so if a filter is marked as negative, we first match against\n    // that filter, and then we flip it here.\n    return negative ? !rowMatchesFilter : rowMatchesFilter;\n  }\n\n  #cloneAndFilterRows(rows: Row[], filters: readonly TextUtils.TextUtils.ParsedFilter[]): Row[] {\n    if (filters.length === 0) {\n      return [...rows];\n    }\n\n    const visibleColumnIds = new Set(this.#columns.filter(column => column.visible).map(column => column.id));\n    return rows.map(row => {\n      // We assume that the row should be visible by default.\n      let rowShouldBeVisible = true;\n      for (const filter of filters) {\n        const rowMatchesFilter = this.#testRowWithFilter(row, filter, visibleColumnIds);\n        // If there are multiple filters, if any return false we hide the row.\n        // So if we get a false from testRowWithFilter, we can break early and return false.\n        if (!rowMatchesFilter) {\n          rowShouldBeVisible = false;\n          break;\n        }\n      }\n      return {\n        ...row,\n        hidden: !rowShouldBeVisible,\n      };\n    });\n  }\n\n  #sortRows(state: SortState): void {\n    const {columnId, direction} = state;\n\n    this.#rows.sort((row1, row2) => {\n      const cell1 = getRowEntryForColumnId(row1, columnId);\n      const cell2 = getRowEntryForColumnId(row2, columnId);\n\n      const value1 = typeof cell1.value === 'number' ? cell1.value : String(cell1.value).toUpperCase();\n      const value2 = typeof cell2.value === 'number' ? cell2.value : String(cell2.value).toUpperCase();\n      if (value1 < value2) {\n        return direction === SortDirection.ASC ? -1 : 1;\n      }\n      if (value1 > value2) {\n        return direction === SortDirection.ASC ? 1 : -1;\n      }\n      return 0;\n    });\n    this.#render();\n  }\n\n  #onColumnHeaderClick(event: ColumnHeaderClickEvent): void {\n    const {column} = event.data;\n    if (column.sortable) {\n      this.#applySortOnColumn(column);\n    }\n  }\n\n  #applySortOnColumn(column: Column): void {\n    if (this.#sortState && this.#sortState.columnId === column.id) {\n      const {columnId, direction} = this.#sortState;\n\n      /* When users sort, we go No Sort => ASC => DESC => No sort\n       * So if the current direction is DESC, we clear the state.\n       */\n      if (direction === SortDirection.DESC) {\n        this.#sortState = null;\n      } else {\n        /* The state is ASC, so toggle to DESC */\n        this.#sortState = {\n          columnId,\n          direction: SortDirection.DESC,\n        };\n      }\n    } else {\n      /* The column wasn't previously sorted, so we sort it in ASC order. */\n      this.#sortState = {\n        columnId: column.id,\n        direction: SortDirection.ASC,\n      };\n    }\n    const headerName = column.title;\n\n    if (this.#sortState) {\n      this.#sortRows(this.#sortState);\n      UI.ARIAUtils.alert(\n          this.#sortState.direction === SortDirection.ASC ?\n              i18nString(UIStrings.sortInAscendingOrder, {PH1: headerName || ''}) :\n              i18nString(UIStrings.sortInDescendingOrder, {PH1: headerName || ''}));\n    } else {\n      // No sortstate = render the original rows.\n      this.#rows = this.#cloneAndFilterRows(this.#originalRows, this.#filters);\n      this.#render();\n      UI.ARIAUtils.alert(i18nString(UIStrings.sortingCanceled, {PH1: headerName || ''}));\n    }\n  }\n\n  #onContextMenuColumnSortClick(event: ContextMenuColumnSortClickEvent): void {\n    this.#applySortOnColumn(event.data.column);\n  }\n\n  #onContextMenuHeaderResetClick(): void {\n    this.#sortState = null;\n    this.#rows = [...this.#originalRows];\n    this.#render();\n  }\n\n  #render(): void {\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    LitHtml.render(html`\n      <devtools-data-grid .data=${{\n          columns: this.#columns,\n          rows: this.#rows,\n          activeSort: this.#sortState,\n          contextMenus: this.#contextMenus,\n          label: this.#label,\n          paddingRowsCount: this.#paddingRowsCount,\n          showScrollbar: this.#showScrollbar,\n          striped: this.#striped,\n          autoScrollToBottom: this.#autoScrollToBottom,\n        }}\n        @columnheaderclick=${this.#onColumnHeaderClick}\n        @contextmenucolumnsortclick=${this.#onContextMenuColumnSortClick}\n        @contextmenuheaderresetclick=${this.#onContextMenuHeaderResetClick}\n     ></devtools-data-grid>\n    `, this.#shadow, {\n      host: this,\n    });\n    // clang-format on\n    this.#hasRenderedAtLeastOnce = true;\n  }\n}\n\ncustomElements.define('devtools-data-grid-controller', DataGridController);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-data-grid-controller': DataGridController;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
