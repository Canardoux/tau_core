{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/components/render_coordinator/RenderCoordinator.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Components don't orchestrate their DOM updates in a wider context\n * (i.e. the host frame's document), which leads to interleaved reading\n * and writing of layout-centric values, e.g. clientHeight, scrollTop etc.\n *\n * This helper to ensure that we do reads, writes, and scrolls at the\n * correct point in the frame lifecycle. It groups reads to the start of a\n * frame, where we can assume layout-centric values are available on the\n * basis of the last completed frame, and then it runs all writes\n * afterwards. In the event that a read / write / scroll callback contains\n * calls for more read / write / scroll calls, such calls will be scheduled\n * for the next available frame.\n */\n\ninterface CoordinatorCallback<T> {\n  (): T|PromiseLike<T>;\n}\n\nclass WorkItem<T> {\n  readonly promise: Promise<T>;\n  readonly trigger: () => void;\n  readonly cancel: (e: Error) => void;\n  readonly label: string;\n  #handler: CoordinatorCallback<T>;\n\n  constructor(label: string, initialHandler: CoordinatorCallback<T>) {\n    const {promise, resolve, reject} = Promise.withResolvers<void>();\n    this.promise = promise.then(() => this.#handler());\n    this.trigger = resolve;\n    this.cancel = reject;\n    this.label = label;\n    this.#handler = initialHandler;\n  }\n\n  set handler(newHandler: CoordinatorCallback<T>) {\n    this.#handler = newHandler;\n  }\n}\n\ninterface CoordinatorLogEntry {\n  time: number;\n  value: string;\n}\n\nconst enum ACTION {\n  READ = 'read',\n  WRITE = 'write',\n}\n\nexport class RenderCoordinatorQueueEmptyEvent extends Event {\n  static readonly eventName = 'renderqueueempty';\n  constructor() {\n    super(RenderCoordinatorQueueEmptyEvent.eventName);\n  }\n}\n\nexport class RenderCoordinatorNewFrameEvent extends Event {\n  static readonly eventName = 'newframe';\n  constructor() {\n    super(RenderCoordinatorNewFrameEvent.eventName);\n  }\n}\n\nlet renderCoordinatorInstance: RenderCoordinator;\n\nconst UNNAMED_READ = 'Unnamed read';\nconst UNNAMED_WRITE = 'Unnamed write';\nconst UNNAMED_SCROLL = 'Unnamed scroll';\nconst DEADLOCK_TIMEOUT = 1500;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).__getRenderCoordinatorPendingFrames = function(): number {\n  return RenderCoordinator.pendingFramesCount();\n};\n\nexport class RenderCoordinator extends EventTarget {\n  static instance({forceNew = false} = {}): RenderCoordinator {\n    if (!renderCoordinatorInstance || forceNew) {\n      renderCoordinatorInstance = new RenderCoordinator();\n    }\n\n    return renderCoordinatorInstance;\n  }\n\n  static pendingFramesCount(): number {\n    if (!renderCoordinatorInstance) {\n      throw new Error('No render coordinator instance found.');\n    }\n\n    return renderCoordinatorInstance.hasPendingWork() ? 1 : 0;\n  }\n\n  // Toggle on to start tracking. You must call takeRecords() to\n  // obtain the records. Please note: records are limited by maxRecordSize below.\n  observe = false;\n  recordStorageLimit = 100;\n\n  // If true, only log activity with an explicit label.\n  // This does not affect logging frames or queue empty events.\n  observeOnlyNamed = true;\n\n  readonly #logInternal: CoordinatorLogEntry[] = [];\n\n  #pendingReaders: WorkItem<unknown>[] = [];\n  #pendingWriters: WorkItem<unknown>[] = [];\n  #scheduledWorkId = 0;\n\n  hasPendingWork(): boolean {\n    return this.#pendingReaders.length !== 0 || this.#pendingWriters.length !== 0;\n  }\n\n  done(options?: {waitForWork: boolean}): Promise<void> {\n    if (!this.hasPendingWork() && !options?.waitForWork) {\n      this.#logIfEnabled('[Queue empty]');\n      return Promise.resolve();\n    }\n    return new Promise(resolve => this.addEventListener('renderqueueempty', () => resolve(), {once: true}));\n  }\n\n  // Schedules a 'read' job which is being executed within an animation frame\n  // before all 'write' jobs. If multiple jobs are scheduled with the same\n  // non-empty label, only the latest callback would be executed. Such\n  // invocations would return the same promise that will resolve to the value of\n  // the latest callback.\n  async read<T>(callback: CoordinatorCallback<T>): Promise<T>;\n  async read<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\n  async read<T>(labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Read called with label but no callback');\n      }\n      return this.#enqueueHandler(ACTION.READ, labelOrCallback, callback) as Promise<T>;\n    }\n\n    return this.#enqueueHandler(ACTION.READ, UNNAMED_READ, labelOrCallback) as Promise<T>;\n  }\n\n  // Schedules a 'write' job which is being executed within an animation frame\n  // after all 'read' and 'scroll' jobs. If multiple jobs are scheduled with\n  // the same non-empty label, only the latest callback would be executed. Such\n  // invocations would return the same promise that will resolve when the latest callback is run.\n  async write<T>(callback: CoordinatorCallback<T>): Promise<T>;\n  async write<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\n  async write<T>(labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Write called with label but no callback');\n      }\n      return this.#enqueueHandler(ACTION.WRITE, labelOrCallback, callback) as Promise<T>;\n    }\n\n    return this.#enqueueHandler(ACTION.WRITE, UNNAMED_WRITE, labelOrCallback) as Promise<T>;\n  }\n\n  findPendingWrite(label: string): Promise<void>|undefined {\n    return this.#enqueueHandler(ACTION.WRITE, label);\n  }\n\n  takeRecords(): CoordinatorLogEntry[] {\n    const logs = [...this.#logInternal];\n    this.#logInternal.length = 0;\n    return logs;\n  }\n\n  /**\n   * We offer a convenience function for scroll-based activity, but often triggering a scroll\n   * requires a layout pass, thus it is better handled as a read activity, i.e. we wait until\n   * the layout-triggering work has been completed then it should be possible to scroll without\n   * first forcing layout.  If multiple jobs are scheduled with the same non-empty label, only\n   * the latest callback would be executed. Such invocations would return the same promise that\n   * will resolve when the latest callback is run.\n   */\n  async scroll<T>(callback: CoordinatorCallback<T>): Promise<T>;\n  async scroll<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\n  async scroll<T>(labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Scroll called with label but no callback');\n      }\n      return this.#enqueueHandler(ACTION.READ, labelOrCallback, callback) as Promise<T>;\n    }\n\n    return this.#enqueueHandler(ACTION.READ, UNNAMED_SCROLL, labelOrCallback) as Promise<T>;\n  }\n\n  #enqueueHandler<T>(action: ACTION, label: string, callback?: CoordinatorCallback<T>): Promise<T>|undefined {\n    const hasName = ![UNNAMED_READ, UNNAMED_WRITE, UNNAMED_SCROLL].includes(label);\n    label = `${action === ACTION.READ ? '[Read]' : '[Write]'}: ${label}`;\n\n    let workItems = null;\n    switch (action) {\n      case ACTION.READ:\n        workItems = this.#pendingReaders;\n        break;\n\n      case ACTION.WRITE:\n        workItems = this.#pendingWriters;\n        break;\n\n      default:\n        throw new Error(`Unknown action: ${action}`);\n    }\n\n    let workItem = hasName ? workItems.find(w => w.label === label) as WorkItem<T>| undefined : undefined;\n    if (callback) {\n      if (!workItem) {\n        workItem = new WorkItem<T>(label, callback);\n        workItems.push(workItem);\n      } else {\n        // We are always using the latest handler, so that we don't end up with a\n        // stale results. We are reusing the promise to avoid blocking the first invocation, when\n        // it is being \"overridden\" by another one.\n        workItem.handler = callback;\n      }\n\n      this.#scheduleWork();\n    }\n    return workItem?.promise;\n  }\n\n  #scheduleWork(): void {\n    const hasScheduledWork = this.#scheduledWorkId !== 0;\n    if (hasScheduledWork) {\n      return;\n    }\n\n    this.#scheduledWorkId = requestAnimationFrame(async () => {\n      if (!this.hasPendingWork()) {\n        // All pending work has completed.\n        // The events dispatched below are mostly for testing contexts.\n        // The first is for cases where we have a direct reference to\n        // the render coordinator. The second is for other test contexts\n        // where we don't, and instead we listen for an event on the window.\n        this.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n        window.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n\n        this.#logIfEnabled('[Queue empty]');\n        this.#scheduledWorkId = 0;\n        return;\n      }\n\n      this.dispatchEvent(new RenderCoordinatorNewFrameEvent());\n      this.#logIfEnabled('[New frame]');\n\n      const readers = this.#pendingReaders;\n      this.#pendingReaders = [];\n      const writers = this.#pendingWriters;\n      this.#pendingWriters = [];\n\n      // Start with all the readers and allow them\n      // to proceed together.\n      for (const reader of readers) {\n        this.#logIfEnabled(reader.label);\n        reader.trigger();\n      }\n\n      // Wait for them all to be done.\n      try {\n        await Promise.race([\n          Promise.all(readers.map(r => r.promise)),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Readers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(readers, err);\n      }\n\n      // Next do all the writers as a block.\n      for (const writer of writers) {\n        this.#logIfEnabled(writer.label);\n        writer.trigger();\n      }\n\n      // And wait for them to be done, too.\n      try {\n        await Promise.race([\n          Promise.all(writers.map(w => w.promise)),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Writers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(writers, err);\n      }\n\n      // Since there may have been more work requested in\n      // the callback of a reader / writer, we attempt to schedule\n      // it at this point.\n      this.#scheduledWorkId = 0;\n      this.#scheduleWork();\n    });\n  }\n\n  #rejectAll(handlers: WorkItem<unknown>[], error: Error): void {\n    for (const handler of handlers) {\n      handler.cancel(error);\n    }\n  }\n\n  cancelPending(): void {\n    const error = new Error();\n    this.#rejectAll(this.#pendingReaders, error);\n    this.#rejectAll(this.#pendingWriters, error);\n  }\n\n  #logIfEnabled(value: string|undefined): void {\n    if (!this.observe || !value) {\n      return;\n    }\n    const hasNoName = value.endsWith(UNNAMED_READ) || value.endsWith(UNNAMED_WRITE) || value.endsWith(UNNAMED_SCROLL);\n    if (hasNoName && this.observeOnlyNamed) {\n      return;\n    }\n\n    this.#logInternal.push({time: performance.now(), value});\n\n    // Keep the log at the log size.\n    while (this.#logInternal.length > this.recordStorageLimit) {\n      this.#logInternal.shift();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["ACTION"]
}
