{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/components/tree_outline/TreeOutline.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as VisualLogging from '../../visual_logging/visual_logging.js';\nimport * as CodeHighlighter from '../code_highlighter/code_highlighter.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\n\nimport treeOutlineStyles from './treeOutline.css.js';\nimport {\n  findNextNodeForTreeOutlineKeyboardNavigation,\n  getNodeChildren,\n  getPathToTreeNode,\n  isExpandableNode,\n  trackDOMNodeToTreeNode,\n  type TreeNode,\n  type TreeNodeId,\n  type TreeNodeWithChildren,\n} from './TreeOutlineUtils.js';\n\nconst {html, Directives: {ifDefined}} = LitHtml;\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nexport interface TreeOutlineData<TreeNodeDataType> {\n  defaultRenderer: (node: TreeNode<TreeNodeDataType>, state: {isExpanded: boolean}) => LitHtml.TemplateResult;\n  /**\n   * Note: it is important that all the TreeNode objects are unique. They are\n   * used internally to the TreeOutline as keys to track state (such as if a\n   * node is expanded or not), and providing the same object multiple times will\n   * cause issues in the TreeOutline.\n   */\n  tree: readonly TreeNode<TreeNodeDataType>[];\n  filter?: (node: TreeNodeDataType) => FilterOption;\n  compact?: boolean;\n}\n\nexport function defaultRenderer(node: TreeNode<string>): LitHtml.TemplateResult {\n  return html`${node.treeNodeData}`;\n}\n\nexport class ItemSelectedEvent<TreeNodeDataType> extends Event {\n  static readonly eventName = 'itemselected';\n  data: {\n    node: TreeNode<TreeNodeDataType>,\n  };\n\n  constructor(node: TreeNode<TreeNodeDataType>) {\n    super(ItemSelectedEvent.eventName, {bubbles: true, composed: true});\n    this.data = {node};\n  }\n}\n\nexport class ItemMouseOverEvent<TreeNodeDataType> extends Event {\n  static readonly eventName = 'itemmouseover';\n  data: {\n    node: TreeNode<TreeNodeDataType>,\n  };\n\n  constructor(node: TreeNode<TreeNodeDataType>) {\n    super(ItemMouseOverEvent.eventName, {bubbles: true, composed: true});\n    this.data = {node};\n  }\n}\n\nexport class ItemMouseOutEvent<TreeNodeDataType> extends Event {\n  static readonly eventName = 'itemmouseout';\n  data: {\n    node: TreeNode<TreeNodeDataType>,\n  };\n\n  constructor(node: TreeNode<TreeNodeDataType>) {\n    super(ItemMouseOutEvent.eventName, {bubbles: true, composed: true});\n    this.data = {node};\n  }\n}\n\n/**\n *\n * The tree can be filtered by providing a custom filter function.\n * The filter is applied on every node when constructing the tree\n * and proceeds as follows:\n * - If the filter return SHOW for a node, the node is included in the tree.\n * - If the filter returns FLATTEN, the node is ignored but its subtree is included.\n */\nexport const enum FilterOption {\n  SHOW = 'SHOW',\n  FLATTEN = 'FLATTEN',\n}\n\nexport class TreeOutline<TreeNodeDataType> extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #treeData: readonly TreeNode<TreeNodeDataType>[] = [];\n  #nodeExpandedMap: Map<string, boolean> = new Map();\n  #domNodeToTreeNodeMap: WeakMap<HTMLLIElement, TreeNode<TreeNodeDataType>> = new WeakMap();\n  #hasRenderedAtLeastOnce = false;\n  /**\n   * If we have expanded to a certain node, we want to focus it once we've\n   * rendered. But we render lazily and wrapped in LitHtml.until, so we can't\n   * know for sure when that node will be rendered. This variable tracks the\n   * node that we want focused but may not yet have been rendered.\n   */\n  #nodeIdPendingFocus: TreeNodeId|null = null;\n  #selectedTreeNode: TreeNode<TreeNodeDataType>|null = null;\n  #defaultRenderer = (node: TreeNode<TreeNodeDataType>, _state: {isExpanded: boolean}): LitHtml.TemplateResult => {\n    if (typeof node.treeNodeData !== 'string') {\n      console.warn(`The default TreeOutline renderer simply stringifies its given value. You passed in ${\n          JSON.stringify(\n              node.treeNodeData, null,\n              2)}. Consider providing a different defaultRenderer that can handle nodes of this type.`);\n    }\n    return html`${String(node.treeNodeData)}`;\n  };\n  #nodeFilter?: ((node: TreeNodeDataType) => FilterOption);\n  #compact = false;\n\n  /**\n   * scheduledRender = render() has been called and scheduled a render.\n   */\n  #scheduledRender = false;\n  /**\n   * enqueuedRender = render() was called mid-way through an existing render.\n   */\n  #enqueuedRender = false;\n\n  static get observedAttributes(): string[] {\n    return ['nowrap', 'toplevelbordercolor'];\n  }\n\n  attributeChangedCallback(name: 'nowrap'|'toplevelbordercolor', oldValue: string|null, newValue: string|null): void {\n    switch (name) {\n      case 'nowrap': {\n        this.#setNodeKeyNoWrapCSSVariable(newValue);\n        break;\n      }\n      case 'toplevelbordercolor': {\n        this.#setTopLevelNodeBorderColorCSSVariable(newValue);\n        break;\n      }\n    }\n  }\n\n  connectedCallback(): void {\n    this.#setTopLevelNodeBorderColorCSSVariable(this.getAttribute('toplevelbordercolor'));\n    this.#setNodeKeyNoWrapCSSVariable(this.getAttribute('nowrap'));\n    this.#shadow.adoptedStyleSheets = [treeOutlineStyles, CodeHighlighter.Style.default];\n  }\n\n  get data(): TreeOutlineData<TreeNodeDataType> {\n    return {\n      tree: this.#treeData as TreeNode<TreeNodeDataType>[],\n      defaultRenderer: this.#defaultRenderer,\n    };\n  }\n\n  set data(data: TreeOutlineData<TreeNodeDataType>) {\n    this.#defaultRenderer = data.defaultRenderer;\n    this.#treeData = data.tree;\n    this.#nodeFilter = data.filter;\n    this.#compact = data.compact || false;\n\n    if (!this.#hasRenderedAtLeastOnce) {\n      this.#selectedTreeNode = this.#treeData[0];\n    }\n    void this.#render();\n  }\n\n  /**\n   * Recursively expands the tree from the root nodes, to a max depth. The max\n   * depth is 0 indexed - so a maxDepth of 2 (default) will expand 3 levels: 0,\n   * 1 and 2.\n   */\n  async expandRecursively(maxDepth = 2): Promise<void> {\n    await Promise.all(this.#treeData.map(rootNode => this.#expandAndRecurse(rootNode, 0, maxDepth)));\n    await this.#render();\n  }\n\n  /**\n   * Collapses all nodes in the tree.\n   */\n  async collapseAllNodes(): Promise<void> {\n    this.#nodeExpandedMap.clear();\n    await this.#render();\n  }\n\n  /**\n   * Takes a TreeNode, expands the outline to reveal it, and focuses it.\n   */\n  async expandToAndSelectTreeNode(targetTreeNode: TreeNode<TreeNodeDataType>): Promise<void> {\n    return this.expandToAndSelectTreeNodeId(targetTreeNode.id);\n  }\n\n  /**\n   * Takes a TreeNode ID, expands the outline to reveal it, and focuses it.\n   */\n  async expandToAndSelectTreeNodeId(targetTreeNodeId: TreeNodeId): Promise<void> {\n    const pathToTreeNode = await getPathToTreeNode(this.#treeData, targetTreeNodeId);\n\n    if (pathToTreeNode === null) {\n      throw new Error(`Could not find node with id ${targetTreeNodeId} in the tree.`);\n    }\n    pathToTreeNode.forEach((node, index) => {\n      // We don't expand the very last node, which was the target node.\n      if (index < pathToTreeNode.length - 1) {\n        this.#setNodeExpandedState(node, true);\n      }\n    });\n\n    // Mark the node as pending focus so when it is rendered into the DOM we can focus it\n    this.#nodeIdPendingFocus = targetTreeNodeId;\n    await this.#render();\n  }\n\n  /**\n   * Takes a list of TreeNode IDs and expands the corresponding nodes.\n   */\n  expandNodeIds(nodeIds: TreeNodeId[]): Promise<void> {\n    nodeIds.forEach(id => this.#nodeExpandedMap.set(id, true));\n    return this.#render();\n  }\n\n  /**\n   * Takes a TreeNode ID and focuses the corresponding node.\n   */\n  focusNodeId(nodeId: TreeNodeId): Promise<void> {\n    this.#nodeIdPendingFocus = nodeId;\n    return this.#render();\n  }\n\n  async collapseChildrenOfNode(domNode: HTMLLIElement): Promise<void> {\n    const treeNode = this.#domNodeToTreeNodeMap.get(domNode);\n    if (!treeNode) {\n      return;\n    }\n    await this.#recursivelyCollapseTreeNodeChildren(treeNode);\n    await this.#render();\n  }\n\n  #setNodeKeyNoWrapCSSVariable(attributeValue: string|null): void {\n    this.style.setProperty('--override-key-whitespace-wrapping', attributeValue !== null ? 'nowrap' : 'initial');\n  }\n\n  #setTopLevelNodeBorderColorCSSVariable(attributeValue: string|null): void {\n    this.style.setProperty('--override-top-node-border', attributeValue ? `1px solid ${attributeValue}` : '');\n  }\n\n  async #recursivelyCollapseTreeNodeChildren(treeNode: TreeNode<TreeNodeDataType>): Promise<void> {\n    if (!isExpandableNode(treeNode) || !this.#nodeIsExpanded(treeNode)) {\n      return;\n    }\n    const children = await this.#fetchNodeChildren(treeNode);\n    const childRecursions = Promise.all(children.map(child => this.#recursivelyCollapseTreeNodeChildren(child)));\n    await childRecursions;\n    this.#setNodeExpandedState(treeNode, false);\n  }\n\n  async #flattenSubtree(node: TreeNodeWithChildren<TreeNodeDataType>, filter: (node: TreeNodeDataType) => FilterOption):\n      Promise<TreeNode<TreeNodeDataType>[]> {\n    const children = await getNodeChildren(node);\n    const filteredChildren = [];\n    for (const child of children) {\n      const filtering = filter(child.treeNodeData);\n      // We always include the selected node in the tree, regardless of its filtering status.\n      const toBeSelected = this.#isSelectedNode(child) || child.id === this.#nodeIdPendingFocus;\n      // If a node is already expanded we should not flatten it away.\n      const expanded = this.#nodeExpandedMap.get(child.id);\n      if (filtering === FilterOption.SHOW || toBeSelected || expanded) {\n        filteredChildren.push(child);\n      } else if (filtering === FilterOption.FLATTEN && isExpandableNode(child)) {\n        const grandChildren = await this.#flattenSubtree(child, filter);\n        filteredChildren.push(...grandChildren);\n      }\n    }\n    return filteredChildren;\n  }\n\n  async #fetchNodeChildren(node: TreeNodeWithChildren<TreeNodeDataType>): Promise<TreeNode<TreeNodeDataType>[]> {\n    const children = await getNodeChildren(node);\n    const filter = this.#nodeFilter;\n    if (!filter) {\n      return children;\n    }\n    const filteredDescendants = await this.#flattenSubtree(node, filter);\n    return filteredDescendants.length ? filteredDescendants : children;\n  }\n\n  #setNodeExpandedState(node: TreeNode<TreeNodeDataType>, newExpandedState: boolean): void {\n    this.#nodeExpandedMap.set(node.id, newExpandedState);\n  }\n\n  #nodeIsExpanded(node: TreeNode<TreeNodeDataType>): boolean {\n    return this.#nodeExpandedMap.get(node.id) || false;\n  }\n\n  async #expandAndRecurse(node: TreeNode<TreeNodeDataType>, currentDepth: number, maxDepth: number): Promise<void> {\n    if (!isExpandableNode(node)) {\n      return;\n    }\n    this.#setNodeExpandedState(node, true);\n    if (currentDepth === maxDepth || !isExpandableNode(node)) {\n      return;\n    }\n    const children = await this.#fetchNodeChildren(node);\n    await Promise.all(children.map(child => this.#expandAndRecurse(child, currentDepth + 1, maxDepth)));\n  }\n\n  #onArrowClick(node: TreeNode<TreeNodeDataType>): ((e: Event) => void) {\n    return (event: Event): void => {\n      event.stopPropagation();\n      if (isExpandableNode(node)) {\n        this.#setNodeExpandedState(node, !this.#nodeIsExpanded(node));\n        void this.#render();\n      }\n    };\n  }\n\n  #onNodeClick(event: Event): void {\n    // Avoid it bubbling up to parent tree elements, else clicking a node deep in the tree will toggle it + all its ancestor's visibility.\n    event.stopPropagation();\n    const nodeClickExpandsOrContracts = this.getAttribute('clickabletitle') !== null;\n    const domNode = event.currentTarget as HTMLLIElement;\n    const node = this.#domNodeToTreeNodeMap.get(domNode);\n    if (nodeClickExpandsOrContracts && node && isExpandableNode(node)) {\n      this.#setNodeExpandedState(node, !this.#nodeIsExpanded(node));\n    }\n    void this.#focusTreeNode(domNode);\n  }\n\n  async #focusTreeNode(domNode: HTMLLIElement): Promise<void> {\n    const treeNode = this.#domNodeToTreeNodeMap.get(domNode);\n    if (!treeNode) {\n      return;\n    }\n    this.#selectedTreeNode = treeNode;\n    await this.#render();\n    this.dispatchEvent(new ItemSelectedEvent(treeNode));\n    void coordinator.write('DOMNode focus', () => {\n      domNode.focus();\n    });\n  }\n\n  #processHomeAndEndKeysNavigation(key: 'Home'|'End'): void {\n    if (key === 'Home') {\n      const firstRootNode = this.#shadow.querySelector<HTMLLIElement>('ul[role=\"tree\"] > li[role=\"treeitem\"]');\n      if (firstRootNode) {\n        void this.#focusTreeNode(firstRootNode);\n      }\n    } else if (key === 'End') {\n      /**\n       * The End key takes the user to the last visible node in the tree - you\n       * can think of this as the one that's rendered closest to the bottom of\n       * the page.\n       *\n       * We could walk our tree and compute this - but it will also be the last\n       * li[role=\"treeitem\"] in the DOM because we only render visible nodes.\n       * Therefore we can select all the nodes and pick the last one.\n       */\n      const allTreeItems = this.#shadow.querySelectorAll<HTMLLIElement>('li[role=\"treeitem\"]');\n      const lastTreeItem = allTreeItems[allTreeItems.length - 1];\n      if (lastTreeItem) {\n        void this.#focusTreeNode(lastTreeItem);\n      }\n    }\n  }\n\n  async #processArrowKeyNavigation(key: Platform.KeyboardUtilities.ArrowKey, currentDOMNode: HTMLLIElement):\n      Promise<void> {\n    const currentTreeNode = this.#domNodeToTreeNodeMap.get(currentDOMNode);\n    if (!currentTreeNode) {\n      return;\n    }\n\n    const domNode = findNextNodeForTreeOutlineKeyboardNavigation({\n      currentDOMNode,\n      currentTreeNode,\n      direction: key,\n      setNodeExpandedState: (node, expanded) => this.#setNodeExpandedState(node, expanded),\n    });\n    await this.#focusTreeNode(domNode);\n  }\n\n  #processEnterOrSpaceNavigation(currentDOMNode: HTMLLIElement): void {\n    const currentTreeNode = this.#domNodeToTreeNodeMap.get(currentDOMNode);\n    if (!currentTreeNode) {\n      return;\n    }\n    if (isExpandableNode(currentTreeNode)) {\n      const currentExpandedState = this.#nodeIsExpanded(currentTreeNode);\n      this.#setNodeExpandedState(currentTreeNode, !currentExpandedState);\n      void this.#render();\n    }\n  }\n\n  async #onTreeKeyDown(event: KeyboardEvent): Promise<void> {\n    if (!(event.target instanceof HTMLLIElement)) {\n      throw new Error('event.target was not an <li> element');\n    }\n\n    if (event.key === 'Home' || event.key === 'End') {\n      event.preventDefault();\n      this.#processHomeAndEndKeysNavigation(event.key);\n    } else if (Platform.KeyboardUtilities.keyIsArrowKey(event.key)) {\n      event.preventDefault();\n      await this.#processArrowKeyNavigation(event.key, event.target);\n    } else if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault();\n      this.#processEnterOrSpaceNavigation(event.target);\n    }\n  }\n\n  #focusPendingNode(domNode: HTMLLIElement): void {\n    this.#nodeIdPendingFocus = null;\n    void this.#focusTreeNode(domNode);\n  }\n\n  #isSelectedNode(node: TreeNode<TreeNodeDataType>): boolean {\n    if (this.#selectedTreeNode) {\n      return node.id === this.#selectedTreeNode.id;\n    }\n    return false;\n  }\n\n  #renderNode(node: TreeNode<TreeNodeDataType>, {depth, setSize, positionInSet}: {\n    depth: number,\n    setSize: number,\n    positionInSet: number,\n  }): LitHtml.TemplateResult {\n    let childrenToRender;\n    const nodeIsExpanded = this.#nodeIsExpanded(node);\n    if (!isExpandableNode(node) || !nodeIsExpanded) {\n      childrenToRender = LitHtml.nothing;\n    } else {\n      const childNodes = this.#fetchNodeChildren(node).then(children => {\n        return children.map((childNode, index) => {\n          return this.#renderNode(childNode, {depth: depth + 1, setSize: children.length, positionInSet: index});\n        });\n      });\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      childrenToRender = html`<ul role=\"group\">${LitHtml.Directives.until(childNodes)}</ul>`;\n      // clang-format on\n    }\n\n    const nodeIsFocusable = this.#isSelectedNode(node);\n    const tabIndex = nodeIsFocusable ? 0 : -1;\n    const listItemClasses = LitHtml.Directives.classMap({\n      expanded: isExpandableNode(node) && nodeIsExpanded,\n      parent: isExpandableNode(node),\n      selected: this.#isSelectedNode(node),\n      'is-top-level': depth === 0,\n      compact: this.#compact,\n    });\n    const ariaExpandedAttribute = !isExpandableNode(node) ? undefined : nodeIsExpanded ? 'true' : 'false';\n\n    let renderedNodeKey: LitHtml.TemplateResult;\n    if (node.renderer) {\n      renderedNodeKey = node.renderer(node, {isExpanded: nodeIsExpanded});\n    } else {\n      renderedNodeKey = this.#defaultRenderer(node, {isExpanded: nodeIsExpanded});\n    }\n\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    return html`\n      <li role=\"treeitem\"\n        tabindex=${tabIndex}\n        aria-setsize=${setSize}\n        aria-expanded=${ifDefined(ariaExpandedAttribute)}\n        aria-level=${depth + 1}\n        aria-posinset=${positionInSet + 1}\n        class=${listItemClasses}\n        jslog=${VisualLogging.treeItem(node.jslogContext).track({click: true, keydown: 'ArrowUp|ArrowDown|ArrowLeft|ArrowRight|Enter|Space|Home|End'})}\n        @click=${this.#onNodeClick}\n        track-dom-node-to-tree-node=${trackDOMNodeToTreeNode(this.#domNodeToTreeNodeMap, node)}\n        on-render=${ComponentHelpers.Directives.nodeRenderedCallback(domNode => {\n         /**\n          * Because TreeNodes are lazily rendered, you can call\n          * `outline.expandToAndSelect(NodeX)`, but `NodeX` will be rendered at some\n          * later point, once it's been fully resolved, within a LitHtml.until\n          * directive. That means we don't have a direct hook into when it's\n          * rendered, which we need because we want to focus the element, so we use this directive to receive a callback when the node is rendered.\n          */\n          if (!(domNode instanceof HTMLLIElement)) {\n            return;\n          }\n\n          if (this.#nodeIdPendingFocus && node.id === this.#nodeIdPendingFocus) {\n            this.#focusPendingNode(domNode);\n          }\n        })}\n      >\n        <span class=\"arrow-and-key-wrapper\"\n          @mouseover=${() => {\n            this.dispatchEvent(new ItemMouseOverEvent(node));\n          }}\n          @mouseout=${() => {\n            this.dispatchEvent(new ItemMouseOutEvent(node));\n          }}\n        >\n          <span class=\"arrow-icon\" @click=${this.#onArrowClick(node)} jslog=${VisualLogging.expand().track({click: true})}>\n          </span>\n          <span class=\"tree-node-key\" data-node-key=${node.treeNodeData}>${renderedNodeKey}</span>\n        </span>\n        ${childrenToRender}\n      </li>\n    `;\n    // clang-format on\n  }\n\n  async #render(): Promise<void> {\n    if (this.#scheduledRender) {\n      // If we are already rendering, don't render again immediately, but\n      // enqueue it to be run after we're done on our current render.\n      this.#enqueuedRender = true;\n      return;\n    }\n\n    this.#scheduledRender = true;\n\n    await coordinator.write('TreeOutline render', () => {\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      LitHtml.render(html`\n      <div class=\"wrapping-container\">\n        <ul role=\"tree\" @keydown=${this.#onTreeKeyDown}>\n          ${this.#treeData.map((topLevelNode, index) => {\n            return this.#renderNode(topLevelNode, {\n              depth: 0,\n              setSize: this.#treeData.length,\n              positionInSet: index,\n            });\n          })}\n        </ul>\n      </div>\n      `, this.#shadow, {\n        host: this,\n      });\n    });\n    // clang-format on\n    this.#hasRenderedAtLeastOnce = true;\n    this.#scheduledRender = false;\n\n    // If render() was called when we were already mid-render, let's re-render\n    // to ensure we're not rendering any stale UI.\n    if (this.#enqueuedRender) {\n      this.#enqueuedRender = false;\n      return this.#render();\n    }\n  }\n}\n\ncustomElements.define('devtools-tree-outline', TreeOutline);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-tree-outline': TreeOutline<unknown>;\n  }\n}\n"],
  "mappings": "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",
  "names": ["FilterOption"]
}
