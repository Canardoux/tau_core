{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/visual_logging/LoggingState.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type {Loggable} from './Loggable.js';\nimport {type LoggingConfig, needsLogging} from './LoggingConfig.js';\n\nexport interface LoggingState {\n  impressionLogged: boolean;\n  processed: boolean;\n  config: LoggingConfig;\n  veid: number;\n  parent: LoggingState|null;\n  processedForDebugging?: boolean;\n  size: DOMRect;\n  selectOpen?: boolean;\n  pendingChangeContext?: string;\n}\n\nconst state = new WeakMap<Loggable, LoggingState>();\n\nfunction nextVeId(): number {\n  const result = new BigInt64Array(1);\n  crypto.getRandomValues(result);\n  return Number(result[0] >> (64n - 53n));\n}\n\nexport function getOrCreateLoggingState(loggable: Loggable, config: LoggingConfig, parent?: Loggable): LoggingState {\n  if (config.parent && parentProviders.has(config.parent) && loggable instanceof Element) {\n    parent = parentProviders.get(config.parent)?.(loggable);\n    while (parent instanceof Element && !needsLogging(parent)) {\n      parent = parent.parentElementOrShadowHost() ?? undefined;\n    }\n  }\n  if (state.has(loggable)) {\n    const currentState = state.get(loggable) as LoggingState;\n    if (parent && currentState.parent !== getLoggingState(parent)) {\n      currentState.parent = getLoggingState(parent);\n    }\n    return currentState;\n  }\n\n  const loggableState = {\n    impressionLogged: false,\n    processed: false,\n    config,\n    veid: nextVeId(),\n    parent: parent ? getLoggingState(parent) : null,\n    size: new DOMRect(0, 0, 0, 0),\n  };\n  state.set(loggable, loggableState);\n  return loggableState;\n}\n\nexport function getLoggingState(loggable: Loggable): LoggingState|null {\n  return state.get(loggable) || null;\n}\n\ntype ParentProvider = (e: Element) => Element|undefined;\nconst parentProviders = new Map<string, ParentProvider>();\n\nexport function registerParentProvider(name: string, provider: ParentProvider): void {\n  if (parentProviders.has(name)) {\n    throw new Error(`Parent provider with the name '${name} is already registered'`);\n  }\n  parentProviders.set(name, provider);\n}\n\nconst parentMap = new WeakMap<Element, Element>();\nregisterParentProvider('mapped', (e: Element) => parentMap.get(e));\n\nexport function setMappedParent(element: Element, parent: Element): void {\n  parentMap.set(element, parent);\n}\n"],
  "mappings": ";AAIA,SAA4B,oBAAmB;AAc/C,MAAM,QAAQ,oBAAI,QAAgC;AAElD,SAAS,WAAmB;AAC1B,QAAM,SAAS,IAAI,cAAc,CAAC;AAClC,SAAO,gBAAgB,MAAM;AAC7B,SAAO,OAAO,OAAO,CAAC,KAAM,MAAM,GAAI;AACxC;AAEO,gBAAS,wBAAwB,UAAoB,QAAuB,QAAiC;AAClH,MAAI,OAAO,UAAU,gBAAgB,IAAI,OAAO,MAAM,KAAK,oBAAoB,SAAS;AACtF,aAAS,gBAAgB,IAAI,OAAO,MAAM,IAAI,QAAQ;AACtD,WAAO,kBAAkB,WAAW,CAAC,aAAa,MAAM,GAAG;AACzD,eAAS,OAAO,0BAA0B,KAAK;AAAA,IACjD;AAAA,EACF;AACA,MAAI,MAAM,IAAI,QAAQ,GAAG;AACvB,UAAM,eAAe,MAAM,IAAI,QAAQ;AACvC,QAAI,UAAU,aAAa,WAAW,gBAAgB,MAAM,GAAG;AAC7D,mBAAa,SAAS,gBAAgB,MAAM;AAAA,IAC9C;AACA,WAAO;AAAA,EACT;AAEA,QAAM,gBAAgB;AAAA,IACpB,kBAAkB;AAAA,IAClB,WAAW;AAAA,IACX;AAAA,IACA,MAAM,SAAS;AAAA,IACf,QAAQ,SAAS,gBAAgB,MAAM,IAAI;AAAA,IAC3C,MAAM,IAAI,QAAQ,GAAG,GAAG,GAAG,CAAC;AAAA,EAC9B;AACA,QAAM,IAAI,UAAU,aAAa;AACjC,SAAO;AACT;AAEO,gBAAS,gBAAgB,UAAuC;AACrE,SAAO,MAAM,IAAI,QAAQ,KAAK;AAChC;AAGA,MAAM,kBAAkB,oBAAI,IAA4B;AAEjD,gBAAS,uBAAuB,MAAc,UAAgC;AACnF,MAAI,gBAAgB,IAAI,IAAI,GAAG;AAC7B,UAAM,IAAI,MAAM,kCAAkC,IAAI,yBAAyB;AAAA,EACjF;AACA,kBAAgB,IAAI,MAAM,QAAQ;AACpC;AAEA,MAAM,YAAY,oBAAI,QAA0B;AAChD,uBAAuB,UAAU,CAAC,MAAe,UAAU,IAAI,CAAC,CAAC;AAE1D,gBAAS,gBAAgB,SAAkB,QAAuB;AACvE,YAAU,IAAI,SAAS,MAAM;AAC/B;",
  "names": []
}
