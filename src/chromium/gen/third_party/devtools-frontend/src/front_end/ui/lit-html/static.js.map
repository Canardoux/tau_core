{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/lit-html/static.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as I18n from '../../third_party/i18n/i18n.js';\nimport * as Lit from '../../third_party/lit/lit.js';\n\nexport interface Static {\n  value: unknown;\n  $$static$$: true;\n}\n\ntype TemplateValues = Static|unknown;\ntype FlattenedTemplateValues = {\n  strings: TemplateStringsArray,\n  valueMap: boolean[],\n};\n\nexport function flattenTemplate(strings: TemplateStringsArray, ...values: TemplateValues[]): FlattenedTemplateValues {\n  const valueMap: boolean[] = [];\n  const newStrings: string[] = [];\n\n  // Start with an empty buffer and start running over the values.\n  let buffer = '';\n  for (let v = 0; v < values.length; v++) {\n    const possibleStatic = values[v];\n    if (isStaticLiteral(possibleStatic)) {\n      // If this is a static literal, add the current string plus the\n      // static literal's value to the buffer.\n      buffer += strings[v] + possibleStatic.value;\n\n      // Filter this value in future invocations.\n      valueMap.push(false);\n    } else {\n      // If we reach a non-static value, push what we have on to\n      // the new strings array, and reset the buffer.\n      buffer += strings[v];\n      newStrings.push(buffer);\n      buffer = '';\n\n      // Include this value in future invocations.\n      valueMap.push(true);\n    }\n  }\n\n  // Since the strings length is always the values length + 1, we need\n  // to append whatever that final string is to whatever is left in the\n  // buffer, and flush both out to the newStrings.\n  newStrings.push(buffer + strings[values.length]);\n  (newStrings as unknown as {raw: readonly string[]}).raw = [...newStrings];\n  return {strings: newStrings as unknown as TemplateStringsArray, valueMap};\n}\n\nexport function html(strings: TemplateStringsArray, ...values: TemplateValues[]): Lit.TemplateResult {\n  const staticValues = values.filter(value => isStaticLiteral(value));\n  if (staticValues.length) {\n    const key = staticValues.map(v => v.value as string).join(' ');\n    return htmlWithStatics(strings, values, key);\n  }\n\n  return Lit.html(strings, ...values);\n}\n\nexport function literal(value: TemplateStringsArray): Static {\n  return {\n    value: value[0],\n    $$static$$: true,\n  };\n}\n\nfunction isStaticLiteral(item: TemplateValues|unknown): item is Static {\n  return typeof item === 'object' && (item !== null && '$$static$$' in item);\n}\n\n// While this is a WeakMap, that doesn't help because TemplateStringsArray are objects in a global registry\n// managed by the V8 runtime. They are never garbage collected.\n// We use a double-keyed cache in order to support dynamically changing the static literal: for example,\n// within a loop that dynamically selects what custom component to render.\nconst flattenedTemplates = new WeakMap<TemplateStringsArray, Map<string, FlattenedTemplateValues>>();\n\nfunction htmlWithStatics(\n    strings: TemplateStringsArray, values: TemplateValues[], staticValuesKey: string): Lit.TemplateResult {\n  // Check to see if we've already converted this before.\n  // Cache key is the TemplateStringsArray, which works because the same usage of template string reuses the same array object.\n  // See: https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-gettemplateobject\n  //      13.2.8.4 GetTemplateObject, step 3.\n  let flattened;\n  let secondaryMap = flattenedTemplates.get(strings);\n  if (!secondaryMap) {\n    secondaryMap = new Map();\n    flattenedTemplates.set(strings, secondaryMap);\n  }\n\n  flattened = secondaryMap.get(staticValuesKey);\n  if (!flattened) {\n    flattened = flattenTemplate(strings, ...values);\n    secondaryMap.set(staticValuesKey, flattened);\n  }\n\n  // Pass through to Lit.\n  const filteredValues = values.filter((_, index) => flattened.valueMap[index]);\n  return Lit.html(flattened.strings, ...filteredValues);\n}\n\n/**\n * @param placeholders placeholders must not contain localized strings or other localized templates as that is\n * incompatible with languages using a different sentence structure or ordering (e.g., RTL).\n */\nexport function i18nTemplate(\n    registeredStrings: I18n.LocalizedStringSet.RegisteredFileStrings, stringId: string,\n    placeholders: Record<string, Lit.TemplateResult|string>): Lit.TemplateResult {\n  const formatter = registeredStrings.getLocalizedStringSetFor(i18n.DevToolsLocale.DevToolsLocale.instance().locale)\n                        .getMessageFormatterFor(stringId);\n  let result = html``;\n  for (const icuElement of formatter.getAst()) {\n    if (icuElement.type === /* argumentElement */ 1) {\n      const placeholderValue = placeholders[icuElement.value];\n      if (placeholderValue) {\n        result = html`${result}${placeholderValue}`;\n      }\n    } else if ('value' in icuElement) {\n      result = html`${result}${icuElement.value}`;\n    }\n  }\n  return result;\n}\n"],
  "mappings": ";AAIA,YAAY,UAAU;AAEtB,YAAY,SAAS;AAad,gBAAS,gBAAgB,YAAkC,QAAmD;AACnH,QAAM,WAAsB,CAAC;AAC7B,QAAM,aAAuB,CAAC;AAG9B,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,iBAAiB,OAAO,CAAC;AAC/B,QAAI,gBAAgB,cAAc,GAAG;AAGnC,gBAAU,QAAQ,CAAC,IAAI,eAAe;AAGtC,eAAS,KAAK,KAAK;AAAA,IACrB,OAAO;AAGL,gBAAU,QAAQ,CAAC;AACnB,iBAAW,KAAK,MAAM;AACtB,eAAS;AAGT,eAAS,KAAK,IAAI;AAAA,IACpB;AAAA,EACF;AAKA,aAAW,KAAK,SAAS,QAAQ,OAAO,MAAM,CAAC;AAC/C,EAAC,WAAmD,MAAM,CAAC,GAAG,UAAU;AACxE,SAAO,EAAC,SAAS,YAA+C,SAAQ;AAC1E;AAEO,gBAAS,KAAK,YAAkC,QAA8C;AACnG,QAAM,eAAe,OAAO,OAAO,WAAS,gBAAgB,KAAK,CAAC;AAClE,MAAI,aAAa,QAAQ;AACvB,UAAM,MAAM,aAAa,IAAI,OAAK,EAAE,KAAe,EAAE,KAAK,GAAG;AAC7D,WAAO,gBAAgB,SAAS,QAAQ,GAAG;AAAA,EAC7C;AAEA,SAAO,IAAI,KAAK,SAAS,GAAG,MAAM;AACpC;AAEO,gBAAS,QAAQ,OAAqC;AAC3D,SAAO;AAAA,IACL,OAAO,MAAM,CAAC;AAAA,IACd,YAAY;AAAA,EACd;AACF;AAEA,SAAS,gBAAgB,MAA8C;AACrE,SAAO,OAAO,SAAS,aAAa,SAAS,QAAQ,gBAAgB;AACvE;AAMA,MAAM,qBAAqB,oBAAI,QAAoE;AAEnG,SAAS,gBACL,SAA+B,QAA0B,iBAA6C;AAKxG,MAAI;AACJ,MAAI,eAAe,mBAAmB,IAAI,OAAO;AACjD,MAAI,CAAC,cAAc;AACjB,mBAAe,oBAAI,IAAI;AACvB,uBAAmB,IAAI,SAAS,YAAY;AAAA,EAC9C;AAEA,cAAY,aAAa,IAAI,eAAe;AAC5C,MAAI,CAAC,WAAW;AACd,gBAAY,gBAAgB,SAAS,GAAG,MAAM;AAC9C,iBAAa,IAAI,iBAAiB,SAAS;AAAA,EAC7C;AAGA,QAAM,iBAAiB,OAAO,OAAO,CAAC,GAAG,UAAU,UAAU,SAAS,KAAK,CAAC;AAC5E,SAAO,IAAI,KAAK,UAAU,SAAS,GAAG,cAAc;AACtD;AAMO,gBAAS,aACZ,mBAAkE,UAClE,cAA6E;AAC/E,QAAM,YAAY,kBAAkB,yBAAyB,KAAK,eAAe,eAAe,SAAS,EAAE,MAAM,EAC1F,uBAAuB,QAAQ;AACtD,MAAI,SAAS;AACb,aAAW,cAAc,UAAU,OAAO,GAAG;AAC3C,QAAI,WAAW;AAAA,IAA+B,GAAG;AAC/C,YAAM,mBAAmB,aAAa,WAAW,KAAK;AACtD,UAAI,kBAAkB;AACpB,iBAAS,OAAO,MAAM,GAAG,gBAAgB;AAAA,MAC3C;AAAA,IACF,WAAW,WAAW,YAAY;AAChC,eAAS,OAAO,MAAM,GAAG,WAAW,KAAK;AAAA,IAC3C;AAAA,EACF;AACA,SAAO;AACT;",
  "names": []
}
