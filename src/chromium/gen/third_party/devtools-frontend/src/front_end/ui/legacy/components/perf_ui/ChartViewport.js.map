{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/legacy/components/perf_ui/ChartViewport.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as Coordinator from '../../../components/render_coordinator/render_coordinator.js';\nimport * as UI from '../../legacy.js';\n\nimport chartViewPortStyles from './chartViewport.css.legacy.js';\nimport {MinimalTimeWindowMs} from './FlameChart.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nexport interface ChartViewportDelegate {\n  windowChanged(startTime: number, endTime: number, animate: boolean): void;\n  updateRangeSelection(startTime: number, endTime: number): void;\n  setSize(width: number, height: number): void;\n  update(): void;\n}\n\nexport interface Config {\n  enableCursorElement: boolean;\n}\n\nexport class ChartViewport extends UI.Widget.VBox {\n  private readonly delegate: ChartViewportDelegate;\n  viewportElement: HTMLElement;\n  private alwaysShowVerticalScrollInternal: boolean;\n  private rangeSelectionEnabled: boolean;\n  private vScrollElement: HTMLElement;\n  private vScrollContent: HTMLElement;\n  private readonly selectionOverlay: HTMLElement;\n  private cursorElement: HTMLElement;\n  private isDraggingInternal!: boolean;\n  private totalHeight!: number;\n  private offsetHeight!: number;\n  private scrollTop!: number;\n  private rangeSelectionStart: number|null;\n  private rangeSelectionEnd: number|null;\n  private dragStartPointX!: number;\n  private dragStartPointY!: number;\n  private dragStartScrollTop!: number;\n  private visibleLeftTime!: number;\n  private visibleRightTime!: number;\n  private offsetWidth!: number;\n  private targetLeftTime!: number;\n  private targetRightTime!: number;\n  private selectionOffsetShiftX!: number;\n  private selectionStartX!: number|null;\n  private lastMouseOffsetX?: number;\n  private minimumBoundary!: number;\n  private totalTime!: number;\n  private isUpdateScheduled?: boolean;\n  private cancelWindowTimesAnimation?: (() => void)|null;\n\n  #config: Config;\n\n  constructor(delegate: ChartViewportDelegate, config: Config) {\n    super();\n    this.#config = config;\n    this.registerRequiredCSS(chartViewPortStyles);\n\n    this.delegate = delegate;\n\n    this.viewportElement = this.contentElement.createChild('div', 'fill');\n    this.viewportElement.addEventListener('mousemove', this.updateCursorPosition.bind(this), false);\n    this.viewportElement.addEventListener('mouseout', this.onMouseOut.bind(this), false);\n    this.viewportElement.addEventListener('wheel', this.onMouseWheel.bind(this), false);\n    this.viewportElement.addEventListener('keydown', this.onChartKeyDown.bind(this), false);\n    this.viewportElement.addEventListener('keyup', this.onChartKeyUp.bind(this), false);\n\n    UI.UIUtils.installDragHandle(\n        this.viewportElement, this.startDragging.bind(this), this.dragging.bind(this), this.endDragging.bind(this),\n        '-webkit-grabbing', null);\n    UI.UIUtils.installDragHandle(\n        this.viewportElement, this.startRangeSelection.bind(this), this.rangeSelectionDragging.bind(this),\n        this.endRangeSelection.bind(this), 'text', null);\n\n    this.alwaysShowVerticalScrollInternal = false;\n    this.rangeSelectionEnabled = true;\n    this.vScrollElement = this.contentElement.createChild('div', 'chart-viewport-v-scroll');\n    this.vScrollContent = this.vScrollElement.createChild('div');\n    this.vScrollElement.addEventListener('scroll', this.onScroll.bind(this), false);\n\n    this.selectionOverlay = this.contentElement.createChild('div', 'chart-viewport-selection-overlay hidden');\n\n    this.cursorElement = this.contentElement.createChild('div', 'chart-cursor-element hidden');\n\n    this.reset();\n    this.rangeSelectionStart = null;\n    this.rangeSelectionEnd = null;\n  }\n\n  alwaysShowVerticalScroll(): void {\n    this.alwaysShowVerticalScrollInternal = true;\n    this.vScrollElement.classList.add('always-show-scrollbar');\n  }\n\n  disableRangeSelection(): void {\n    this.rangeSelectionEnabled = false;\n    this.rangeSelectionStart = null;\n    this.rangeSelectionEnd = null;\n  }\n\n  isDragging(): boolean {\n    return this.isDraggingInternal;\n  }\n\n  override elementsToRestoreScrollPositionsFor(): Element[] {\n    return [this.vScrollElement];\n  }\n\n  private updateScrollBar(): void {\n    const showScroll = this.alwaysShowVerticalScrollInternal || this.totalHeight > this.offsetHeight;\n    if (this.vScrollElement.classList.contains('hidden') !== showScroll) {\n      return;\n    }\n    this.vScrollElement.classList.toggle('hidden', !showScroll);\n    this.updateContentElementSize();\n  }\n\n  override onResize(): void {\n    this.updateScrollBar();\n    this.updateContentElementSize();\n    this.scheduleUpdate();\n  }\n\n  reset(): void {\n    this.vScrollElement.scrollTop = 0;\n    this.scrollTop = 0;\n    this.rangeSelectionStart = null;\n    this.rangeSelectionEnd = null;\n    this.isDraggingInternal = false;\n    this.dragStartPointX = 0;\n    this.dragStartPointY = 0;\n    this.dragStartScrollTop = 0;\n    this.visibleLeftTime = 0;\n    this.visibleRightTime = 0;\n    this.offsetWidth = 0;\n    this.offsetHeight = 0;\n    this.totalHeight = 0;\n    this.targetLeftTime = 0;\n    this.targetRightTime = 0;\n    this.isUpdateScheduled = false;\n    this.updateContentElementSize();\n  }\n\n  private updateContentElementSize(): void {\n    let offsetWidth: number = this.vScrollElement.offsetLeft;\n    if (!offsetWidth) {\n      offsetWidth = this.contentElement.offsetWidth;\n    }\n    this.offsetWidth = offsetWidth;\n    this.offsetHeight = this.contentElement.offsetHeight;\n    this.delegate.setSize(this.offsetWidth, this.offsetHeight);\n  }\n\n  setContentHeight(totalHeight: number): void {\n    this.totalHeight = totalHeight;\n    this.vScrollContent.style.height = totalHeight + 'px';\n    this.updateScrollBar();\n    this.updateContentElementSize();\n    if (this.scrollTop + this.offsetHeight <= totalHeight) {\n      return;\n    }\n    this.scrollTop = Math.max(0, totalHeight - this.offsetHeight);\n    this.vScrollElement.scrollTop = this.scrollTop;\n  }\n\n  /**\n   * @param centered - If true, scrolls offset to where it is centered on the chart,\n   * based on current the this.offsetHeight value.\n   */\n  setScrollOffset(offset: number, height?: number, centered?: boolean): void {\n    height = height || 0;\n    if (centered) {\n      // Half of the height for padding.\n      const halfPadding = Math.floor(this.offsetHeight / 2);\n\n      if (this.vScrollElement.scrollTop > offset) {\n        // Need to scroll up, include height.\n        this.vScrollElement.scrollTop = offset - (height + halfPadding);\n      }\n    } else {\n      if (this.vScrollElement.scrollTop > offset) {\n        this.vScrollElement.scrollTop = offset;\n      }\n    }\n\n    if (this.vScrollElement.scrollTop < offset - this.offsetHeight + height) {\n      this.vScrollElement.scrollTop = offset - this.offsetHeight + height;\n    }\n  }\n\n  scrollOffset(): number {\n    return this.vScrollElement.scrollTop;\n  }\n\n  chartHeight(): number {\n    return this.offsetHeight;\n  }\n\n  setBoundaries(zeroTime: number, totalTime: number): void {\n    this.minimumBoundary = zeroTime;\n    this.totalTime = totalTime;\n  }\n\n  /**\n   * The mouse wheel can results in flamechart zoom, scroll and pan actions, depending on the scroll deltas and the selected navigation:\n   *\n   * Classic navigation:\n   * 1. Mouse Wheel --> Zoom\n   * 2. Mouse Wheel + Shift --> Scroll\n   * 3. Trackpad: Mouse Wheel AND horizontal scroll (deltaX > deltaY): --> Pan left/right\n   *\n   * Modern navigation:\n   * 1. Mouse Wheel -> Scroll\n   * 2. Mouse Wheel + Shift -> Pan left/right\n   * 3. Mouse Wheel + Ctrl/Cmd -> Zoom\n   * 4. Trackpad: Mouse Wheel AND horizontal scroll (deltaX > deltaY): --> Zoom\n   */\n  private onMouseWheel(wheelEvent: WheelEvent): void {\n    const navigation = Common.Settings.Settings.instance().moduleSetting('flamechart-selected-navigation').get();\n    const scrollDelta = (wheelEvent.deltaY || wheelEvent.deltaX) / 53 * this.offsetHeight / 8;\n    const zoomDelta = Math.pow(1.2, (wheelEvent.deltaY || wheelEvent.deltaX) * 1 / 53) - 1;\n\n    if (navigation === 'classic') {\n      if (wheelEvent.shiftKey) {  // Scroll\n        this.vScrollElement.scrollTop += scrollDelta;\n      } else if (Math.abs(wheelEvent.deltaX) > Math.abs(wheelEvent.deltaY)) {  // Pan left/right\n        this.handlePanGesture(wheelEvent.deltaX, /* animate */ true);\n      } else {  // Zoom\n        this.handleZoomGesture(zoomDelta);\n      }\n    } else if (navigation === 'modern') {\n      if (wheelEvent.shiftKey) {  // Pan left/right\n        this.handlePanGesture(wheelEvent.deltaY, /* animate */ true);\n      } else if (wheelEvent.ctrlKey || Math.abs(wheelEvent.deltaX) > Math.abs(wheelEvent.deltaY)) {  // Zoom\n        this.handleZoomGesture(zoomDelta);\n      } else {  // Scroll\n        this.vScrollElement.scrollTop += scrollDelta;\n      }\n    }\n\n    // Block swipe gesture.\n    wheelEvent.consume(true);\n  }\n\n  private startDragging(event: MouseEvent): boolean {\n    if (event.shiftKey) {\n      return false;\n    }\n    this.isDraggingInternal = true;\n    this.dragStartPointX = event.pageX;\n    this.dragStartPointY = event.pageY;\n    this.dragStartScrollTop = this.vScrollElement.scrollTop;\n    this.viewportElement.style.cursor = '';\n    return true;\n  }\n\n  private dragging(event: MouseEvent): void {\n    const pixelShift = this.dragStartPointX - event.pageX;\n    this.dragStartPointX = event.pageX;\n    this.handlePanGesture(pixelShift);\n    const pixelScroll = this.dragStartPointY - event.pageY;\n    this.vScrollElement.scrollTop = this.dragStartScrollTop + pixelScroll;\n  }\n\n  private endDragging(): void {\n    this.isDraggingInternal = false;\n  }\n\n  private startRangeSelection(event: MouseEvent): boolean {\n    if (!event.shiftKey || !this.rangeSelectionEnabled) {\n      return false;\n    }\n    this.isDraggingInternal = true;\n    this.selectionOffsetShiftX = event.offsetX - event.pageX;\n    this.selectionStartX = event.offsetX;\n    return true;\n  }\n\n  private endRangeSelection(): void {\n    this.isDraggingInternal = false;\n    this.selectionStartX = null;\n  }\n\n  hideRangeSelection(): void {\n    this.selectionOverlay.classList.add('hidden');\n    this.rangeSelectionStart = null;\n    this.rangeSelectionEnd = null;\n  }\n\n  /**\n   * @param startTime - the start time of the selection in MilliSeconds\n   * @param endTime - the end time of the selection in MilliSeconds\n   * TODO(crbug.com/346312365): update the type definitions in ChartViewport.ts\n   */\n  setRangeSelection(startTime: number, endTime: number): void {\n    if (!this.rangeSelectionEnabled) {\n      return;\n    }\n    this.rangeSelectionStart = Math.min(startTime, endTime);\n    this.rangeSelectionEnd = Math.max(startTime, endTime);\n    this.delegate.updateRangeSelection(this.rangeSelectionStart, this.rangeSelectionEnd);\n  }\n\n  onClick(event: Event): void {\n    const mouseEvent = (event as MouseEvent);\n    const time = this.pixelToTime(mouseEvent.offsetX);\n    if (this.rangeSelectionStart !== null && this.rangeSelectionEnd !== null && time >= this.rangeSelectionStart &&\n        time <= this.rangeSelectionEnd) {\n      return;\n    }\n    this.hideRangeSelection();\n  }\n\n  private rangeSelectionDragging(event: MouseEvent): void {\n    const x = Platform.NumberUtilities.clamp(event.pageX + this.selectionOffsetShiftX, 0, this.offsetWidth);\n    const start = this.pixelToTime(this.selectionStartX || 0);\n    const end = this.pixelToTime(x);\n    this.setRangeSelection(start, end);\n  }\n\n  private onScroll(): void {\n    this.scrollTop = this.vScrollElement.scrollTop;\n    this.scheduleUpdate();\n  }\n\n  private onMouseOut(): void {\n    this.lastMouseOffsetX = -1;\n    this.showCursor(false);\n  }\n\n  private updateCursorPosition(e: Event): void {\n    const mouseEvent = (e as MouseEvent);\n    this.lastMouseOffsetX = mouseEvent.offsetX;\n    const shouldShowCursor = this.#config.enableCursorElement && mouseEvent.shiftKey && !mouseEvent.metaKey;\n    this.showCursor(shouldShowCursor);\n    if (shouldShowCursor) {\n      this.cursorElement.style.left = mouseEvent.offsetX + 'px';\n    }\n  }\n\n  pixelToTime(x: number): number {\n    return this.pixelToTimeOffset(x) + this.visibleLeftTime;\n  }\n\n  pixelToTimeOffset(x: number): number {\n    return x * (this.visibleRightTime - this.visibleLeftTime) / this.offsetWidth;\n  }\n\n  timeToPosition(time: number): number {\n    return Math.floor(\n        (time - this.visibleLeftTime) / (this.visibleRightTime - this.visibleLeftTime) * this.offsetWidth);\n  }\n\n  timeToPixel(): number {\n    return this.offsetWidth / (this.visibleRightTime - this.visibleLeftTime);\n  }\n\n  private showCursor(visible: boolean): void {\n    this.cursorElement.classList.toggle('hidden', !visible || this.isDraggingInternal);\n  }\n\n  private onChartKeyDown(keyboardEvent: KeyboardEvent): void {\n    this.showCursor(keyboardEvent.shiftKey);\n    this.handleZoomPanScrollKeys(keyboardEvent);\n  }\n\n  private onChartKeyUp(keyboardEvent: KeyboardEvent): void {\n    this.showCursor(keyboardEvent.shiftKey);\n  }\n\n  private handleZoomPanScrollKeys(keyboardEvent: KeyboardEvent): void {\n    // Do not zoom, pan or scroll if the key combination has any modifiers other than shift key\n    if (UI.KeyboardShortcut.KeyboardShortcut.hasAtLeastOneModifier(keyboardEvent) && !keyboardEvent.shiftKey) {\n      return;\n    }\n    const zoomFactor = keyboardEvent.shiftKey ? 0.8 : 0.3;\n    const panOffset = keyboardEvent.shiftKey ? 320 : 160;\n    const scrollOffset = 50;\n    switch (keyboardEvent.code) {\n      case 'KeyA':\n        this.handlePanGesture(-panOffset, /* animate */ true);\n        break;\n      case 'KeyD':\n        this.handlePanGesture(panOffset, /* animate */ true);\n        break;\n      case 'Equal':  // '+' key for zoom in\n      case 'KeyW':\n        this.handleZoomGesture(-zoomFactor);\n        break;\n      case 'Minus':  // '-' key for zoom out\n      case 'KeyS':\n        this.handleZoomGesture(zoomFactor);\n        break;\n      case 'ArrowUp':\n        if (keyboardEvent.shiftKey) {\n          this.vScrollElement.scrollTop -= scrollOffset;\n        }\n        break;\n      case 'ArrowDown':\n        if (keyboardEvent.shiftKey) {\n          this.vScrollElement.scrollTop += scrollOffset;\n        }\n        break;\n      default:\n        return;\n    }\n    keyboardEvent.consume(true);\n  }\n\n  private handleZoomGesture(zoom: number): void {\n    const bounds = {left: this.targetLeftTime, right: this.targetRightTime};\n    // If the user has not moved their mouse over the panel (unlikely but\n    // possible!), the offsetX will be undefined. In that case, let's just use\n    // the minimum time / pixel 0 as their mouse point.\n    const cursorTime = this.pixelToTime(this.lastMouseOffsetX || 0);\n    bounds.left += (bounds.left - cursorTime) * zoom;\n    bounds.right += (bounds.right - cursorTime) * zoom;\n    this.requestWindowTimes(bounds, /* animate */ true);\n  }\n\n  private handlePanGesture(offset: number, animate?: boolean): void {\n    const bounds = {left: this.targetLeftTime, right: this.targetRightTime};\n    const timeOffset = Platform.NumberUtilities.clamp(\n        this.pixelToTimeOffset(offset), this.minimumBoundary - bounds.left,\n        this.totalTime + this.minimumBoundary - bounds.right);\n    bounds.left += timeOffset;\n    bounds.right += timeOffset;\n    this.requestWindowTimes(bounds, Boolean(animate));\n  }\n\n  private requestWindowTimes(\n      bounds: {\n        left: number,\n        right: number,\n      },\n      animate: boolean): void {\n    const maxBound = this.minimumBoundary + this.totalTime;\n    if (bounds.left < this.minimumBoundary) {\n      bounds.right = Math.min(bounds.right + this.minimumBoundary - bounds.left, maxBound);\n      bounds.left = this.minimumBoundary;\n    } else if (bounds.right > maxBound) {\n      bounds.left = Math.max(bounds.left - bounds.right + maxBound, this.minimumBoundary);\n      bounds.right = maxBound;\n    }\n    if (bounds.right - bounds.left < MinimalTimeWindowMs) {\n      return;\n    }\n    this.delegate.windowChanged(bounds.left, bounds.right, animate);\n  }\n\n  scheduleUpdate(): void {\n    if (this.cancelWindowTimesAnimation || this.isUpdateScheduled) {\n      return;\n    }\n    this.isUpdateScheduled = true;\n    void coordinator.write(() => {\n      this.isUpdateScheduled = false;\n      this.update();\n    });\n  }\n\n  override update(): void {\n    this.delegate.update();\n  }\n\n  setWindowTimes(startTime: number, endTime: number, animate?: boolean): void {\n    if (startTime === this.targetLeftTime && endTime === this.targetRightTime) {\n      return;\n    }\n    if (!animate || this.visibleLeftTime === 0 || this.visibleRightTime === Infinity ||\n        (startTime === 0 && endTime === Infinity) || (startTime === Infinity && endTime === Infinity)) {\n      // Skip animation, move instantly.\n      this.targetLeftTime = startTime;\n      this.targetRightTime = endTime;\n      this.visibleLeftTime = startTime;\n      this.visibleRightTime = endTime;\n      this.scheduleUpdate();\n      return;\n    }\n    if (this.cancelWindowTimesAnimation) {\n      this.cancelWindowTimesAnimation();\n      this.visibleLeftTime = this.targetLeftTime;\n      this.visibleRightTime = this.targetRightTime;\n    }\n    this.targetLeftTime = startTime;\n    this.targetRightTime = endTime;\n    this.cancelWindowTimesAnimation = UI.UIUtils.animateFunction(\n        this.element.window(), animateWindowTimes.bind(this),\n        [{from: this.visibleLeftTime, to: startTime}, {from: this.visibleRightTime, to: endTime}], 100, () => {\n          this.cancelWindowTimesAnimation = null;\n        });\n\n    function animateWindowTimes(this: ChartViewport, startTime: number, endTime: number): void {\n      this.visibleLeftTime = startTime;\n      this.visibleRightTime = endTime;\n      this.update();\n    }\n  }\n\n  windowLeftTime(): number {\n    return this.visibleLeftTime;\n  }\n\n  windowRightTime(): number {\n    return this.visibleRightTime;\n  }\n}\n"],
  "mappings": "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",
  "names": ["startTime", "endTime"]
}
