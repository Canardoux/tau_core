{
  "version": 3,
  "sources": ["../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/components/text_editor/javascript.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport * as Bindings from '../../../models/bindings/bindings.js';\nimport * as JavaScriptMetaData from '../../../models/javascript_metadata/javascript_metadata.js';\nimport * as SourceMapScopes from '../../../models/source_map_scopes/source_map_scopes.js';\nimport * as CodeMirror from '../../../third_party/codemirror.next/codemirror.next.js';\nimport * as UI from '../../legacy/legacy.js';\n\nimport {type ArgumentHintsTooltip, closeTooltip, cursorTooltip} from './cursor_tooltip.js';\n\nexport function completion(): CodeMirror.Extension {\n  return CodeMirror.javascript.javascriptLanguage.data.of({\n    autocomplete: javascriptCompletionSource,\n  });\n}\n\nexport async function completeInContext(\n    textBefore: string, query: string, force: boolean = false): Promise<UI.SuggestBox.Suggestions> {\n  const state = CodeMirror.EditorState.create({\n    doc: textBefore + query,\n    selection: {anchor: textBefore.length},\n    extensions: CodeMirror.javascript.javascriptLanguage,\n  });\n  const result = await javascriptCompletionSource(new CodeMirror.CompletionContext(state, state.doc.length, force));\n  return result ? result.options.filter(o => o.label.startsWith(query)).map(o => ({\n                                                                              text: o.label,\n                                                                              priority: 100 + (o.boost || 0),\n                                                                              isSecondary: o.type === 'secondary',\n                                                                            })) :\n                  [];\n}\n\nclass CompletionSet {\n  constructor(\n      readonly completions: CodeMirror.Completion[] = [],\n      readonly seen: Set<string> = new Set(),\n  ) {\n  }\n\n  add(completion: CodeMirror.Completion): void {\n    if (!this.seen.has(completion.label)) {\n      this.seen.add(completion.label);\n      this.completions.push(completion);\n    }\n  }\n\n  copy(): CompletionSet {\n    return new CompletionSet(this.completions.slice(), new Set(this.seen));\n  }\n}\n\nconst javascriptKeywords = [\n  'async',      'await', 'break',  'case',    'catch', 'class',   'const',  'continue', 'debugger', 'default', 'delete',\n  'do',         'else',  'export', 'extends', 'false', 'finally', 'for',    'function', 'if',       'import',  'in',\n  'instanceof', 'let',   'new',    'null',    'of',    'return',  'static', 'super',    'switch',   'this',    'throw',\n  'true',       'try',   'typeof', 'var',     'void',  'while',   'with',   'yield',\n];\nconst consoleBuiltinFunctions = [\n  'clear',\n  'copy',\n  'debug',\n  'dir',\n  'dirxml',\n  'getEventListeners',\n  'inspect',\n  'keys',\n  'monitor',\n  'monitorEvents',\n  'profile',\n  'profileEnd',\n  'queryObjects',\n  'table',\n  'undebug',\n  'unmonitor',\n  'unmonitorEvents',\n  'values',\n];\nconst consoleBuiltinVariables = ['$', '$$', '$x', '$0', '$_'];\n\nconst baseCompletions = new CompletionSet();\nfor (const kw of javascriptKeywords) {\n  baseCompletions.add({label: kw, type: 'keyword'});\n}\nfor (const builtin of consoleBuiltinFunctions) {\n  baseCompletions.add({label: builtin, type: 'function'});\n}\nfor (const varName of consoleBuiltinVariables) {\n  baseCompletions.add({label: varName, type: 'variable'});\n}\n\nconst dontCompleteIn = new Set([\n  'TemplateString',\n  'LineComment',\n  'BlockComment',\n  'TypeDefinition',\n  'VariableDefinition',\n  'PropertyDefinition',\n  'TypeName',\n]);\n\nexport const enum QueryType {\n  EXPRESSION = 0,\n  PROPERTY_NAME = 1,\n  PROPERTY_EXPRESSION = 2,\n  POTENTIALLY_RETRIEVING_FROM_MAP = 3,\n}\n\nexport function getQueryType(tree: CodeMirror.Tree, pos: number, doc: CodeMirror.Text): {\n  type: QueryType,\n  from?: number,\n  relatedNode?: CodeMirror.SyntaxNode,\n}|null {\n  let node = tree.resolveInner(pos, -1);\n  const parent = node.parent;\n  if (dontCompleteIn.has(node.name)) {\n    return null;\n  }\n\n  if (node.name === 'PropertyName' || node.name === 'PrivatePropertyName') {\n    return parent?.name !== 'MemberExpression' ? null :\n                                                 {type: QueryType.PROPERTY_NAME, from: node.from, relatedNode: parent};\n  }\n  if (node.name === 'VariableName' ||\n      // Treat alphabetic keywords as variables\n      !node.firstChild && node.to - node.from < 20 && !/[^a-z]/.test(doc.sliceString(node.from, node.to))) {\n    return {type: QueryType.EXPRESSION, from: node.from};\n  }\n  if (node.name === 'String') {\n    const parent = node.parent;\n    return parent?.name === 'MemberExpression' && parent.childBefore(node.from)?.name === '[' ?\n        {type: QueryType.PROPERTY_EXPRESSION, from: node.from, relatedNode: parent} :\n        null;\n  }\n  // Enter unfinished nodes before the position.\n  node = node.enterUnfinishedNodesBefore(pos);\n  // Normalize to parent node when pointing after a child of a member expr.\n  if (node.to === pos && node.parent?.name === 'MemberExpression') {\n    node = node.parent;\n  }\n  if (node.name === 'MemberExpression') {\n    const before = node.childBefore(Math.min(pos, node.to));\n    if (before?.name === '[') {\n      return {type: QueryType.PROPERTY_EXPRESSION, relatedNode: node};\n    }\n    if (before?.name === '.' || before?.name === '?.') {\n      return {type: QueryType.PROPERTY_NAME, relatedNode: node};\n    }\n  }\n  if (node.name === '(') {\n    // map.get(<auto-complete>\n    if (parent?.name === 'ArgList' && parent?.parent?.name === 'CallExpression') {\n      // map.get\n      const callReceiver = parent?.parent?.firstChild;\n      if (callReceiver?.name === 'MemberExpression') {\n        // get\n        const propertyExpression = callReceiver?.lastChild;\n        if (propertyExpression && doc.sliceString(propertyExpression.from, propertyExpression.to) === 'get') {\n          // map\n          const potentiallyMapObject = callReceiver?.firstChild;\n          return {type: QueryType.POTENTIALLY_RETRIEVING_FROM_MAP, relatedNode: potentiallyMapObject || undefined};\n        }\n      }\n    }\n  }\n  return {type: QueryType.EXPRESSION};\n}\n\nexport async function javascriptCompletionSource(cx: CodeMirror.CompletionContext):\n    Promise<CodeMirror.CompletionResult|null> {\n  const query = getQueryType(CodeMirror.syntaxTree(cx.state), cx.pos, cx.state.doc);\n  if (!query || query.from === undefined && !cx.explicit && query.type === QueryType.EXPRESSION) {\n    return null;\n  }\n\n  const script = getExecutionContext()?.debuggerModel.selectedCallFrame()?.script;\n  if (script &&\n      Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().pluginManager.hasPluginForScript(script)) {\n    return null;\n  }\n\n  let result: CompletionSet;\n  let quote: string|undefined = undefined;\n  if (query.type === QueryType.EXPRESSION) {\n    const [scope, global] = await Promise.all([\n      completeExpressionInScope(),\n      completeExpressionGlobal(),\n    ]);\n    if (scope.completions.length) {\n      result = scope;\n      for (const r of global.completions) {\n        result.add(r);\n      }\n    } else {\n      result = global;\n    }\n  } else if (query.type === QueryType.PROPERTY_NAME || query.type === QueryType.PROPERTY_EXPRESSION) {\n    const objectExpr = (query.relatedNode as CodeMirror.SyntaxNode).getChild('Expression');\n    if (query.type === QueryType.PROPERTY_EXPRESSION) {\n      quote = query.from === undefined ? '\\'' : cx.state.sliceDoc(query.from, query.from + 1);\n    }\n    if (!objectExpr) {\n      return null;\n    }\n    result = await completeProperties(\n        cx.state.sliceDoc(objectExpr.from, objectExpr.to), quote, cx.state.sliceDoc(cx.pos, cx.pos + 1) === ']');\n  } else if (query.type === QueryType.POTENTIALLY_RETRIEVING_FROM_MAP) {\n    const potentialMapObject = query.relatedNode;\n    if (!potentialMapObject) {\n      return null;\n    }\n    result = await maybeCompleteKeysFromMap(cx.state.sliceDoc(potentialMapObject.from, potentialMapObject.to));\n  } else {\n    return null;\n  }\n  return {\n    from: query.from ?? cx.pos,\n    options: result.completions,\n    validFor: !quote   ? SPAN_IDENT :\n        quote === '\\'' ? SPAN_SINGLE_QUOTE :\n                         SPAN_DOUBLE_QUOTE,\n  };\n}\n\nconst SPAN_IDENT = /^#?(?:[$_\\p{ID_Start}])(?:[$_\\u200C\\u200D\\p{ID_Continue}])*$/u,\n      SPAN_SINGLE_QUOTE = /^\\'(\\\\.|[^\\\\'\\n])*'?$/, SPAN_DOUBLE_QUOTE = /^\"(\\\\.|[^\\\\\"\\n])*\"?$/;\n\nfunction getExecutionContext(): SDK.RuntimeModel.ExecutionContext|null {\n  return UI.Context.Context.instance().flavor(SDK.RuntimeModel.ExecutionContext);\n}\n\nasync function evaluateExpression(\n    context: SDK.RuntimeModel.ExecutionContext,\n    expression: string,\n    group: string,\n    ): Promise<SDK.RemoteObject.RemoteObject|null> {\n  const result = await context.evaluate(\n      {\n        expression,\n        objectGroup: group,\n        includeCommandLineAPI: true,\n        silent: true,\n        returnByValue: false,\n        generatePreview: false,\n        throwOnSideEffect: true,\n        timeout: 500,\n        replMode: true,\n      },\n      false, false);\n  if ('error' in result || result.exceptionDetails || !result.object) {\n    return null;\n  }\n  return result.object;\n}\n\nconst primitivePrototypes = new Map<string, string>([\n  ['string', 'String'],\n  ['symbol', 'Symbol'],\n  ['number', 'Number'],\n  ['boolean', 'Boolean'],\n  ['bigint', 'BigInt'],\n]);\n\nconst maxCacheAge = 30_000;\n\nlet cacheInstance: PropertyCache|null = null;\n\n// Store recent collections of property completions. The empty string\n// is used to store the set of global bindings.\nclass PropertyCache {\n  readonly #cache: Map<string, Promise<CompletionSet>> = new Map();\n\n  constructor() {\n    const clear = (): void => this.#cache.clear();\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.ConsoleModel.ConsoleModel, SDK.ConsoleModel.Events.CommandEvaluated, clear);\n    UI.Context.Context.instance().addFlavorChangeListener(SDK.RuntimeModel.ExecutionContext, clear);\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.DebuggerResumed, clear);\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.DebuggerPaused, clear);\n  }\n\n  get(expression: string): Promise<CompletionSet>|undefined {\n    return this.#cache.get(expression);\n  }\n\n  set(expression: string, value: Promise<CompletionSet>): void {\n    this.#cache.set(expression, value);\n    window.setTimeout(() => {\n      if (this.#cache.get(expression) === value) {\n        this.#cache.delete(expression);\n      }\n    }, maxCacheAge);\n  }\n\n  static instance(): PropertyCache {\n    if (!cacheInstance) {\n      cacheInstance = new PropertyCache();\n    }\n    return cacheInstance;\n  }\n}\n\nasync function maybeCompleteKeysFromMap(objectVariable: string): Promise<CompletionSet> {\n  const result = new CompletionSet();\n  const context = getExecutionContext();\n  if (!context) {\n    return result;\n  }\n  const maybeRetrieveKeys =\n      await evaluateExpression(context, `[...Map.prototype.keys.call(${objectVariable})]`, 'completion');\n  if (!maybeRetrieveKeys) {\n    return result;\n  }\n  const properties = SDK.RemoteObject.RemoteArray.objectAsArray(maybeRetrieveKeys);\n  const numProperties = properties.length();\n  for (let i = 0; i < numProperties; i++) {\n    result.add({\n      label: `\"${(await properties.at(i)).value}\")`,\n      type: 'constant',\n      boost: i * -1,\n    });\n  }\n  return result;\n}\n\nasync function completeProperties(\n    expression: string,\n    quoted?: string,\n    hasBracket: boolean = false,\n    ): Promise<CompletionSet> {\n  const cache = PropertyCache.instance();\n  if (!quoted) {\n    const cached = cache.get(expression);\n    if (cached) {\n      return cached;\n    }\n  }\n  const context = getExecutionContext();\n  if (!context) {\n    return new CompletionSet();\n  }\n  const result = completePropertiesInner(expression, context, quoted, hasBracket);\n  if (!quoted) {\n    cache.set(expression, result);\n  }\n  return result;\n}\n\nasync function completePropertiesInner(\n    expression: string,\n    context: SDK.RuntimeModel.ExecutionContext,\n    quoted?: string,\n    hasBracket: boolean = false,\n    ): Promise<CompletionSet> {\n  const result = new CompletionSet();\n  if (!context) {\n    return result;\n  }\n  let object = await evaluateExpression(context, expression, 'completion');\n  if (!object) {\n    return result;\n  }\n\n  while (object.type === 'object' && object.subtype === 'proxy') {\n    const properties = await object.getOwnProperties(false);\n    const innerObject = properties.internalProperties?.find(p => p.name === '[[Target]]')?.value;\n    if (!innerObject) {\n      break;\n    }\n    object = innerObject as SDK.RemoteObject.RemoteObject;\n  }\n\n  const toPrototype = primitivePrototypes.get(object.type);\n  if (toPrototype) {\n    object = await evaluateExpression(context, toPrototype + '.prototype', 'completion');\n  }\n\n  const functionType = expression === 'globalThis' ? 'function' : 'method';\n  const otherType = expression === 'globalThis' ? 'variable' : 'property';\n  if (object && (object.type === 'object' || object.type === 'function')) {\n    const properties = await object.getAllProperties(\n        /* accessorPropertiesOnly */ false, /* generatePreview */ false, /* nonIndexedPropertiesOnly */ true);\n    const isFunction = object.type === 'function';\n    for (const prop of properties.properties || []) {\n      if (!prop.symbol && !(isFunction && (prop.name === 'arguments' || prop.name === 'caller')) &&\n          (quoted || SPAN_IDENT.test(prop.name))) {\n        const label =\n            quoted ? quoted + prop.name.replaceAll('\\\\', '\\\\\\\\').replaceAll(quoted, '\\\\' + quoted) + quoted : prop.name;\n        const apply = (quoted && !hasBracket) ? `${label}]` : undefined;\n        const boost = 2 * Number(prop.isOwn) + 1 * Number(prop.enumerable);\n        const type = prop.value?.type === 'function' ? functionType : otherType;\n        result.add({apply, label, type, boost});\n      }\n    }\n  }\n  context.runtimeModel.releaseObjectGroup('completion');\n  return result;\n}\n\nasync function completeExpressionInScope(): Promise<CompletionSet> {\n  const result = new CompletionSet();\n  const selectedFrame = getExecutionContext()?.debuggerModel.selectedCallFrame();\n  if (!selectedFrame) {\n    return result;\n  }\n\n  const scopes = await Promise.all(selectedFrame.scopeChain().map(\n      scope => SourceMapScopes.NamesResolver.resolveScopeInObject(scope).getAllProperties(false, false)));\n  for (const scope of scopes) {\n    for (const property of scope.properties || []) {\n      result.add({\n        label: property.name,\n        type: property.value?.type === 'function' ? 'function' : 'variable',\n      });\n    }\n  }\n  return result;\n}\n\nasync function completeExpressionGlobal(): Promise<CompletionSet> {\n  const cache = PropertyCache.instance();\n  const cached = cache.get('');\n  if (cached) {\n    return cached;\n  }\n\n  const context = getExecutionContext();\n  if (!context) {\n    return baseCompletions;\n  }\n  const result = baseCompletions.copy();\n\n  const fetchNames = completePropertiesInner('globalThis', context).then(fromWindow => {\n    return context.globalLexicalScopeNames().then(globals => {\n      for (const option of fromWindow.completions) {\n        result.add(option);\n      }\n      for (const name of globals || []) {\n        result.add({label: name, type: 'variable'});\n      }\n      return result;\n    });\n  });\n  cache.set('', fetchNames);\n  return fetchNames;\n}\n\nexport async function isExpressionComplete(expression: string): Promise<boolean> {\n  const currentExecutionContext = UI.Context.Context.instance().flavor(SDK.RuntimeModel.ExecutionContext);\n  if (!currentExecutionContext) {\n    return true;\n  }\n  const result =\n      await currentExecutionContext.runtimeModel.compileScript(expression, '', false, currentExecutionContext.id);\n  if (!result || !result.exceptionDetails || !result.exceptionDetails.exception) {\n    return true;\n  }\n  const description = result.exceptionDetails.exception.description;\n  if (description) {\n    return !description.startsWith('SyntaxError: Unexpected end of input') &&\n        !description.startsWith('SyntaxError: Unterminated template literal');\n  }\n  return false;\n}\n\nexport function argumentHints(): ArgumentHintsTooltip {\n  return cursorTooltip(getArgumentHints);\n}\n\nexport function closeArgumentsHintsTooltip(\n    view: CodeMirror.EditorView, tooltip: CodeMirror.StateField<CodeMirror.Tooltip|null>): boolean {\n  // If the tooltip is currently showing, the state will reflect its properties.\n  // If it isn't showing, the state is explicitly set to `null`.\n  if (view.state.field(tooltip) === null) {\n    return false;\n  }\n  view.dispatch({effects: closeTooltip.of(null)});\n  return true;\n}\n\nasync function getArgumentHints(\n    state: CodeMirror.EditorState, pos: number): Promise<(() => CodeMirror.TooltipView)|null> {\n  const node = CodeMirror.syntaxTree(state).resolveInner(pos).enterUnfinishedNodesBefore(pos);\n\n  if (node.name !== 'ArgList') {\n    return null;\n  }\n  const callee = node.parent?.getChild('Expression');\n  if (!callee) {\n    return null;\n  }\n  const argumentList = await getArgumentsForExpression(callee, state.doc);\n  if (!argumentList) {\n    return null;\n  }\n\n  let argumentIndex = 0;\n  for (let scanPos = pos;;) {\n    const before = node.childBefore(scanPos);\n    if (!before) {\n      break;\n    }\n    if (before.type.is('Expression')) {\n      argumentIndex++;\n    }\n    scanPos = before.from;\n  }\n  return () => tooltipBuilder(argumentList, argumentIndex);\n}\n\nasync function getArgumentsForExpression(\n    callee: CodeMirror.SyntaxNode, doc: CodeMirror.Text): Promise<string[][]|null> {\n  const context = getExecutionContext();\n  if (!context) {\n    return null;\n  }\n  const expression = doc.sliceString(callee.from, callee.to);\n  const result = await evaluateExpression(context, expression, 'argumentsHint');\n  if (!result || result.type !== 'function') {\n    return null;\n  }\n  const objGetter = async(): Promise<SDK.RemoteObject.RemoteObject|null> => {\n    const first = callee.firstChild;\n    if (!first || callee.name !== 'MemberExpression') {\n      return null;\n    }\n    return evaluateExpression(context, doc.sliceString(first.from, first.to), 'argumentsHint');\n  };\n  return getArgumentsForFunctionValue(result, objGetter, expression)\n      .finally(() => context.runtimeModel.releaseObjectGroup('argumentsHint'));\n}\n\nexport function argumentsList(input: string): string[] {\n  function parseParamList(cursor: CodeMirror.TreeCursor): string[] {\n    while (cursor.name !== 'ParamList' && cursor.nextSibling()) {\n    }\n    const parameters = [];\n    if (cursor.name === 'ParamList' && cursor.firstChild()) {\n      let prefix = '';\n      do {\n        switch (cursor.name as string) {\n          case 'ArrayPattern':\n            parameters.push(prefix + 'arr');\n            prefix = '';\n            break;\n          case 'ObjectPattern':\n            parameters.push(prefix + 'obj');\n            prefix = '';\n            break;\n          case 'VariableDefinition':\n            parameters.push(prefix + input.slice(cursor.from, cursor.to));\n            prefix = '';\n            break;\n          case 'Spread':\n            prefix = '...';\n            break;\n        }\n      } while (cursor.nextSibling());\n    }\n    return parameters;\n  }\n  try {\n    try {\n      // First check if the |input| can be parsed as a method definition.\n      const {parser} = CodeMirror.javascript.javascriptLanguage.configure({strict: true, top: 'SingleClassItem'});\n      const cursor = parser.parse(input).cursor();\n      if (cursor.firstChild() && cursor.name === 'MethodDeclaration' && cursor.firstChild()) {\n        return parseParamList(cursor);\n      }\n      throw new Error('SingleClassItem rule is expected to have exactly one MethodDeclaration child');\n    } catch {\n      // Otherwise fall back to parsing as an expression.\n      const {parser} = CodeMirror.javascript.javascriptLanguage.configure({strict: true, top: 'SingleExpression'});\n      const cursor = parser.parse(input).cursor();\n      if (!cursor.firstChild()) {\n        throw new Error('SingleExpression rule is expected to have children');\n      }\n      switch (cursor.name) {\n        case 'ArrowFunction':\n        case 'FunctionExpression': {\n          if (!cursor.firstChild()) {\n            throw new Error(`${cursor.name} rule is expected to have children`);\n          }\n          return parseParamList(cursor);\n        }\n        case 'ClassExpression': {\n          if (!cursor.firstChild()) {\n            throw new Error(`${cursor.name} rule is expected to have children`);\n          }\n          while (cursor.nextSibling() && cursor.name as string !== 'ClassBody') {\n          }\n          if (cursor.name as string === 'ClassBody' && cursor.firstChild()) {\n            do {\n              if (cursor.name as string === 'MethodDeclaration' && cursor.firstChild()) {\n                if (cursor.name as string === 'PropertyDefinition' &&\n                    input.slice(cursor.from, cursor.to) === 'constructor') {\n                  return parseParamList(cursor);\n                }\n                cursor.parent();\n              }\n            } while (cursor.nextSibling());\n          }\n          return [];\n        }\n      }\n      throw new Error('Unexpected expression');\n    }\n  } catch (cause) {\n    throw new Error(`Failed to parse for arguments list: ${input}`, {cause});\n  }\n}\n\nasync function getArgumentsForFunctionValue(\n    object: SDK.RemoteObject.RemoteObject,\n    receiverObjGetter: () => Promise<SDK.RemoteObject.RemoteObject|null>,\n    functionName?: string,\n    ): Promise<string[][]|null> {\n  const description = object.description;\n  if (!description) {\n    return null;\n  }\n  if (!description.endsWith('{ [native code] }')) {\n    return [argumentsList(description)];\n  }\n\n  // Check if this is a bound function.\n  if (description === 'function () { [native code] }') {\n    const fromBound = await getArgumentsForBoundFunction(object);\n    if (fromBound) {\n      return fromBound;\n    }\n  }\n\n  const javaScriptMetadata = JavaScriptMetaData.JavaScriptMetadata.JavaScriptMetadataImpl.instance();\n\n  const descriptionRegexResult = /^function ([^(]*)\\(/.exec(description);\n  const name = descriptionRegexResult && descriptionRegexResult[1] || functionName;\n  if (!name) {\n    return null;\n  }\n  const uniqueSignatures = javaScriptMetadata.signaturesForNativeFunction(name);\n  if (uniqueSignatures) {\n    return uniqueSignatures;\n  }\n  const receiverObj = await receiverObjGetter();\n  if (!receiverObj) {\n    return null;\n  }\n  const className = receiverObj.className;\n  if (className) {\n    const instanceMethods = javaScriptMetadata.signaturesForInstanceMethod(name, className);\n    if (instanceMethods) {\n      return instanceMethods;\n    }\n  }\n\n  // Check for static methods on a constructor.\n  if (receiverObj.description && receiverObj.type === 'function' &&\n      receiverObj.description.endsWith('{ [native code] }')) {\n    const receiverDescriptionRegexResult = /^function ([^(]*)\\(/.exec(receiverObj.description);\n    if (receiverDescriptionRegexResult) {\n      const receiverName = receiverDescriptionRegexResult[1];\n      const staticSignatures = javaScriptMetadata.signaturesForStaticMethod(name, receiverName);\n      if (staticSignatures) {\n        return staticSignatures;\n      }\n    }\n  }\n\n  for (const proto of await prototypesFromObject(receiverObj)) {\n    const instanceSignatures = javaScriptMetadata.signaturesForInstanceMethod(name, proto);\n    if (instanceSignatures) {\n      return instanceSignatures;\n    }\n  }\n  return null;\n}\n\nasync function prototypesFromObject(object: SDK.RemoteObject.RemoteObject): Promise<string[]> {\n  if (object.type === 'number') {\n    return ['Number', 'Object'];\n  }\n  if (object.type === 'string') {\n    return ['String', 'Object'];\n  }\n  if (object.type === 'symbol') {\n    return ['Symbol', 'Object'];\n  }\n  if (object.type === 'bigint') {\n    return ['BigInt', 'Object'];\n  }\n  if (object.type === 'boolean') {\n    return ['Boolean', 'Object'];\n  }\n  if (object.type === 'undefined' || object.subtype === 'null') {\n    return [];\n  }\n  return await object.callFunctionJSON(function(this: Object) {\n    const result = [];\n    for (let object = this; object; object = Object.getPrototypeOf(object)) {\n      if (typeof object === 'object' && object.constructor && object.constructor.name) {\n        result[result.length] = object.constructor.name;\n      }\n    }\n    return result;\n  }, []);\n}\n\n// Given a function object that is probably a bound function, try to\n// retrieve the argument list from its target function.\nasync function getArgumentsForBoundFunction(object: SDK.RemoteObject.RemoteObject): Promise<string[][]|null> {\n  const {internalProperties} = await object.getOwnProperties(false);\n  if (!internalProperties) {\n    return null;\n  }\n  const target = internalProperties.find(p => p.name === '[[TargetFunction]]')?.value;\n  const args = internalProperties.find(p => p.name === '[[BoundArgs]]')?.value;\n  const thisValue = internalProperties.find(p => p.name === '[[BoundThis]]')?.value;\n  if (!thisValue || !target || !args) {\n    return null;\n  }\n  const originalSignatures = await getArgumentsForFunctionValue(target, () => Promise.resolve(thisValue));\n  const boundArgsLength = SDK.RemoteObject.RemoteObject.arrayLength(args);\n  if (!originalSignatures) {\n    return null;\n  }\n  return originalSignatures.map(signature => {\n    const restIndex = signature.findIndex(arg => arg.startsWith('...'));\n    return restIndex > -1 && restIndex < boundArgsLength ? signature.slice(restIndex) :\n                                                           signature.slice(boundArgsLength);\n  });\n}\n\nfunction tooltipBuilder(signatures: string[][], currentIndex: number): {dom: HTMLElement} {\n  const tooltip = document.createElement('div');\n  tooltip.className = 'cm-argumentHints';\n  for (const args of signatures) {\n    const argumentsElement = document.createElement('span');\n    for (let i = 0; i < args.length; i++) {\n      if (i === currentIndex || (i < currentIndex && args[i].startsWith('...'))) {\n        const argElement = argumentsElement.appendChild(document.createElement('b'));\n        argElement.appendChild(document.createTextNode(args[i]));\n      } else {\n        argumentsElement.appendChild(document.createTextNode(args[i]));\n      }\n      if (i < args.length - 1) {\n        argumentsElement.appendChild(document.createTextNode(', '));\n      }\n    }\n    const signatureElement = tooltip.appendChild(document.createElement('div'));\n    signatureElement.className = 'source-code';\n    signatureElement.appendChild(document.createTextNode('\\u0192('));\n    signatureElement.appendChild(argumentsElement);\n    signatureElement.appendChild(document.createTextNode(')'));\n  }\n  return {dom: tooltip};\n}\n"],
  "mappings": "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",
  "names": ["completion", "QueryType", "parent", "object"]
}
