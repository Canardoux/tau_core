{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/legacy/components/data_grid/ViewportDataGrid.ts"],
  "sourcesContent": ["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as Coordinator from '../../../components/render_coordinator/render_coordinator.js';\n\nimport {type DataGridData, DataGridImpl, DataGridNode, type Parameters} from './DataGrid.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nexport class ViewportDataGrid<T> extends Common.ObjectWrapper.eventMixin<EventTypes, typeof DataGridImpl>(\n    DataGridImpl)<ViewportDataGridNode<T>> {\n  private readonly onScrollBound: (event: Event|null) => void;\n  private visibleNodes: ViewportDataGridNode<T>[];\n  /** A datagrid preference to express that the grid represents an updating log of rows (eg Network panel request log, websocket messages).\n   * If `true`, the datagrid will mostly keep the scroll at the bottom, so new items are visible.\n   * If the data is sorted descending (eg Performance Call Tree, heap snapshot), keep the default of `false`.\n   */\n  enableAutoScrollToBottom: boolean = false;\n  /** When true, the datagrid will manipulate the scrollTop to focus on the bottom, mostly so new additions are visible.\n   * Some actions will unset this, like revealing or expanding a particular node.\n   * Only matters if enableAutoScrollToBottom is true. */\n  keepScrollingToBottom: boolean = false;\n  private updateIsFromUser: boolean;\n  private lastScrollTop: number;\n  private firstVisibleIsStriped: boolean;\n  private isStriped: boolean;\n\n  constructor(dataGridParameters: Parameters) {\n    super(dataGridParameters);\n\n    this.onScrollBound = this.onScroll.bind(this);\n    this.scrollContainer.addEventListener('scroll', this.onScrollBound, true);\n\n    this.visibleNodes = [];\n    this.inline = false;\n\n    this.updateIsFromUser = false;\n    this.lastScrollTop = 0;\n    this.firstVisibleIsStriped = false;\n    this.isStriped = false;\n\n    this.setRootNode(new ViewportDataGridNode());\n  }\n\n  override setStriped(striped: boolean): void {\n    this.isStriped = striped;\n    let startsWithOdd = true;\n    if (this.visibleNodes.length) {\n      const allChildren = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n      startsWithOdd = Boolean(allChildren.indexOf(this.visibleNodes[0]));\n    }\n    this.updateStripesClass(startsWithOdd);\n  }\n\n  private updateStripesClass(startsWithOdd: boolean): void {\n    this.element.classList.toggle('striped-data-grid', !startsWithOdd && this.isStriped);\n    this.element.classList.toggle('striped-data-grid-starts-with-odd', startsWithOdd && this.isStriped);\n  }\n\n  setScrollContainer(scrollContainer: HTMLElement): void {\n    this.scrollContainer.removeEventListener('scroll', this.onScrollBound, true);\n    this.scrollContainerInternal = scrollContainer;\n    this.scrollContainer.addEventListener('scroll', this.onScrollBound, true);\n  }\n\n  override onResize(): void {\n    if (this.keepScrollingToBottom) {\n      this.scrollContainer.scrollTop = this.scrollContainer.scrollHeight - this.scrollContainer.clientHeight;\n    }\n    this.scheduleUpdate();\n    super.onResize();\n  }\n\n  setEnableAutoScrollToBottom(stick: boolean): void {\n    this.keepScrollingToBottom = this.enableAutoScrollToBottom = stick;\n  }\n\n  private onScroll(_event: Event|null): void {\n    if (this.lastScrollTop !== this.scrollContainer.scrollTop) {\n      this.scheduleUpdate(true);\n    }\n  }\n\n  scheduleUpdateStructure(): void {\n    this.scheduleUpdate();\n  }\n\n  scheduleUpdate(isFromUser?: boolean): void {\n    this.updateIsFromUser = this.updateIsFromUser || Boolean(isFromUser);\n    void coordinator.write('ViewportDataGrid.render', this.update.bind(this));\n  }\n\n  // TODO(allada) This should be fixed to never be needed. It is needed right now for network because removing\n  // elements happens followed by a scheduleRefresh() which causes white space to be visible, but the waterfall\n  // updates instantly.\n  updateInstantly(): void {\n    this.update();\n  }\n\n  override renderInline(): void {\n    this.inline = true;\n    super.renderInline();\n    this.update();\n  }\n\n  private calculateVisibleNodes(clientHeight: number, scrollTop: number): {\n    topPadding: number,\n    bottomPadding: number,\n    contentHeight: number,\n    visibleNodes: Array<ViewportDataGridNode<T>>,\n    offset: number,\n  } {\n    const nodes = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n    if (this.inline) {\n      return {topPadding: 0, bottomPadding: 0, contentHeight: 0, visibleNodes: nodes, offset: 0};\n    }\n\n    const size = nodes.length;\n    let i = 0;\n    let y = 0;\n\n    for (; i < size && y + nodes[i].nodeSelfHeight() < scrollTop; ++i) {\n      y += nodes[i].nodeSelfHeight();\n    }\n    const start = i;\n    const topPadding = y;\n\n    for (; i < size && y < scrollTop + clientHeight; ++i) {\n      y += nodes[i].nodeSelfHeight();\n    }\n    const end = i;\n\n    let bottomPadding = 0;\n    for (; i < size; ++i) {\n      bottomPadding += nodes[i].nodeSelfHeight();\n    }\n\n    if (this.enableAutoScrollToBottom) {\n      // If we're scrolled to the very end, keep the scroll viewport focused to the end (as new items arrive)\n      this.keepScrollingToBottom = end === nodes.length;\n    }\n\n    return {\n      topPadding,\n      bottomPadding,\n      contentHeight: y - topPadding,\n      visibleNodes: nodes.slice(start, end),\n      offset: start,\n    };\n  }\n\n  private contentHeight(): number {\n    const nodes = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n    let result = 0;\n    for (let i = 0, size = nodes.length; i < size; ++i) {\n      result += nodes[i].nodeSelfHeight();\n    }\n    return result;\n  }\n\n  private update(): void {\n    const clientHeight = this.scrollContainer.clientHeight - this.headerHeightInScroller();\n    let scrollTop: number = this.scrollContainer.scrollTop;\n    const currentScrollTop = scrollTop;\n    const maxScrollTop = Math.max(0, this.contentHeight() - clientHeight);\n    if (!this.updateIsFromUser && this.keepScrollingToBottom) {\n      scrollTop = maxScrollTop;\n    }\n    this.updateIsFromUser = false;\n    scrollTop = Math.min(maxScrollTop, scrollTop);\n\n    const viewportState = this.calculateVisibleNodes(clientHeight, scrollTop);\n    const visibleNodes = viewportState.visibleNodes;\n    const visibleNodesSet = new Set<ViewportDataGridNode<T>>(visibleNodes);\n\n    for (let i = 0; i < this.visibleNodes.length; ++i) {\n      const oldNode = this.visibleNodes[i];\n      if (!visibleNodesSet.has(oldNode) && oldNode.attached()) {\n        const element = oldNode.existingElement();\n        if (element) {\n          element.remove();\n        }\n      }\n    }\n\n    let previousElement = this.topFillerRowElement();\n    const tBody = this.dataTableBody;\n    let offset = viewportState.offset;\n\n    if (visibleNodes.length) {\n      const nodes = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n      const index = nodes.indexOf(visibleNodes[0]);\n      this.updateStripesClass(Boolean(index % 2));\n      if (this.keepScrollingToBottom && index !== -1 && Boolean(index % 2) !== this.firstVisibleIsStriped) {\n        offset += 1;\n      }\n    }\n\n    this.firstVisibleIsStriped = Boolean(offset % 2);\n\n    for (let i = 0; i < visibleNodes.length; ++i) {\n      const node = visibleNodes[i];\n      const element = (node.element() as HTMLElement);\n      node.setStriped((offset + i) % 2 === 0);\n      if (element !== previousElement.nextSibling) {\n        tBody.insertBefore(element, previousElement.nextSibling);\n      }\n      node.revealed = true;\n      previousElement = element;\n    }\n\n    this.setVerticalPadding(viewportState.topPadding, viewportState.bottomPadding);\n    this.lastScrollTop = scrollTop;\n    if (scrollTop !== currentScrollTop) {\n      this.scrollContainer.scrollTop = scrollTop;\n    }\n    const contentFits =\n        viewportState.contentHeight <= clientHeight && viewportState.topPadding + viewportState.bottomPadding === 0;\n    if (contentFits !== this.element.classList.contains('data-grid-fits-viewport')) {\n      this.element.classList.toggle('data-grid-fits-viewport', contentFits);\n      this.updateWidths();\n    }\n    this.visibleNodes = visibleNodes;\n    this.dispatchEventToListeners(Events.VIEWPORT_CALCULATED);\n  }\n\n  revealViewportNode(node: ViewportDataGridNode<T>): void {\n    const nodes = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n    const index = nodes.indexOf(node);\n    if (index === -1) {\n      return;\n    }\n    let fromY = 0;\n    for (let i = 0; i < index; ++i) {\n      fromY += nodes[i].nodeSelfHeight();\n    }\n    const toY = fromY + node.nodeSelfHeight();\n    let scrollTop: number = this.scrollContainer.scrollTop;\n    const visibleHeight = this.scrollContainer.offsetHeight - this.headerHeightInScroller();\n    if (scrollTop > fromY) {\n      scrollTop = fromY;\n      this.keepScrollingToBottom = false;\n    } else if (scrollTop + visibleHeight < toY) {\n      scrollTop = toY - visibleHeight;\n    }\n    this.scrollContainer.scrollTop = scrollTop;\n  }\n}\n\nexport const enum Events {\n  VIEWPORT_CALCULATED = 'ViewportCalculated',\n}\n\nexport type EventTypes = {\n  [Events.VIEWPORT_CALCULATED]: void,\n};\n\nexport class ViewportDataGridNode<T> extends DataGridNode<ViewportDataGridNode<T>> {\n  private stale: boolean;\n  private flatNodes: ViewportDataGridNode<T>[]|null;\n  private isStripedInternal: boolean;\n\n  constructor(data?: DataGridData|null, hasChildren?: boolean) {\n    super(data, hasChildren);\n    this.stale = false;\n    this.flatNodes = null;\n    this.isStripedInternal = false;\n  }\n\n  override element(): HTMLElement {\n    const existingElement = this.existingElement();\n    const element = existingElement || this.createElement();\n    if (!existingElement || this.stale) {\n      this.createCells(element);\n      this.stale = false;\n    }\n    return element;\n  }\n\n  setStriped(isStriped: boolean): void {\n    this.isStripedInternal = isStriped;\n    this.element().classList.toggle('odd', isStriped);\n  }\n\n  isStriped(): boolean {\n    return this.isStripedInternal;\n  }\n\n  clearFlatNodes(): void {\n    this.flatNodes = null;\n    const parent = (this.parent as ViewportDataGridNode<T>);\n    if (parent) {\n      parent.clearFlatNodes();\n    }\n  }\n\n  flatChildren(): ViewportDataGridNode<T>[] {\n    if (this.flatNodes) {\n      return this.flatNodes;\n    }\n    const flatNodes: ViewportDataGridNode<T>[] = [];\n    const children = ([this.children] as ViewportDataGridNode<T>[][]);\n    const counters: number[] = [0];\n    let depth = 0;\n    while (depth >= 0) {\n      if (children[depth].length <= counters[depth]) {\n        depth--;\n        continue;\n      }\n      const node = children[depth][counters[depth]++];\n      flatNodes.push(node);\n      if (node.expanded && node.children.length) {\n        depth++;\n        children[depth] = (node.children as ViewportDataGridNode<T>[]);\n        counters[depth] = 0;\n      }\n    }\n\n    this.flatNodes = flatNodes;\n    return flatNodes;\n  }\n\n  override insertChild(child: DataGridNode<ViewportDataGridNode<T>>, index: number): void {\n    this.clearFlatNodes();\n    if (child.parent === this) {\n      const currentIndex = this.children.indexOf(child);\n      if (currentIndex < 0) {\n        console.assert(false, 'Inconsistent DataGrid state');\n      }\n      if (currentIndex === index) {\n        return;\n      }\n      if (currentIndex < index) {\n        --index;\n      }\n    }\n    child.remove();\n    child.parent = this;\n    child.dataGrid = this.dataGrid;\n    if (!this.children.length) {\n      this.setHasChildren(true);\n    }\n    this.children.splice(index, 0, child);\n    child.recalculateSiblings(index);\n    if (this.expanded && this.dataGrid) {\n      (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n    }\n  }\n\n  override removeChild(child: DataGridNode<ViewportDataGridNode<T>>): void {\n    this.clearFlatNodes();\n    if (this.dataGrid) {\n      this.dataGrid.updateSelectionBeforeRemoval(child, false);\n    }\n    if (child.previousSibling) {\n      child.previousSibling.nextSibling = child.nextSibling;\n    }\n    if (child.nextSibling) {\n      child.nextSibling.previousSibling = child.previousSibling;\n    }\n    if (child.parent !== this) {\n      throw 'removeChild: Node is not a child of this node.';\n    }\n\n    Platform.ArrayUtilities.removeElement(this.children, child, true);\n    (child as ViewportDataGridNode<T>).unlink();\n\n    if (!this.children.length) {\n      this.setHasChildren(false);\n    }\n    if (this.expanded && this.dataGrid) {\n      (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n    }\n  }\n\n  override removeChildren(): void {\n    this.clearFlatNodes();\n    if (this.dataGrid) {\n      this.dataGrid.updateSelectionBeforeRemoval(this, true);\n    }\n    for (let i = 0; i < this.children.length; ++i) {\n      (this.children[i] as ViewportDataGridNode<T>).unlink();\n    }\n    this.children = ([] as ViewportDataGridNode<T>[]);\n\n    if (this.expanded && this.dataGrid) {\n      (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n    }\n  }\n\n  private unlink(): void {\n    const existingElement = this.existingElement();\n    if (this.attached() && existingElement) {\n      existingElement.remove();\n    }\n    this.resetNode();\n  }\n\n  override collapse(): void {\n    if (!this.expanded) {\n      return;\n    }\n    this.clearFlatNodes();\n    this.expandedInternal = false;\n    const existingElement = this.existingElement();\n    if (existingElement) {\n      existingElement.classList.remove('expanded');\n    }\n    if (this.selected) {\n      (this.dataGrid as ViewportDataGrid<T>).announceSelectedGridNode();\n    }\n    (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n  }\n\n  override expand(): void {\n    if (this.expanded) {\n      return;\n    }\n    (this.dataGrid as ViewportDataGrid<T>).keepScrollingToBottom = false;\n    this.clearFlatNodes();\n    super.expand();\n    (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n  }\n\n  attached(): boolean {\n    const existingElement = this.existingElement();\n    return Boolean(this.dataGrid && existingElement && existingElement.parentElement);\n  }\n\n  override refresh(): void {\n    if (this.attached()) {\n      this.stale = true;\n      (this.dataGrid as ViewportDataGrid<T>).scheduleUpdate();\n    } else {\n      this.resetElement();\n    }\n  }\n\n  override reveal(): void {\n    (this.dataGrid as ViewportDataGrid<T>).revealViewportNode(this);\n  }\n\n  override recalculateSiblings(index: number): void {\n    this.clearFlatNodes();\n    super.recalculateSiblings(index);\n  }\n}\n"],
  "mappings": ";AAIA,YAAY,YAAY;AACxB,YAAY,cAAc;AAC1B,YAAY,iBAAiB;AAE7B,SAA2B,cAAc,oBAAoC;AAE7E,MAAM,cAAc,YAAY,kBAAkB,kBAAkB,SAAS;AAEtE,aAAM,yBAA4B,OAAO,cAAc;AAAA,EAC1D;AAAY,EAA2B;AAAA,EACxB;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKR,2BAAoC;AAAA;AAAA;AAAA;AAAA,EAIpC,wBAAiC;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,oBAAgC;AAC1C,UAAM,kBAAkB;AAExB,SAAK,gBAAgB,KAAK,SAAS,KAAK,IAAI;AAC5C,SAAK,gBAAgB,iBAAiB,UAAU,KAAK,eAAe,IAAI;AAExE,SAAK,eAAe,CAAC;AACrB,SAAK,SAAS;AAEd,SAAK,mBAAmB;AACxB,SAAK,gBAAgB;AACrB,SAAK,wBAAwB;AAC7B,SAAK,YAAY;AAEjB,SAAK,YAAY,IAAI,qBAAqB,CAAC;AAAA,EAC7C;AAAA,EAES,WAAW,SAAwB;AAC1C,SAAK,YAAY;AACjB,QAAI,gBAAgB;AACpB,QAAI,KAAK,aAAa,QAAQ;AAC5B,YAAM,cAAe,KAAK,SAAS,EAA8B,aAAa;AAC9E,sBAAgB,QAAQ,YAAY,QAAQ,KAAK,aAAa,CAAC,CAAC,CAAC;AAAA,IACnE;AACA,SAAK,mBAAmB,aAAa;AAAA,EACvC;AAAA,EAEQ,mBAAmB,eAA8B;AACvD,SAAK,QAAQ,UAAU,OAAO,qBAAqB,CAAC,iBAAiB,KAAK,SAAS;AACnF,SAAK,QAAQ,UAAU,OAAO,qCAAqC,iBAAiB,KAAK,SAAS;AAAA,EACpG;AAAA,EAEA,mBAAmB,iBAAoC;AACrD,SAAK,gBAAgB,oBAAoB,UAAU,KAAK,eAAe,IAAI;AAC3E,SAAK,0BAA0B;AAC/B,SAAK,gBAAgB,iBAAiB,UAAU,KAAK,eAAe,IAAI;AAAA,EAC1E;AAAA,EAES,WAAiB;AACxB,QAAI,KAAK,uBAAuB;AAC9B,WAAK,gBAAgB,YAAY,KAAK,gBAAgB,eAAe,KAAK,gBAAgB;AAAA,IAC5F;AACA,SAAK,eAAe;AACpB,UAAM,SAAS;AAAA,EACjB;AAAA,EAEA,4BAA4B,OAAsB;AAChD,SAAK,wBAAwB,KAAK,2BAA2B;AAAA,EAC/D;AAAA,EAEQ,SAAS,QAA0B;AACzC,QAAI,KAAK,kBAAkB,KAAK,gBAAgB,WAAW;AACzD,WAAK,eAAe,IAAI;AAAA,IAC1B;AAAA,EACF;AAAA,EAEA,0BAAgC;AAC9B,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,eAAe,YAA4B;AACzC,SAAK,mBAAmB,KAAK,oBAAoB,QAAQ,UAAU;AACnE,SAAK,YAAY,MAAM,2BAA2B,KAAK,OAAO,KAAK,IAAI,CAAC;AAAA,EAC1E;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAwB;AACtB,SAAK,OAAO;AAAA,EACd;AAAA,EAES,eAAqB;AAC5B,SAAK,SAAS;AACd,UAAM,aAAa;AACnB,SAAK,OAAO;AAAA,EACd;AAAA,EAEQ,sBAAsB,cAAsB,WAMlD;AACA,UAAM,QAAS,KAAK,SAAS,EAA8B,aAAa;AACxE,QAAI,KAAK,QAAQ;AACf,aAAO,EAAC,YAAY,GAAG,eAAe,GAAG,eAAe,GAAG,cAAc,OAAO,QAAQ,EAAC;AAAA,IAC3F;AAEA,UAAM,OAAO,MAAM;AACnB,QAAI,IAAI;AACR,QAAI,IAAI;AAER,WAAO,IAAI,QAAQ,IAAI,MAAM,CAAC,EAAE,eAAe,IAAI,WAAW,EAAE,GAAG;AACjE,WAAK,MAAM,CAAC,EAAE,eAAe;AAAA,IAC/B;AACA,UAAM,QAAQ;AACd,UAAM,aAAa;AAEnB,WAAO,IAAI,QAAQ,IAAI,YAAY,cAAc,EAAE,GAAG;AACpD,WAAK,MAAM,CAAC,EAAE,eAAe;AAAA,IAC/B;AACA,UAAM,MAAM;AAEZ,QAAI,gBAAgB;AACpB,WAAO,IAAI,MAAM,EAAE,GAAG;AACpB,uBAAiB,MAAM,CAAC,EAAE,eAAe;AAAA,IAC3C;AAEA,QAAI,KAAK,0BAA0B;AAEjC,WAAK,wBAAwB,QAAQ,MAAM;AAAA,IAC7C;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,eAAe,IAAI;AAAA,MACnB,cAAc,MAAM,MAAM,OAAO,GAAG;AAAA,MACpC,QAAQ;AAAA,IACV;AAAA,EACF;AAAA,EAEQ,gBAAwB;AAC9B,UAAM,QAAS,KAAK,SAAS,EAA8B,aAAa;AACxE,QAAI,SAAS;AACb,aAAS,IAAI,GAAG,OAAO,MAAM,QAAQ,IAAI,MAAM,EAAE,GAAG;AAClD,gBAAU,MAAM,CAAC,EAAE,eAAe;AAAA,IACpC;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,SAAe;AACrB,UAAM,eAAe,KAAK,gBAAgB,eAAe,KAAK,uBAAuB;AACrF,QAAI,YAAoB,KAAK,gBAAgB;AAC7C,UAAM,mBAAmB;AACzB,UAAM,eAAe,KAAK,IAAI,GAAG,KAAK,cAAc,IAAI,YAAY;AACpE,QAAI,CAAC,KAAK,oBAAoB,KAAK,uBAAuB;AACxD,kBAAY;AAAA,IACd;AACA,SAAK,mBAAmB;AACxB,gBAAY,KAAK,IAAI,cAAc,SAAS;AAE5C,UAAM,gBAAgB,KAAK,sBAAsB,cAAc,SAAS;AACxE,UAAM,eAAe,cAAc;AACnC,UAAM,kBAAkB,IAAI,IAA6B,YAAY;AAErE,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,EAAE,GAAG;AACjD,YAAM,UAAU,KAAK,aAAa,CAAC;AACnC,UAAI,CAAC,gBAAgB,IAAI,OAAO,KAAK,QAAQ,SAAS,GAAG;AACvD,cAAM,UAAU,QAAQ,gBAAgB;AACxC,YAAI,SAAS;AACX,kBAAQ,OAAO;AAAA,QACjB;AAAA,MACF;AAAA,IACF;AAEA,QAAI,kBAAkB,KAAK,oBAAoB;AAC/C,UAAM,QAAQ,KAAK;AACnB,QAAI,SAAS,cAAc;AAE3B,QAAI,aAAa,QAAQ;AACvB,YAAM,QAAS,KAAK,SAAS,EAA8B,aAAa;AACxE,YAAM,QAAQ,MAAM,QAAQ,aAAa,CAAC,CAAC;AAC3C,WAAK,mBAAmB,QAAQ,QAAQ,CAAC,CAAC;AAC1C,UAAI,KAAK,yBAAyB,UAAU,MAAM,QAAQ,QAAQ,CAAC,MAAM,KAAK,uBAAuB;AACnG,kBAAU;AAAA,MACZ;AAAA,IACF;AAEA,SAAK,wBAAwB,QAAQ,SAAS,CAAC;AAE/C,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,EAAE,GAAG;AAC5C,YAAM,OAAO,aAAa,CAAC;AAC3B,YAAM,UAAW,KAAK,QAAQ;AAC9B,WAAK,YAAY,SAAS,KAAK,MAAM,CAAC;AACtC,UAAI,YAAY,gBAAgB,aAAa;AAC3C,cAAM,aAAa,SAAS,gBAAgB,WAAW;AAAA,MACzD;AACA,WAAK,WAAW;AAChB,wBAAkB;AAAA,IACpB;AAEA,SAAK,mBAAmB,cAAc,YAAY,cAAc,aAAa;AAC7E,SAAK,gBAAgB;AACrB,QAAI,cAAc,kBAAkB;AAClC,WAAK,gBAAgB,YAAY;AAAA,IACnC;AACA,UAAM,cACF,cAAc,iBAAiB,gBAAgB,cAAc,aAAa,cAAc,kBAAkB;AAC9G,QAAI,gBAAgB,KAAK,QAAQ,UAAU,SAAS,yBAAyB,GAAG;AAC9E,WAAK,QAAQ,UAAU,OAAO,2BAA2B,WAAW;AACpE,WAAK,aAAa;AAAA,IACpB;AACA,SAAK,eAAe;AACpB,SAAK,yBAAyB,8CAA0B;AAAA,EAC1D;AAAA,EAEA,mBAAmB,MAAqC;AACtD,UAAM,QAAS,KAAK,SAAS,EAA8B,aAAa;AACxE,UAAM,QAAQ,MAAM,QAAQ,IAAI;AAChC,QAAI,UAAU,IAAI;AAChB;AAAA,IACF;AACA,QAAI,QAAQ;AACZ,aAAS,IAAI,GAAG,IAAI,OAAO,EAAE,GAAG;AAC9B,eAAS,MAAM,CAAC,EAAE,eAAe;AAAA,IACnC;AACA,UAAM,MAAM,QAAQ,KAAK,eAAe;AACxC,QAAI,YAAoB,KAAK,gBAAgB;AAC7C,UAAM,gBAAgB,KAAK,gBAAgB,eAAe,KAAK,uBAAuB;AACtF,QAAI,YAAY,OAAO;AACrB,kBAAY;AACZ,WAAK,wBAAwB;AAAA,IAC/B,WAAW,YAAY,gBAAgB,KAAK;AAC1C,kBAAY,MAAM;AAAA,IACpB;AACA,SAAK,gBAAgB,YAAY;AAAA,EACnC;AACF;AAEO,WAAW,SAAX,kBAAWA,YAAX;AACL,EAAAA,QAAA,yBAAsB;AADN,SAAAA;AAAA,GAAA;AAQX,aAAM,6BAAgC,aAAsC;AAAA,EACzE;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,MAA0B,aAAuB;AAC3D,UAAM,MAAM,WAAW;AACvB,SAAK,QAAQ;AACb,SAAK,YAAY;AACjB,SAAK,oBAAoB;AAAA,EAC3B;AAAA,EAES,UAAuB;AAC9B,UAAM,kBAAkB,KAAK,gBAAgB;AAC7C,UAAM,UAAU,mBAAmB,KAAK,cAAc;AACtD,QAAI,CAAC,mBAAmB,KAAK,OAAO;AAClC,WAAK,YAAY,OAAO;AACxB,WAAK,QAAQ;AAAA,IACf;AACA,WAAO;AAAA,EACT;AAAA,EAEA,WAAW,WAA0B;AACnC,SAAK,oBAAoB;AACzB,SAAK,QAAQ,EAAE,UAAU,OAAO,OAAO,SAAS;AAAA,EAClD;AAAA,EAEA,YAAqB;AACnB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,iBAAuB;AACrB,SAAK,YAAY;AACjB,UAAM,SAAU,KAAK;AACrB,QAAI,QAAQ;AACV,aAAO,eAAe;AAAA,IACxB;AAAA,EACF;AAAA,EAEA,eAA0C;AACxC,QAAI,KAAK,WAAW;AAClB,aAAO,KAAK;AAAA,IACd;AACA,UAAM,YAAuC,CAAC;AAC9C,UAAM,WAAY,CAAC,KAAK,QAAQ;AAChC,UAAM,WAAqB,CAAC,CAAC;AAC7B,QAAI,QAAQ;AACZ,WAAO,SAAS,GAAG;AACjB,UAAI,SAAS,KAAK,EAAE,UAAU,SAAS,KAAK,GAAG;AAC7C;AACA;AAAA,MACF;AACA,YAAM,OAAO,SAAS,KAAK,EAAE,SAAS,KAAK,GAAG;AAC9C,gBAAU,KAAK,IAAI;AACnB,UAAI,KAAK,YAAY,KAAK,SAAS,QAAQ;AACzC;AACA,iBAAS,KAAK,IAAK,KAAK;AACxB,iBAAS,KAAK,IAAI;AAAA,MACpB;AAAA,IACF;AAEA,SAAK,YAAY;AACjB,WAAO;AAAA,EACT;AAAA,EAES,YAAY,OAA8C,OAAqB;AACtF,SAAK,eAAe;AACpB,QAAI,MAAM,WAAW,MAAM;AACzB,YAAM,eAAe,KAAK,SAAS,QAAQ,KAAK;AAChD,UAAI,eAAe,GAAG;AACpB,gBAAQ,OAAO,OAAO,6BAA6B;AAAA,MACrD;AACA,UAAI,iBAAiB,OAAO;AAC1B;AAAA,MACF;AACA,UAAI,eAAe,OAAO;AACxB,UAAE;AAAA,MACJ;AAAA,IACF;AACA,UAAM,OAAO;AACb,UAAM,SAAS;AACf,UAAM,WAAW,KAAK;AACtB,QAAI,CAAC,KAAK,SAAS,QAAQ;AACzB,WAAK,eAAe,IAAI;AAAA,IAC1B;AACA,SAAK,SAAS,OAAO,OAAO,GAAG,KAAK;AACpC,UAAM,oBAAoB,KAAK;AAC/B,QAAI,KAAK,YAAY,KAAK,UAAU;AAClC,MAAC,KAAK,SAAiC,wBAAwB;AAAA,IACjE;AAAA,EACF;AAAA,EAES,YAAY,OAAoD;AACvE,SAAK,eAAe;AACpB,QAAI,KAAK,UAAU;AACjB,WAAK,SAAS,6BAA6B,OAAO,KAAK;AAAA,IACzD;AACA,QAAI,MAAM,iBAAiB;AACzB,YAAM,gBAAgB,cAAc,MAAM;AAAA,IAC5C;AACA,QAAI,MAAM,aAAa;AACrB,YAAM,YAAY,kBAAkB,MAAM;AAAA,IAC5C;AACA,QAAI,MAAM,WAAW,MAAM;AACzB,YAAM;AAAA,IACR;AAEA,aAAS,eAAe,cAAc,KAAK,UAAU,OAAO,IAAI;AAChE,IAAC,MAAkC,OAAO;AAE1C,QAAI,CAAC,KAAK,SAAS,QAAQ;AACzB,WAAK,eAAe,KAAK;AAAA,IAC3B;AACA,QAAI,KAAK,YAAY,KAAK,UAAU;AAClC,MAAC,KAAK,SAAiC,wBAAwB;AAAA,IACjE;AAAA,EACF;AAAA,EAES,iBAAuB;AAC9B,SAAK,eAAe;AACpB,QAAI,KAAK,UAAU;AACjB,WAAK,SAAS,6BAA6B,MAAM,IAAI;AAAA,IACvD;AACA,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,EAAE,GAAG;AAC7C,MAAC,KAAK,SAAS,CAAC,EAA8B,OAAO;AAAA,IACvD;AACA,SAAK,WAAY,CAAC;AAElB,QAAI,KAAK,YAAY,KAAK,UAAU;AAClC,MAAC,KAAK,SAAiC,wBAAwB;AAAA,IACjE;AAAA,EACF;AAAA,EAEQ,SAAe;AACrB,UAAM,kBAAkB,KAAK,gBAAgB;AAC7C,QAAI,KAAK,SAAS,KAAK,iBAAiB;AACtC,sBAAgB,OAAO;AAAA,IACzB;AACA,SAAK,UAAU;AAAA,EACjB;AAAA,EAES,WAAiB;AACxB,QAAI,CAAC,KAAK,UAAU;AAClB;AAAA,IACF;AACA,SAAK,eAAe;AACpB,SAAK,mBAAmB;AACxB,UAAM,kBAAkB,KAAK,gBAAgB;AAC7C,QAAI,iBAAiB;AACnB,sBAAgB,UAAU,OAAO,UAAU;AAAA,IAC7C;AACA,QAAI,KAAK,UAAU;AACjB,MAAC,KAAK,SAAiC,yBAAyB;AAAA,IAClE;AACA,IAAC,KAAK,SAAiC,wBAAwB;AAAA,EACjE;AAAA,EAES,SAAe;AACtB,QAAI,KAAK,UAAU;AACjB;AAAA,IACF;AACA,IAAC,KAAK,SAAiC,wBAAwB;AAC/D,SAAK,eAAe;AACpB,UAAM,OAAO;AACb,IAAC,KAAK,SAAiC,wBAAwB;AAAA,EACjE;AAAA,EAEA,WAAoB;AAClB,UAAM,kBAAkB,KAAK,gBAAgB;AAC7C,WAAO,QAAQ,KAAK,YAAY,mBAAmB,gBAAgB,aAAa;AAAA,EAClF;AAAA,EAES,UAAgB;AACvB,QAAI,KAAK,SAAS,GAAG;AACnB,WAAK,QAAQ;AACb,MAAC,KAAK,SAAiC,eAAe;AAAA,IACxD,OAAO;AACL,WAAK,aAAa;AAAA,IACpB;AAAA,EACF;AAAA,EAES,SAAe;AACtB,IAAC,KAAK,SAAiC,mBAAmB,IAAI;AAAA,EAChE;AAAA,EAES,oBAAoB,OAAqB;AAChD,SAAK,eAAe;AACpB,UAAM,oBAAoB,KAAK;AAAA,EACjC;AACF;",
  "names": ["Events"]
}
