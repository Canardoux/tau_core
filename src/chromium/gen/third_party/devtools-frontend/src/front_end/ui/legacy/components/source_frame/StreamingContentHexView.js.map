{
  "version": 3,
  "sources": ["../../../../../../../../../../../third_party/devtools-frontend/src/front_end/ui/legacy/components/source_frame/StreamingContentHexView.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as TextUtils from '../../../../models/text_utils/text_utils.js';\nimport * as LinearMemoryInspectorComponents from '../../../../panels/linear_memory_inspector/components/components.js';\nimport * as UI from '../../legacy.js';\n\nconst MEMORY_TRANSFER_MIN_CHUNK_SIZE = 1000;\n\n/**\n * This is a slightly reduced version of `panels/LinearMemoryInspectorPane.LinearMemoryInspectorView.\n *\n * It's not hooked up to the LinearMemoryInspectorController and it operates on a fixed memory array thats\n * known upfront.\n */\nclass LinearMemoryInspectorView extends UI.Widget.VBox {\n  #memory = new Uint8Array([0]);\n  #address = 0;\n  #inspector = new LinearMemoryInspectorComponents.LinearMemoryInspector.LinearMemoryInspector();\n\n  constructor() {\n    super(false);\n    this.#inspector.addEventListener(\n        LinearMemoryInspectorComponents.LinearMemoryInspector.MemoryRequestEvent.eventName,\n        this.#memoryRequested.bind(this));\n    this.#inspector.addEventListener(\n        LinearMemoryInspectorComponents.LinearMemoryInspector.AddressChangedEvent.eventName, event => {\n          this.#address = event.data;\n        });\n    this.contentElement.appendChild(this.#inspector);\n  }\n\n  override wasShown(): void {\n    this.refreshData();\n  }\n\n  setMemory(memory: Uint8Array): void {\n    this.#memory = memory;\n    this.refreshData();\n  }\n\n  refreshData(): void {\n    // TODO(szuend): The following lines are copied from `LinearMemoryInspectorController`. We can't reuse them\n    // as depending on a module in `panels/` from a component is a layering violation.\n\n    // Provide a chunk of memory that covers the address to show and some before and after\n    // as 1. the address shown is not necessarily at the beginning of a page and\n    // 2. to allow for fewer memory requests.\n    const memoryChunkStart = Math.max(0, this.#address - MEMORY_TRANSFER_MIN_CHUNK_SIZE / 2);\n    const memoryChunkEnd = memoryChunkStart + MEMORY_TRANSFER_MIN_CHUNK_SIZE;\n    const memory = this.#memory.slice(memoryChunkStart, memoryChunkEnd);\n    this.#inspector.data = {\n      memory,\n      address: this.#address,\n      memoryOffset: memoryChunkStart,\n      outerMemoryLength: this.#memory.length,\n      hideValueInspector: true,\n    };\n  }\n\n  #memoryRequested(event: LinearMemoryInspectorComponents.LinearMemoryInspector.MemoryRequestEvent): void {\n    // TODO(szuend): The following lines are copied from `LinearMemoryInspectorController`. We can't reuse them\n    // as depending on a module in `panels/` from a component is a layering violation.\n\n    const {start, end, address} = event.data;\n    if (address < start || address >= end) {\n      throw new Error('Requested address is out of bounds.');\n    }\n\n    // Check that the requested start is within bounds.\n    // If the requested end is larger than the actual\n    // memory, it will be automatically capped when\n    // requesting the range.\n    if (start < 0 || start > end || start >= this.#memory.length) {\n      throw new Error('Requested range is out of bounds.');\n    }\n\n    const chunkEnd = Math.max(end, start + MEMORY_TRANSFER_MIN_CHUNK_SIZE);\n    const memory = this.#memory.slice(start, chunkEnd);\n\n    this.#inspector.data = {\n      memory,\n      address,\n      memoryOffset: start,\n      outerMemoryLength: this.#memory.length,\n      hideValueInspector: true,\n    };\n  }\n}\n\n/**\n * Adapter for the linear memory inspector that can show a {@link StreamingContentData}.\n */\nexport class StreamingContentHexView extends LinearMemoryInspectorView {\n  readonly #streamingContentData: TextUtils.StreamingContentData.StreamingContentData;\n\n  constructor(streamingContentData: TextUtils.StreamingContentData.StreamingContentData) {\n    super();\n    this.#streamingContentData = streamingContentData;\n  }\n\n  override wasShown(): void {\n    this.#updateMemoryFromContentData();\n    this.#streamingContentData.addEventListener(\n        TextUtils.StreamingContentData.Events.CHUNK_ADDED, this.#updateMemoryFromContentData, this);\n\n    // No need to call super.wasShown() as we call super.refreshData() ourselves.\n  }\n\n  override willHide(): void {\n    super.willHide();\n    this.#streamingContentData.removeEventListener(\n        TextUtils.StreamingContentData.Events.CHUNK_ADDED, this.#updateMemoryFromContentData, this);\n  }\n\n  #updateMemoryFromContentData(): void {\n    const binaryString = window.atob(this.#streamingContentData.content().base64);\n    const memory = Uint8Array.from(binaryString, m => m.codePointAt(0) as number);\n    this.setMemory(memory);\n  }\n}\n"],
  "mappings": ";AAIA,YAAY,eAAe;AAC3B,YAAY,qCAAqC;AACjD,YAAY,QAAQ;AAEpB,MAAM,iCAAiC;AAQvC,MAAM,kCAAkC,GAAG,OAAO,KAAK;AAAA,EACrD,UAAU,IAAI,WAAW,CAAC,CAAC,CAAC;AAAA,EAC5B,WAAW;AAAA,EACX,aAAa,IAAI,gCAAgC,sBAAsB,sBAAsB;AAAA,EAE7F,cAAc;AACZ,UAAM,KAAK;AACX,SAAK,WAAW;AAAA,MACZ,gCAAgC,sBAAsB,mBAAmB;AAAA,MACzE,KAAK,iBAAiB,KAAK,IAAI;AAAA,IAAC;AACpC,SAAK,WAAW;AAAA,MACZ,gCAAgC,sBAAsB,oBAAoB;AAAA,MAAW,WAAS;AAC5F,aAAK,WAAW,MAAM;AAAA,MACxB;AAAA,IAAC;AACL,SAAK,eAAe,YAAY,KAAK,UAAU;AAAA,EACjD;AAAA,EAES,WAAiB;AACxB,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,UAAU,QAA0B;AAClC,SAAK,UAAU;AACf,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,cAAoB;AAOlB,UAAM,mBAAmB,KAAK,IAAI,GAAG,KAAK,WAAW,iCAAiC,CAAC;AACvF,UAAM,iBAAiB,mBAAmB;AAC1C,UAAM,SAAS,KAAK,QAAQ,MAAM,kBAAkB,cAAc;AAClE,SAAK,WAAW,OAAO;AAAA,MACrB;AAAA,MACA,SAAS,KAAK;AAAA,MACd,cAAc;AAAA,MACd,mBAAmB,KAAK,QAAQ;AAAA,MAChC,oBAAoB;AAAA,IACtB;AAAA,EACF;AAAA,EAEA,iBAAiB,OAAuF;AAItG,UAAM,EAAC,OAAO,KAAK,QAAO,IAAI,MAAM;AACpC,QAAI,UAAU,SAAS,WAAW,KAAK;AACrC,YAAM,IAAI,MAAM,qCAAqC;AAAA,IACvD;AAMA,QAAI,QAAQ,KAAK,QAAQ,OAAO,SAAS,KAAK,QAAQ,QAAQ;AAC5D,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AAEA,UAAM,WAAW,KAAK,IAAI,KAAK,QAAQ,8BAA8B;AACrE,UAAM,SAAS,KAAK,QAAQ,MAAM,OAAO,QAAQ;AAEjD,SAAK,WAAW,OAAO;AAAA,MACrB;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd,mBAAmB,KAAK,QAAQ;AAAA,MAChC,oBAAoB;AAAA,IACtB;AAAA,EACF;AACF;AAKO,aAAM,gCAAgC,0BAA0B;AAAA,EAC5D;AAAA,EAET,YAAY,sBAA2E;AACrF,UAAM;AACN,SAAK,wBAAwB;AAAA,EAC/B;AAAA,EAES,WAAiB;AACxB,SAAK,6BAA6B;AAClC,SAAK,sBAAsB;AAAA,MACvB,UAAU,qBAAqB,OAAO;AAAA,MAAa,KAAK;AAAA,MAA8B;AAAA,IAAI;AAAA,EAGhG;AAAA,EAES,WAAiB;AACxB,UAAM,SAAS;AACf,SAAK,sBAAsB;AAAA,MACvB,UAAU,qBAAqB,OAAO;AAAA,MAAa,KAAK;AAAA,MAA8B;AAAA,IAAI;AAAA,EAChG;AAAA,EAEA,+BAAqC;AACnC,UAAM,eAAe,OAAO,KAAK,KAAK,sBAAsB,QAAQ,EAAE,MAAM;AAC5E,UAAM,SAAS,WAAW,KAAK,cAAc,OAAK,EAAE,YAAY,CAAC,CAAW;AAC5E,SAAK,UAAU,MAAM;AAAA,EACvB;AACF;",
  "names": []
}
