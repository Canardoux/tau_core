{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/CPUThrottlingManager.ts"],
  "sourcesContent": ["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\n\nimport {EmulationModel} from './EmulationModel.js';\nimport {type SDKModelObserver, TargetManager} from './TargetManager.js';\n\nlet throttlingManagerInstance: CPUThrottlingManager;\n\nexport class CPUThrottlingManager extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements\n    SDKModelObserver<EmulationModel> {\n  #cpuThrottlingRateInternal: number;\n  #hardwareConcurrencyInternal?: number;\n  #pendingMainTargetPromise?: (r: number) => void;\n\n  private constructor() {\n    super();\n    this.#cpuThrottlingRateInternal = CPUThrottlingRates.NO_THROTTLING;\n    TargetManager.instance().observeModels(EmulationModel, this);\n  }\n\n  static instance(opts: {forceNew: boolean|null} = {forceNew: null}): CPUThrottlingManager {\n    const {forceNew} = opts;\n    if (!throttlingManagerInstance || forceNew) {\n      throttlingManagerInstance = new CPUThrottlingManager();\n    }\n\n    return throttlingManagerInstance;\n  }\n\n  cpuThrottlingRate(): number {\n    return this.#cpuThrottlingRateInternal;\n  }\n\n  setCPUThrottlingRate(rate: number): void {\n    if (rate === this.#cpuThrottlingRateInternal) {\n      return;\n    }\n\n    this.#cpuThrottlingRateInternal = rate;\n    for (const emulationModel of TargetManager.instance().models(EmulationModel)) {\n      void emulationModel.setCPUThrottlingRate(this.#cpuThrottlingRateInternal);\n    }\n    this.dispatchEventToListeners(Events.RATE_CHANGED, this.#cpuThrottlingRateInternal);\n  }\n\n  setHardwareConcurrency(concurrency: number): void {\n    this.#hardwareConcurrencyInternal = concurrency;\n    for (const emulationModel of TargetManager.instance().models(EmulationModel)) {\n      void emulationModel.setHardwareConcurrency(concurrency);\n    }\n    this.dispatchEventToListeners(Events.HARDWARE_CONCURRENCY_CHANGED, this.#hardwareConcurrencyInternal);\n  }\n\n  hasPrimaryPageTargetSet(): boolean {\n    // In some environments, such as Node, trying to check if we have a page\n    // target may error. So if we get any errors here at all, assume that we do\n    // not have a target.\n    try {\n      return TargetManager.instance().primaryPageTarget() !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  async getHardwareConcurrency(): Promise<number> {\n    const target = TargetManager.instance().primaryPageTarget();\n    const existingCallback = this.#pendingMainTargetPromise;\n\n    // If the main target hasn't attached yet, block callers until it appears.\n    if (!target) {\n      if (existingCallback) {\n        return new Promise(r => {\n          this.#pendingMainTargetPromise = (result: number) => {\n            r(result);\n            existingCallback(result);\n          };\n        });\n      }\n      return new Promise(r => {\n        this.#pendingMainTargetPromise = r;\n      });\n    }\n\n    const evalResult = await target.runtimeAgent().invoke_evaluate(\n        {expression: 'navigator.hardwareConcurrency', returnByValue: true, silent: true, throwOnSideEffect: true});\n    const error = evalResult.getError();\n    if (error) {\n      throw new Error(error);\n    }\n    const {result, exceptionDetails} = evalResult;\n    if (exceptionDetails) {\n      throw new Error(exceptionDetails.text);\n    }\n    return result.value;\n  }\n\n  modelAdded(emulationModel: EmulationModel): void {\n    if (this.#cpuThrottlingRateInternal !== CPUThrottlingRates.NO_THROTTLING) {\n      void emulationModel.setCPUThrottlingRate(this.#cpuThrottlingRateInternal);\n    }\n    if (this.#hardwareConcurrencyInternal !== undefined) {\n      void emulationModel.setHardwareConcurrency(this.#hardwareConcurrencyInternal);\n    }\n\n    // If there are any callers blocked on a getHardwareConcurrency call, let's wake them now.\n    if (this.#pendingMainTargetPromise) {\n      const existingCallback = this.#pendingMainTargetPromise;\n      this.#pendingMainTargetPromise = undefined;\n      void this.getHardwareConcurrency().then(existingCallback);\n    }\n  }\n\n  modelRemoved(_emulationModel: EmulationModel): void {\n    // Implemented as a requirement for being a SDKModelObserver.\n  }\n}\n\nexport const enum Events {\n  RATE_CHANGED = 'RateChanged',\n  HARDWARE_CONCURRENCY_CHANGED = 'HardwareConcurrencyChanged',\n}\n\nexport type EventTypes = {\n  [Events.RATE_CHANGED]: number,\n  [Events.HARDWARE_CONCURRENCY_CHANGED]: number,\n};\n\nexport function throttlingManager(): CPUThrottlingManager {\n  return CPUThrottlingManager.instance();\n}\n\nexport enum CPUThrottlingRates {\n  NO_THROTTLING = 1,\n  // eslint-disable-next-line @typescript-eslint/naming-convention -- Used by web_tests.\n  MidTierMobile = 4,\n  // eslint-disable-next-line @typescript-eslint/naming-convention -- Used by web_tests.\n  LowEndMobile = 6,\n  EXTRA_SLOW = 20,\n}\n"],
  "mappings": "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",
  "names": ["result", "Events", "CPUThrottlingRates"]
}
