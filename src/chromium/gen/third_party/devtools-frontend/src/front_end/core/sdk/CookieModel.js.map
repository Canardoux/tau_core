{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/CookieModel.ts"],
  "sourcesContent": ["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Common from '../common/common.js';\nimport * as Platform from '../platform/platform.js';\nimport * as Root from '../root/root.js';\n\nimport {type Attribute, Cookie} from './Cookie.js';\nimport {Events as NetworkManagerEvents, NetworkManager} from './NetworkManager.js';\nimport type {Resource} from './Resource.js';\nimport {Events as ResourceTreeModelEvents, ResourceTreeModel} from './ResourceTreeModel.js';\nimport {SDKModel} from './SDKModel.js';\nimport {Capability, type Target} from './Target.js';\n\nexport class CookieModel extends SDKModel<EventTypes> {\n  readonly #blockedCookies: Map<string, Cookie>;\n  readonly #cookieToBlockedReasons: Map<Cookie, BlockedReason[]>;\n  readonly #refreshThrottler: Common.Throttler.Throttler;\n  #cookies: Map<string, Cookie[]>;\n\n  constructor(target: Target) {\n    super(target);\n\n    this.#refreshThrottler = new Common.Throttler.Throttler(300);\n    this.#blockedCookies = new Map();\n    this.#cookieToBlockedReasons = new Map();\n    this.#cookies = new Map();\n    target.model(ResourceTreeModel)\n        ?.addEventListener(ResourceTreeModelEvents.PrimaryPageChanged, this.#onPrimaryPageChanged, this);\n    target.model(NetworkManager)\n        ?.addEventListener(NetworkManagerEvents.ResponseReceived, this.#onResponseReceived, this);\n    target.model(NetworkManager)?.addEventListener(NetworkManagerEvents.LoadingFinished, this.#onLoadingFinished, this);\n  }\n\n  addBlockedCookie(cookie: Cookie, blockedReasons: BlockedReason[]|null): void {\n    const key = cookie.key();\n    const previousCookie = this.#blockedCookies.get(key);\n    this.#blockedCookies.set(key, cookie);\n    if (blockedReasons) {\n      this.#cookieToBlockedReasons.set(cookie, blockedReasons);\n    } else {\n      this.#cookieToBlockedReasons.delete(cookie);\n    }\n    if (previousCookie) {\n      this.#cookieToBlockedReasons.delete(previousCookie);\n    }\n  }\n\n  removeBlockedCookie(cookie: Cookie): void {\n    this.#blockedCookies.delete(cookie.key());\n  }\n\n  async #onPrimaryPageChanged(): Promise<void> {\n    this.#blockedCookies.clear();\n    this.#cookieToBlockedReasons.clear();\n    await this.#refresh();\n  }\n\n  getCookieToBlockedReasonsMap(): ReadonlyMap<Cookie, BlockedReason[]> {\n    return this.#cookieToBlockedReasons;\n  }\n\n  async #getCookies(urls: Platform.MapUtilities.Multimap<string, string>): Promise<void> {\n    const networkAgent = this.target().networkAgent();\n    const newCookies = new Map<string, Cookie[]>(await Promise.all(urls.keysArray().map(\n        domain => networkAgent.invoke_getCookies({urls: [...urls.get(domain).values()]})\n                      .then(({cookies}) => [domain, cookies.map(Cookie.fromProtocolCookie)] as const))));\n    const updated = this.#isUpdated(newCookies);\n    this.#cookies = newCookies;\n    if (updated) {\n      this.dispatchEventToListeners(Events.COOKIE_LIST_UPDATED);\n    }\n  }\n\n  async deleteCookie(cookie: Cookie): Promise<void> {\n    await this.deleteCookies([cookie]);\n  }\n\n  async clear(domain?: string, securityOrigin?: string): Promise<void> {\n    if (!this.#isRefreshing()) {\n      await this.#refreshThrottled();\n    }\n    const cookies = domain ? (this.#cookies.get(domain) || []) : [...this.#cookies.values()].flat();\n    cookies.push(...this.#blockedCookies.values());\n    if (securityOrigin) {\n      const cookiesToDelete = cookies.filter(cookie => {\n        return cookie.matchesSecurityOrigin(securityOrigin);\n      });\n      await this.deleteCookies(cookiesToDelete);\n    } else {\n      await this.deleteCookies(cookies);\n    }\n  }\n\n  async saveCookie(cookie: Cookie): Promise<boolean> {\n    let domain = cookie.domain();\n    if (!domain.startsWith('.')) {\n      domain = '';\n    }\n    let expires: number|undefined = undefined;\n    if (cookie.expires()) {\n      expires = Math.floor(Date.parse(`${cookie.expires()}`) / 1000);\n    }\n    const enabled = Root.Runtime.experiments.isEnabled('experimental-cookie-features');\n    const preserveUnset = (scheme: Protocol.Network.CookieSourceScheme): Protocol.Network.CookieSourceScheme.Unset|\n                          undefined => scheme === Protocol.Network.CookieSourceScheme.Unset ? scheme : undefined;\n    const protocolCookie = {\n      name: cookie.name(),\n      value: cookie.value(),\n      url: cookie.url() || undefined,\n      domain,\n      path: cookie.path(),\n      secure: cookie.secure(),\n      httpOnly: cookie.httpOnly(),\n      sameSite: cookie.sameSite(),\n      expires,\n      priority: cookie.priority(),\n      partitionKey: cookie.partitionKey(),\n      sourceScheme: enabled ? cookie.sourceScheme() : preserveUnset(cookie.sourceScheme()),\n      sourcePort: enabled ? cookie.sourcePort() : undefined,\n    };\n    const response = await this.target().networkAgent().invoke_setCookie(protocolCookie);\n    const error = response.getError();\n    if (error || !response.success) {\n      return false;\n    }\n    await this.#refreshThrottled();\n    return response.success;\n  }\n\n  /**\n   * Returns cookies needed by current page's frames whose security origins are |domain|.\n   */\n  async getCookiesForDomain(domain: string, forceUpdate?: boolean): Promise<Cookie[]> {\n    if (!this.#isRefreshing() || forceUpdate) {\n      await this.#refreshThrottled();\n    }\n    const normalCookies = this.#cookies.get(domain) || [];\n    return normalCookies.concat(Array.from(this.#blockedCookies.values()));\n  }\n\n  async deleteCookies(cookies: Cookie[]): Promise<void> {\n    const networkAgent = this.target().networkAgent();\n    this.#blockedCookies.clear();\n    this.#cookieToBlockedReasons.clear();\n    await Promise.all(cookies.map(cookie => networkAgent.invoke_deleteCookies({\n      name: cookie.name(),\n      url: undefined,\n      domain: cookie.domain(),\n      path: cookie.path(),\n      partitionKey: cookie.partitionKey(),\n    })));\n    await this.#refreshThrottled();\n  }\n\n  #isRefreshing(): boolean {\n    return Boolean(this.listeners?.size);\n  }\n\n  #isUpdated(newCookies: Map<string, Cookie[]>): boolean {\n    if (newCookies.size !== this.#cookies.size) {\n      return true;\n    }\n    for (const [domain, newDomainCookies] of newCookies) {\n      if (!this.#cookies.has(domain)) {\n        return true;\n      }\n      const oldDomainCookies = this.#cookies.get(domain) || [];\n      if (newDomainCookies.length !== oldDomainCookies.length) {\n        return true;\n      }\n      const comparisonKey = (c: Cookie): string => c.key() + ' ' + c.value();\n      const oldDomainCookieKeys = new Set(oldDomainCookies.map(comparisonKey));\n      for (const newCookie of newDomainCookies) {\n        if (!oldDomainCookieKeys.has(comparisonKey(newCookie))) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  #refreshThrottled(): Promise<void> {\n    return this.#refreshThrottler.schedule(() => this.#refresh());\n  }\n\n  #refresh(): Promise<void> {\n    const resourceURLs = new Platform.MapUtilities.Multimap<string, string>();\n    function populateResourceURLs(resource: Resource): boolean {\n      const documentURL = Common.ParsedURL.ParsedURL.fromString(resource.documentURL);\n      if (documentURL) {\n        resourceURLs.set(documentURL.securityOrigin(), resource.url);\n      }\n      return false;\n    }\n    const resourceTreeModel = this.target().model(ResourceTreeModel);\n    if (resourceTreeModel) {\n      // In case the current frame was unreachable, add its cookies\n      // because they might help to debug why the frame was unreachable.\n      const unreachableUrl = resourceTreeModel.mainFrame?.unreachableUrl();\n      if (unreachableUrl) {\n        const documentURL = Common.ParsedURL.ParsedURL.fromString(unreachableUrl);\n        if (documentURL) {\n          resourceURLs.set(documentURL.securityOrigin(), unreachableUrl);\n        }\n      }\n\n      resourceTreeModel.forAllResources(populateResourceURLs);\n    }\n    return this.#getCookies(resourceURLs);\n  }\n\n  #onResponseReceived(): void {\n    if (this.#isRefreshing()) {\n      void this.#refreshThrottled();\n    }\n  }\n\n  #onLoadingFinished(): void {\n    if (this.#isRefreshing()) {\n      void this.#refreshThrottled();\n    }\n  }\n}\n\nSDKModel.register(CookieModel, {capabilities: Capability.NETWORK, autostart: false});\nexport interface BlockedReason {\n  uiString: string;\n  attribute: Attribute|null;\n}\nexport interface ExemptionReason {\n  uiString: string;\n}\n\nexport const enum Events {\n  COOKIE_LIST_UPDATED = 'CookieListUpdated',\n}\n\nexport type EventTypes = {\n  [Events.COOKIE_LIST_UPDATED]: void,\n};\n"],
  "mappings": "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",
  "names": ["Events"]
}
