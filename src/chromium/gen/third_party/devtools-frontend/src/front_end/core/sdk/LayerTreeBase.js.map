{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/LayerTreeBase.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport {DOMModel, type DOMNode} from './DOMModel.js';\nimport type {SnapshotWithRect} from './PaintProfiler.js';\nimport type {Target} from './Target.js';\n\nexport interface Layer {\n  id(): string;\n  parentId(): string|null;\n  parent(): Layer|null;\n  isRoot(): boolean;\n  children(): Layer[];\n  addChild(child: Layer): void;\n  node(): DOMNode|null;\n  nodeForSelfOrAncestor(): DOMNode|null;\n  offsetX(): number;\n  offsetY(): number;\n  width(): number;\n  height(): number;\n  transform(): number[]|null;\n  quad(): number[];\n  anchorPoint(): number[];\n  invisible(): boolean;\n  paintCount(): number;\n  lastPaintRect(): Protocol.DOM.Rect|null;\n  scrollRects(): Protocol.LayerTree.ScrollRect[];\n  stickyPositionConstraint(): StickyPositionConstraint|null;\n  gpuMemoryUsage(): number;\n  requestCompositingReasons(): Promise<string[]>;\n  requestCompositingReasonIds(): Promise<string[]>;\n  drawsContent(): boolean;\n  snapshots(): Promise<SnapshotWithRect|null>[];\n}\n\nexport namespace Layer {\n  export const enum ScrollRectType {\n    NON_FAST_SCROLLABLE = 'NonFastScrollable',\n    TOUCH_EVENT_HANDLER = 'TouchEventHandler',\n    WHEEL_EVENT_HANDLER = 'WheelEventHandler',\n    REPAINTS_ON_SCROLL = 'RepaintsOnScroll',\n    MAIN_THREAD_SCROLL_REASON = 'MainThreadScrollingReason',\n  }\n}\n\nexport class StickyPositionConstraint {\n  readonly #stickyBoxRectInternal: Protocol.DOM.Rect;\n  readonly #containingBlockRectInternal: Protocol.DOM.Rect;\n  readonly #nearestLayerShiftingStickyBoxInternal: Layer|null;\n  readonly #nearestLayerShiftingContainingBlockInternal: Layer|null;\n\n  constructor(layerTree: LayerTreeBase|null, constraint: Protocol.LayerTree.StickyPositionConstraint) {\n    this.#stickyBoxRectInternal = constraint.stickyBoxRect;\n    this.#containingBlockRectInternal = constraint.containingBlockRect;\n    this.#nearestLayerShiftingStickyBoxInternal = null;\n    if (layerTree && constraint.nearestLayerShiftingStickyBox) {\n      this.#nearestLayerShiftingStickyBoxInternal = layerTree.layerById(constraint.nearestLayerShiftingStickyBox);\n    }\n\n    this.#nearestLayerShiftingContainingBlockInternal = null;\n    if (layerTree && constraint.nearestLayerShiftingContainingBlock) {\n      this.#nearestLayerShiftingContainingBlockInternal =\n          layerTree.layerById(constraint.nearestLayerShiftingContainingBlock);\n    }\n  }\n\n  stickyBoxRect(): Protocol.DOM.Rect {\n    return this.#stickyBoxRectInternal;\n  }\n\n  containingBlockRect(): Protocol.DOM.Rect {\n    return this.#containingBlockRectInternal;\n  }\n\n  nearestLayerShiftingStickyBox(): Layer|null {\n    return this.#nearestLayerShiftingStickyBoxInternal;\n  }\n\n  nearestLayerShiftingContainingBlock(): Layer|null {\n    return this.#nearestLayerShiftingContainingBlockInternal;\n  }\n}\n\nexport class LayerTreeBase {\n  readonly #targetInternal: Target|null;\n  #domModel: DOMModel|null;\n  layersById: Map<string|number, Layer>;\n  #rootInternal: Layer|null;\n  #contentRootInternal: Layer|null;\n  readonly #backendNodeIdToNodeInternal: Map<Protocol.DOM.BackendNodeId, DOMNode|null>;\n  #viewportSizeInternal?: {\n    width: number,\n    height: number,\n  };\n\n  constructor(target: Target|null) {\n    this.#targetInternal = target;\n    this.#domModel = target ? target.model(DOMModel) : null;\n    this.layersById = new Map();\n    this.#rootInternal = null;\n    this.#contentRootInternal = null;\n    this.#backendNodeIdToNodeInternal = new Map();\n  }\n\n  target(): Target|null {\n    return this.#targetInternal;\n  }\n\n  root(): Layer|null {\n    return this.#rootInternal;\n  }\n\n  setRoot(root: Layer|null): void {\n    this.#rootInternal = root;\n  }\n\n  contentRoot(): Layer|null {\n    return this.#contentRootInternal;\n  }\n\n  setContentRoot(contentRoot: Layer|null): void {\n    this.#contentRootInternal = contentRoot;\n  }\n\n  forEachLayer<T>(callback: (arg0: Layer) => T, root?: Layer|null): T|boolean {\n    if (!root) {\n      root = this.root();\n      if (!root) {\n        return false;\n      }\n    }\n    return callback(root) || root.children().some(this.forEachLayer.bind(this, callback));\n  }\n\n  layerById(id: string): Layer|null {\n    return this.layersById.get(id) || null;\n  }\n\n  async resolveBackendNodeIds(requestedNodeIds: Set<Protocol.DOM.BackendNodeId>): Promise<void> {\n    if (!requestedNodeIds.size || !this.#domModel) {\n      return;\n    }\n\n    const nodesMap = await this.#domModel.pushNodesByBackendIdsToFrontend(requestedNodeIds);\n\n    if (!nodesMap) {\n      return;\n    }\n    for (const nodeId of nodesMap.keys()) {\n      this.#backendNodeIdToNodeInternal.set(nodeId, nodesMap.get(nodeId) || null);\n    }\n  }\n\n  backendNodeIdToNode(): Map<Protocol.DOM.BackendNodeId, DOMNode|null> {\n    return this.#backendNodeIdToNodeInternal;\n  }\n\n  setViewportSize(viewportSize: {\n    width: number,\n    height: number,\n  }): void {\n    this.#viewportSizeInternal = viewportSize;\n  }\n\n  viewportSize(): {\n    width: number,\n    height: number,\n  }|undefined {\n    return this.#viewportSizeInternal;\n  }\n\n  private nodeForId(id: Protocol.DOM.NodeId): DOMNode|null {\n    return this.#domModel ? this.#domModel.nodeForId(id) : null;\n  }\n}\n"],
  "mappings": "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",
  "names": ["Layer", "ScrollRectType"]
}
