{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/FrameManager.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../generated/protocol.js';\nimport * as Common from '../common/common.js';\n\nimport type {Resource} from './Resource.js';\nimport {Events as ResourceTreeModelEvents, type ResourceTreeFrame, ResourceTreeModel} from './ResourceTreeModel.js';\nimport type {Target} from './Target.js';\nimport {type SDKModelObserver, TargetManager} from './TargetManager.js';\n\nlet frameManagerInstance: FrameManager|null = null;\n\n/**\n * The FrameManager is a central storage for all #frames. It collects #frames from all\n * ResourceTreeModel-instances (one per target), so that #frames can be found by id\n * without needing to know their target.\n */\nexport class FrameManager extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements\n    SDKModelObserver<ResourceTreeModel> {\n  readonly #eventListeners = new WeakMap<ResourceTreeModel, Common.EventTarget.EventDescriptor[]>();\n\n  // Maps frameIds to #frames and a count of how many ResourceTreeModels contain this frame.\n  // (OOPIFs are usually first attached to a new target and then detached from their old target,\n  // therefore being contained in 2 models for a short period of time.)\n  #frames = new Map<string, {\n    frame: ResourceTreeFrame,\n    count: number,\n  }>();\n\n  readonly #framesForTarget = new Map<Protocol.Target.TargetID|'main', Set<Protocol.Page.FrameId>>();\n  #outermostFrame: ResourceTreeFrame|null = null;\n  #transferringFramesDataCache = new Map<string, {\n    creationStackTrace?: Protocol.Runtime.StackTrace,\n    creationStackTraceTarget?: Target,\n  }>();\n  #awaitedFrames: Map<string, {notInTarget?: Target, resolve: (frame: ResourceTreeFrame) => void}[]> = new Map();\n\n  constructor() {\n    super();\n    TargetManager.instance().observeModels(ResourceTreeModel, this);\n  }\n\n  static instance({forceNew}: {\n    forceNew: boolean,\n  } = {forceNew: false}): FrameManager {\n    if (!frameManagerInstance || forceNew) {\n      frameManagerInstance = new FrameManager();\n    }\n    return frameManagerInstance;\n  }\n\n  static removeInstance(): void {\n    frameManagerInstance = null;\n  }\n\n  modelAdded(resourceTreeModel: ResourceTreeModel): void {\n    const addListener = resourceTreeModel.addEventListener(ResourceTreeModelEvents.FrameAdded, this.frameAdded, this);\n    const detachListener =\n        resourceTreeModel.addEventListener(ResourceTreeModelEvents.FrameDetached, this.frameDetached, this);\n    const navigatedListener =\n        resourceTreeModel.addEventListener(ResourceTreeModelEvents.FrameNavigated, this.frameNavigated, this);\n    const resourceAddedListener =\n        resourceTreeModel.addEventListener(ResourceTreeModelEvents.ResourceAdded, this.resourceAdded, this);\n    this.#eventListeners.set(\n        resourceTreeModel, [addListener, detachListener, navigatedListener, resourceAddedListener]);\n    this.#framesForTarget.set(resourceTreeModel.target().id(), new Set());\n  }\n\n  modelRemoved(resourceTreeModel: ResourceTreeModel): void {\n    const listeners = this.#eventListeners.get(resourceTreeModel);\n    if (listeners) {\n      Common.EventTarget.removeEventListeners(listeners);\n    }\n\n    // Iterate over this model's #frames and decrease their count or remove them.\n    // (The ResourceTreeModel does not send FrameDetached events when a model\n    // is removed.)\n    const frameSet = this.#framesForTarget.get(resourceTreeModel.target().id());\n    if (frameSet) {\n      for (const frameId of frameSet) {\n        this.decreaseOrRemoveFrame(frameId);\n      }\n    }\n    this.#framesForTarget.delete(resourceTreeModel.target().id());\n  }\n\n  private frameAdded(event: Common.EventTarget.EventTargetEvent<ResourceTreeFrame>): void {\n    const frame = event.data;\n    const frameData = this.#frames.get(frame.id);\n    // If the frame is already in the map, increase its count, otherwise add it to the map.\n    if (frameData) {\n      // In order to not lose the following attributes of a frame during\n      // an OOPIF transfer we need to copy them to the new frame\n      frame.setCreationStackTrace(frameData.frame.getCreationStackTraceData());\n      this.#frames.set(frame.id, {frame, count: frameData.count + 1});\n    } else {\n      // If the transferring frame's detached event is received before its frame added\n      // event in the new target, the frame's cached attributes are reassigned.\n      const cachedFrameAttributes = this.#transferringFramesDataCache.get(frame.id);\n      if (cachedFrameAttributes?.creationStackTrace && cachedFrameAttributes?.creationStackTraceTarget) {\n        frame.setCreationStackTrace({\n          creationStackTrace: cachedFrameAttributes.creationStackTrace,\n          creationStackTraceTarget: cachedFrameAttributes.creationStackTraceTarget,\n        });\n      }\n      this.#frames.set(frame.id, {frame, count: 1});\n      this.#transferringFramesDataCache.delete(frame.id);\n    }\n    this.resetOutermostFrame();\n\n    // Add the frameId to the the targetId's set of frameIds.\n    const frameSet = this.#framesForTarget.get(frame.resourceTreeModel().target().id());\n    if (frameSet) {\n      frameSet.add(frame.id);\n    }\n\n    this.dispatchEventToListeners(Events.FRAME_ADDED_TO_TARGET, {frame});\n    this.resolveAwaitedFrame(frame);\n  }\n\n  private frameDetached(event: Common.EventTarget.EventTargetEvent<{frame: ResourceTreeFrame, isSwap: boolean}>): void {\n    const {frame, isSwap} = event.data;\n    // Decrease the frame's count or remove it entirely from the map.\n    this.decreaseOrRemoveFrame(frame.id);\n\n    // If the transferring frame's detached event is received before its frame\n    // added event in the new target, we persist some attributes of the frame here\n    // so that later on the frame added event in the new target they can be reassigned.\n    if (isSwap && !this.#frames.get(frame.id)) {\n      const traceData = frame.getCreationStackTraceData();\n      const cachedFrameAttributes = {\n        ...(traceData.creationStackTrace && {creationStackTrace: traceData.creationStackTrace}),\n        ...(traceData.creationStackTrace && {creationStackTraceTarget: traceData.creationStackTraceTarget}),\n      };\n      this.#transferringFramesDataCache.set(frame.id, cachedFrameAttributes);\n    }\n\n    // Remove the frameId from the target's set of frameIds.\n    const frameSet = this.#framesForTarget.get(frame.resourceTreeModel().target().id());\n    if (frameSet) {\n      frameSet.delete(frame.id);\n    }\n  }\n\n  private frameNavigated(event: Common.EventTarget.EventTargetEvent<ResourceTreeFrame>): void {\n    const frame = event.data;\n    this.dispatchEventToListeners(Events.FRAME_NAVIGATED, {frame});\n    if (frame.isOutermostFrame()) {\n      this.dispatchEventToListeners(Events.OUTERMOST_FRAME_NAVIGATED, {frame});\n    }\n  }\n\n  private resourceAdded(event: Common.EventTarget.EventTargetEvent<Resource>): void {\n    this.dispatchEventToListeners(Events.RESOURCE_ADDED, {resource: event.data});\n  }\n\n  private decreaseOrRemoveFrame(frameId: Protocol.Page.FrameId): void {\n    const frameData = this.#frames.get(frameId);\n    if (frameData) {\n      if (frameData.count === 1) {\n        this.#frames.delete(frameId);\n        this.resetOutermostFrame();\n        this.dispatchEventToListeners(Events.FRAME_REMOVED, {frameId});\n      } else {\n        frameData.count--;\n      }\n    }\n  }\n\n  /**\n   * Looks for the outermost frame in `#frames` and sets `#outermostFrame` accordingly.\n   *\n   * Important: This method needs to be called everytime `#frames` is updated.\n   */\n  private resetOutermostFrame(): void {\n    const outermostFrames = this.getAllFrames().filter(frame => frame.isOutermostFrame());\n    this.#outermostFrame = outermostFrames.length > 0 ? outermostFrames[0] : null;\n  }\n\n  /**\n   * Returns the ResourceTreeFrame with a given frameId.\n   * When a frame is being detached a new ResourceTreeFrame but with the same\n   * frameId is created. Consequently getFrame() will return a different\n   * ResourceTreeFrame after detachment. Callers of getFrame() should therefore\n   * immediately use the function return value and not store it for later use.\n   */\n  getFrame(frameId: Protocol.Page.FrameId): ResourceTreeFrame|null {\n    const frameData = this.#frames.get(frameId);\n    if (frameData) {\n      return frameData.frame;\n    }\n    return null;\n  }\n\n  getAllFrames(): ResourceTreeFrame[] {\n    return Array.from(this.#frames.values(), frameData => frameData.frame);\n  }\n\n  getOutermostFrame(): ResourceTreeFrame|null {\n    return this.#outermostFrame;\n  }\n\n  async getOrWaitForFrame(frameId: Protocol.Page.FrameId, notInTarget?: Target): Promise<ResourceTreeFrame> {\n    const frame = this.getFrame(frameId);\n    if (frame && (!notInTarget || notInTarget !== frame.resourceTreeModel().target())) {\n      return frame;\n    }\n    return new Promise<ResourceTreeFrame>(resolve => {\n      const waiting = this.#awaitedFrames.get(frameId);\n      if (waiting) {\n        waiting.push({notInTarget, resolve});\n      } else {\n        this.#awaitedFrames.set(frameId, [{notInTarget, resolve}]);\n      }\n    });\n  }\n\n  private resolveAwaitedFrame(frame: ResourceTreeFrame): void {\n    const waiting = this.#awaitedFrames.get(frame.id);\n    if (!waiting) {\n      return;\n    }\n    const newWaiting = waiting.filter(({notInTarget, resolve}) => {\n      if (!notInTarget || notInTarget !== frame.resourceTreeModel().target()) {\n        resolve(frame);\n        return false;\n      }\n      return true;\n    });\n    if (newWaiting.length > 0) {\n      this.#awaitedFrames.set(frame.id, newWaiting);\n    } else {\n      this.#awaitedFrames.delete(frame.id);\n    }\n  }\n}\n\nexport const enum Events {\n  // The FrameAddedToTarget event is sent whenever a frame is added to a target.\n  // This means that for OOPIFs it is sent twice: once when it's added to a\n  // parent target and a second time when it's added to its own target.\n  FRAME_ADDED_TO_TARGET = 'FrameAddedToTarget',\n  FRAME_NAVIGATED = 'FrameNavigated',\n  // The FrameRemoved event is only sent when a frame has been detached from\n  // all targets.\n  FRAME_REMOVED = 'FrameRemoved',\n  RESOURCE_ADDED = 'ResourceAdded',\n  OUTERMOST_FRAME_NAVIGATED = 'OutermostFrameNavigated',\n}\n\nexport type EventTypes = {\n  [Events.FRAME_ADDED_TO_TARGET]: {frame: ResourceTreeFrame},\n  [Events.FRAME_NAVIGATED]: {frame: ResourceTreeFrame},\n  [Events.FRAME_REMOVED]: {frameId: Protocol.Page.FrameId},\n  [Events.RESOURCE_ADDED]: {resource: Resource},\n  [Events.OUTERMOST_FRAME_NAVIGATED]: {frame: ResourceTreeFrame},\n};\n"],
  "mappings": "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",
  "names": ["Events"]
}
