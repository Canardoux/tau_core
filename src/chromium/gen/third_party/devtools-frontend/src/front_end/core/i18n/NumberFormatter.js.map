{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/i18n/NumberFormatter.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {DevToolsLocale} from './DevToolsLocale.js';\n\nexport interface NumberFormatter {\n  format(value: number): string;\n  formatToParts(value: number): Intl.NumberFormatPart[];\n}\n\n/**\n * Creates an instance of NumberFormatter.\n *\n * Safe to call in top-level of a module, since the creation of Intl.NumberFormat is deferred\n * until first usage.\n */\nexport function defineFormatter(options: Intl.NumberFormatOptions): NumberFormatter {\n  let intlNumberFormat: Intl.NumberFormat;\n\n  return {\n    format(value) {\n      if (!intlNumberFormat) {\n        intlNumberFormat = new Intl.NumberFormat(DevToolsLocale.instance().locale, options);\n      }\n      return formatAndEnsureSpace(intlNumberFormat, value);\n    },\n    formatToParts(value) {\n      if (!intlNumberFormat) {\n        intlNumberFormat = new Intl.NumberFormat(DevToolsLocale.instance().locale, options);\n      }\n      return intlNumberFormat.formatToParts(value);\n    },\n  };\n}\n\n/**\n * When using 'narrow' unitDisplay, many locales exclude the space between the literal and the unit.\n * We don't like that, so when there is no space literal we inject an nbsp manually.\n */\nfunction formatAndEnsureSpace(formatter: Intl.NumberFormat, value: number): string {\n  const parts = formatter.formatToParts(value);\n\n  let hasSpace = false;\n  for (const part of parts) {\n    if (part.type === 'literal') {\n      if (part.value === ' ') {\n        hasSpace = true;\n        part.value = '\\xA0';\n      } else if (part.value === '\\xA0') {\n        hasSpace = true;\n      }\n    }\n  }\n\n  if (hasSpace) {\n    return parts.map(part => part.value).join('');\n  }\n\n  const unitIndex = parts.findIndex(part => part.type === 'unit');\n\n  // Unexpected for there to be no unit, but just in case, handle that.\n  if (unitIndex === -1) {\n    return parts.map(part => part.value).join('');\n  }\n\n  // For locales where the unit comes first (sw), the space has to come after the unit.\n  if (unitIndex === 0) {\n    return parts[0].value + '\\xA0' + parts.slice(1).map(part => part.value).join('');\n  }\n\n  // Otherwise, it comes before.\n  return parts.slice(0, unitIndex).map(part => part.value).join('') + '\\xA0' +\n      parts.slice(unitIndex).map(part => part.value).join('');\n}\n"],
  "mappings": ";AAIA,SAAQ,sBAAqB;AAatB,gBAAS,gBAAgB,SAAoD;AAClF,MAAI;AAEJ,SAAO;AAAA,IACL,OAAO,OAAO;AACZ,UAAI,CAAC,kBAAkB;AACrB,2BAAmB,IAAI,KAAK,aAAa,eAAe,SAAS,EAAE,QAAQ,OAAO;AAAA,MACpF;AACA,aAAO,qBAAqB,kBAAkB,KAAK;AAAA,IACrD;AAAA,IACA,cAAc,OAAO;AACnB,UAAI,CAAC,kBAAkB;AACrB,2BAAmB,IAAI,KAAK,aAAa,eAAe,SAAS,EAAE,QAAQ,OAAO;AAAA,MACpF;AACA,aAAO,iBAAiB,cAAc,KAAK;AAAA,IAC7C;AAAA,EACF;AACF;AAMA,SAAS,qBAAqB,WAA8B,OAAuB;AACjF,QAAM,QAAQ,UAAU,cAAc,KAAK;AAE3C,MAAI,WAAW;AACf,aAAW,QAAQ,OAAO;AACxB,QAAI,KAAK,SAAS,WAAW;AAC3B,UAAI,KAAK,UAAU,KAAK;AACtB,mBAAW;AACX,aAAK,QAAQ;AAAA,MACf,WAAW,KAAK,UAAU,QAAQ;AAChC,mBAAW;AAAA,MACb;AAAA,IACF;AAAA,EACF;AAEA,MAAI,UAAU;AACZ,WAAO,MAAM,IAAI,UAAQ,KAAK,KAAK,EAAE,KAAK,EAAE;AAAA,EAC9C;AAEA,QAAM,YAAY,MAAM,UAAU,UAAQ,KAAK,SAAS,MAAM;AAG9D,MAAI,cAAc,IAAI;AACpB,WAAO,MAAM,IAAI,UAAQ,KAAK,KAAK,EAAE,KAAK,EAAE;AAAA,EAC9C;AAGA,MAAI,cAAc,GAAG;AACnB,WAAO,MAAM,CAAC,EAAE,QAAQ,SAAS,MAAM,MAAM,CAAC,EAAE,IAAI,UAAQ,KAAK,KAAK,EAAE,KAAK,EAAE;AAAA,EACjF;AAGA,SAAO,MAAM,MAAM,GAAG,SAAS,EAAE,IAAI,UAAQ,KAAK,KAAK,EAAE,KAAK,EAAE,IAAI,SAChE,MAAM,MAAM,SAAS,EAAE,IAAI,UAAQ,KAAK,KAAK,EAAE,KAAK,EAAE;AAC5D;",
  "names": []
}
