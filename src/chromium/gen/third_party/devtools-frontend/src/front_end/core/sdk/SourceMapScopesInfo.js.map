{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/SourceMapScopesInfo.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Protocol from '../../generated/protocol.js';\n\nimport type {CallFrame, ScopeChainEntry} from './DebuggerModel.js';\nimport type {SourceMap, SourceMapV3Object} from './SourceMap.js';\nimport {SourceMapScopeChainEntry} from './SourceMapScopeChainEntry.js';\nimport {\n  decodeGeneratedRanges,\n  decodeOriginalScopes,\n  type GeneratedRange,\n  type OriginalPosition,\n  type OriginalScope,\n} from './SourceMapScopes.js';\n\nexport class SourceMapScopesInfo {\n  /* eslint-disable-next-line no-unused-private-class-members */\n  readonly #sourceMap: SourceMap;\n  readonly #originalScopes: OriginalScope[];\n  readonly #generatedRanges: GeneratedRange[];\n\n  #cachedVariablesAndBindingsPresent: boolean|null = null;\n\n  constructor(sourceMap: SourceMap, originalScopes: OriginalScope[], generatedRanges: GeneratedRange[]) {\n    this.#sourceMap = sourceMap;\n    this.#originalScopes = originalScopes;\n    this.#generatedRanges = generatedRanges;\n  }\n\n  static parseFromMap(\n      sourceMap: SourceMap,\n      sourceMapJson: Pick<SourceMapV3Object, 'names'|'originalScopes'|'generatedRanges'>): SourceMapScopesInfo {\n    if (!sourceMapJson.originalScopes || !sourceMapJson.generatedRanges) {\n      throw new Error('Cant create SourceMapScopesInfo without encoded scopes');\n    }\n    const scopeTrees = decodeOriginalScopes(sourceMapJson.originalScopes, sourceMapJson.names ?? []);\n    const originalScopes = scopeTrees.map(tree => tree.root);\n    const generatedRanges = decodeGeneratedRanges(sourceMapJson.generatedRanges, scopeTrees, sourceMapJson.names ?? []);\n    return new SourceMapScopesInfo(sourceMap, originalScopes, generatedRanges);\n  }\n\n  /**\n   * Given a generated position, returns the original name of the surrounding function as well as\n   * all the original function names that got inlined into the surrounding generated function and their\n   * respective callsites in the original code (ordered from inner to outer).\n   *\n   * @returns a list with inlined functions. Every entry in the list has a callsite in the orignal code,\n   * except the last function (since the last function didn't get inlined).\n   */\n  findInlinedFunctions(generatedLine: number, generatedColumn: number): InlineInfo {\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n    const result: InlineInfo = {\n      inlinedFunctions: [],\n      originalFunctionName: '',\n    };\n\n    // Walk the generated ranges from the innermost containing range outwards as long as we don't\n    // encounter a range that is a scope in the generated code and a function scope originally.\n    for (let i = rangeChain.length - 1; i >= 0; --i) {\n      const range = rangeChain[i];\n\n      if (range.callsite) {\n        // Record the name and call-site if the range corresponds to an inlined function.\n        result.inlinedFunctions.push({name: range.originalScope?.name ?? '', callsite: range.callsite});\n      }\n      if (range.isStackFrame) {\n        // We arrived at an actual generated JS function, don't go further.\n        // The corresponding original scope could not actually be a function\n        // (e.g. a block scope transpiled down to a JS function), but we'll\n        // filter that out later.\n        result.originalFunctionName = range.originalScope?.name ?? '';\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Takes a V8 provided call frame and expands any inlined frames into virtual call frames.\n   *\n   * For call frames where nothing was inlined, the result contains only a single element,\n   * the provided frame but with the original name.\n   *\n   * For call frames where we are paused in inlined code, this function returns a list of\n   * call frames from \"inner to outer\". This is the call frame at index 0\n   * signifies the top of this stack trace fragment.\n   *\n   * The rest are \"virtual\" call frames and will have an \"inlineFrameIndex\" set in ascending\n   * order, so the condition `result[index] === result[index].inlineFrameIndex` always holds.\n   */\n  expandCallFrame(callFrame: CallFrame): CallFrame[] {\n    const {originalFunctionName, inlinedFunctions} =\n        this.findInlinedFunctions(callFrame.location().lineNumber, callFrame.location().columnNumber);\n    const result: CallFrame[] = [];\n    for (const [index, fn] of inlinedFunctions.entries()) {\n      result.push(callFrame.createVirtualCallFrame(index, fn.name));\n    }\n    result.push(callFrame.createVirtualCallFrame(result.length, originalFunctionName));\n    return result;\n  }\n\n  /**\n   * Given a generated position, this returns all the surrounding generated ranges from outer\n   * to inner.\n   */\n  #findGeneratedRangeChain(line: number, column: number): GeneratedRange[] {\n    const result: GeneratedRange[] = [];\n\n    (function walkRanges(ranges: GeneratedRange[]) {\n      for (const range of ranges) {\n        if (!contains(range, line, column)) {\n          continue;\n        }\n        result.push(range);\n        walkRanges(range.children);\n      }\n    })(this.#generatedRanges);\n\n    return result;\n  }\n\n  /**\n   * @returns true if we have enough info (i.e. variable and binding expressions) to build\n   * a scope view.\n   */\n  hasVariablesAndBindings(): boolean {\n    if (this.#cachedVariablesAndBindingsPresent === null) {\n      this.#cachedVariablesAndBindingsPresent = this.#areVariablesAndBindingsPresent();\n    }\n    return this.#cachedVariablesAndBindingsPresent;\n  }\n\n  #areVariablesAndBindingsPresent(): boolean {\n    // We check whether any original scope has a non-empty list of variables, and\n    // generated ranges with a non-empty binding list.\n\n    function walkTree(nodes: OriginalScope[]|GeneratedRange[]): boolean {\n      for (const node of nodes) {\n        if ('variables' in node && node.variables.length > 0) {\n          return true;\n        }\n\n        if ('values' in node && node.values.some(v => v !== undefined)) {\n          return true;\n        }\n\n        if (walkTree(node.children)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return walkTree(this.#originalScopes) && walkTree(this.#generatedRanges);\n  }\n\n  /**\n   * Constructs a scope chain based on the CallFrame's paused position.\n   *\n   * The algorithm to obtain the original scope chain is straight-forward:\n   *\n   *   1) Find the inner-most generated range that contains the CallFrame's\n   *      paused position.\n   *\n   *   2) Does the found range have an associated original scope?\n   *\n   *      2a) If no, return null. This is a \"hidden\" range and technically\n   *          we shouldn't be pausing here in the first place. This code doesn't\n   *          correspond to anything in the authored code.\n   *\n   *      2b) If yes, the associated original scope is the inner-most\n   *          original scope in the resulting scope chain.\n   *\n   *   3) Walk the parent chain of the found original scope outwards. This is\n   *      our scope view. For each original scope we also try to find a\n   *      corresponding generated range that contains the CallFrame's\n   *      paused position. We need the generated range to resolve variable\n   *      values.\n   */\n  resolveMappedScopeChain(callFrame: CallFrame): ScopeChainEntry[]|null {\n    const rangeChain = this.#findGeneratedRangeChainForFrame(callFrame);\n    const innerMostOriginalScope = rangeChain.at(-1)?.originalScope;\n    if (innerMostOriginalScope === undefined) {\n      return null;\n    }\n\n    // TODO(crbug.com/40277685): Add a sanity check here where we map the paused position using\n    //         the source map's mappings, find the inner-most original scope with that mapped paused\n    //         position and compare that result with `innerMostOriginalScope`. If they don't match we\n    //         should emit a warning about the broken source map as mappings and scopes are inconsistent\n    //         w.r.t. each other.\n\n    let seenFunctionScope = false;\n    const result: SourceMapScopeChainEntry[] = [];\n    // Walk the original scope chain outwards and try to find the corresponding generated range along the way.\n    for (let originalScope = rangeChain.at(-1)?.originalScope; originalScope; originalScope = originalScope.parent) {\n      const range = rangeChain.findLast(r => r.originalScope === originalScope);\n      const isFunctionScope = originalScope.kind === 'function';\n      const isInnerMostFunction = isFunctionScope && !seenFunctionScope;\n      const returnValue = isInnerMostFunction ? callFrame.returnValue() : null;\n      result.push(\n          new SourceMapScopeChainEntry(callFrame, originalScope, range, isInnerMostFunction, returnValue ?? undefined));\n      seenFunctionScope ||= isFunctionScope;\n    }\n\n    // If we are paused on a return statement, we need to drop inner block scopes. This is because V8 only emits a\n    // single return bytecode and \"gotos\" at the functions' end, where we are now paused.\n    if (callFrame.returnValue() !== null) {\n      while (result.length && result[0].type() !== Protocol.Debugger.ScopeType.Local) {\n        result.shift();\n      }\n    }\n\n    return result;\n  }\n\n  /** Similar to #findGeneratedRangeChain, but takes inlineFrameIndex of virtual call frames into account */\n  #findGeneratedRangeChainForFrame(callFrame: CallFrame): GeneratedRange[] {\n    const rangeChain =\n        this.#findGeneratedRangeChain(callFrame.location().lineNumber, callFrame.location().columnNumber);\n    if (callFrame.inlineFrameIndex === 0) {\n      return rangeChain;\n    }\n\n    // Drop ranges in the chain until we reach our desired inlined range.\n    for (let inlineIndex = 0; inlineIndex < callFrame.inlineFrameIndex;) {\n      const range = rangeChain.pop();\n      if (range?.callsite) {\n        ++inlineIndex;\n      }\n    }\n\n    return rangeChain;\n  }\n}\n\n/**\n * Represents the inlining information for a given generated position.\n *\n * It contains a list of all the inlined original functions at the generated position\n * as well as the original function name of the generated position's surrounding\n * function.\n *\n * The inlined functions are sorted from inner to outer (or top to bottom on the stack).\n */\nexport interface InlineInfo {\n  inlinedFunctions: {name: string, callsite: OriginalPosition}[];\n  originalFunctionName: string;\n}\n\nexport function contains(range: Pick<GeneratedRange, 'start'|'end'>, line: number, column: number): boolean {\n  if (range.start.line > line || (range.start.line === line && range.start.column > column)) {\n    return false;\n  }\n\n  if (range.end.line < line || (range.end.line === line && range.end.column <= column)) {\n    return false;\n  }\n\n  return true;\n}\n"],
  "mappings": ";AAIA,YAAY,cAAc;AAI1B,SAAQ,gCAA+B;AACvC;AAAA,EACE;AAAA,EACA;AAAA,OAIK;AAEA,aAAM,oBAAoB;AAAA;AAAA,EAEtB;AAAA,EACA;AAAA,EACA;AAAA,EAET,qCAAmD;AAAA,EAEnD,YAAY,WAAsB,gBAAiC,iBAAmC;AACpG,SAAK,aAAa;AAClB,SAAK,kBAAkB;AACvB,SAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEA,OAAO,aACH,WACA,eAAyG;AAC3G,QAAI,CAAC,cAAc,kBAAkB,CAAC,cAAc,iBAAiB;AACnE,YAAM,IAAI,MAAM,wDAAwD;AAAA,IAC1E;AACA,UAAM,aAAa,qBAAqB,cAAc,gBAAgB,cAAc,SAAS,CAAC,CAAC;AAC/F,UAAM,iBAAiB,WAAW,IAAI,UAAQ,KAAK,IAAI;AACvD,UAAM,kBAAkB,sBAAsB,cAAc,iBAAiB,YAAY,cAAc,SAAS,CAAC,CAAC;AAClH,WAAO,IAAI,oBAAoB,WAAW,gBAAgB,eAAe;AAAA,EAC3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,qBAAqB,eAAuB,iBAAqC;AAC/E,UAAM,aAAa,KAAK,yBAAyB,eAAe,eAAe;AAC/E,UAAM,SAAqB;AAAA,MACzB,kBAAkB,CAAC;AAAA,MACnB,sBAAsB;AAAA,IACxB;AAIA,aAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAC/C,YAAM,QAAQ,WAAW,CAAC;AAE1B,UAAI,MAAM,UAAU;AAElB,eAAO,iBAAiB,KAAK,EAAC,MAAM,MAAM,eAAe,QAAQ,IAAI,UAAU,MAAM,SAAQ,CAAC;AAAA,MAChG;AACA,UAAI,MAAM,cAAc;AAKtB,eAAO,uBAAuB,MAAM,eAAe,QAAQ;AAC3D;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,gBAAgB,WAAmC;AACjD,UAAM,EAAC,sBAAsB,iBAAgB,IACzC,KAAK,qBAAqB,UAAU,SAAS,EAAE,YAAY,UAAU,SAAS,EAAE,YAAY;AAChG,UAAM,SAAsB,CAAC;AAC7B,eAAW,CAAC,OAAO,EAAE,KAAK,iBAAiB,QAAQ,GAAG;AACpD,aAAO,KAAK,UAAU,uBAAuB,OAAO,GAAG,IAAI,CAAC;AAAA,IAC9D;AACA,WAAO,KAAK,UAAU,uBAAuB,OAAO,QAAQ,oBAAoB,CAAC;AACjF,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,yBAAyB,MAAc,QAAkC;AACvE,UAAM,SAA2B,CAAC;AAElC,KAAC,SAAS,WAAW,QAA0B;AAC7C,iBAAW,SAAS,QAAQ;AAC1B,YAAI,CAAC,SAAS,OAAO,MAAM,MAAM,GAAG;AAClC;AAAA,QACF;AACA,eAAO,KAAK,KAAK;AACjB,mBAAW,MAAM,QAAQ;AAAA,MAC3B;AAAA,IACF,GAAG,KAAK,gBAAgB;AAExB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,0BAAmC;AACjC,QAAI,KAAK,uCAAuC,MAAM;AACpD,WAAK,qCAAqC,KAAK,gCAAgC;AAAA,IACjF;AACA,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,kCAA2C;AAIzC,aAAS,SAAS,OAAkD;AAClE,iBAAW,QAAQ,OAAO;AACxB,YAAI,eAAe,QAAQ,KAAK,UAAU,SAAS,GAAG;AACpD,iBAAO;AAAA,QACT;AAEA,YAAI,YAAY,QAAQ,KAAK,OAAO,KAAK,OAAK,MAAM,MAAS,GAAG;AAC9D,iBAAO;AAAA,QACT;AAEA,YAAI,SAAS,KAAK,QAAQ,GAAG;AAC3B,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,WAAO,SAAS,KAAK,eAAe,KAAK,SAAS,KAAK,gBAAgB;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,wBAAwB,WAA8C;AACpE,UAAM,aAAa,KAAK,iCAAiC,SAAS;AAClE,UAAM,yBAAyB,WAAW,GAAG,EAAE,GAAG;AAClD,QAAI,2BAA2B,QAAW;AACxC,aAAO;AAAA,IACT;AAQA,QAAI,oBAAoB;AACxB,UAAM,SAAqC,CAAC;AAE5C,aAAS,gBAAgB,WAAW,GAAG,EAAE,GAAG,eAAe,eAAe,gBAAgB,cAAc,QAAQ;AAC9G,YAAM,QAAQ,WAAW,SAAS,OAAK,EAAE,kBAAkB,aAAa;AACxE,YAAM,kBAAkB,cAAc,SAAS;AAC/C,YAAM,sBAAsB,mBAAmB,CAAC;AAChD,YAAM,cAAc,sBAAsB,UAAU,YAAY,IAAI;AACpE,aAAO;AAAA,QACH,IAAI,yBAAyB,WAAW,eAAe,OAAO,qBAAqB,eAAe,MAAS;AAAA,MAAC;AAChH,4BAAsB;AAAA,IACxB;AAIA,QAAI,UAAU,YAAY,MAAM,MAAM;AACpC,aAAO,OAAO,UAAU,OAAO,CAAC,EAAE,KAAK,MAAM,SAAS,SAAS,UAAU,OAAO;AAC9E,eAAO,MAAM;AAAA,MACf;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,iCAAiC,WAAwC;AACvE,UAAM,aACF,KAAK,yBAAyB,UAAU,SAAS,EAAE,YAAY,UAAU,SAAS,EAAE,YAAY;AACpG,QAAI,UAAU,qBAAqB,GAAG;AACpC,aAAO;AAAA,IACT;AAGA,aAAS,cAAc,GAAG,cAAc,UAAU,oBAAmB;AACnE,YAAM,QAAQ,WAAW,IAAI;AAC7B,UAAI,OAAO,UAAU;AACnB,UAAE;AAAA,MACJ;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;AAgBO,gBAAS,SAAS,OAA4C,MAAc,QAAyB;AAC1G,MAAI,MAAM,MAAM,OAAO,QAAS,MAAM,MAAM,SAAS,QAAQ,MAAM,MAAM,SAAS,QAAS;AACzF,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,IAAI,OAAO,QAAS,MAAM,IAAI,SAAS,QAAQ,MAAM,IAAI,UAAU,QAAS;AACpF,WAAO;AAAA,EACT;AAEA,SAAO;AACT;",
  "names": []
}
