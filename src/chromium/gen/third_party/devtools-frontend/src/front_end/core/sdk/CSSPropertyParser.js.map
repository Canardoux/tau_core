{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/CSSPropertyParser.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as CodeMirror from '../../third_party/codemirror.next/codemirror.next.js';\n\nconst globalValues = new Set<string>(['inherit', 'initial', 'unset']);\n\nconst tagRegexp = /[\\x20-\\x7E]{4}/;\nconst numRegexp = /[+-]?(?:\\d*\\.)?\\d+(?:[eE]\\d+)?/;\nconst fontVariationSettingsRegexp =\n    new RegExp(`(?:'(${tagRegexp.source})')|(?:\"(${tagRegexp.source})\")\\\\s+(${numRegexp.source})`);\n\n/**\n * Extracts information about font variation settings assuming\n * value is valid according to the spec: https://drafts.csswg.org/css-fonts-4/#font-variation-settings-def\n */\nexport function parseFontVariationSettings(value: string): {\n  tag: string,\n  value: number,\n}[] {\n  if (globalValues.has(value.trim()) || value.trim() === 'normal') {\n    return [];\n  }\n  const results = [];\n  for (const setting of splitByComma(stripComments(value))) {\n    const match = setting.match(fontVariationSettingsRegexp);\n    if (match) {\n      results.push({\n        tag: match[1] || match[2],\n        value: parseFloat(match[3]),\n      });\n    }\n  }\n  return results;\n}\n\n// \"str\" or 'str'\nconst fontFamilyRegexp = /^\"(.+)\"|'(.+)'$/;\n\n/**\n * Extracts font families assuming the value is valid according to\n * the spec: https://drafts.csswg.org/css-fonts-4/#font-family-prop\n */\nexport function parseFontFamily(value: string): string[] {\n  if (globalValues.has(value.trim())) {\n    return [];\n  }\n  const results = [];\n  for (const family of splitByComma(stripComments(value))) {\n    const match = family.match(fontFamilyRegexp);\n    if (match) {\n      // Either the 1st or 2nd group matches if the value is in quotes\n      results.push(match[1] || match[2]);\n    } else {\n      // Value without without quotes.\n      results.push(family);\n    }\n  }\n  return results;\n}\n\n/**\n * Splits a list of values by comma and trims parts\n */\nexport function splitByComma(value: string): string[] {\n  return value.split(',').map(part => part.trim());\n}\n\nexport function stripComments(value: string): string {\n  return value.replaceAll(/(\\/\\*(?:.|\\s)*?\\*\\/)/g, '');\n}\n\nconst cssParser = CodeMirror.css.cssLanguage.parser;\n\nfunction nodeText(node: CodeMirror.SyntaxNode, text: string): string {\n  return nodeTextRange(node, node, text);\n}\nfunction nodeTextRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode, text: string): string {\n  return text.substring(from.from, to.to);\n}\n\nexport class SyntaxTree {\n  readonly propertyValue: string;\n  readonly rule: string;\n  readonly tree: CodeMirror.SyntaxNode;\n  readonly trailingNodes: CodeMirror.SyntaxNode[];\n  readonly propertyName: string|undefined;\n  constructor(\n      propertyValue: string, rule: string, tree: CodeMirror.SyntaxNode, propertyName?: string,\n      trailingNodes: CodeMirror.SyntaxNode[] = []) {\n    this.propertyName = propertyName;\n    this.propertyValue = propertyValue;\n    this.rule = rule;\n    this.tree = tree;\n    this.trailingNodes = trailingNodes;\n  }\n\n  text(node?: CodeMirror.SyntaxNode|null): string {\n    if (node === null) {\n      return '';\n    }\n    return nodeText(node ?? this.tree, this.rule);\n  }\n\n  textRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode): string {\n    return nodeTextRange(from, to, this.rule);\n  }\n\n  subtree(node: CodeMirror.SyntaxNode): SyntaxTree {\n    return new SyntaxTree(this.propertyValue, this.rule, node);\n  }\n}\n\nexport interface SyntaxNodeRef {\n  node: CodeMirror.SyntaxNode;\n}\n\nexport abstract class TreeWalker {\n  readonly ast: SyntaxTree;\n  constructor(ast: SyntaxTree) {\n    this.ast = ast;\n  }\n  static walkExcludingSuccessors<T extends TreeWalker, ArgTs extends unknown[]>(\n      this: {new(ast: SyntaxTree, ...args: ArgTs): T}, propertyValue: SyntaxTree, ...args: ArgTs): T {\n    const instance = new this(propertyValue, ...args);\n    if (propertyValue.tree.name === 'Declaration') {\n      instance.iterateDeclaration(propertyValue.tree);\n    } else {\n      instance.iterateExcludingSuccessors(propertyValue.tree);\n    }\n    return instance;\n  }\n  static walk<T extends TreeWalker, ArgTs extends unknown[]>(\n      this: {new(ast: SyntaxTree, ...args: ArgTs): T}, propertyValue: SyntaxTree, ...args: ArgTs): T {\n    const instance = new this(propertyValue, ...args);\n    if (propertyValue.tree.name === 'Declaration') {\n      instance.iterateDeclaration(propertyValue.tree);\n    } else {\n      instance.iterate(propertyValue.tree);\n    }\n    return instance;\n  }\n\n  iterateDeclaration(tree: CodeMirror.SyntaxNode): void {\n    if (tree.name !== 'Declaration') {\n      return;\n    }\n    if (this.enter(tree)) {\n      ASTUtils.declValue(tree)?.cursor().iterate(this.enter.bind(this), this.leave.bind(this));\n    }\n    this.leave(tree);\n  }\n\n  protected iterate(tree: CodeMirror.SyntaxNode): void {\n    tree.cursor().iterate(this.enter.bind(this), this.leave.bind(this));\n  }\n\n  protected iterateExcludingSuccessors(tree: CodeMirror.SyntaxNode): void {\n    // Customize the first step to avoid visiting siblings of `tree`\n    if (this.enter(tree)) {\n      tree.firstChild?.cursor().iterate(this.enter.bind(this), this.leave.bind(this));\n    }\n    this.leave(tree);\n  }\n\n  protected enter(_node: SyntaxNodeRef): boolean {\n    return true;\n  }\n\n  protected leave(_node: SyntaxNodeRef): void {\n  }\n}\n\nexport interface Match {\n  readonly text: string;\n  readonly node: CodeMirror.SyntaxNode;\n  computedText?(): string|null;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Constructor<T = any> = (abstract new (...args: any[]) => T)|(new (...args: any[]) => T);\n\nexport interface Matcher<MatchT extends Match> {\n  readonly matchType: Constructor<MatchT>;\n  accepts(propertyName: string): boolean;\n  matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null;\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function matcherBase<MatchT extends Match>(matchT: Constructor<MatchT>) {\n  class MatcherBase implements Matcher<MatchT> {\n    matchType = matchT;\n    accepts(_propertyName: string): boolean {\n      return true;\n    }\n\n    matches(_node: CodeMirror.SyntaxNode, _matching: BottomUpTreeMatching): Match|null {\n      return null;\n    }\n  }\n  return MatcherBase;\n}\n\ntype MatchKey = Platform.Brand.Brand<string, 'MatchKey'>;\nexport class BottomUpTreeMatching extends TreeWalker {\n  #matchers: Matcher<Match>[] = [];\n  #matchedNodes = new Map<MatchKey, Match>();\n  readonly computedText: ComputedText;\n\n  #key(node: CodeMirror.SyntaxNode): MatchKey {\n    return `${node.from}:${node.to}` as MatchKey;\n  }\n\n  constructor(ast: SyntaxTree, matchers: Matcher<Match>[]) {\n    super(ast);\n    this.computedText = new ComputedText(ast.rule.substring(ast.tree.from));\n    this.#matchers.push(...matchers.filter(m => !ast.propertyName || m.accepts(ast.propertyName)));\n    this.#matchers.push(new TextMatcher());\n  }\n\n  protected override leave({node}: SyntaxNodeRef): void {\n    for (const matcher of this.#matchers) {\n      const match = matcher.matches(node, this);\n      if (match) {\n        this.computedText.push(match, node.from - this.ast.tree.from);\n        this.#matchedNodes.set(this.#key(node), match);\n        break;\n      }\n    }\n  }\n\n  matchText(node: CodeMirror.SyntaxNode): void {\n    const matchers = this.#matchers.splice(0);\n    this.#matchers.push(new TextMatcher());\n    this.iterateExcludingSuccessors(node);\n    this.#matchers.push(...matchers);\n  }\n\n  getMatch(node: CodeMirror.SyntaxNode): Match|undefined {\n    return this.#matchedNodes.get(this.#key(node));\n  }\n\n  hasUnresolvedVars(node: CodeMirror.SyntaxNode): boolean {\n    return this.hasUnresolvedVarsRange(node, node);\n  }\n\n  hasUnresolvedVarsRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode): boolean {\n    return this.computedText.hasUnresolvedVars(from.from - this.ast.tree.from, to.to - this.ast.tree.from);\n  }\n\n  getComputedText(node: CodeMirror.SyntaxNode, substitutions?: Map<Match, string>): string {\n    return this.getComputedTextRange(node, node, substitutions);\n  }\n\n  getComputedTextRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode, substitutions?: Map<Match, string>):\n      string {\n    return this.computedText.get(from.from - this.ast.tree.from, to.to - this.ast.tree.from, substitutions);\n  }\n}\n\ntype MatchWithComputedText = Match&{computedText: NonNullable<Match['computedText']>};\nclass ComputedTextChunk {\n  #cachedComputedText: string|null = null;\n  constructor(readonly match: MatchWithComputedText, readonly offset: number) {\n  }\n\n  get end(): number {\n    return this.offset + this.length;\n  }\n\n  get length(): number {\n    return this.match.text.length;\n  }\n\n  get computedText(): string|null {\n    if (this.#cachedComputedText === null) {\n      this.#cachedComputedText = this.match.computedText();\n    }\n    return this.#cachedComputedText;\n  }\n}\n\n// This class constructs the \"computed\" text from the input property text, i.e., it will strip comments and substitute\n// var() functions if possible. It's intended for use during the bottom-up tree matching process. The original text is\n// not modified. Instead, computed text slices are produced on the fly. During bottom-up matching, the sequence of\n// top-level comments and var() matches will be recorded. This produces an ordered sequence of text pieces that need to\n// be substituted into the original text. When a computed text slice is requested, it is generated by piecing together\n// original and computed slices as required.\nexport class ComputedText {\n  readonly #chunks: ComputedTextChunk[] = [];\n  readonly text: string;\n  #sorted: boolean = true;\n  constructor(text: string) {\n    this.text = text;\n  }\n\n  clear(): void {\n    this.#chunks.splice(0);\n  }\n\n  get chunkCount(): number {\n    return this.#chunks.length;\n  }\n\n  #sortIfNecessary(): void {\n    if (this.#sorted) {\n      return;\n    }\n    // Sort intervals by offset, with longer intervals first if the offset is identical.\n    this.#chunks.sort((a, b) => {\n      if (a.offset < b.offset) {\n        return -1;\n      }\n      if (b.offset < a.offset) {\n        return 1;\n      }\n      if (a.end > b.end) {\n        return -1;\n      }\n      if (a.end < b.end) {\n        return 1;\n      }\n      return 0;\n    });\n    this.#sorted = true;\n  }\n\n  // Add another substitutable match. The match will either be appended to the list of existing matches or it will\n  // be substituted for the last match(es) if it encompasses them.\n  push(match: Match, offset: number): void {\n    function hasComputedText(match: Match): match is MatchWithComputedText {\n      return Boolean(match.computedText);\n    }\n    if (!hasComputedText(match) || offset < 0 || offset >= this.text.length) {\n      return;\n    }\n    const chunk = new ComputedTextChunk(match, offset);\n    if (chunk.end > this.text.length) {\n      return;\n    }\n    this.#sorted = false;\n    this.#chunks.push(chunk);\n  }\n\n  * #range(begin: number, end: number): Generator<ComputedTextChunk> {\n    this.#sortIfNecessary();\n    let i = this.#chunks.findIndex(c => c.offset >= begin);\n    while (i >= 0 && i < this.#chunks.length && this.#chunks[i].end > begin && begin < end) {\n      if (this.#chunks[i].end > end) {\n        i++;\n        continue;\n      }\n      yield this.#chunks[i];\n      begin = this.#chunks[i].end;\n      while (begin < end && i < this.#chunks.length && this.#chunks[i].offset < begin) {\n        i++;\n      }\n    }\n  }\n\n  hasUnresolvedVars(begin: number, end: number): boolean {\n    for (const chunk of this.#range(begin, end)) {\n      if (chunk.computedText === null) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  * #getPieces(begin: number, end: number): Generator<string|ComputedTextChunk> {\n    for (const chunk of this.#range(begin, end)) {\n      const piece = this.text.substring(begin, Math.min(chunk.offset, end));\n      yield piece;\n      if (end >= chunk.end) {\n        yield chunk;\n      }\n      begin = chunk.end;\n    }\n    if (begin < end) {\n      const piece = this.text.substring(begin, end);\n      yield piece;\n    }\n  }\n\n  // Get a slice of the computed text corresponding to the property text in the range [begin, end). The slice may not\n  // start within a substitution chunk, e.g., it's invalid to request the computed text for the property value text\n  // slice \"1px var(--\".\n  get(begin: number, end: number, substitutions?: Map<Match, string>): string {\n    const pieces: string[] = [];\n    const getText = (piece: string|ComputedTextChunk): string => {\n      if (typeof piece === 'string') {\n        return piece;\n      }\n      const substitution = substitutions?.get(piece.match);\n      if (substitution) {\n        return getText(substitution);\n      }\n      return piece.computedText ?? piece.match.text;\n    };\n\n    for (const piece of this.#getPieces(begin, end)) {\n      const text = getText(piece);\n      if (text.length === 0) {\n        continue;\n      }\n      if (pieces.length > 0 && requiresSpace(pieces[pieces.length - 1], text)) {\n        pieces.push(' ');\n      }\n      pieces.push(text);\n    }\n    return pieces.join('');\n  }\n}\n\n// This function determines whether concatenating two pieces of text requires any spacing inbetween. For example, there\n// shouldn't be any space between 'var' and '(', but there should be a space between '1px' and 'solid'. The node\n// sequences that make up the pieces of text may contain non-text nodes/trees. Any such element inbetween the texts is\n// ignored for the spacing requirement.\nexport function requiresSpace(a: string, b: string): boolean;\nexport function requiresSpace(a: Node[], b: Node[]): boolean;\nexport function requiresSpace(a: Node[]|string|undefined, b: Node[]|string|undefined): boolean {\n  const tail = Array.isArray(a) ? a.findLast(node => node.textContent)?.textContent : a;\n  const head = Array.isArray(b) ? b.find(node => node.textContent)?.textContent : b;\n  const trailingChar = tail ? tail[tail.length - 1] : '';\n  const leadingChar = head ? head[0] : '';\n\n  const noSpaceAfter = ['', '(', '{', '}', ';', '['];\n  const noSpaceBefore = ['', '(', ')', ',', ':', '*', '{', ';', ']'];\n  return !/\\s/.test(trailingChar) && !/\\s/.test(leadingChar) && !noSpaceAfter.includes(trailingChar) &&\n      !noSpaceBefore.includes(leadingChar);\n}\n\nexport const CSSControlMap = Map<string, HTMLElement[]>;\nexport type CSSControlMap = Map<string, HTMLElement[]>;\nexport namespace ASTUtils {\n  export function siblings(node: CodeMirror.SyntaxNode|null): CodeMirror.SyntaxNode[] {\n    const result = [];\n    while (node) {\n      result.push(node);\n      node = node.nextSibling;\n    }\n    return result;\n  }\n\n  export function children(node: CodeMirror.SyntaxNode|null): CodeMirror.SyntaxNode[] {\n    return siblings(node?.firstChild ?? null);\n  }\n\n  export function declValue(node: CodeMirror.SyntaxNode): CodeMirror.SyntaxNode|null {\n    if (node.name !== 'Declaration') {\n      return null;\n    }\n    return children(node).find(node => node.name === ':')?.nextSibling ?? null;\n  }\n\n  export function* stripComments(nodes: CodeMirror.SyntaxNode[]): Generator<CodeMirror.SyntaxNode> {\n    for (const node of nodes) {\n      if (node.type.name !== 'Comment') {\n        yield node;\n      }\n    }\n  }\n\n  export function split(nodes: CodeMirror.SyntaxNode[]): CodeMirror.SyntaxNode[][] {\n    const result = [];\n    let current = [];\n    for (const node of nodes) {\n      if (node.name === ',') {\n        result.push(current);\n        current = [];\n      } else {\n        current.push(node);\n      }\n    }\n    result.push(current);\n    return result;\n  }\n\n  export function callArgs(node: CodeMirror.SyntaxNode): CodeMirror.SyntaxNode[][] {\n    const args = children(node.getChild('ArgList'));\n    const openParen = args.splice(0, 1)[0];\n    const closingParen = args.pop();\n\n    if (openParen?.name !== '(' || closingParen?.name !== ')') {\n      return [];\n    }\n\n    return split(args);\n  }\n\n  export function equals(a: CodeMirror.SyntaxNode, b: CodeMirror.SyntaxNode): boolean {\n    return a.name === b.name && a.from === b.from && a.to === b.to;\n  }\n}\n\nexport class VariableMatch implements Match {\n  constructor(\n      readonly text: string,\n      readonly node: CodeMirror.SyntaxNode,\n      readonly name: string,\n      readonly fallback: CodeMirror.SyntaxNode[],\n      readonly matching: BottomUpTreeMatching,\n      readonly computedTextCallback: (match: VariableMatch, matching: BottomUpTreeMatching) => string | null,\n  ) {\n  }\n\n  computedText(): string|null {\n    return this.computedTextCallback(this, this.matching);\n  }\n}\n\n// clang-format off\nexport class VariableMatcher extends matcherBase(VariableMatch) {\n  // clang-format on\n  readonly #computedTextCallback: (match: VariableMatch, matching: BottomUpTreeMatching) => string | null;\n  constructor(computedTextCallback: (match: VariableMatch, matching: BottomUpTreeMatching) => string | null) {\n    super();\n    this.#computedTextCallback = computedTextCallback;\n  }\n\n  override matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    const callee = node.getChild('Callee');\n    const args = node.getChild('ArgList');\n    if (node.name !== 'CallExpression' || !callee || (matching.ast.text(callee) !== 'var') || !args) {\n      return null;\n    }\n\n    const [lparenNode, nameNode, ...fallbackOrRParenNodes] = ASTUtils.children(args);\n\n    if (lparenNode?.name !== '(' || nameNode?.name !== 'VariableName') {\n      return null;\n    }\n\n    if (fallbackOrRParenNodes.length <= 1 && fallbackOrRParenNodes[0]?.name !== ')') {\n      return null;\n    }\n\n    let fallback: CodeMirror.SyntaxNode[] = [];\n    if (fallbackOrRParenNodes.length > 1) {\n      if (fallbackOrRParenNodes.shift()?.name !== ',') {\n        return null;\n      }\n      if (fallbackOrRParenNodes.pop()?.name !== ')') {\n        return null;\n      }\n      fallback = fallbackOrRParenNodes;\n      if (fallback.length === 0) {\n        return null;\n      }\n      if (fallback.some(n => n.name === ',')) {\n        return null;\n      }\n    }\n\n    const varName = matching.ast.text(nameNode);\n    if (!varName.startsWith('--')) {\n      return null;\n    }\n\n    return new VariableMatch(matching.ast.text(node), node, varName, fallback, matching, this.#computedTextCallback);\n  }\n}\n\nexport class TextMatch implements Match {\n  computedText?: () => string;\n  constructor(readonly text: string, readonly node: CodeMirror.SyntaxNode) {\n    if (node.name === 'Comment') {\n      this.computedText = () => '';\n    }\n  }\n  render(): Node[] {\n    return [document.createTextNode(this.text)];\n  }\n}\n\n// clang-format off\nclass TextMatcher extends matcherBase(TextMatch) {\n  // clang-format on\n  override accepts(): boolean {\n    return true;\n  }\n  override matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): Match|null {\n    if (!node.firstChild || node.name === 'NumberLiteral' /* may have a Unit child */) {\n      // Leaf node, just emit text\n      const text = matching.ast.text(node);\n      if (text.length) {\n        return new TextMatch(text, node);\n      }\n    }\n    return null;\n  }\n}\n\nfunction declaration(rule: string): CodeMirror.SyntaxNode|null {\n  return cssParser.parse(rule).topNode.getChild('RuleSet')?.getChild('Block')?.getChild('Declaration') ?? null;\n}\n\nexport function tokenizeDeclaration(propertyName: string, propertyValue: string): SyntaxTree|null {\n  const name = tokenizePropertyName(propertyName);\n  if (!name) {\n    return null;\n  }\n  const rule = `*{${name}: ${propertyValue};}`;\n  const decl = declaration(rule);\n  if (!decl || decl.type.isError) {\n    return null;\n  }\n\n  const childNodes = ASTUtils.children(decl);\n  if (childNodes.length < 2) {\n    return null;\n  }\n  const [varName, colon, tree] = childNodes;\n  if (!varName || varName.type.isError || !colon || colon.type.isError || tree?.type.isError) {\n    return null;\n  }\n\n  // It's possible that there are nodes following the declaration when there are comments or syntax errors. We want to\n  // render any comments, so pick up any trailing nodes following the declaration excluding the final semicolon and\n  // brace.\n  const trailingNodes = ASTUtils.siblings(decl).slice(1);\n  const [semicolon, brace] = trailingNodes.splice(trailingNodes.length - 2, 2);\n  if (semicolon?.name !== ';' && brace?.name !== '}') {\n    return null;\n  }\n\n  const ast = new SyntaxTree(propertyValue, rule, decl, name, trailingNodes);\n  if (ast.text(varName) !== name || colon.name !== ':') {\n    return null;\n  }\n  return ast;\n}\n\nexport function tokenizePropertyName(name: string): string|null {\n  const rule = `*{${name}: inherit;}`;\n  const decl = declaration(rule);\n  if (!decl || decl.type.isError) {\n    return null;\n  }\n\n  const propertyName = decl.getChild('PropertyName') ?? decl.getChild('VariableName');\n  if (!propertyName) {\n    return null;\n  }\n\n  return nodeText(propertyName, rule);\n}\n\nexport class TreeSearch extends TreeWalker {\n  #found: CodeMirror.SyntaxNode|null = null;\n  #predicate: (node: CodeMirror.SyntaxNode) => boolean;\n\n  constructor(ast: SyntaxTree, predicate: (node: CodeMirror.SyntaxNode) => boolean) {\n    super(ast);\n    this.#predicate = predicate;\n  }\n\n  protected override enter({node}: SyntaxNodeRef): boolean {\n    if (this.#found) {\n      return false;\n    }\n\n    if (this.#predicate(node)) {\n      this.#found = this.#found ?? node;\n      return false;\n    }\n    return true;\n  }\n\n  static find(ast: SyntaxTree, predicate: (node: CodeMirror.SyntaxNode) => boolean): CodeMirror.SyntaxNode|null {\n    return TreeSearch.walk(ast, predicate).#found;\n  }\n\n  static findAll(ast: SyntaxTree, predicate: (node: CodeMirror.SyntaxNode) => boolean): CodeMirror.SyntaxNode[] {\n    const foundNodes: CodeMirror.SyntaxNode[] = [];\n    TreeSearch.walk(ast, (node: CodeMirror.SyntaxNode) => {\n      if (predicate(node)) {\n        foundNodes.push(node);\n      }\n\n      return false;\n    });\n    return foundNodes;\n  }\n}\n"],
  "mappings": "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",
  "names": ["match", "ASTUtils", "node", "stripComments"]
}
