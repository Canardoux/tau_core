{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/CSSMatchedStyles.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Platform from '../platform/platform.js';\n\nimport {CSSMetadata, cssMetadata, CSSWideKeyword} from './CSSMetadata.js';\nimport type {CSSModel} from './CSSModel.js';\nimport {CSSProperty} from './CSSProperty.js';\nimport * as PropertyParser from './CSSPropertyParser.js';\nimport {\n  CSSFontPaletteValuesRule,\n  CSSKeyframesRule,\n  CSSPositionTryRule,\n  CSSPropertyRule,\n  CSSStyleRule,\n} from './CSSRule.js';\nimport {CSSStyleDeclaration, Type} from './CSSStyleDeclaration.js';\nimport type {DOMNode} from './DOMModel.js';\n\nfunction containsStyle(styles: CSSStyleDeclaration[]|Set<CSSStyleDeclaration>, query: CSSStyleDeclaration): boolean {\n  if (!query.styleSheetId || !query.range) {\n    return false;\n  }\n  for (const style of styles) {\n    if (query.styleSheetId === style.styleSheetId && style.range && query.range.equal(style.range)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction containsCustomProperties(style: CSSStyleDeclaration): boolean {\n  const properties = style.allProperties();\n  return properties.some(property => cssMetadata().isCustomProperty(property.name));\n}\n\nfunction containsInherited(style: CSSStyleDeclaration): boolean {\n  const properties = style.allProperties();\n  for (let i = 0; i < properties.length; ++i) {\n    const property = properties[i];\n    // Does this style contain non-overridden inherited property?\n    if (property.activeInStyle() && cssMetadata().isPropertyInherited(property.name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction cleanUserAgentPayload(payload: Protocol.CSS.RuleMatch[]): Protocol.CSS.RuleMatch[] {\n  for (const ruleMatch of payload) {\n    cleanUserAgentSelectors(ruleMatch);\n  }\n\n  // Merge UA rules that are sequential and have similar selector/media.\n  const cleanMatchedPayload = [];\n  for (const ruleMatch of payload) {\n    const lastMatch = cleanMatchedPayload[cleanMatchedPayload.length - 1];\n    if (!lastMatch || ruleMatch.rule.origin !== 'user-agent' || lastMatch.rule.origin !== 'user-agent' ||\n        ruleMatch.rule.selectorList.text !== lastMatch.rule.selectorList.text ||\n        mediaText(ruleMatch) !== mediaText(lastMatch)) {\n      cleanMatchedPayload.push(ruleMatch);\n      continue;\n    }\n    mergeRule(ruleMatch, lastMatch);\n  }\n  return cleanMatchedPayload;\n\n  function mergeRule(from: Protocol.CSS.RuleMatch, to: Protocol.CSS.RuleMatch): void {\n    const shorthands = (new Map() as Map<string, string>);\n    const properties = (new Map() as Map<string, string>);\n    for (const entry of to.rule.style.shorthandEntries) {\n      shorthands.set(entry.name, entry.value);\n    }\n    for (const entry of to.rule.style.cssProperties) {\n      properties.set(entry.name, entry.value);\n    }\n    for (const entry of from.rule.style.shorthandEntries) {\n      shorthands.set(entry.name, entry.value);\n    }\n    for (const entry of from.rule.style.cssProperties) {\n      properties.set(entry.name, entry.value);\n    }\n    to.rule.style.shorthandEntries = [...shorthands.entries()].map(([name, value]) => ({name, value}));\n    to.rule.style.cssProperties = [...properties.entries()].map(([name, value]) => ({name, value}));\n  }\n\n  function mediaText(ruleMatch: Protocol.CSS.RuleMatch): string|null {\n    if (!ruleMatch.rule.media) {\n      return null;\n    }\n    return ruleMatch.rule.media.map(media => media.text).join(', ');\n  }\n\n  function cleanUserAgentSelectors(ruleMatch: Protocol.CSS.RuleMatch): void {\n    const {matchingSelectors, rule} = ruleMatch;\n    if (rule.origin !== 'user-agent' || !matchingSelectors.length) {\n      return;\n    }\n    rule.selectorList.selectors = rule.selectorList.selectors.filter((item, i) => matchingSelectors.includes(i));\n    rule.selectorList.text = rule.selectorList.selectors.map(item => item.text).join(', ');\n    ruleMatch.matchingSelectors = matchingSelectors.map((item, i) => i);\n  }\n}\n\n/**\n * Return a mapping of the highlight names in the specified RuleMatch to\n * the indices of selectors in that selector list with that highlight name.\n *\n * For example, consider the following ruleset:\n * span::highlight(foo), div, #mySpan::highlight(bar), .highlighted::highlight(foo) {\n *   color: blue;\n * }\n *\n * For a <span id=\"mySpan\" class=\"highlighted\"></span>, a RuleMatch for that span\n * would have matchingSelectors [0, 2, 3] indicating that the span\n * matches all of the highlight selectors.\n *\n * For that RuleMatch, this function would produce the following map:\n * {\n *  \"foo\": [0, 3],\n *  \"bar\": [2]\n * }\n *\n * @param ruleMatch\n * @returns A mapping of highlight names to lists of indices into the selector\n * list associated with ruleMatch. The indices correspond to the selectors in the rule\n * associated with the key's highlight name.\n */\nfunction customHighlightNamesToMatchingSelectorIndices(ruleMatch: Protocol.CSS.RuleMatch): Map<string, number[]> {\n  const highlightNamesToMatchingSelectors = new Map<string, number[]>();\n\n  for (let i = 0; i < ruleMatch.matchingSelectors.length; i++) {\n    const matchingSelectorIndex = ruleMatch.matchingSelectors[i];\n    const selectorText = ruleMatch.rule.selectorList.selectors[matchingSelectorIndex].text;\n    const highlightNameMatch = selectorText.match(/::highlight\\((.*)\\)/);\n    if (highlightNameMatch) {\n      const highlightName = highlightNameMatch[1];\n      const selectorsForName = highlightNamesToMatchingSelectors.get(highlightName);\n      if (selectorsForName) {\n        selectorsForName.push(matchingSelectorIndex);\n      } else {\n        highlightNamesToMatchingSelectors.set(highlightName, [matchingSelectorIndex]);\n      }\n    }\n  }\n  return highlightNamesToMatchingSelectors;\n}\n\nfunction queryMatches(style: CSSStyleDeclaration): boolean {\n  if (!style.parentRule) {\n    return true;\n  }\n  const parentRule = style.parentRule as CSSStyleRule;\n  const queries = [...parentRule.media, ...parentRule.containerQueries, ...parentRule.supports, ...parentRule.scopes];\n  for (const query of queries) {\n    if (!query.active()) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport interface CSSMatchedStylesPayload {\n  cssModel: CSSModel;\n  node: DOMNode;\n  inlinePayload: Protocol.CSS.CSSStyle|null;\n  attributesPayload: Protocol.CSS.CSSStyle|null;\n  matchedPayload: Protocol.CSS.RuleMatch[];\n  pseudoPayload: Protocol.CSS.PseudoElementMatches[];\n  inheritedPayload: Protocol.CSS.InheritedStyleEntry[];\n  inheritedPseudoPayload: Protocol.CSS.InheritedPseudoElementMatches[];\n  animationsPayload: Protocol.CSS.CSSKeyframesRule[];\n  parentLayoutNodeId: Protocol.DOM.NodeId|undefined;\n  positionTryRules: Protocol.CSS.CSSPositionTryRule[];\n  propertyRules: Protocol.CSS.CSSPropertyRule[];\n  cssPropertyRegistrations: Protocol.CSS.CSSPropertyRegistration[];\n  fontPaletteValuesRule: Protocol.CSS.CSSFontPaletteValuesRule|undefined;\n  activePositionFallbackIndex: number;\n}\n\nexport class CSSRegisteredProperty {\n  #registration: Protocol.CSS.CSSPropertyRegistration|CSSPropertyRule;\n  #cssModel: CSSModel;\n  #style: CSSStyleDeclaration|undefined;\n  constructor(cssModel: CSSModel, registration: CSSPropertyRule|Protocol.CSS.CSSPropertyRegistration) {\n    this.#cssModel = cssModel;\n    this.#registration = registration;\n  }\n\n  isAtProperty(): boolean {\n    return this.#registration instanceof CSSPropertyRule;\n  }\n\n  propertyName(): string {\n    return this.#registration instanceof CSSPropertyRule ? this.#registration.propertyName().text :\n                                                           this.#registration.propertyName;\n  }\n\n  initialValue(): string|null {\n    return this.#registration instanceof CSSPropertyRule ? this.#registration.initialValue() :\n                                                           this.#registration.initialValue?.text ?? null;\n  }\n\n  inherits(): boolean {\n    return this.#registration instanceof CSSPropertyRule ? this.#registration.inherits() : this.#registration.inherits;\n  }\n\n  syntax(): string {\n    return this.#registration instanceof CSSPropertyRule ? this.#registration.syntax() :\n                                                           `\"${this.#registration.syntax}\"`;\n  }\n\n  #asCSSProperties(): Protocol.CSS.CSSProperty[] {\n    if (this.#registration instanceof CSSPropertyRule) {\n      return [];\n    }\n    const {inherits, initialValue, syntax} = this.#registration;\n    const properties = [\n      {name: 'inherits', value: `${inherits}`},\n      {name: 'syntax', value: `\"${syntax}\"`},\n    ];\n    if (initialValue !== undefined) {\n      properties.push({name: 'initial-value', value: initialValue.text});\n    }\n    return properties;\n  }\n\n  style(): CSSStyleDeclaration {\n    if (!this.#style) {\n      this.#style = this.#registration instanceof CSSPropertyRule ?\n          this.#registration.style :\n          new CSSStyleDeclaration(\n              this.#cssModel, null, {cssProperties: this.#asCSSProperties(), shorthandEntries: []}, Type.Pseudo);\n    }\n    return this.#style;\n  }\n}\n\nexport class CSSMatchedStyles {\n  #cssModelInternal: CSSModel;\n  #nodeInternal: DOMNode;\n  #addedStyles: Map<CSSStyleDeclaration, DOMNode>;\n  #matchingSelectors: Map<number, Map<string, boolean>>;\n  #keyframesInternal: CSSKeyframesRule[];\n  #registeredProperties: CSSRegisteredProperty[];\n  #registeredPropertyMap = new Map<string, CSSRegisteredProperty>();\n  #nodeForStyleInternal: Map<CSSStyleDeclaration, DOMNode|null>;\n  #inheritedStyles: Set<CSSStyleDeclaration>;\n  #styleToDOMCascade: Map<CSSStyleDeclaration, DOMInheritanceCascade>;\n  #parentLayoutNodeId: Protocol.DOM.NodeId|undefined;\n  #positionTryRules: CSSPositionTryRule[];\n  #activePositionFallbackIndex: number;\n  #mainDOMCascade?: DOMInheritanceCascade;\n  #pseudoDOMCascades?: Map<Protocol.DOM.PseudoType, DOMInheritanceCascade>;\n  #customHighlightPseudoDOMCascades?: Map<string, DOMInheritanceCascade>;\n  readonly #fontPaletteValuesRule: CSSFontPaletteValuesRule|undefined;\n\n  static async create(payload: CSSMatchedStylesPayload): Promise<CSSMatchedStyles> {\n    const cssMatchedStyles = new CSSMatchedStyles(payload);\n    await cssMatchedStyles.init(payload);\n    return cssMatchedStyles;\n  }\n\n  private constructor({\n    cssModel,\n    node,\n    animationsPayload,\n    parentLayoutNodeId,\n    positionTryRules,\n    propertyRules,\n    cssPropertyRegistrations,\n    fontPaletteValuesRule,\n    activePositionFallbackIndex,\n  }: CSSMatchedStylesPayload) {\n    this.#cssModelInternal = cssModel;\n    this.#nodeInternal = node;\n    this.#addedStyles = new Map();\n    this.#matchingSelectors = new Map();\n    this.#registeredProperties = [\n      ...propertyRules.map(rule => new CSSPropertyRule(cssModel, rule)),\n      ...cssPropertyRegistrations,\n    ].map(r => new CSSRegisteredProperty(cssModel, r));\n    this.#keyframesInternal = [];\n    if (animationsPayload) {\n      this.#keyframesInternal = animationsPayload.map(rule => new CSSKeyframesRule(cssModel, rule));\n    }\n    this.#positionTryRules = positionTryRules.map(rule => new CSSPositionTryRule(cssModel, rule));\n    this.#parentLayoutNodeId = parentLayoutNodeId;\n    this.#fontPaletteValuesRule =\n        fontPaletteValuesRule ? new CSSFontPaletteValuesRule(cssModel, fontPaletteValuesRule) : undefined;\n\n    this.#nodeForStyleInternal = new Map();\n    this.#inheritedStyles = new Set();\n    this.#styleToDOMCascade = new Map();\n    this.#registeredPropertyMap = new Map();\n    this.#activePositionFallbackIndex = activePositionFallbackIndex;\n  }\n\n  private async init({\n    matchedPayload,\n    inheritedPayload,\n    inlinePayload,\n    attributesPayload,\n    pseudoPayload,\n    inheritedPseudoPayload,\n  }: CSSMatchedStylesPayload): Promise<void> {\n    matchedPayload = cleanUserAgentPayload(matchedPayload);\n    for (const inheritedResult of inheritedPayload) {\n      inheritedResult.matchedCSSRules = cleanUserAgentPayload(inheritedResult.matchedCSSRules);\n    }\n\n    this.#mainDOMCascade =\n        await this.buildMainCascade(inlinePayload, attributesPayload, matchedPayload, inheritedPayload);\n    [this.#pseudoDOMCascades, this.#customHighlightPseudoDOMCascades] =\n        this.buildPseudoCascades(pseudoPayload, inheritedPseudoPayload);\n\n    for (const domCascade of Array.from(this.#customHighlightPseudoDOMCascades.values())\n             .concat(Array.from(this.#pseudoDOMCascades.values()))\n             .concat(this.#mainDOMCascade)) {\n      for (const style of domCascade.styles()) {\n        this.#styleToDOMCascade.set(style, domCascade);\n      }\n    }\n\n    for (const prop of this.#registeredProperties) {\n      this.#registeredPropertyMap.set(prop.propertyName(), prop);\n    }\n  }\n\n  private async buildMainCascade(\n      inlinePayload: Protocol.CSS.CSSStyle|null, attributesPayload: Protocol.CSS.CSSStyle|null,\n      matchedPayload: Protocol.CSS.RuleMatch[],\n      inheritedPayload: Protocol.CSS.InheritedStyleEntry[]): Promise<DOMInheritanceCascade> {\n    const nodeCascades: NodeCascade[] = [];\n\n    const nodeStyles: CSSStyleDeclaration[] = [];\n\n    function addAttributesStyle(this: CSSMatchedStyles): void {\n      if (!attributesPayload) {\n        return;\n      }\n      const style = new CSSStyleDeclaration(this.#cssModelInternal, null, attributesPayload, Type.Attributes);\n      this.#nodeForStyleInternal.set(style, this.#nodeInternal);\n      nodeStyles.push(style);\n    }\n\n    // Inline style has the greatest specificity.\n    if (inlinePayload && this.#nodeInternal.nodeType() === Node.ELEMENT_NODE) {\n      const style = new CSSStyleDeclaration(this.#cssModelInternal, null, inlinePayload, Type.Inline);\n      this.#nodeForStyleInternal.set(style, this.#nodeInternal);\n      nodeStyles.push(style);\n    }\n\n    // Add rules in reverse order to match the cascade order.\n    let addedAttributesStyle;\n    for (let i = matchedPayload.length - 1; i >= 0; --i) {\n      const rule = new CSSStyleRule(this.#cssModelInternal, matchedPayload[i].rule);\n      if ((rule.isInjected() || rule.isUserAgent()) && !addedAttributesStyle) {\n        // Show element's Style Attributes after all author rules.\n        addedAttributesStyle = true;\n        addAttributesStyle.call(this);\n      }\n      this.#nodeForStyleInternal.set(rule.style, this.#nodeInternal);\n      nodeStyles.push(rule.style);\n      this.addMatchingSelectors(this.#nodeInternal, rule, matchedPayload[i].matchingSelectors);\n    }\n\n    if (!addedAttributesStyle) {\n      addAttributesStyle.call(this);\n    }\n    nodeCascades.push(new NodeCascade(this, nodeStyles, false /* #isInherited */));\n\n    // Walk the node structure and identify styles with inherited properties.\n    let parentNode: (DOMNode|null) = this.#nodeInternal.parentNode;\n    const traverseParentInFlatTree = async(node: DOMNode): Promise<DOMNode|null> => {\n      if (node.hasAssignedSlot()) {\n        return await node.assignedSlot?.deferredNode.resolvePromise() ?? null;\n      }\n\n      return node.parentNode;\n    };\n\n    for (let i = 0; parentNode && inheritedPayload && i < inheritedPayload.length; ++i) {\n      const inheritedStyles = [];\n      const entryPayload = inheritedPayload[i];\n      const inheritedInlineStyle = entryPayload.inlineStyle ?\n          new CSSStyleDeclaration(this.#cssModelInternal, null, entryPayload.inlineStyle, Type.Inline) :\n          null;\n      if (inheritedInlineStyle && containsInherited(inheritedInlineStyle)) {\n        this.#nodeForStyleInternal.set(inheritedInlineStyle, parentNode);\n        inheritedStyles.push(inheritedInlineStyle);\n        this.#inheritedStyles.add(inheritedInlineStyle);\n      }\n\n      const inheritedMatchedCSSRules = entryPayload.matchedCSSRules || [];\n      for (let j = inheritedMatchedCSSRules.length - 1; j >= 0; --j) {\n        const inheritedRule = new CSSStyleRule(this.#cssModelInternal, inheritedMatchedCSSRules[j].rule);\n        this.addMatchingSelectors(parentNode, inheritedRule, inheritedMatchedCSSRules[j].matchingSelectors);\n        if (!containsInherited(inheritedRule.style)) {\n          continue;\n        }\n        if (!containsCustomProperties(inheritedRule.style)) {\n          if (containsStyle(nodeStyles, inheritedRule.style) ||\n              containsStyle(this.#inheritedStyles, inheritedRule.style)) {\n            continue;\n          }\n        }\n        this.#nodeForStyleInternal.set(inheritedRule.style, parentNode);\n        inheritedStyles.push(inheritedRule.style);\n        this.#inheritedStyles.add(inheritedRule.style);\n      }\n      parentNode = await traverseParentInFlatTree(parentNode);\n      nodeCascades.push(new NodeCascade(this, inheritedStyles, true /* #isInherited */));\n    }\n\n    return new DOMInheritanceCascade(nodeCascades, this.#registeredProperties);\n  }\n\n  /**\n   * Pseudo rule matches received via the inspector protocol are grouped by pseudo type.\n   * For custom highlight pseudos, we need to instead group the rule matches by highlight\n   * name in order to produce separate cascades for each highlight name. This is necessary\n   * so that styles of ::highlight(foo) are not shown as overriding styles of ::highlight(bar).\n   *\n   * This helper function takes a list of rule matches and generates separate NodeCascades\n   * for each custom highlight name that was matched.\n   */\n  private buildSplitCustomHighlightCascades(\n      rules: Protocol.CSS.RuleMatch[], node: DOMNode, isInherited: boolean,\n      pseudoCascades: Map<string, NodeCascade[]>): void {\n    const splitHighlightRules = new Map<string, CSSStyleDeclaration[]>();\n\n    for (let j = rules.length - 1; j >= 0; --j) {\n      const highlightNamesToMatchingSelectorIndices = customHighlightNamesToMatchingSelectorIndices(rules[j]);\n\n      for (const [highlightName, matchingSelectors] of highlightNamesToMatchingSelectorIndices) {\n        const pseudoRule = new CSSStyleRule(this.#cssModelInternal, rules[j].rule);\n        this.#nodeForStyleInternal.set(pseudoRule.style, node);\n        if (isInherited) {\n          this.#inheritedStyles.add(pseudoRule.style);\n        }\n        this.addMatchingSelectors(node, pseudoRule, matchingSelectors);\n\n        const ruleListForHighlightName = splitHighlightRules.get(highlightName);\n        if (ruleListForHighlightName) {\n          ruleListForHighlightName.push(pseudoRule.style);\n        } else {\n          splitHighlightRules.set(highlightName, [pseudoRule.style]);\n        }\n      }\n    }\n\n    for (const [highlightName, highlightStyles] of splitHighlightRules) {\n      const nodeCascade = new NodeCascade(this, highlightStyles, isInherited, true /* #isHighlightPseudoCascade*/);\n      const cascadeListForHighlightName = pseudoCascades.get(highlightName);\n      if (cascadeListForHighlightName) {\n        cascadeListForHighlightName.push(nodeCascade);\n      } else {\n        pseudoCascades.set(highlightName, [nodeCascade]);\n      }\n    }\n  }\n\n  private buildPseudoCascades(\n      pseudoPayload: Protocol.CSS.PseudoElementMatches[],\n      inheritedPseudoPayload: Protocol.CSS.InheritedPseudoElementMatches[]):\n      [Map<Protocol.DOM.PseudoType, DOMInheritanceCascade>, Map<string, DOMInheritanceCascade>] {\n    const pseudoInheritanceCascades = new Map<Protocol.DOM.PseudoType, DOMInheritanceCascade>();\n    const customHighlightPseudoInheritanceCascades = new Map<string, DOMInheritanceCascade>();\n    if (!pseudoPayload) {\n      return [pseudoInheritanceCascades, customHighlightPseudoInheritanceCascades];\n    }\n\n    const pseudoCascades = new Map<Protocol.DOM.PseudoType, NodeCascade[]>();\n    const customHighlightPseudoCascades = new Map<string, NodeCascade[]>();\n    for (let i = 0; i < pseudoPayload.length; ++i) {\n      const entryPayload = pseudoPayload[i];\n      // PseudoElement nodes are not created unless \"content\" css property is set.\n      const pseudoElement = this.#nodeInternal.pseudoElements().get(entryPayload.pseudoType)?.at(-1) || null;\n      const pseudoStyles = [];\n      const rules = entryPayload.matches || [];\n\n      if (entryPayload.pseudoType === Protocol.DOM.PseudoType.Highlight) {\n        this.buildSplitCustomHighlightCascades(\n            rules, this.#nodeInternal, false /* #isInherited */, customHighlightPseudoCascades);\n      } else {\n        for (let j = rules.length - 1; j >= 0; --j) {\n          const pseudoRule = new CSSStyleRule(this.#cssModelInternal, rules[j].rule);\n          pseudoStyles.push(pseudoRule.style);\n          const nodeForStyle =\n              cssMetadata().isHighlightPseudoType(entryPayload.pseudoType) ? this.#nodeInternal : pseudoElement;\n          this.#nodeForStyleInternal.set(pseudoRule.style, nodeForStyle);\n          if (nodeForStyle) {\n            this.addMatchingSelectors(nodeForStyle, pseudoRule, rules[j].matchingSelectors);\n          }\n        }\n        const isHighlightPseudoCascade = cssMetadata().isHighlightPseudoType(entryPayload.pseudoType);\n        const nodeCascade = new NodeCascade(\n            this, pseudoStyles, false /* #isInherited */, isHighlightPseudoCascade /* #isHighlightPseudoCascade*/);\n        pseudoCascades.set(entryPayload.pseudoType, [nodeCascade]);\n      }\n    }\n\n    if (inheritedPseudoPayload) {\n      let parentNode: (DOMNode|null) = this.#nodeInternal.parentNode;\n      for (let i = 0; parentNode && i < inheritedPseudoPayload.length; ++i) {\n        const inheritedPseudoMatches = inheritedPseudoPayload[i].pseudoElements;\n        for (let j = 0; j < inheritedPseudoMatches.length; ++j) {\n          const inheritedEntryPayload = inheritedPseudoMatches[j];\n          const rules = inheritedEntryPayload.matches || [];\n\n          if (inheritedEntryPayload.pseudoType === Protocol.DOM.PseudoType.Highlight) {\n            this.buildSplitCustomHighlightCascades(\n                rules, parentNode, true /* #isInherited */, customHighlightPseudoCascades);\n          } else {\n            const pseudoStyles = [];\n            for (let k = rules.length - 1; k >= 0; --k) {\n              const pseudoRule = new CSSStyleRule(this.#cssModelInternal, rules[k].rule);\n              pseudoStyles.push(pseudoRule.style);\n              this.#nodeForStyleInternal.set(pseudoRule.style, parentNode);\n              this.#inheritedStyles.add(pseudoRule.style);\n              this.addMatchingSelectors(parentNode, pseudoRule, rules[k].matchingSelectors);\n            }\n\n            const isHighlightPseudoCascade = cssMetadata().isHighlightPseudoType(inheritedEntryPayload.pseudoType);\n            const nodeCascade = new NodeCascade(\n                this, pseudoStyles, true /* #isInherited */, isHighlightPseudoCascade /* #isHighlightPseudoCascade*/);\n            const cascadeListForPseudoType = pseudoCascades.get(inheritedEntryPayload.pseudoType);\n            if (cascadeListForPseudoType) {\n              cascadeListForPseudoType.push(nodeCascade);\n            } else {\n              pseudoCascades.set(inheritedEntryPayload.pseudoType, [nodeCascade]);\n            }\n          }\n        }\n\n        parentNode = parentNode.parentNode;\n      }\n    }\n\n    // Now that we've built the arrays of NodeCascades for each pseudo type, convert them into\n    // DOMInheritanceCascades.\n    for (const [pseudoType, nodeCascade] of pseudoCascades.entries()) {\n      pseudoInheritanceCascades.set(pseudoType, new DOMInheritanceCascade(nodeCascade, this.#registeredProperties));\n    }\n\n    for (const [highlightName, nodeCascade] of customHighlightPseudoCascades.entries()) {\n      customHighlightPseudoInheritanceCascades.set(\n          highlightName, new DOMInheritanceCascade(nodeCascade, this.#registeredProperties));\n    }\n\n    return [pseudoInheritanceCascades, customHighlightPseudoInheritanceCascades];\n  }\n\n  private addMatchingSelectors(\n      this: CSSMatchedStyles, node: DOMNode, rule: CSSStyleRule, matchingSelectorIndices: number[]): void {\n    for (const matchingSelectorIndex of matchingSelectorIndices) {\n      const selector = rule.selectors[matchingSelectorIndex];\n      if (selector) {\n        this.setSelectorMatches(node, selector.text, true);\n      }\n    }\n  }\n\n  node(): DOMNode {\n    return this.#nodeInternal;\n  }\n\n  cssModel(): CSSModel {\n    return this.#cssModelInternal;\n  }\n\n  hasMatchingSelectors(rule: CSSStyleRule): boolean {\n    return (rule.selectors.length === 0 || this.getMatchingSelectors(rule).length > 0) && queryMatches(rule.style);\n  }\n\n  getParentLayoutNodeId(): Protocol.DOM.NodeId|undefined {\n    return this.#parentLayoutNodeId;\n  }\n\n  getMatchingSelectors(rule: CSSStyleRule): number[] {\n    const node = this.nodeForStyle(rule.style);\n    if (!node || typeof node.id !== 'number') {\n      return [];\n    }\n    const map = this.#matchingSelectors.get(node.id);\n    if (!map) {\n      return [];\n    }\n    const result = [];\n    for (let i = 0; i < rule.selectors.length; ++i) {\n      if (map.get(rule.selectors[i].text)) {\n        result.push(i);\n      }\n    }\n    return result;\n  }\n\n  async recomputeMatchingSelectors(rule: CSSStyleRule): Promise<void> {\n    const node = this.nodeForStyle(rule.style);\n    if (!node) {\n      return;\n    }\n    const promises = [];\n    for (const selector of rule.selectors) {\n      promises.push(querySelector.call(this, node, selector.text));\n    }\n    await Promise.all(promises);\n\n    async function querySelector(this: CSSMatchedStyles, node: DOMNode, selectorText: string): Promise<void> {\n      const ownerDocument = node.ownerDocument;\n      if (!ownerDocument) {\n        return;\n      }\n      // We assume that \"matching\" property does not ever change during the\n      // MatchedStyleResult's lifetime.\n      if (typeof node.id === 'number') {\n        const map = this.#matchingSelectors.get(node.id);\n        if (map && map.has(selectorText)) {\n          return;\n        }\n      }\n\n      if (typeof ownerDocument.id !== 'number') {\n        return;\n      }\n      const matchingNodeIds = await this.#nodeInternal.domModel().querySelectorAll(ownerDocument.id, selectorText);\n\n      if (matchingNodeIds) {\n        if (typeof node.id === 'number') {\n          this.setSelectorMatches(node, selectorText, matchingNodeIds.indexOf(node.id) !== -1);\n        } else {\n          this.setSelectorMatches(node, selectorText, false);\n        }\n      }\n    }\n  }\n\n  addNewRule(rule: CSSStyleRule, node: DOMNode): Promise<void> {\n    this.#addedStyles.set(rule.style, node);\n    return this.recomputeMatchingSelectors(rule);\n  }\n\n  private setSelectorMatches(node: DOMNode, selectorText: string, value: boolean): void {\n    if (typeof node.id !== 'number') {\n      return;\n    }\n    let map = this.#matchingSelectors.get(node.id);\n    if (!map) {\n      map = new Map();\n      this.#matchingSelectors.set(node.id, map);\n    }\n    map.set(selectorText, value);\n  }\n\n  nodeStyles(): CSSStyleDeclaration[] {\n    Platform.assertNotNullOrUndefined(this.#mainDOMCascade);\n    return this.#mainDOMCascade.styles();\n  }\n\n  registeredProperties(): CSSRegisteredProperty[] {\n    return this.#registeredProperties;\n  }\n\n  getRegisteredProperty(name: string): CSSRegisteredProperty|undefined {\n    return this.#registeredPropertyMap.get(name);\n  }\n\n  fontPaletteValuesRule(): CSSFontPaletteValuesRule|undefined {\n    return this.#fontPaletteValuesRule;\n  }\n\n  keyframes(): CSSKeyframesRule[] {\n    return this.#keyframesInternal;\n  }\n\n  positionTryRules(): CSSPositionTryRule[] {\n    return this.#positionTryRules;\n  }\n\n  activePositionFallbackIndex(): number {\n    return this.#activePositionFallbackIndex;\n  }\n\n  pseudoStyles(pseudoType: Protocol.DOM.PseudoType): CSSStyleDeclaration[] {\n    Platform.assertNotNullOrUndefined(this.#pseudoDOMCascades);\n    const domCascade = this.#pseudoDOMCascades.get(pseudoType);\n    return domCascade ? domCascade.styles() : [];\n  }\n\n  pseudoTypes(): Set<Protocol.DOM.PseudoType> {\n    Platform.assertNotNullOrUndefined(this.#pseudoDOMCascades);\n    return new Set(this.#pseudoDOMCascades.keys());\n  }\n\n  customHighlightPseudoStyles(highlightName: string): CSSStyleDeclaration[] {\n    Platform.assertNotNullOrUndefined(this.#customHighlightPseudoDOMCascades);\n    const domCascade = this.#customHighlightPseudoDOMCascades.get(highlightName);\n    return domCascade ? domCascade.styles() : [];\n  }\n\n  customHighlightPseudoNames(): Set<string> {\n    Platform.assertNotNullOrUndefined(this.#customHighlightPseudoDOMCascades);\n    return new Set(this.#customHighlightPseudoDOMCascades.keys());\n  }\n\n  nodeForStyle(style: CSSStyleDeclaration): DOMNode|null {\n    return this.#addedStyles.get(style) || this.#nodeForStyleInternal.get(style) || null;\n  }\n\n  availableCSSVariables(style: CSSStyleDeclaration): string[] {\n    const domCascade = this.#styleToDOMCascade.get(style);\n    return domCascade ? domCascade.findAvailableCSSVariables(style) : [];\n  }\n\n  computeCSSVariable(style: CSSStyleDeclaration, variableName: string): CSSVariableValue|null {\n    const domCascade = this.#styleToDOMCascade.get(style);\n    return domCascade ? domCascade.computeCSSVariable(style, variableName) : null;\n  }\n\n  resolveGlobalKeyword(property: CSSProperty, keyword: CSSWideKeyword): CSSValueSource|null {\n    const resolved = this.#styleToDOMCascade.get(property.ownerStyle)?.resolveGlobalKeyword(property, keyword);\n    return resolved ? new CSSValueSource(resolved) : null;\n  }\n\n  isInherited(style: CSSStyleDeclaration): boolean {\n    return this.#inheritedStyles.has(style);\n  }\n\n  propertyState(property: CSSProperty): PropertyState|null {\n    const domCascade = this.#styleToDOMCascade.get(property.ownerStyle);\n    return domCascade ? domCascade.propertyState(property) : null;\n  }\n\n  resetActiveProperties(): void {\n    Platform.assertNotNullOrUndefined(this.#mainDOMCascade);\n    Platform.assertNotNullOrUndefined(this.#pseudoDOMCascades);\n    Platform.assertNotNullOrUndefined(this.#customHighlightPseudoDOMCascades);\n    this.#mainDOMCascade.reset();\n    for (const domCascade of this.#pseudoDOMCascades.values()) {\n      domCascade.reset();\n    }\n\n    for (const domCascade of this.#customHighlightPseudoDOMCascades.values()) {\n      domCascade.reset();\n    }\n  }\n}\n\nclass NodeCascade {\n  #matchedStyles: CSSMatchedStyles;\n  readonly styles: CSSStyleDeclaration[];\n  readonly #isInherited: boolean;\n  readonly #isHighlightPseudoCascade: boolean;\n  readonly propertiesState: Map<CSSProperty, PropertyState>;\n  readonly activeProperties: Map<string, CSSProperty>;\n  constructor(\n      matchedStyles: CSSMatchedStyles, styles: CSSStyleDeclaration[], isInherited: boolean,\n      isHighlightPseudoCascade: boolean = false) {\n    this.#matchedStyles = matchedStyles;\n    this.styles = styles;\n    this.#isInherited = isInherited;\n    this.#isHighlightPseudoCascade = isHighlightPseudoCascade;\n    this.propertiesState = new Map();\n    this.activeProperties = new Map();\n  }\n\n  computeActiveProperties(): void {\n    this.propertiesState.clear();\n    this.activeProperties.clear();\n\n    for (let i = this.styles.length - 1; i >= 0; i--) {\n      const style = this.styles[i];\n      const rule = style.parentRule;\n      // Compute cascade for CSSStyleRules only.\n      if (rule && !(rule instanceof CSSStyleRule)) {\n        continue;\n      }\n      if (rule && !this.#matchedStyles.hasMatchingSelectors(rule)) {\n        continue;\n      }\n\n      for (const property of style.allProperties()) {\n        // Do not pick non-inherited properties from inherited styles.\n        const metadata = cssMetadata();\n\n        // All properties are inherited for highlight pseudos.\n        if (this.#isInherited && !this.#isHighlightPseudoCascade && !metadata.isPropertyInherited(property.name)) {\n          continue;\n        }\n\n        // When a property does not have a range in an otherwise ranged CSSStyleDeclaration,\n        // we consider it as a non-leading property (see computeLeadingProperties()), and most\n        // of them are computed longhands. We exclude these from activeProperties calculation,\n        // and use parsed longhands instead (see below).\n        if (style.range && !property.range) {\n          continue;\n        }\n\n        if (!property.activeInStyle()) {\n          this.propertiesState.set(property, PropertyState.OVERLOADED);\n          continue;\n        }\n\n        // If the custom property was registered with `inherits: false;`, inherited properties are invalid.\n        if (this.#isInherited) {\n          const registration = this.#matchedStyles.getRegisteredProperty(property.name);\n          if (registration && !registration.inherits()) {\n            this.propertiesState.set(property, PropertyState.OVERLOADED);\n            continue;\n          }\n        }\n\n        const canonicalName = metadata.canonicalPropertyName(property.name);\n        this.updatePropertyState(property, canonicalName);\n        for (const longhand of property.getLonghandProperties()) {\n          if (metadata.isCSSPropertyName(longhand.name)) {\n            this.updatePropertyState(longhand, longhand.name);\n          }\n        }\n      }\n    }\n  }\n\n  private updatePropertyState(propertyWithHigherSpecificity: CSSProperty, canonicalName: string): void {\n    const activeProperty = this.activeProperties.get(canonicalName);\n    if (activeProperty?.important && !propertyWithHigherSpecificity.important) {\n      this.propertiesState.set(propertyWithHigherSpecificity, PropertyState.OVERLOADED);\n      return;\n    }\n\n    if (activeProperty) {\n      this.propertiesState.set(activeProperty, PropertyState.OVERLOADED);\n    }\n    this.propertiesState.set(propertyWithHigherSpecificity, PropertyState.ACTIVE);\n    this.activeProperties.set(canonicalName, propertyWithHigherSpecificity);\n  }\n}\n\nfunction isRegular(declaration: CSSProperty|CSSRegisteredProperty): declaration is CSSProperty {\n  return 'ownerStyle' in declaration;\n}\nexport class CSSValueSource {\n  readonly declaration: CSSProperty|CSSRegisteredProperty;\n  constructor(declaration: CSSProperty|CSSRegisteredProperty) {\n    this.declaration = declaration;\n  }\n\n  get value(): string|null {\n    return isRegular(this.declaration) ? this.declaration.value : this.declaration.initialValue();\n  }\n  get style(): CSSStyleDeclaration {\n    return isRegular(this.declaration) ? this.declaration.ownerStyle : this.declaration.style();\n  }\n  get name(): string {\n    return isRegular(this.declaration) ? this.declaration.name : this.declaration.propertyName();\n  }\n}\n\nexport interface CSSVariableValue {\n  value: string;\n  declaration: CSSValueSource;\n}\n\nclass SCCRecordEntry {\n  private rootDiscoveryTime: number;\n  get isRootEntry(): boolean {\n    return this.rootDiscoveryTime === this.discoveryTime;\n  }\n  updateRoot(neighbor: SCCRecordEntry): void {\n    this.rootDiscoveryTime = Math.min(this.rootDiscoveryTime, neighbor.rootDiscoveryTime);\n  }\n  constructor(readonly nodeCascade: NodeCascade, readonly name: string, private readonly discoveryTime: number) {\n    this.rootDiscoveryTime = discoveryTime;\n  }\n}\n\nclass SCCRecord {\n  #time = 0;\n  #stack: SCCRecordEntry[] = [];\n  #entries = new Map<NodeCascade, Map<string, SCCRecordEntry>>();\n\n  get(nodeCascade: NodeCascade, variable: string): SCCRecordEntry|undefined {\n    return this.#entries.get(nodeCascade)?.get(variable);\n  }\n\n  add(nodeCascade: NodeCascade, variable: string): SCCRecordEntry {\n    const existing = this.get(nodeCascade, variable);\n    if (existing) {\n      return existing;\n    }\n    const entry = new SCCRecordEntry(nodeCascade, variable, this.#time++);\n    this.#stack.push(entry);\n    let map = this.#entries.get(nodeCascade);\n    if (!map) {\n      map = new Map();\n      this.#entries.set(nodeCascade, map);\n    }\n    map.set(variable, entry);\n    return entry;\n  }\n\n  isInInProgressSCC(childRecord: SCCRecordEntry): boolean {\n    return this.#stack.includes(childRecord);\n  }\n\n  finishSCC(root: SCCRecordEntry): SCCRecordEntry[] {\n    const startIndex = this.#stack.lastIndexOf(root);\n    console.assert(startIndex >= 0, 'Root is not an in-progress scc');\n    return this.#stack.splice(startIndex);\n  }\n}\n\nfunction* forEach<T>(array: T[], startAfter?: T): Generator<T> {\n  const startIdx = startAfter !== undefined ? array.indexOf(startAfter) + 1 : 0;\n  for (let i = startIdx; i < array.length; ++i) {\n    yield array[i];\n  }\n}\n\nclass DOMInheritanceCascade {\n  readonly #nodeCascades: NodeCascade[];\n  readonly #propertiesState: Map<CSSProperty, PropertyState>;\n  readonly #availableCSSVariables: Map<NodeCascade, Map<string, CSSVariableValue|null>>;\n  readonly #computedCSSVariables: Map<NodeCascade, Map<string, CSSVariableValue|null>>;\n  #initialized: boolean;\n  readonly #styleToNodeCascade: Map<CSSStyleDeclaration, NodeCascade>;\n  #registeredProperties: CSSRegisteredProperty[];\n  constructor(nodeCascades: NodeCascade[], registeredProperties: CSSRegisteredProperty[]) {\n    this.#nodeCascades = nodeCascades;\n    this.#propertiesState = new Map();\n    this.#availableCSSVariables = new Map();\n    this.#computedCSSVariables = new Map();\n    this.#initialized = false;\n    this.#registeredProperties = registeredProperties;\n\n    this.#styleToNodeCascade = new Map();\n    for (const nodeCascade of nodeCascades) {\n      for (const style of nodeCascade.styles) {\n        this.#styleToNodeCascade.set(style, nodeCascade);\n      }\n    }\n  }\n\n  findAvailableCSSVariables(style: CSSStyleDeclaration): string[] {\n    const nodeCascade = this.#styleToNodeCascade.get(style);\n    if (!nodeCascade) {\n      return [];\n    }\n    this.ensureInitialized();\n    const availableCSSVariables = this.#availableCSSVariables.get(nodeCascade);\n    if (!availableCSSVariables) {\n      return [];\n    }\n    return Array.from(availableCSSVariables.keys());\n  }\n\n  #findPropertyInPreviousStyle(property: CSSProperty, filter: (property: CSSProperty) => boolean): CSSProperty|null {\n    const cascade = this.#styleToNodeCascade.get(property.ownerStyle);\n    if (!cascade) {\n      return null;\n    }\n\n    for (const style of forEach(cascade.styles, property.ownerStyle)) {\n      const candidate =\n          style.allProperties().findLast(candidate => candidate.name === property.name && filter(candidate));\n      if (candidate) {\n        return candidate;\n      }\n    }\n    return null;\n  }\n\n  #findPropertyInParentCascade(property: CSSProperty): CSSProperty|null {\n    const nodeCascade = this.#styleToNodeCascade.get(property.ownerStyle);\n    if (!nodeCascade) {\n      return null;\n    }\n    for (const cascade of forEach(this.#nodeCascades, nodeCascade)) {\n      for (const style of cascade.styles) {\n        const inheritedProperty =\n            style.allProperties().findLast(inheritedProperty => inheritedProperty.name === property.name);\n        if (inheritedProperty) {\n          return inheritedProperty;\n        }\n      }\n    }\n    return null;\n  }\n\n  #findPropertyInParentCascadeIfInherited(property: CSSProperty): CSSProperty|null {\n    if (!cssMetadata().isPropertyInherited(property.name) ||\n        !(this.#findCustomPropertyRegistration(property)?.inherits() ?? true)) {\n      return null;\n    }\n    return this.#findPropertyInParentCascade(property);\n  }\n\n  #findCustomPropertyRegistration(property: CSSProperty): CSSRegisteredProperty|null {\n    const registration = this.#registeredProperties.find(registration => registration.propertyName() === property.name);\n    return registration ? registration : null;\n  }\n\n  resolveGlobalKeyword(property: CSSProperty, keyword: CSSWideKeyword): null|CSSProperty|CSSRegisteredProperty {\n    const isPreviousLayer = (other: CSSProperty): boolean => {\n      // If there's no parent rule on then it isn't layered and is thus not in a previous one.\n      if (!(other.ownerStyle.parentRule instanceof CSSStyleRule)) {\n        return false;\n      }\n      // Element-attached style -> author origin counts as a previous layer transition for revert-layer.\n      if (property.ownerStyle.type === Type.Inline) {\n        return true;\n      }\n      // Compare layers\n      if (property.ownerStyle.parentRule instanceof CSSStyleRule &&\n          other.ownerStyle.parentRule?.origin === Protocol.CSS.StyleSheetOrigin.Regular) {\n        return JSON.stringify(other.ownerStyle.parentRule.layers) !==\n            JSON.stringify(property.ownerStyle.parentRule.layers);\n      }\n      return false;\n    };\n\n    switch (keyword) {\n      case CSSWideKeyword.INITIAL:\n        return this.#findCustomPropertyRegistration(property);\n      case CSSWideKeyword.INHERIT:\n        return this.#findPropertyInParentCascade(property) ?? this.#findCustomPropertyRegistration(property);\n      case CSSWideKeyword.REVERT:\n        return this.#findPropertyInPreviousStyle(\n                   property,\n                   other => other.ownerStyle.parentRule !== null &&\n                       other.ownerStyle.parentRule.origin !==\n                           (property.ownerStyle.parentRule?.origin ?? Protocol.CSS.StyleSheetOrigin.Regular)) ??\n            this.resolveGlobalKeyword(property, CSSWideKeyword.UNSET);\n      case CSSWideKeyword.REVERT_LAYER:\n        return this.#findPropertyInPreviousStyle(property, isPreviousLayer) ??\n            this.resolveGlobalKeyword(property, CSSWideKeyword.REVERT);\n      case CSSWideKeyword.UNSET:\n        return this.#findPropertyInParentCascadeIfInherited(property) ?? this.#findCustomPropertyRegistration(property);\n    }\n  }\n\n  computeCSSVariable(style: CSSStyleDeclaration, variableName: string): CSSVariableValue|null {\n    const nodeCascade = this.#styleToNodeCascade.get(style);\n    if (!nodeCascade) {\n      return null;\n    }\n    this.ensureInitialized();\n    return this.innerComputeCSSVariable(nodeCascade, variableName);\n  }\n\n  private innerComputeCSSVariable(nodeCascade: NodeCascade, variableName: string, sccRecord = new SCCRecord()):\n      CSSVariableValue|null {\n    const availableCSSVariables = this.#availableCSSVariables.get(nodeCascade);\n    const computedCSSVariables = this.#computedCSSVariables.get(nodeCascade);\n    if (!computedCSSVariables || !availableCSSVariables?.has(variableName)) {\n      return null;\n    }\n\n    if (computedCSSVariables?.has(variableName)) {\n      return computedCSSVariables.get(variableName) || null;\n    }\n\n    let definedValue = availableCSSVariables.get(variableName);\n    if (definedValue === undefined || definedValue === null) {\n      return null;\n    }\n\n    if (definedValue.declaration.declaration instanceof CSSProperty && definedValue.declaration.value &&\n        CSSMetadata.isCSSWideKeyword(definedValue.declaration.value)) {\n      const resolvedProperty =\n          this.resolveGlobalKeyword(definedValue.declaration.declaration, definedValue.declaration.value);\n      if (!resolvedProperty) {\n        return definedValue;\n      }\n      const declaration = new CSSValueSource(resolvedProperty);\n      const {value} = declaration;\n      if (!value) {\n        return definedValue;\n      }\n      definedValue = {declaration, value};\n    }\n\n    const ast = PropertyParser.tokenizeDeclaration(`--${variableName}`, definedValue.value);\n    if (!ast) {\n      return null;\n    }\n\n    // While computing CSS variable values we need to detect declaration cycles. Every declaration on the cycle is\n    // invalid. However, var()s outside of the cycle that reference a property on the cycle are not automatically\n    // invalid, but rather use the fallback value. We use a version of Tarjan's algorithm to detect cycles, which are\n    // SCCs on the custom property dependency graph. Computing variable values is DFS. When encountering a previously\n    // unseen variable, we record its discovery time. We keep a stack of visited variables and detect cycles when we\n    // find a reference to a variable already on the stack. For each node we also keep track of the \"root\" of the\n    // corresponding SCC, which is the node in that component with the smallest discovery time. This is determined by\n    // bubbling up the minimum discovery time whenever we close a cycle.\n    const record = sccRecord.add(nodeCascade, variableName);\n\n    const matching = PropertyParser.BottomUpTreeMatching.walk(\n        ast, [new PropertyParser.VariableMatcher((match: PropertyParser.VariableMatch) => {\n          const parentStyle = definedValue.declaration.style;\n          const nodeCascade = this.#styleToNodeCascade.get(parentStyle);\n          if (!nodeCascade) {\n            return null;\n          }\n          const childRecord = sccRecord.get(nodeCascade, match.name);\n          if (childRecord) {\n            if (sccRecord.isInInProgressSCC(childRecord)) {\n              // Cycle detected, update the root.\n              record.updateRoot(childRecord);\n              return null;\n            }\n\n            // We've seen the variable before, so we can look up the text directly.\n            return this.#computedCSSVariables.get(nodeCascade)?.get(match.name)?.value ?? null;\n          }\n\n          const cssVariableValue = this.innerComputeCSSVariable(nodeCascade, match.name, sccRecord);\n          // Variable reference is resolved, so return it.\n          const newChildRecord = sccRecord.get(nodeCascade, match.name);\n          // The SCC record for the referenced variable may not exist if the var was already computed in a previous\n          // iteration. That means it's in a different SCC.\n          newChildRecord && record.updateRoot(newChildRecord);\n          if (cssVariableValue?.value !== undefined) {\n            return cssVariableValue.value;\n          }\n\n          // Variable reference is not resolved, use the fallback.\n          if (match.fallback.length === 0 ||\n              match.matching.hasUnresolvedVarsRange(match.fallback[0], match.fallback[match.fallback.length - 1])) {\n            return null;\n          }\n          return match.matching.getComputedTextRange(match.fallback[0], match.fallback[match.fallback.length - 1]);\n        })]);\n\n    const decl = PropertyParser.ASTUtils.siblings(PropertyParser.ASTUtils.declValue(matching.ast.tree));\n    const computedText = decl.length > 0 ? matching.getComputedTextRange(decl[0], decl[decl.length - 1]) : '';\n\n    if (record.isRootEntry) {\n      // Variables are kept on the stack until all descendents in the same SCC have been visited. That's the case when\n      // completing the recursion on the root of the SCC.\n      const scc = sccRecord.finishSCC(record);\n      if (scc.length > 1) {\n        for (const entry of scc) {\n          console.assert(entry.nodeCascade === nodeCascade, 'Circles should be within the cascade');\n          computedCSSVariables.set(entry.name, null);\n        }\n        return null;\n      }\n    }\n    if (decl.length > 0 && matching.hasUnresolvedVarsRange(decl[0], decl[decl.length - 1])) {\n      computedCSSVariables.set(variableName, null);\n      return null;\n    }\n\n    const cssVariableValue = {value: computedText, declaration: definedValue.declaration};\n    computedCSSVariables.set(variableName, cssVariableValue);\n    return cssVariableValue;\n  }\n\n  styles(): CSSStyleDeclaration[] {\n    return Array.from(this.#styleToNodeCascade.keys());\n  }\n\n  propertyState(property: CSSProperty): PropertyState|null {\n    this.ensureInitialized();\n    return this.#propertiesState.get(property) || null;\n  }\n\n  reset(): void {\n    this.#initialized = false;\n    this.#propertiesState.clear();\n    this.#availableCSSVariables.clear();\n    this.#computedCSSVariables.clear();\n  }\n\n  private ensureInitialized(): void {\n    if (this.#initialized) {\n      return;\n    }\n    this.#initialized = true;\n\n    const activeProperties = new Map<string, CSSProperty>();\n    for (const nodeCascade of this.#nodeCascades) {\n      nodeCascade.computeActiveProperties();\n      for (const [property, state] of nodeCascade.propertiesState) {\n        if (state === PropertyState.OVERLOADED) {\n          this.#propertiesState.set(property, PropertyState.OVERLOADED);\n          continue;\n        }\n        const canonicalName = cssMetadata().canonicalPropertyName(property.name);\n        if (activeProperties.has(canonicalName)) {\n          this.#propertiesState.set(property, PropertyState.OVERLOADED);\n          continue;\n        }\n        activeProperties.set(canonicalName, property);\n        this.#propertiesState.set(property, PropertyState.ACTIVE);\n      }\n    }\n    // If every longhand of the shorthand is not active, then the shorthand is not active too.\n    for (const [canonicalName, shorthandProperty] of activeProperties) {\n      const shorthandStyle = shorthandProperty.ownerStyle;\n      const longhands = shorthandProperty.getLonghandProperties();\n      if (!longhands.length) {\n        continue;\n      }\n      let hasActiveLonghands = false;\n      for (const longhand of longhands) {\n        const longhandCanonicalName = cssMetadata().canonicalPropertyName(longhand.name);\n        const longhandActiveProperty = activeProperties.get(longhandCanonicalName);\n        if (!longhandActiveProperty) {\n          continue;\n        }\n        if (longhandActiveProperty.ownerStyle === shorthandStyle) {\n          hasActiveLonghands = true;\n          break;\n        }\n      }\n      if (hasActiveLonghands) {\n        continue;\n      }\n      activeProperties.delete(canonicalName);\n      this.#propertiesState.set(shorthandProperty, PropertyState.OVERLOADED);\n    }\n\n    // Work inheritance chain backwards to compute visible CSS Variables.\n    const accumulatedCSSVariables = new Map<string, CSSVariableValue|null>();\n    for (const rule of this.#registeredProperties) {\n      const initialValue = rule.initialValue();\n      accumulatedCSSVariables.set(\n          rule.propertyName(),\n          initialValue !== null ? {value: initialValue, declaration: new CSSValueSource(rule)} : null);\n    }\n    for (let i = this.#nodeCascades.length - 1; i >= 0; --i) {\n      const nodeCascade = this.#nodeCascades[i];\n      const variableNames = [];\n      for (const entry of nodeCascade.activeProperties.entries()) {\n        const propertyName = (entry[0] as string);\n        const property = (entry[1] as CSSProperty);\n        if (propertyName.startsWith('--')) {\n          accumulatedCSSVariables.set(propertyName, {value: property.value, declaration: new CSSValueSource(property)});\n          variableNames.push(propertyName);\n        }\n      }\n      const availableCSSVariablesMap = new Map(accumulatedCSSVariables);\n      const computedVariablesMap = new Map();\n      this.#availableCSSVariables.set(nodeCascade, availableCSSVariablesMap);\n      this.#computedCSSVariables.set(nodeCascade, computedVariablesMap);\n      for (const variableName of variableNames) {\n        const prevValue = accumulatedCSSVariables.get(variableName);\n        accumulatedCSSVariables.delete(variableName);\n        const computedValue = this.innerComputeCSSVariable(nodeCascade, variableName);\n        if (prevValue && computedValue?.value === prevValue.value) {\n          computedValue.declaration = prevValue.declaration;\n        }\n        accumulatedCSSVariables.set(variableName, computedValue);\n      }\n    }\n  }\n}\n\nexport const enum PropertyState {\n  ACTIVE = 'Active',\n  OVERLOADED = 'Overloaded',\n}\n"],
  "mappings": "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",
  "names": ["node", "candidate", "inheritedProperty", "registration", "nodeCascade", "cssVariableValue", "PropertyState"]
}
