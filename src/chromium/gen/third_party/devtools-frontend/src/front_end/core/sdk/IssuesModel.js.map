{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/IssuesModel.ts"],
  "sourcesContent": ["// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport {Capability, type Target} from './Target.js';\nimport {SDKModel} from './SDKModel.js';\n\n/**\n * The `IssuesModel` is a thin dispatch that does not store issues, but only creates the representation\n * class (usually derived from `Issue`) and passes the instances on via a dispatched event.\n * We chose this approach here because the lifetime of the Model is tied to the target, but DevTools\n * wants to preserve issues for targets (e.g. iframes) that are already gone as well.\n */\nexport class IssuesModel extends SDKModel<EventTypes> implements ProtocolProxyApi.AuditsDispatcher {\n  #disposed = false;\n  #enabled = false;\n\n  constructor(target: Target) {\n    super(target);\n    void this.ensureEnabled();\n  }\n\n  private async ensureEnabled(): Promise<void> {\n    if (this.#enabled) {\n      return;\n    }\n\n    this.#enabled = true;\n    this.target().registerAuditsDispatcher(this);\n    const auditsAgent = this.target().auditsAgent();\n    await auditsAgent.invoke_enable();\n  }\n\n  issueAdded(issueAddedEvent: Protocol.Audits.IssueAddedEvent): void {\n    this.dispatchEventToListeners(Events.ISSUE_ADDED, {issuesModel: this, inspectorIssue: issueAddedEvent.issue});\n  }\n\n  override dispose(): void {\n    super.dispose();\n    this.#disposed = true;\n  }\n\n  getTargetIfNotDisposed(): Target|null {\n    if (!this.#disposed) {\n      return this.target();\n    }\n    return null;\n  }\n}\n\nexport const enum Events {\n  ISSUE_ADDED = 'IssueAdded',\n}\n\nexport interface IssueAddedEvent {\n  issuesModel: IssuesModel;\n  inspectorIssue: Protocol.Audits.InspectorIssue;\n}\n\nexport type EventTypes = {\n  [Events.ISSUE_ADDED]: IssueAddedEvent,\n};\n\nSDKModel.register(IssuesModel, {capabilities: Capability.AUDITS, autostart: true});\n"],
  "mappings": ";AAOA,SAAQ,kBAA8B;AACtC,SAAQ,gBAAe;AAQhB,aAAM,oBAAoB,SAAkE;AAAA,EACjG,YAAY;AAAA,EACZ,WAAW;AAAA,EAEX,YAAY,QAAgB;AAC1B,UAAM,MAAM;AACZ,SAAK,KAAK,cAAc;AAAA,EAC1B;AAAA,EAEA,MAAc,gBAA+B;AAC3C,QAAI,KAAK,UAAU;AACjB;AAAA,IACF;AAEA,SAAK,WAAW;AAChB,SAAK,OAAO,EAAE,yBAAyB,IAAI;AAC3C,UAAM,cAAc,KAAK,OAAO,EAAE,YAAY;AAC9C,UAAM,YAAY,cAAc;AAAA,EAClC;AAAA,EAEA,WAAW,iBAAwD;AACjE,SAAK,yBAAyB,gCAAoB,EAAC,aAAa,MAAM,gBAAgB,gBAAgB,MAAK,CAAC;AAAA,EAC9G;AAAA,EAES,UAAgB;AACvB,UAAM,QAAQ;AACd,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,yBAAsC;AACpC,QAAI,CAAC,KAAK,WAAW;AACnB,aAAO,KAAK,OAAO;AAAA,IACrB;AACA,WAAO;AAAA,EACT;AACF;AAEO,WAAW,SAAX,kBAAWA,YAAX;AACL,EAAAA,QAAA,iBAAc;AADE,SAAAA;AAAA,GAAA;AAalB,SAAS,SAAS,aAAa,EAAC,cAAc,WAAW,QAAQ,WAAW,KAAI,CAAC;",
  "names": ["Events"]
}
