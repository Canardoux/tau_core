{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/RehydratingConnection.ts"],
  "sourcesContent": ["// Copyright (c) 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * This file is the implementation of a protocol `Connection` object\n *  which is central to the rehydrated devtools feature. The premise of\n * this feature is that the enhanced traces will contain enough\n * information to power this class with all metadata needed. This class\n * then interacts with rehydrated devtools in a way that produces the\n * equivalent result as live debugging session.\n *\n * It's much more of a state machine than the other Connection\n * implementations, which simply interact with a network protocol in\n * one way or another.\n *\n * Note on the methodology to derive runtime/debugger domain behavior below:\n * We can use protocol monitor in the devtools to look at how dt-fe\n * communicates with the backend, and it's also how majority of the behavior\n * in the rehydrated sesion was derived at the first place. In the event of\n * adding more support and capability to rehydrated session, developers will\n * want to look at protocol monitor to imitate the behavior in a real session\n *\n */\n\nimport type * as Protocol from '../../generated/protocol.js';\nimport * as i18n from '../i18n/i18n.js';\nimport type * as ProtocolClient from '../protocol_client/protocol_client.js';\n\nimport * as EnhancedTraces from './EnhancedTracesParser.js';\nimport type {\n  ProtocolMessage, RehydratingExecutionContext, RehydratingScript, RehydratingTarget, ServerMessage} from\n  './RehydratingObject.js';\n\nconst UIStrings = {\n  /**\n   * @description Text that appears when no source text is available for the given script\n   */\n  noSourceText: 'No source text available',\n};\nconst str_ = i18n.i18n.registerUIStrings('core/sdk/RehydratingConnection.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport interface RehydratingConnectionInterface {\n  postToFrontend: (arg: ServerMessage) => void;\n}\n\nexport const enum RehydratingConnectionState {\n  UNINITIALIZED = 1,\n  INITIALIZED = 2,\n  REHYDRATED = 3,\n}\n\nexport class RehydratingConnection implements ProtocolClient.InspectorBackend.Connection {\n  rehydratingConnectionState: RehydratingConnectionState = RehydratingConnectionState.UNINITIALIZED;\n  onDisconnect: ((arg0: string) => void)|null = null;\n  onMessage: ((arg0: Object) => void)|null = null;\n  traceEvents: unknown[] = [];\n  sessions: Map<number, RehydratingSessionBase> = new Map();\n  private static rehydratingConnectionInstance: RehydratingConnection|null = null;\n\n  private constructor() {\n  }\n\n  static instance(): RehydratingConnection {\n    if (!this.rehydratingConnectionInstance) {\n      this.rehydratingConnectionInstance = new RehydratingConnection();\n    }\n    return this.rehydratingConnectionInstance;\n  }\n\n  async startHydration(logPayload: string): Promise<boolean> {\n    // OnMessage should've been set before hydration, and the connection should\n    // be initialized and not hydrated already.\n    if (!this.onMessage || this.rehydratingConnectionState !== RehydratingConnectionState.INITIALIZED) {\n      return false;\n    }\n\n    const payload = JSON.parse(logPayload);\n    if (!('traceEvents' in payload)) {\n      console.error('RehydratingConnection failed to initialize due to missing trace events in payload');\n      return false;\n    }\n\n    this.traceEvents = payload.traceEvents;\n    const enhancedTracesParser = new EnhancedTraces.EnhancedTracesParser(this.traceEvents);\n    const dataPerTarget = enhancedTracesParser.data();\n\n    let sessionId = 0;\n    // Set up default rehydrating session.\n    this.sessions.set(sessionId, new RehydratingSessionBase(this));\n    for (const [target, [executionContexts, scripts]] of dataPerTarget.entries()) {\n      this.postToFrontend({\n        method: 'Target.targetCreated',\n        params: {\n          targetInfo: {\n            targetId: target.targetId,\n            type: target.type,\n            title: target.url,\n            url: target.url,\n            attached: false,\n            canAccessOpener: false,\n          },\n        },\n      });\n\n      // Create new session associated to the target created and send\n      // Target.attachedToTarget to frontend.\n      sessionId += 1;\n      this.sessions.set(sessionId, new RehydratingSession(sessionId, target, executionContexts, scripts, this));\n    }\n    this.rehydratingConnectionState = RehydratingConnectionState.REHYDRATED;\n    return true;\n  }\n\n  setOnMessage(onMessage: (arg0: (Object|string)) => void): void {\n    this.onMessage = onMessage;\n    this.rehydratingConnectionState = RehydratingConnectionState.INITIALIZED;\n  }\n\n  setOnDisconnect(onDisconnect: (arg0: string) => void): void {\n    this.onDisconnect = onDisconnect;\n  }\n\n  // The function \"sendRawMessage\" is typically devtools front-end\n  // sending message to the backend via CDP. In this case, given that Rehydrating\n  // connection is an emulation of devtool back-end, sendRawMessage here\n  // is in fact rehydrating connection directly handling and acting on the\n  // receieved message.\n  sendRawMessage(message: string|object): void {\n    if (typeof message === 'string') {\n      message = JSON.parse(message);\n    }\n    const data = message as ProtocolMessage;\n    if (typeof data.sessionId !== 'undefined') {\n      const session = this.sessions.get(data.sessionId);\n      if (session) {\n        session.handleFrontendMessageAsFakeCDPAgent(data);\n      } else {\n        console.error('Invalid SessionId: ' + data.sessionId);\n      }\n    } else {\n      this.sessions.get(0)?.handleFrontendMessageAsFakeCDPAgent(data);\n    }\n  }\n\n  // Posting rehydrating connection's message/response\n  // to devtools frontend through debugger protocol.\n  postToFrontend(arg: ServerMessage): void {\n    if (this.onMessage) {\n      this.onMessage(arg);\n    } else {\n      // onMessage should be set before the connection is rehydrated\n      console.error('onMessage was not initialized');\n    }\n  }\n\n  disconnect(): Promise<void> {\n    return Promise.reject();\n  }\n}\n\n// Default rehydrating session with default responses.\nclass RehydratingSessionBase {\n  connection: RehydratingConnectionInterface|null = null;\n\n  constructor(connection: RehydratingConnectionInterface) {\n    this.connection = connection;\n  }\n\n  sendMessageToFrontend(payload: ServerMessage): void {\n    requestAnimationFrame(() => {\n      if (this.connection) {\n        this.connection.postToFrontend(payload);\n      }\n    });\n  }\n\n  handleFrontendMessageAsFakeCDPAgent(data: ProtocolMessage): void {\n    // Send default response in default session.\n    this.sendMessageToFrontend({\n      id: data.id,\n      result: {},\n    });\n  }\n}\n\nexport class RehydratingSession extends RehydratingSessionBase {\n  sessionId: number;\n  target: RehydratingTarget;\n  executionContexts: RehydratingExecutionContext[] = [];\n  scripts: RehydratingScript[] = [];\n\n  constructor(\n      sessionId: number, target: RehydratingTarget, executionContexts: RehydratingExecutionContext[],\n      scripts: RehydratingScript[], connection: RehydratingConnectionInterface) {\n    super(connection);\n    this.sessionId = sessionId;\n    this.target = target;\n    this.executionContexts = executionContexts;\n    this.scripts = scripts;\n    this.sessionAttachToTarget();\n  }\n\n  override sendMessageToFrontend(payload: ServerMessage, attachSessionId: boolean = true): void {\n    // Attach the session's Id to the message.\n    if (this.sessionId !== 0 && attachSessionId) {\n      payload.sessionId = this.sessionId;\n    }\n    super.sendMessageToFrontend(payload);\n  }\n\n  override handleFrontendMessageAsFakeCDPAgent(data: ProtocolMessage): void {\n    switch (data.method) {\n      case 'Runtime.enable':\n        this.handleRuntimeEnabled(data.id);\n        break;\n      case 'Debugger.enable':\n        this.handleDebuggerEnable(data.id);\n        break;\n      case 'Debugger.getScriptSource':\n        if (data.params) {\n          const params = data.params as Protocol.Debugger.GetScriptSourceRequest;\n          this.handleDebuggerGetScriptSource(data.id, params.scriptId);\n        }\n        break;\n      default:\n        this.sendMessageToFrontend({\n          id: data.id,\n          result: {},\n        });\n        break;\n    }\n  }\n\n  private sessionAttachToTarget(): void {\n    this.sendMessageToFrontend(\n        {\n          method: 'Target.attachedToTarget',\n          params: {\n            sessionId: this.sessionId,\n            waitingForDebugger: false,\n            targetInfo: {\n              targetId: this.target.targetId,\n              type: this.target.type,\n              title: this.target.url,\n              url: this.target.url,\n              attached: true,\n              canAccessOpener: false,\n            },\n          },\n        },\n        /* attachSessionId */ false);\n  }\n\n  // Runtime.Enable indicates that Runtime domain is flushing the event to communicate\n  // the current state with the backend. In rehydrating connection, we made up the artificial\n  // execution context to support the rehydrated session.\n  private handleRuntimeEnabled(id: number): void {\n    for (const executionContext of this.executionContexts) {\n      executionContext.name = executionContext.origin;\n      this.sendMessageToFrontend({\n        method: 'Runtime.executionContextCreated',\n        params: {\n          context: executionContext,\n        },\n      });\n    }\n\n    this.sendMessageToFrontend({\n      id,\n      result: {},\n    });\n  }\n\n  private handleDebuggerGetScriptSource(id: number, scriptId: Protocol.Runtime.ScriptId): void {\n    const script = this.scripts.find(script => script.scriptId === scriptId);\n    if (!script) {\n      console.error('No script for id: ' + scriptId);\n      return;\n    }\n    this.sendMessageToFrontend({\n      id,\n      result: {\n        scriptSource: typeof script.sourceText === 'undefined' ? i18nString(UIStrings.noSourceText) : script.sourceText,\n      },\n    });\n  }\n\n  // Debugger.Enable indicates that Debugger domain is flushing the event to communicate\n  // the current state with the backend. In rehydrating connection, we made up the artificial\n  // script parsed event to communicate the current script state and respond with a mock\n  // debugger id.\n  private handleDebuggerEnable(id: number): void {\n    for (const script of this.scripts) {\n      this.sendMessageToFrontend({\n        method: 'Debugger.scriptParsed',\n        params: script,\n      });\n    }\n\n    const mockDebuggerId = '7777777777777777777.8888888888888888888';\n    this.sendMessageToFrontend({\n      id,\n      result: {\n        debuggerId: mockDebuggerId,\n      },\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["RehydratingConnectionState", "script"]
}
