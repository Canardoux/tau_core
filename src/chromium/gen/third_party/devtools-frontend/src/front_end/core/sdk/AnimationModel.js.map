{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/AnimationModel.ts"],
  "sourcesContent": ["// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport * as Protocol from '../../generated/protocol.js';\n\nimport {DeferredDOMNode, type DOMNode} from './DOMModel.js';\nimport {RemoteObject} from './RemoteObject.js';\nimport {Events as ResourceTreeModelEvents, ResourceTreeModel} from './ResourceTreeModel.js';\nimport {Events as RuntimeModelEvents, type EventTypes as RuntimeModelEventTypes, RuntimeModel} from './RuntimeModel.js';\nimport {ScreenCaptureModel} from './ScreenCaptureModel.js';\nimport {SDKModel} from './SDKModel.js';\nimport {Capability, type Target} from './Target.js';\n\nconst DEVTOOLS_ANIMATIONS_WORLD_NAME = 'devtools_animations';\nconst REPORT_SCROLL_POSITION_BINDING_NAME = '__devtools_report_scroll_position__';\n\nconst getScrollListenerNameInPage = (id: number): string => `__devtools_scroll_listener_${id}__`;\n\ntype ScrollListener = (param: {scrollLeft: number, scrollTop: number}) => void;\ntype BindingListener =\n    (ev: Common.EventTarget.EventTargetEvent<Protocol.Runtime.BindingCalledEvent, RuntimeModelEventTypes>) => void;\n\nasync function resolveToObjectInWorld(domNode: DOMNode, worldName: string): Promise<RemoteObject|null> {\n  const resourceTreeModel = domNode.domModel().target().model(ResourceTreeModel) as ResourceTreeModel;\n  const pageAgent = domNode.domModel().target().pageAgent();\n  for (const frame of resourceTreeModel.frames()) {\n    // This returns previously created world if it exists for the frame.\n    const {executionContextId} = await pageAgent.invoke_createIsolatedWorld({frameId: frame.id, worldName});\n    const object = await domNode.resolveToObject(undefined, executionContextId);\n    if (object) {\n      return object;\n    }\n  }\n  return null;\n}\n\n/**\n * Provides an extension over `DOMNode` that gives it additional\n * capabilities for animation debugging, mainly:\n * - getting a node's scroll information (scroll offsets and scroll range).\n * - updating a node's scroll offset.\n * - tracking the node's scroll offsets with event listeners.\n *\n * It works by running functions on the target page, see `DOMNode`s `callFunction` method\n * for more details on how a function is called on the target page.\n *\n * For listening to events on the target page and getting notified on the devtools frontend\n * side, we're adding a binding to the page `__devtools_report_scroll_position__` in a world `devtools_animation`\n * we've created. Then, we're setting scroll listeners of the `node` in the same world which calls the binding\n * itself with the scroll offsets.\n */\nexport class AnimationDOMNode {\n  #domNode: DOMNode;\n  #scrollListenersById: Map<number, ScrollListener>;\n  #scrollBindingListener?: BindingListener;\n\n  static lastAddedListenerId: number = 0;\n\n  constructor(domNode: DOMNode) {\n    this.#domNode = domNode;\n    this.#scrollListenersById = new Map();\n  }\n\n  async #addReportScrollPositionBinding(): Promise<void> {\n    // The binding is already added so we don't need to add it again.\n    if (this.#scrollBindingListener) {\n      return;\n    }\n\n    this.#scrollBindingListener = ev => {\n      const {name, payload} = ev.data;\n      if (name !== REPORT_SCROLL_POSITION_BINDING_NAME) {\n        return;\n      }\n\n      const {scrollTop, scrollLeft, id} = JSON.parse(payload) as {scrollTop: number, scrollLeft: number, id: number};\n      const scrollListener = this.#scrollListenersById.get(id);\n      if (!scrollListener) {\n        return;\n      }\n\n      scrollListener({scrollTop, scrollLeft});\n    };\n\n    const runtimeModel = this.#domNode.domModel().target().model(RuntimeModel) as RuntimeModel;\n    await runtimeModel.addBinding({\n      name: REPORT_SCROLL_POSITION_BINDING_NAME,\n      executionContextName: DEVTOOLS_ANIMATIONS_WORLD_NAME,\n    });\n    runtimeModel.addEventListener(RuntimeModelEvents.BindingCalled, this.#scrollBindingListener);\n  }\n\n  async #removeReportScrollPositionBinding(): Promise<void> {\n    // There isn't any binding added yet.\n    if (!this.#scrollBindingListener) {\n      return;\n    }\n\n    const runtimeModel = this.#domNode.domModel().target().model(RuntimeModel) as RuntimeModel;\n    await runtimeModel.removeBinding({\n      name: REPORT_SCROLL_POSITION_BINDING_NAME,\n    });\n    runtimeModel.removeEventListener(RuntimeModelEvents.BindingCalled, this.#scrollBindingListener);\n    this.#scrollBindingListener = undefined;\n  }\n\n  async addScrollEventListener(onScroll: ({scrollLeft, scrollTop}: {scrollLeft: number, scrollTop: number}) => void):\n      Promise<number|null> {\n    AnimationDOMNode.lastAddedListenerId++;\n    const id = AnimationDOMNode.lastAddedListenerId;\n    this.#scrollListenersById.set(id, onScroll);\n    // Add the binding for reporting scroll events from the page if it doesn't exist.\n    if (!this.#scrollBindingListener) {\n      await this.#addReportScrollPositionBinding();\n    }\n\n    const object = await resolveToObjectInWorld(this.#domNode, DEVTOOLS_ANIMATIONS_WORLD_NAME);\n    if (!object) {\n      return null;\n    }\n\n    await object.callFunction(scrollListenerInPage, [\n      id,\n      REPORT_SCROLL_POSITION_BINDING_NAME,\n      getScrollListenerNameInPage(id),\n    ].map(arg => RemoteObject.toCallArgument(arg)));\n    object.release();\n    return id;\n\n    function scrollListenerInPage(\n        this: HTMLElement|Document, id: number, reportScrollPositionBindingName: string,\n        scrollListenerNameInPage: string): void {\n      if ('scrollingElement' in this && !this.scrollingElement) {\n        return;\n      }\n\n      const scrollingElement = ('scrollingElement' in this ? this.scrollingElement : this) as HTMLElement;\n      // @ts-ignore We're setting a custom field on `Element` or `Document` for retaining the function on the page.\n      this[scrollListenerNameInPage] = () => {\n        // @ts-ignore `reportScrollPosition` binding is injected to the page before calling the function.\n        globalThis[reportScrollPositionBindingName](\n            JSON.stringify({scrollTop: scrollingElement.scrollTop, scrollLeft: scrollingElement.scrollLeft, id}));\n      };\n\n      // @ts-ignore We've already defined the function used below.\n      this.addEventListener('scroll', this[scrollListenerNameInPage], true);\n    }\n  }\n\n  async removeScrollEventListener(id: number): Promise<void> {\n    const object = await resolveToObjectInWorld(this.#domNode, DEVTOOLS_ANIMATIONS_WORLD_NAME);\n    if (!object) {\n      return;\n    }\n\n    await object.callFunction(\n        removeScrollListenerInPage, [getScrollListenerNameInPage(id)].map(arg => RemoteObject.toCallArgument(arg)));\n    object.release();\n\n    this.#scrollListenersById.delete(id);\n    // There aren't any scroll listeners remained on the page\n    // so we remove the binding.\n    if (this.#scrollListenersById.size === 0) {\n      await this.#removeReportScrollPositionBinding();\n    }\n\n    function removeScrollListenerInPage(this: HTMLElement|Document, scrollListenerNameInPage: string): void {\n      // @ts-ignore We've already set this custom field while adding scroll listener.\n      this.removeEventListener('scroll', this[scrollListenerNameInPage]);\n      // @ts-ignore We've already set this custom field while adding scroll listener.\n      delete this[scrollListenerNameInPage];\n    }\n  }\n\n  async scrollTop(): Promise<number|null> {\n    return this.#domNode.callFunction(scrollTopInPage).then(res => res?.value ?? null);\n\n    function scrollTopInPage(this: Element|Document): number {\n      if ('scrollingElement' in this) {\n        if (!this.scrollingElement) {\n          return 0;\n        }\n\n        return this.scrollingElement.scrollTop;\n      }\n      return this.scrollTop;\n    }\n  }\n\n  async scrollLeft(): Promise<number|null> {\n    return this.#domNode.callFunction(scrollLeftInPage).then(res => res?.value ?? null);\n\n    function scrollLeftInPage(this: Element|Document): number {\n      if ('scrollingElement' in this) {\n        if (!this.scrollingElement) {\n          return 0;\n        }\n\n        return this.scrollingElement.scrollLeft;\n      }\n      return this.scrollLeft;\n    }\n  }\n\n  async setScrollTop(offset: number): Promise<void> {\n    await this.#domNode.callFunction(setScrollTopInPage, [offset]);\n\n    function setScrollTopInPage(this: Element|Document, offsetInPage: number): void {\n      if ('scrollingElement' in this) {\n        if (!this.scrollingElement) {\n          return;\n        }\n\n        this.scrollingElement.scrollTop = offsetInPage;\n      } else {\n        this.scrollTop = offsetInPage;\n      }\n    }\n  }\n\n  async setScrollLeft(offset: number): Promise<void> {\n    await this.#domNode.callFunction(setScrollLeftInPage, [offset]);\n\n    function setScrollLeftInPage(this: Element|Document, offsetInPage: number): void {\n      if ('scrollingElement' in this) {\n        if (!this.scrollingElement) {\n          return;\n        }\n\n        this.scrollingElement.scrollLeft = offsetInPage;\n      } else {\n        this.scrollLeft = offsetInPage;\n      }\n    }\n  }\n\n  async verticalScrollRange(): Promise<number|null> {\n    return this.#domNode.callFunction(verticalScrollRangeInPage).then(res => res?.value ?? null);\n\n    function verticalScrollRangeInPage(this: Element|Document): number {\n      if ('scrollingElement' in this) {\n        if (!this.scrollingElement) {\n          return 0;\n        }\n\n        return this.scrollingElement.scrollHeight - this.scrollingElement.clientHeight;\n      }\n\n      return this.scrollHeight - this.clientHeight;\n    }\n  }\n\n  async horizontalScrollRange(): Promise<number|null> {\n    return this.#domNode.callFunction(horizontalScrollRangeInPage).then(res => res?.value ?? null);\n\n    function horizontalScrollRangeInPage(this: Element|Document): number {\n      if ('scrollingElement' in this) {\n        if (!this.scrollingElement) {\n          return 0;\n        }\n\n        return this.scrollingElement.scrollWidth - this.scrollingElement.clientWidth;\n      }\n\n      return this.scrollWidth - this.clientWidth;\n    }\n  }\n}\n\nfunction shouldGroupAnimations(firstAnimation: AnimationImpl, anim: AnimationImpl): boolean {\n  const firstAnimationTimeline = firstAnimation.viewOrScrollTimeline();\n  const animationTimeline = anim.viewOrScrollTimeline();\n  if (firstAnimationTimeline) {\n    // This is a SDA group so check whether the animation's\n    // scroll container and scroll axis is the same with the first animation.\n    return Boolean(\n        animationTimeline && firstAnimationTimeline.sourceNodeId === animationTimeline.sourceNodeId &&\n        firstAnimationTimeline.axis === animationTimeline.axis);\n  }\n  // This is a non-SDA group so check whether the coming animation\n  // is a time based one too and if so, compare their start times.\n  return !animationTimeline && firstAnimation.startTime() === anim.startTime();\n}\n\nexport class AnimationModel extends SDKModel<EventTypes> {\n  readonly runtimeModel: RuntimeModel;\n  readonly agent: ProtocolProxyApi.AnimationApi;\n  #animationsById: Map<string, AnimationImpl>;\n  readonly animationGroups: Map<string, AnimationGroup>;\n  #pendingAnimations: Set<string>;\n  playbackRate: number;\n  readonly #screenshotCapture?: ScreenshotCapture;\n  #flushPendingAnimations: () => void;\n\n  constructor(target: Target) {\n    super(target);\n    this.runtimeModel = (target.model(RuntimeModel) as RuntimeModel);\n    this.agent = target.animationAgent();\n    target.registerAnimationDispatcher(new AnimationDispatcher(this));\n    this.#animationsById = new Map();\n    this.animationGroups = new Map();\n    this.#pendingAnimations = new Set();\n    this.playbackRate = 1;\n\n    if (!target.suspended()) {\n      void this.agent.invoke_enable();\n    }\n\n    const resourceTreeModel = (target.model(ResourceTreeModel) as ResourceTreeModel);\n    resourceTreeModel.addEventListener(ResourceTreeModelEvents.PrimaryPageChanged, this.reset, this);\n    const screenCaptureModel = target.model(ScreenCaptureModel);\n    if (screenCaptureModel) {\n      this.#screenshotCapture = new ScreenshotCapture(this, screenCaptureModel);\n    }\n\n    this.#flushPendingAnimations = Common.Debouncer.debounce(() => {\n      while (this.#pendingAnimations.size) {\n        this.matchExistingGroups(this.createGroupFromPendingAnimations());\n      }\n    }, 100);\n  }\n\n  private reset(): void {\n    this.#animationsById.clear();\n    this.animationGroups.clear();\n    this.#pendingAnimations.clear();\n    this.dispatchEventToListeners(Events.ModelReset);\n  }\n\n  async devicePixelRatio(): Promise<number> {\n    const evaluateResult = await this.target().runtimeAgent().invoke_evaluate({expression: 'window.devicePixelRatio'});\n    if (evaluateResult?.result.type === 'number') {\n      return evaluateResult?.result.value as number ?? 1;\n    }\n\n    return 1;\n  }\n\n  async getAnimationGroupForAnimation(name: string, nodeId: Protocol.DOM.NodeId): Promise<AnimationGroup|null> {\n    for (const animationGroup of this.animationGroups.values()) {\n      for (const animation of animationGroup.animations()) {\n        if (animation.name() === name) {\n          const animationNode = await animation.source().node();\n          if (animationNode?.id === nodeId) {\n            return animationGroup;\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  animationCanceled(id: string): void {\n    this.#pendingAnimations.delete(id);\n  }\n\n  async animationUpdated(payload: Protocol.Animation.Animation): Promise<void> {\n    let foundAnimationGroup: AnimationGroup|undefined;\n    let foundAnimation: AnimationImpl|undefined;\n    for (const animationGroup of this.animationGroups.values()) {\n      foundAnimation = animationGroup.animations().find(animation => animation.id() === payload.id);\n      if (foundAnimation) {\n        foundAnimationGroup = animationGroup;\n        break;\n      }\n    }\n\n    if (!foundAnimation || !foundAnimationGroup) {\n      return;\n    }\n\n    await foundAnimation.setPayload(payload);\n    this.dispatchEventToListeners(Events.AnimationGroupUpdated, foundAnimationGroup);\n  }\n\n  async animationStarted(payload: Protocol.Animation.Animation): Promise<void> {\n    // We are not interested in animations without effect or target.\n    if (!payload.source || !payload.source.backendNodeId) {\n      return;\n    }\n\n    const animation = await AnimationImpl.parsePayload(this, payload);\n    // Ignore Web Animations custom effects & groups.\n    const keyframesRule = animation.source().keyframesRule();\n    if (animation.type() === 'WebAnimation' && keyframesRule && keyframesRule.keyframes().length === 0) {\n      this.#pendingAnimations.delete(animation.id());\n    } else {\n      this.#animationsById.set(animation.id(), animation);\n      this.#pendingAnimations.add(animation.id());\n    }\n\n    this.#flushPendingAnimations();\n  }\n\n  private matchExistingGroups(incomingGroup: AnimationGroup): boolean {\n    let matchedGroup: AnimationGroup|null = null;\n    for (const group of this.animationGroups.values()) {\n      if (group.matches(incomingGroup)) {\n        matchedGroup = group;\n        group.rebaseTo(incomingGroup);\n        break;\n      }\n\n      if (group.shouldInclude(incomingGroup)) {\n        matchedGroup = group;\n        group.appendAnimations(incomingGroup.animations());\n        break;\n      }\n    }\n\n    if (!matchedGroup) {\n      this.animationGroups.set(incomingGroup.id(), incomingGroup);\n      if (this.#screenshotCapture) {\n        this.#screenshotCapture.captureScreenshots(incomingGroup.finiteDuration(), incomingGroup.screenshotsInternal);\n      }\n      this.dispatchEventToListeners(Events.AnimationGroupStarted, incomingGroup);\n    } else {\n      this.dispatchEventToListeners(Events.AnimationGroupUpdated, matchedGroup);\n    }\n    return Boolean(matchedGroup);\n  }\n\n  private createGroupFromPendingAnimations(): AnimationGroup {\n    console.assert(this.#pendingAnimations.size > 0);\n    const firstAnimationId = this.#pendingAnimations.values().next().value as string;\n    this.#pendingAnimations.delete(firstAnimationId);\n\n    const firstAnimation = this.#animationsById.get(firstAnimationId);\n    if (!firstAnimation) {\n      throw new Error('Unable to locate first animation');\n    }\n\n    const groupedAnimations = [firstAnimation];\n    const remainingAnimations = new Set<string>();\n\n    for (const id of this.#pendingAnimations) {\n      const anim = this.#animationsById.get(id) as AnimationImpl;\n      if (shouldGroupAnimations(firstAnimation, anim)) {\n        groupedAnimations.push(anim);\n      } else {\n        remainingAnimations.add(id);\n      }\n    }\n\n    this.#pendingAnimations = remainingAnimations;\n    // Show the first starting animation at the top of the animations of the animation group.\n    groupedAnimations.sort((anim1, anim2) => anim1.startTime() - anim2.startTime());\n    return new AnimationGroup(this, firstAnimationId, groupedAnimations);\n  }\n\n  setPlaybackRate(playbackRate: number): void {\n    this.playbackRate = playbackRate;\n    void this.agent.invoke_setPlaybackRate({playbackRate});\n  }\n\n  releaseAnimations(animations: string[]): void {\n    void this.agent.invoke_releaseAnimations({animations});\n  }\n\n  override async suspendModel(): Promise<void> {\n    await this.agent.invoke_disable().then(() => this.reset());\n  }\n\n  override async resumeModel(): Promise<void> {\n    await this.agent.invoke_enable();\n  }\n}\n\nexport enum Events {\n  /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n  AnimationGroupStarted = 'AnimationGroupStarted',\n  AnimationGroupUpdated = 'AnimationGroupUpdated',\n  ModelReset = 'ModelReset',\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport type EventTypes = {\n  [Events.AnimationGroupStarted]: AnimationGroup,\n  [Events.AnimationGroupUpdated]: AnimationGroup,\n  [Events.ModelReset]: void,\n};\n\nexport class AnimationImpl {\n  readonly #animationModel: AnimationModel;\n  #payloadInternal!: Protocol.Animation\n      .Animation;  // Assertion is safe because only way to create `AnimationImpl` is to use `parsePayload` which calls `setPayload` and sets the value.\n  #sourceInternal!:\n      AnimationEffect;  // Assertion is safe because only way to create `AnimationImpl` is to use `parsePayload` which calls `setPayload` and sets the value.\n  #playStateInternal?: string;\n\n  private constructor(animationModel: AnimationModel) {\n    this.#animationModel = animationModel;\n  }\n\n  static async parsePayload(animationModel: AnimationModel, payload: Protocol.Animation.Animation):\n      Promise<AnimationImpl> {\n    const animation = new AnimationImpl(animationModel);\n    await animation.setPayload(payload);\n    return animation;\n  }\n\n  async setPayload(payload: Protocol.Animation.Animation): Promise<void> {\n    // TODO(b/40929569): Remove normalizing by devicePixelRatio after the attached bug is resolved.\n    if (payload.viewOrScrollTimeline) {\n      const devicePixelRatio = await this.#animationModel.devicePixelRatio();\n      if (payload.viewOrScrollTimeline.startOffset) {\n        payload.viewOrScrollTimeline.startOffset /= devicePixelRatio;\n      }\n\n      if (payload.viewOrScrollTimeline.endOffset) {\n        payload.viewOrScrollTimeline.endOffset /= devicePixelRatio;\n      }\n    }\n\n    this.#payloadInternal = payload;\n    if (this.#sourceInternal && payload.source) {\n      this.#sourceInternal.setPayload(payload.source);\n    } else if (!this.#sourceInternal && payload.source) {\n      this.#sourceInternal = new AnimationEffect(this.#animationModel, payload.source);\n    }\n  }\n\n  // `startTime` and `duration` is represented as the\n  // percentage of the view timeline range that starts at `startOffset`px\n  // from the scroll container and ends at `endOffset`px of the scroll container.\n  // This takes a percentage of the timeline range and returns the absolute\n  // pixels values as a scroll offset of the scroll container.\n  private percentageToPixels(percentage: number, viewOrScrollTimeline: Protocol.Animation.ViewOrScrollTimeline):\n      number {\n    const {startOffset, endOffset} = viewOrScrollTimeline;\n    if (startOffset === undefined || endOffset === undefined) {\n      // We don't expect this situation to occur since after an animation is started\n      // we expect the scroll offsets to be resolved and provided correctly. If `startOffset`\n      // or `endOffset` is not provided in a viewOrScrollTimeline; we can assume that there is a bug here\n      // so it's fine to throw an error.\n      throw new Error('startOffset or endOffset does not exist in viewOrScrollTimeline');\n    }\n\n    return (endOffset - startOffset) * (percentage / 100);\n  }\n\n  viewOrScrollTimeline(): Protocol.Animation.ViewOrScrollTimeline|undefined {\n    return this.#payloadInternal.viewOrScrollTimeline;\n  }\n\n  id(): string {\n    return this.#payloadInternal.id;\n  }\n\n  name(): string {\n    return this.#payloadInternal.name;\n  }\n\n  paused(): boolean {\n    return this.#payloadInternal.pausedState;\n  }\n\n  playState(): string {\n    return this.#playStateInternal || this.#payloadInternal.playState;\n  }\n\n  setPlayState(playState: string): void {\n    this.#playStateInternal = playState;\n  }\n\n  playbackRate(): number {\n    return this.#payloadInternal.playbackRate;\n  }\n\n  // For scroll driven animations, it returns the pixel offset in the scroll container\n  // For time animations, it returns milliseconds.\n  startTime(): number {\n    const viewOrScrollTimeline = this.viewOrScrollTimeline();\n    if (viewOrScrollTimeline) {\n      return this.percentageToPixels(\n                 this.playbackRate() > 0 ? this.#payloadInternal.startTime : 100 - this.#payloadInternal.startTime,\n                 viewOrScrollTimeline) +\n          (this.viewOrScrollTimeline()?.startOffset ?? 0);\n    }\n\n    return this.#payloadInternal.startTime;\n  }\n\n  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)\n  // For time animations, it returns milliseconds.\n  iterationDuration(): number {\n    const viewOrScrollTimeline = this.viewOrScrollTimeline();\n    if (viewOrScrollTimeline) {\n      return this.percentageToPixels(this.source().duration(), viewOrScrollTimeline);\n    }\n\n    return this.source().duration();\n  }\n\n  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)\n  // For time animations, it returns milliseconds.\n  endTime(): number {\n    if (!this.source().iterations) {\n      return Infinity;\n    }\n\n    if (this.viewOrScrollTimeline()) {\n      return this.startTime() + this.iterationDuration() * this.source().iterations();\n    }\n\n    return this.startTime() + this.source().delay() + this.source().duration() * this.source().iterations() +\n        this.source().endDelay();\n  }\n\n  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)\n  // For time animations, it returns milliseconds.\n  finiteDuration(): number {\n    const iterations = Math.min(this.source().iterations(), 3);\n    if (this.viewOrScrollTimeline()) {\n      return this.iterationDuration() * iterations;\n    }\n\n    return this.source().delay() + this.source().duration() * iterations;\n  }\n\n  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)\n  // For time animations, it returns milliseconds.\n  currentTime(): number {\n    const viewOrScrollTimeline = this.viewOrScrollTimeline();\n    if (viewOrScrollTimeline) {\n      return this.percentageToPixels(this.#payloadInternal.currentTime, viewOrScrollTimeline);\n    }\n\n    return this.#payloadInternal.currentTime;\n  }\n\n  source(): AnimationEffect {\n    return this.#sourceInternal;\n  }\n\n  type(): Protocol.Animation.AnimationType {\n    return this.#payloadInternal.type;\n  }\n\n  overlaps(animation: AnimationImpl): boolean {\n    // Infinite animations\n    if (!this.source().iterations() || !animation.source().iterations()) {\n      return true;\n    }\n\n    const firstAnimation = this.startTime() < animation.startTime() ? this : animation;\n    const secondAnimation = firstAnimation === this ? animation : this;\n    return firstAnimation.endTime() >= secondAnimation.startTime();\n  }\n\n  // Utility method for returning `delay` for time based animations\n  // and `startTime` in pixels for scroll driven animations. It is used to\n  // find the exact starting time of the first keyframe for both cases.\n  delayOrStartTime(): number {\n    if (this.viewOrScrollTimeline()) {\n      return this.startTime();\n    }\n\n    return this.source().delay();\n  }\n\n  setTiming(duration: number, delay: number): void {\n    void this.#sourceInternal.node().then(node => {\n      if (!node) {\n        throw new Error('Unable to find node');\n      }\n      this.updateNodeStyle(duration, delay, node);\n    });\n    this.#sourceInternal.durationInternal = duration;\n    this.#sourceInternal.delayInternal = delay;\n    void this.#animationModel.agent.invoke_setTiming({animationId: this.id(), duration, delay});\n  }\n\n  private updateNodeStyle(duration: number, delay: number, node: DOMNode): void {\n    let animationPrefix;\n    if (this.type() === Protocol.Animation.AnimationType.CSSTransition) {\n      animationPrefix = 'transition-';\n    } else if (this.type() === Protocol.Animation.AnimationType.CSSAnimation) {\n      animationPrefix = 'animation-';\n    } else {\n      return;\n    }\n\n    if (!node.id) {\n      throw new Error('Node has no id');\n    }\n\n    const cssModel = node.domModel().cssModel();\n    cssModel.setEffectivePropertyValueForNode(node.id, animationPrefix + 'duration', duration + 'ms');\n    cssModel.setEffectivePropertyValueForNode(node.id, animationPrefix + 'delay', delay + 'ms');\n  }\n\n  async remoteObjectPromise(): Promise<RemoteObject|null> {\n    const payload = await this.#animationModel.agent.invoke_resolveAnimation({animationId: this.id()});\n    if (!payload) {\n      return null;\n    }\n\n    return this.#animationModel.runtimeModel.createRemoteObject(payload.remoteObject);\n  }\n\n  cssId(): string {\n    return this.#payloadInternal.cssId || '';\n  }\n}\n\nexport class AnimationEffect {\n  #animationModel: AnimationModel;\n  #payload!: Protocol.Animation\n      .AnimationEffect;       // Assertion is safe because `setPayload` call in `constructor` sets the value.\n  delayInternal!: number;     // Assertion is safe because `setPayload` call in `constructor` sets the value.\n  durationInternal!: number;  // Assertion is safe because `setPayload` call in `constructor` sets the value.\n  #keyframesRuleInternal: KeyframesRule|undefined;\n  #deferredNodeInternal?: DeferredDOMNode;\n  constructor(animationModel: AnimationModel, payload: Protocol.Animation.AnimationEffect) {\n    this.#animationModel = animationModel;\n    this.setPayload(payload);\n  }\n\n  setPayload(payload: Protocol.Animation.AnimationEffect): void {\n    this.#payload = payload;\n    if (!this.#keyframesRuleInternal && payload.keyframesRule) {\n      this.#keyframesRuleInternal = new KeyframesRule(payload.keyframesRule);\n    } else if (this.#keyframesRuleInternal && payload.keyframesRule) {\n      this.#keyframesRuleInternal.setPayload(payload.keyframesRule);\n    }\n\n    this.delayInternal = payload.delay;\n    this.durationInternal = payload.duration;\n  }\n\n  delay(): number {\n    return this.delayInternal;\n  }\n\n  endDelay(): number {\n    return this.#payload.endDelay;\n  }\n\n  iterations(): number {\n    // Animations with zero duration, zero delays and infinite iterations can't be shown.\n    if (!this.delay() && !this.endDelay() && !this.duration()) {\n      return 0;\n    }\n    return this.#payload.iterations || Infinity;\n  }\n\n  duration(): number {\n    return this.durationInternal;\n  }\n\n  direction(): string {\n    return this.#payload.direction;\n  }\n\n  fill(): string {\n    return this.#payload.fill;\n  }\n\n  node(): Promise<DOMNode|null> {\n    if (!this.#deferredNodeInternal) {\n      this.#deferredNodeInternal = new DeferredDOMNode(this.#animationModel.target(), this.backendNodeId());\n    }\n    return this.#deferredNodeInternal.resolvePromise();\n  }\n\n  deferredNode(): DeferredDOMNode {\n    return new DeferredDOMNode(this.#animationModel.target(), this.backendNodeId());\n  }\n\n  backendNodeId(): Protocol.DOM.BackendNodeId {\n    return this.#payload.backendNodeId as Protocol.DOM.BackendNodeId;\n  }\n\n  keyframesRule(): KeyframesRule|null {\n    return this.#keyframesRuleInternal || null;\n  }\n\n  easing(): string {\n    return this.#payload.easing;\n  }\n}\n\nexport class KeyframesRule {\n  #payload!: Protocol.Animation\n      .KeyframesRule;  // Assertion is safe because `setPayload` call in `constructor` sets the value.;\n  #keyframesInternal!:\n      KeyframeStyle[];  // Assertion is safe because `setPayload` call in `constructor` sets the value.;\n  constructor(payload: Protocol.Animation.KeyframesRule) {\n    this.setPayload(payload);\n  }\n\n  setPayload(payload: Protocol.Animation.KeyframesRule): void {\n    this.#payload = payload;\n    if (!this.#keyframesInternal) {\n      this.#keyframesInternal = this.#payload.keyframes.map(keyframeStyle => new KeyframeStyle(keyframeStyle));\n    } else {\n      this.#payload.keyframes.forEach((keyframeStyle, index) => {\n        this.#keyframesInternal[index]?.setPayload(keyframeStyle);\n      });\n    }\n  }\n\n  name(): string|undefined {\n    return this.#payload.name;\n  }\n\n  keyframes(): KeyframeStyle[] {\n    return this.#keyframesInternal;\n  }\n}\n\nexport class KeyframeStyle {\n  #payload!:\n      Protocol.Animation.KeyframeStyle;  // Assertion is safe because `setPayload` call in `constructor` sets the value.\n  #offsetInternal!: string;              // Assertion is safe because `setPayload` call in `constructor` sets the value.\n  constructor(payload: Protocol.Animation.KeyframeStyle) {\n    this.setPayload(payload);\n  }\n\n  setPayload(payload: Protocol.Animation.KeyframeStyle): void {\n    this.#payload = payload;\n    this.#offsetInternal = payload.offset;\n  }\n\n  offset(): string {\n    return this.#offsetInternal;\n  }\n\n  setOffset(offset: number): void {\n    this.#offsetInternal = offset * 100 + '%';\n  }\n\n  offsetAsNumber(): number {\n    return parseFloat(this.#offsetInternal) / 100;\n  }\n\n  easing(): string {\n    return this.#payload.easing;\n  }\n}\n\nexport class AnimationGroup {\n  readonly #animationModel: AnimationModel;\n  readonly #idInternal: string;\n  #scrollNodeInternal: AnimationDOMNode|undefined;\n  #animationsInternal: AnimationImpl[];\n  #pausedInternal: boolean;\n  screenshotsInternal: string[];\n  readonly #screenshotImages: HTMLImageElement[];\n  constructor(animationModel: AnimationModel, id: string, animations: AnimationImpl[]) {\n    this.#animationModel = animationModel;\n    this.#idInternal = id;\n    this.#animationsInternal = animations;\n    this.#pausedInternal = false;\n    this.screenshotsInternal = [];\n\n    this.#screenshotImages = [];\n  }\n\n  isScrollDriven(): boolean {\n    return Boolean(this.#animationsInternal[0]?.viewOrScrollTimeline());\n  }\n\n  id(): string {\n    return this.#idInternal;\n  }\n\n  animations(): AnimationImpl[] {\n    return this.#animationsInternal;\n  }\n\n  release(): void {\n    this.#animationModel.animationGroups.delete(this.id());\n    this.#animationModel.releaseAnimations(this.animationIds());\n  }\n\n  private animationIds(): string[] {\n    function extractId(animation: AnimationImpl): string {\n      return animation.id();\n    }\n\n    return this.#animationsInternal.map(extractId);\n  }\n\n  startTime(): number {\n    return this.#animationsInternal[0].startTime();\n  }\n\n  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)\n  // For time animations, it returns milliseconds.\n  groupDuration(): number {\n    let duration = 0;\n    for (const anim of this.#animationsInternal) {\n      duration = Math.max(duration, anim.delayOrStartTime() + anim.iterationDuration());\n    }\n    return duration;\n  }\n\n  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)\n  // For time animations, it returns milliseconds.\n  finiteDuration(): number {\n    let maxDuration = 0;\n    for (let i = 0; i < this.#animationsInternal.length; ++i) {\n      maxDuration = Math.max(maxDuration, this.#animationsInternal[i].finiteDuration());\n    }\n    return maxDuration;\n  }\n\n  scrollOrientation(): Protocol.DOM.ScrollOrientation|null {\n    const timeline = this.#animationsInternal[0]?.viewOrScrollTimeline();\n    if (!timeline) {\n      return null;\n    }\n\n    return timeline.axis;\n  }\n\n  async scrollNode(): Promise<AnimationDOMNode|null> {\n    if (this.#scrollNodeInternal) {\n      return this.#scrollNodeInternal;\n    }\n\n    if (!this.isScrollDriven()) {\n      return null;\n    }\n\n    const sourceNodeId = this.#animationsInternal[0]?.viewOrScrollTimeline()?.sourceNodeId;\n    if (!sourceNodeId) {\n      return null;\n    }\n\n    const deferredScrollNode = new DeferredDOMNode(this.#animationModel.target(), sourceNodeId);\n    const scrollNode = await deferredScrollNode.resolvePromise();\n    if (!scrollNode) {\n      return null;\n    }\n\n    this.#scrollNodeInternal = new AnimationDOMNode(scrollNode);\n    return this.#scrollNodeInternal;\n  }\n\n  seekTo(currentTime: number): void {\n    void this.#animationModel.agent.invoke_seekAnimations({animations: this.animationIds(), currentTime});\n  }\n\n  paused(): boolean {\n    return this.#pausedInternal;\n  }\n\n  togglePause(paused: boolean): void {\n    if (paused === this.#pausedInternal) {\n      return;\n    }\n    this.#pausedInternal = paused;\n    void this.#animationModel.agent.invoke_setPaused({animations: this.animationIds(), paused});\n  }\n\n  currentTimePromise(): Promise<number> {\n    let longestAnim: AnimationImpl|null = null;\n    for (const anim of this.#animationsInternal) {\n      if (!longestAnim || anim.endTime() > longestAnim.endTime()) {\n        longestAnim = anim;\n      }\n    }\n    if (!longestAnim) {\n      throw new Error('No longest animation found');\n    }\n\n    return this.#animationModel.agent.invoke_getCurrentTime({id: longestAnim.id()})\n        .then(({currentTime}) => currentTime || 0);\n  }\n\n  matches(group: AnimationGroup): boolean {\n    function extractId(anim: AnimationImpl): string {\n      const timelineId = (anim.viewOrScrollTimeline()?.sourceNodeId ?? '') + (anim.viewOrScrollTimeline()?.axis ?? '');\n      const regularId =\n          anim.type() === Protocol.Animation.AnimationType.WebAnimation ? anim.type() + anim.id() : anim.cssId();\n\n      return regularId + timelineId;\n    }\n\n    if (this.#animationsInternal.length !== group.#animationsInternal.length) {\n      return false;\n    }\n    const left = this.#animationsInternal.map(extractId).sort();\n    const right = group.#animationsInternal.map(extractId).sort();\n    for (let i = 0; i < left.length; i++) {\n      if (left[i] !== right[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  shouldInclude(group: AnimationGroup): boolean {\n    // We want to include the animations coming from the incoming group\n    // inside this group if they were to be grouped if the events came at the same time.\n    const [firstIncomingAnimation] = group.#animationsInternal;\n    const [firstAnimation] = this.#animationsInternal;\n    return shouldGroupAnimations(firstAnimation, firstIncomingAnimation);\n  }\n\n  appendAnimations(animations: AnimationImpl[]): void {\n    this.#animationsInternal.push(...animations);\n  }\n\n  rebaseTo(group: AnimationGroup): void {\n    this.#animationModel.releaseAnimations(this.animationIds());\n    this.#animationsInternal = group.#animationsInternal;\n    this.#scrollNodeInternal = undefined;\n  }\n\n  screenshots(): HTMLImageElement[] {\n    for (let i = 0; i < this.screenshotsInternal.length; ++i) {\n      const image = new Image();\n      image.src = 'data:image/jpeg;base64,' + this.screenshotsInternal[i];\n      this.#screenshotImages.push(image);\n    }\n    this.screenshotsInternal = [];\n    return this.#screenshotImages;\n  }\n}\n\nexport class AnimationDispatcher implements ProtocolProxyApi.AnimationDispatcher {\n  readonly #animationModel: AnimationModel;\n  constructor(animationModel: AnimationModel) {\n    this.#animationModel = animationModel;\n  }\n\n  animationCreated(_event: Protocol.Animation.AnimationCreatedEvent): void {\n    // Previously this event was used to batch the animations into groups\n    // and we were waiting for animationStarted events to be sent for\n    // all the created animations and until then we weren't creating any\n    // groups. This was allowing us to not miss any animations that were\n    // going to be in the same group. However, now we're not using this event\n    // to do batching and instead:\n    // * We debounce the flush calls so that if the animationStarted events\n    // for the same animation group come in different times; we create one\n    // group for them.\n    // * Even though an animation group is created and rendered for some animations\n    // that have the same startTime (or same timeline & scroll axis for SDAs), now\n    // whenever an `animationStarted` event comes we check whether there is a group\n    // we can add the related animation. If so, we add it and emit `animationGroupUpdated`\n    // event. So that, all the animations that were supposed to be in the same group\n    // will be in the same group.\n  }\n\n  animationCanceled({id}: Protocol.Animation.AnimationCanceledEvent): void {\n    this.#animationModel.animationCanceled(id);\n  }\n\n  animationStarted({animation}: Protocol.Animation.AnimationStartedEvent): void {\n    void this.#animationModel.animationStarted(animation);\n  }\n\n  animationUpdated({animation}: Protocol.Animation.AnimationUpdatedEvent): void {\n    void this.#animationModel.animationUpdated(animation);\n  }\n}\n\nexport class ScreenshotCapture {\n  #requests: Request[];\n  readonly #screenCaptureModel: ScreenCaptureModel;\n  readonly #animationModel: AnimationModel;\n  #stopTimer?: number;\n  #endTime?: number;\n  #capturing?: boolean;\n  constructor(animationModel: AnimationModel, screenCaptureModel: ScreenCaptureModel) {\n    this.#requests = [];\n    this.#screenCaptureModel = screenCaptureModel;\n    this.#animationModel = animationModel;\n    this.#animationModel.addEventListener(Events.ModelReset, this.stopScreencast, this);\n  }\n\n  captureScreenshots(duration: number, screenshots: string[]): void {\n    const screencastDuration = Math.min(duration / this.#animationModel.playbackRate, 3000);\n    const endTime = screencastDuration + window.performance.now();\n    this.#requests.push({endTime, screenshots});\n\n    if (!this.#endTime || endTime > this.#endTime) {\n      clearTimeout(this.#stopTimer);\n      this.#stopTimer = window.setTimeout(this.stopScreencast.bind(this), screencastDuration);\n      this.#endTime = endTime;\n    }\n\n    if (this.#capturing) {\n      return;\n    }\n    this.#capturing = true;\n    this.#screenCaptureModel.startScreencast(\n        Protocol.Page.StartScreencastRequestFormat.Jpeg, 80, undefined, 300, 2, this.screencastFrame.bind(this),\n        _visible => {});\n  }\n\n  private screencastFrame(base64Data: string, _metadata: Protocol.Page.ScreencastFrameMetadata): void {\n    function isAnimating(request: Request): boolean {\n      return request.endTime >= now;\n    }\n\n    if (!this.#capturing) {\n      return;\n    }\n\n    const now = window.performance.now();\n    this.#requests = this.#requests.filter(isAnimating);\n    for (const request of this.#requests) {\n      request.screenshots.push(base64Data);\n    }\n  }\n\n  private stopScreencast(): void {\n    if (!this.#capturing) {\n      return;\n    }\n\n    this.#stopTimer = undefined;\n    this.#endTime = undefined;\n    this.#requests = [];\n    this.#capturing = false;\n    this.#screenCaptureModel.stopScreencast();\n  }\n}\n\nSDKModel.register(AnimationModel, {capabilities: Capability.DOM, autostart: true});\nexport interface Request {\n  endTime: number;\n  screenshots: string[];\n}\n"],
  "mappings": "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",
  "names": ["id", "Events"]
}
