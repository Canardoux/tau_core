{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/PreloadingModel.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Common from '../common/common.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\n\nimport {assertNotNullOrUndefined} from '../platform/platform.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport {SDKModel} from './SDKModel.js';\nimport {Capability, type Target} from './Target.js';\nimport {TargetManager} from './TargetManager.js';\nimport {\n  Events as ResourceTreeModelEvents,\n  PrimaryPageChangeType,\n  ResourceTreeModel,\n  type ResourceTreeFrame,\n} from './ResourceTreeModel.js';\n\nexport interface WithId<I, V> {\n  id: I;\n  value: V;\n}\n\n// Holds preloading related information.\n//\n// - SpeculationRule rule sets\n// - Preloading attempts\n// - Relationship between rule sets and preloading attempts\nexport class PreloadingModel extends SDKModel<EventTypes> {\n  private agent: ProtocolProxyApi.PreloadApi;\n  private loaderIds: Protocol.Network.LoaderId[] = [];\n  private targetJustAttached: boolean = true;\n  private lastPrimaryPageModel: PreloadingModel|null = null;\n  private documents: Map<Protocol.Network.LoaderId, DocumentPreloadingData> =\n      new Map<Protocol.Network.LoaderId, DocumentPreloadingData>();\n\n  constructor(target: Target) {\n    super(target);\n\n    target.registerPreloadDispatcher(new PreloadDispatcher(this));\n\n    this.agent = target.preloadAgent();\n    void this.agent.invoke_enable();\n\n    const targetInfo = target.targetInfo();\n    if (targetInfo !== undefined && targetInfo.subtype === 'prerender') {\n      this.lastPrimaryPageModel = TargetManager.instance().primaryPageTarget()?.model(PreloadingModel) || null;\n    }\n\n    TargetManager.instance().addModelListener(\n        ResourceTreeModel, ResourceTreeModelEvents.PrimaryPageChanged, this.onPrimaryPageChanged, this);\n  }\n\n  override dispose(): void {\n    super.dispose();\n\n    TargetManager.instance().removeModelListener(\n        ResourceTreeModel, ResourceTreeModelEvents.PrimaryPageChanged, this.onPrimaryPageChanged, this);\n\n    void this.agent.invoke_disable();\n  }\n\n  private ensureDocumentPreloadingData(loaderId: Protocol.Network.LoaderId): void {\n    if (this.documents.get(loaderId) === undefined) {\n      this.documents.set(loaderId, new DocumentPreloadingData());\n    }\n  }\n\n  private currentLoaderId(): Protocol.Network.LoaderId|null {\n    // Target is just attached and didn't received CDP events that we can infer loaderId.\n    if (this.targetJustAttached) {\n      return null;\n    }\n\n    if (this.loaderIds.length === 0) {\n      throw new Error('unreachable');\n    }\n\n    return this.loaderIds[this.loaderIds.length - 1];\n  }\n\n  private currentDocument(): DocumentPreloadingData|null {\n    const loaderId = this.currentLoaderId();\n    return loaderId === null ? null : this.documents.get(loaderId) || null;\n  }\n\n  // Returns a rule set of the current page.\n  //\n  // Returns reference. Don't save returned values.\n  // Returned value may or may not be updated as the time grows.\n  getRuleSetById(id: Protocol.Preload.RuleSetId): Protocol.Preload.RuleSet|null {\n    return this.currentDocument()?.ruleSets.getById(id) || null;\n  }\n\n  // Returns rule sets of the current page.\n  //\n  // Returns array of pairs of id and reference. Don't save returned references.\n  // Returned values may or may not be updated as the time grows.\n  getAllRuleSets(): WithId<Protocol.Preload.RuleSetId, Protocol.Preload.RuleSet>[] {\n    return this.currentDocument()?.ruleSets.getAll() || [];\n  }\n\n  getPreloadCountsByRuleSetId(): Map<Protocol.Preload.RuleSetId|null, Map<PreloadingStatus, number>> {\n    const countsByRuleSetId = new Map<Protocol.Preload.RuleSetId|null, Map<PreloadingStatus, number>>();\n\n    for (const {value} of this.getPreloadingAttempts(null)) {\n      for (const ruleSetId of [null, ...value.ruleSetIds]) {\n        if (countsByRuleSetId.get(ruleSetId) === undefined) {\n          countsByRuleSetId.set(ruleSetId, new Map<PreloadingStatus, number>());\n        }\n\n        const countsByStatus = countsByRuleSetId.get(ruleSetId);\n        assertNotNullOrUndefined(countsByStatus);\n        const i = countsByStatus.get(value.status) || 0;\n        countsByStatus.set(value.status, i + 1);\n      }\n    }\n\n    return countsByRuleSetId;\n  }\n\n  // Returns a preloading attempt of the current page.\n  //\n  // Returns reference. Don't save returned values.\n  // Returned value may or may not be updated as the time grows.\n  getPreloadingAttemptById(id: PreloadingAttemptId): PreloadingAttempt|null {\n    const document = this.currentDocument();\n    if (document === null) {\n      return null;\n    }\n\n    return document.preloadingAttempts.getById(id, document.sources) || null;\n  }\n\n  // Returs preloading attempts of the current page that triggered by the rule set with `ruleSetId`.\n  // `ruleSetId === null` means \"do not filter\".\n  //\n  // Returns array of pairs of id and reference. Don't save returned references.\n  // Returned values may or may not be updated as the time grows.\n  getPreloadingAttempts(ruleSetId: Protocol.Preload.RuleSetId|null): WithId<PreloadingAttemptId, PreloadingAttempt>[] {\n    const document = this.currentDocument();\n    if (document === null) {\n      return [];\n    }\n\n    return document.preloadingAttempts.getAll(ruleSetId, document.sources);\n  }\n\n  // Returs preloading attempts of the previousPgae.\n  //\n  // Returns array of pairs of id and reference. Don't save returned references.\n  // Returned values may or may not be updated as the time grows.\n  getPreloadingAttemptsOfPreviousPage(): WithId<PreloadingAttemptId, PreloadingAttempt>[] {\n    if (this.loaderIds.length <= 1) {\n      return [];\n    }\n\n    const document = this.documents.get(this.loaderIds[this.loaderIds.length - 2]);\n    if (document === undefined) {\n      return [];\n    }\n\n    return document.preloadingAttempts.getAll(null, document.sources);\n  }\n\n  private onPrimaryPageChanged(\n      event: Common.EventTarget.EventTargetEvent<{frame: ResourceTreeFrame, type: PrimaryPageChangeType}>): void {\n    const {frame, type} = event.data;\n\n    // Model of prerendered page's target will hands over. Do nothing for the initiator page.\n    if (this.lastPrimaryPageModel === null && type === PrimaryPageChangeType.ACTIVATION) {\n      return;\n    }\n\n    if (this.lastPrimaryPageModel !== null && type !== PrimaryPageChangeType.ACTIVATION) {\n      return;\n    }\n\n    if (this.lastPrimaryPageModel !== null && type === PrimaryPageChangeType.ACTIVATION) {\n      // Hand over from the model of the last primary page.\n      this.loaderIds = this.lastPrimaryPageModel.loaderIds;\n      for (const [loaderId, prev] of this.lastPrimaryPageModel.documents.entries()) {\n        this.ensureDocumentPreloadingData(loaderId);\n        this.documents.get(loaderId)?.mergePrevious(prev);\n      }\n    }\n\n    this.lastPrimaryPageModel = null;\n\n    // Note that at this timing ResourceTreeFrame.loaderId is ensured to\n    // be non empty and Protocol.Network.LoaderId because it is filled\n    // by ResourceTreeFrame.navigate.\n    const currentLoaderId = frame.loaderId as Protocol.Network.LoaderId;\n\n    // Holds histories for two pages at most.\n    this.loaderIds.push(currentLoaderId);\n    this.loaderIds = this.loaderIds.slice(-2);\n    this.ensureDocumentPreloadingData(currentLoaderId);\n    for (const loaderId of this.documents.keys()) {\n      if (!this.loaderIds.includes(loaderId)) {\n        this.documents.delete(loaderId);\n      }\n    }\n\n    this.dispatchEventToListeners(Events.MODEL_UPDATED);\n  }\n\n  onRuleSetUpdated(event: Protocol.Preload.RuleSetUpdatedEvent): void {\n    const ruleSet = event.ruleSet;\n\n    const loaderId = ruleSet.loaderId;\n\n    // Infer current loaderId if DevTools is opned at the current page.\n    if (this.currentLoaderId() === null) {\n      this.loaderIds = [loaderId];\n      this.targetJustAttached = false;\n    }\n\n    this.ensureDocumentPreloadingData(loaderId);\n    this.documents.get(loaderId)?.ruleSets.upsert(ruleSet);\n    this.dispatchEventToListeners(Events.MODEL_UPDATED);\n  }\n\n  onRuleSetRemoved(event: Protocol.Preload.RuleSetRemovedEvent): void {\n    const id = event.id;\n\n    for (const document of this.documents.values()) {\n      document.ruleSets.delete(id);\n    }\n    this.dispatchEventToListeners(Events.MODEL_UPDATED);\n  }\n\n  onPreloadingAttemptSourcesUpdated(event: Protocol.Preload.PreloadingAttemptSourcesUpdatedEvent): void {\n    const loaderId = event.loaderId;\n    this.ensureDocumentPreloadingData(loaderId);\n\n    const document = this.documents.get(loaderId);\n    if (document === undefined) {\n      return;\n    }\n\n    document.sources.update(event.preloadingAttemptSources);\n    document.preloadingAttempts.maybeRegisterNotTriggered(document.sources);\n    document.preloadingAttempts.cleanUpRemovedAttempts(document.sources);\n    this.dispatchEventToListeners(Events.MODEL_UPDATED);\n  }\n\n  onPrefetchStatusUpdated(event: Protocol.Preload.PrefetchStatusUpdatedEvent): void {\n    // We ignore this event to avoid reinserting an attempt after it was removed by\n    // onPreloadingAttemptSourcesUpdated.\n    if (event.prefetchStatus === Protocol.Preload.PrefetchStatus.PrefetchEvictedAfterCandidateRemoved) {\n      return;\n    }\n\n    const loaderId = event.key.loaderId;\n    this.ensureDocumentPreloadingData(loaderId);\n    const attempt: PrefetchAttemptInternal = {\n      action: Protocol.Preload.SpeculationAction.Prefetch,\n      key: event.key,\n      status: convertPreloadingStatus(event.status),\n      prefetchStatus: event.prefetchStatus || null,\n      requestId: event.requestId,\n    };\n    this.documents.get(loaderId)?.preloadingAttempts.upsert(attempt);\n    this.dispatchEventToListeners(Events.MODEL_UPDATED);\n  }\n\n  onPrerenderStatusUpdated(event: Protocol.Preload.PrerenderStatusUpdatedEvent): void {\n    const loaderId = event.key.loaderId;\n    this.ensureDocumentPreloadingData(loaderId);\n    const attempt: PrerenderAttemptInternal = {\n      action: Protocol.Preload.SpeculationAction.Prerender,\n      key: event.key,\n      status: convertPreloadingStatus(event.status),\n      prerenderStatus: event.prerenderStatus || null,\n      disallowedMojoInterface: event.disallowedMojoInterface || null,\n      mismatchedHeaders: event.mismatchedHeaders || null,\n    };\n    this.documents.get(loaderId)?.preloadingAttempts.upsert(attempt);\n    this.dispatchEventToListeners(Events.MODEL_UPDATED);\n  }\n\n  onPreloadEnabledStateUpdated(event: Protocol.Preload.PreloadEnabledStateUpdatedEvent): void {\n    this.dispatchEventToListeners(Events.WARNINGS_UPDATED, event);\n  }\n}\n\nSDKModel.register(PreloadingModel, {capabilities: Capability.DOM, autostart: false});\n\nexport const enum Events {\n  MODEL_UPDATED = 'ModelUpdated',\n  WARNINGS_UPDATED = 'WarningsUpdated',\n}\n\nexport type EventTypes = {\n  [Events.MODEL_UPDATED]: void,\n  [Events.WARNINGS_UPDATED]: Protocol.Preload.PreloadEnabledStateUpdatedEvent,\n};\n\nclass PreloadDispatcher implements ProtocolProxyApi.PreloadDispatcher {\n  private model: PreloadingModel;\n\n  constructor(model: PreloadingModel) {\n    this.model = model;\n  }\n\n  ruleSetUpdated(event: Protocol.Preload.RuleSetUpdatedEvent): void {\n    this.model.onRuleSetUpdated(event);\n  }\n\n  ruleSetRemoved(event: Protocol.Preload.RuleSetRemovedEvent): void {\n    this.model.onRuleSetRemoved(event);\n  }\n\n  preloadingAttemptSourcesUpdated(event: Protocol.Preload.PreloadingAttemptSourcesUpdatedEvent): void {\n    this.model.onPreloadingAttemptSourcesUpdated(event);\n  }\n\n  prefetchStatusUpdated(event: Protocol.Preload.PrefetchStatusUpdatedEvent): void {\n    this.model.onPrefetchStatusUpdated(event);\n  }\n\n  prerenderStatusUpdated(event: Protocol.Preload.PrerenderStatusUpdatedEvent): void {\n    this.model.onPrerenderStatusUpdated(event);\n  }\n\n  preloadEnabledStateUpdated(event: Protocol.Preload.PreloadEnabledStateUpdatedEvent): void {\n    void this.model.onPreloadEnabledStateUpdated(event);\n  }\n}\n\nclass DocumentPreloadingData {\n  ruleSets: RuleSetRegistry = new RuleSetRegistry();\n  preloadingAttempts: PreloadingAttemptRegistry = new PreloadingAttemptRegistry();\n  sources: SourceRegistry = new SourceRegistry();\n\n  mergePrevious(prev: DocumentPreloadingData): void {\n    // Note that CDP events Preload.ruleSetUpdated/Deleted and\n    // Preload.preloadingAttemptSourcesUpdated with a loaderId are emitted to target that bounded to\n    // a document with the loaderId. On the other hand, prerendering activation changes targets\n    // of Preload.prefetch/prerenderStatusUpdated, i.e. activated page receives those events for\n    // triggering outcome \"Success\".\n    if (!this.ruleSets.isEmpty() || !this.sources.isEmpty()) {\n      throw new Error('unreachable');\n    }\n\n    this.ruleSets = prev.ruleSets;\n    this.preloadingAttempts.mergePrevious(prev.preloadingAttempts);\n    this.sources = prev.sources;\n  }\n}\n\nclass RuleSetRegistry {\n  private map: Map<Protocol.Preload.RuleSetId, Protocol.Preload.RuleSet> =\n      new Map<Protocol.Preload.RuleSetId, Protocol.Preload.RuleSet>();\n\n  isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n  // Returns reference. Don't save returned values.\n  // Returned values may or may not be updated as the time grows.\n  getById(id: Protocol.Preload.RuleSetId): Protocol.Preload.RuleSet|null {\n    return this.map.get(id) || null;\n  }\n\n  // Returns reference. Don't save returned values.\n  // Returned values may or may not be updated as the time grows.\n  getAll(): WithId<Protocol.Preload.RuleSetId, Protocol.Preload.RuleSet>[] {\n    return Array.from(this.map.entries()).map(([id, value]) => ({id, value}));\n  }\n\n  upsert(ruleSet: Protocol.Preload.RuleSet): void {\n    this.map.set(ruleSet.id, ruleSet);\n  }\n\n  delete(id: Protocol.Preload.RuleSetId): void {\n    this.map.delete(id);\n  }\n}\n\n// Protocol.Preload.PreloadingStatus|'NotTriggered'\n//\n// A renderer sends SpeculationCandidate to the browser process and the\n// browser process checks eligibilities, and starts PreloadingAttempt.\n//\n// In the frontend, \"NotTriggered\" is used to denote that a\n// PreloadingAttempt is waiting for at trigger event (eg:\n// mousedown/mouseover). All PreloadingAttempts will start off as\n// \"NotTriggered\", but \"eager\" preloading attempts (attempts not\n// actually waiting for any trigger) will be processed by the browser\n// immediately, and will not stay in this state for long.\n//\n// TODO(https://crbug.com/1384419): Add NotEligible.\nexport const enum PreloadingStatus {\n  NOT_TRIGGERED = 'NotTriggered',\n  PENDING = 'Pending',\n  RUNNING = 'Running',\n  READY = 'Ready',\n  SUCCESS = 'Success',\n  FAILURE = 'Failure',\n  NOT_SUPPORTED = 'NotSupported',\n}\n\nfunction convertPreloadingStatus(status: Protocol.Preload.PreloadingStatus): PreloadingStatus {\n  switch (status) {\n    case Protocol.Preload.PreloadingStatus.Pending:\n      return PreloadingStatus.PENDING;\n    case Protocol.Preload.PreloadingStatus.Running:\n      return PreloadingStatus.RUNNING;\n    case Protocol.Preload.PreloadingStatus.Ready:\n      return PreloadingStatus.READY;\n    case Protocol.Preload.PreloadingStatus.Success:\n      return PreloadingStatus.SUCCESS;\n    case Protocol.Preload.PreloadingStatus.Failure:\n      return PreloadingStatus.FAILURE;\n    case Protocol.Preload.PreloadingStatus.NotSupported:\n      return PreloadingStatus.NOT_SUPPORTED;\n  }\n\n  throw new Error('unreachable');\n}\n\nexport type PreloadingAttemptId = string;\n\nexport type PreloadingAttempt = PrefetchAttempt|PrerenderAttempt;\n\nexport interface PrefetchAttempt {\n  action: Protocol.Preload.SpeculationAction.Prefetch;\n  key: Protocol.Preload.PreloadingAttemptKey;\n  status: PreloadingStatus;\n  prefetchStatus: Protocol.Preload.PrefetchStatus|null;\n  requestId: Protocol.Network.RequestId;\n  ruleSetIds: Protocol.Preload.RuleSetId[];\n  nodeIds: Protocol.DOM.BackendNodeId[];\n}\n\nexport interface PrerenderAttempt {\n  action: Protocol.Preload.SpeculationAction.Prerender;\n  key: Protocol.Preload.PreloadingAttemptKey;\n  status: PreloadingStatus;\n  prerenderStatus: Protocol.Preload.PrerenderFinalStatus|null;\n  disallowedMojoInterface: string|null;\n  mismatchedHeaders: Protocol.Preload.PrerenderMismatchedHeaders[]|null;\n  ruleSetIds: Protocol.Preload.RuleSetId[];\n  nodeIds: Protocol.DOM.BackendNodeId[];\n}\n\nexport type PreloadingAttemptInternal = PrefetchAttemptInternal|PrerenderAttemptInternal;\n\nexport interface PrefetchAttemptInternal {\n  action: Protocol.Preload.SpeculationAction.Prefetch;\n  key: Protocol.Preload.PreloadingAttemptKey;\n  status: PreloadingStatus;\n  prefetchStatus: Protocol.Preload.PrefetchStatus|null;\n  requestId: Protocol.Network.RequestId;\n}\n\nexport interface PrerenderAttemptInternal {\n  action: Protocol.Preload.SpeculationAction.Prerender;\n  key: Protocol.Preload.PreloadingAttemptKey;\n  status: PreloadingStatus;\n  prerenderStatus: Protocol.Preload.PrerenderFinalStatus|null;\n  disallowedMojoInterface: string|null;\n  mismatchedHeaders: Protocol.Preload.PrerenderMismatchedHeaders[]|null;\n}\n\nfunction makePreloadingAttemptId(key: Protocol.Preload.PreloadingAttemptKey): PreloadingAttemptId {\n  let action;\n  switch (key.action) {\n    case Protocol.Preload.SpeculationAction.Prefetch:\n      action = 'Prefetch';\n      break;\n    case Protocol.Preload.SpeculationAction.Prerender:\n      action = 'Prerender';\n      break;\n  }\n\n  let targetHint;\n  switch (key.targetHint) {\n    case undefined:\n      targetHint = 'undefined';\n      break;\n    case Protocol.Preload.SpeculationTargetHint.Blank:\n      targetHint = 'Blank';\n      break;\n    case Protocol.Preload.SpeculationTargetHint.Self:\n      targetHint = 'Self';\n      break;\n  }\n\n  return `${key.loaderId}:${action}:${key.url}:${targetHint}`;\n}\n\nclass PreloadingAttemptRegistry {\n  private map: Map<PreloadingAttemptId, PreloadingAttemptInternal> =\n      new Map<PreloadingAttemptId, PreloadingAttemptInternal>();\n\n  private enrich(attempt: PreloadingAttemptInternal, source: Protocol.Preload.PreloadingAttemptSource|null):\n      PreloadingAttempt {\n    let ruleSetIds: Protocol.Preload.RuleSetId[] = [];\n    let nodeIds: Protocol.DOM.BackendNodeId[] = [];\n    if (source !== null) {\n      ruleSetIds = source.ruleSetIds;\n      nodeIds = source.nodeIds;\n    }\n\n    return {\n      ...attempt,\n      ruleSetIds,\n      nodeIds,\n    };\n  }\n\n  // Returns reference. Don't save returned values.\n  // Returned values may or may not be updated as the time grows.\n  getById(id: PreloadingAttemptId, sources: SourceRegistry): PreloadingAttempt|null {\n    const attempt = this.map.get(id) || null;\n    if (attempt === null) {\n      return null;\n    }\n\n    return this.enrich(attempt, sources.getById(id));\n  }\n\n  // Returs preloading attempts that triggered by the rule set with `ruleSetId`.\n  // `ruleSetId === null` means \"do not filter\".\n  //\n  // Returns reference. Don't save returned values.\n  // Returned values may or may not be updated as the time grows.\n  getAll(ruleSetId: Protocol.Preload.RuleSetId|null, sources: SourceRegistry):\n      WithId<PreloadingAttemptId, PreloadingAttempt>[] {\n    return [...this.map.entries()]\n        .map(([id, value]) => ({id, value: this.enrich(value, sources.getById(id))}))\n        .filter(({value}) => !ruleSetId || value.ruleSetIds.includes(ruleSetId));\n  }\n\n  upsert(attempt: PreloadingAttemptInternal): void {\n    const id = makePreloadingAttemptId(attempt.key);\n\n    this.map.set(id, attempt);\n  }\n\n  // Speculation rules emits a CDP event Preload.preloadingAttemptSourcesUpdated\n  // and an IPC SpeculationHost::UpdateSpeculationCandidates. The latter emits\n  // Preload.prefetch/prerenderAttemptUpdated for each preload attempt triggered.\n  // In general, \"Not triggered to triggered\" period is short (resp. long) for\n  // eager (resp. non-eager) preloads. For not yet emitted ones, we fill\n  // \"Not triggered\" preload attempts and show them.\n  maybeRegisterNotTriggered(sources: SourceRegistry): void {\n    for (const [id, {key}] of sources.entries()) {\n      if (this.map.get(id) !== undefined) {\n        continue;\n      }\n\n      let attempt: PreloadingAttemptInternal;\n      switch (key.action) {\n        case Protocol.Preload.SpeculationAction.Prefetch:\n          attempt = {\n            action: Protocol.Preload.SpeculationAction.Prefetch,\n            key,\n            status: PreloadingStatus.NOT_TRIGGERED,\n            prefetchStatus: null,\n            // Fill invalid request id.\n            requestId: '' as Protocol.Network.RequestId,\n          };\n          break;\n        case Protocol.Preload.SpeculationAction.Prerender:\n          attempt = {\n            action: Protocol.Preload.SpeculationAction.Prerender,\n            key,\n            status: PreloadingStatus.NOT_TRIGGERED,\n            prerenderStatus: null,\n            disallowedMojoInterface: null,\n            mismatchedHeaders: null,\n          };\n          break;\n      }\n      this.map.set(id, attempt);\n    }\n  }\n\n  // Removes keys in `this.map` that are not in `sources`. This is used to\n  // remove attempts that no longer have a matching speculation rule.\n  cleanUpRemovedAttempts(sources: SourceRegistry): void {\n    const keysToRemove = Array.from(this.map.keys()).filter(key => !sources.getById(key));\n    for (const key of keysToRemove) {\n      this.map.delete(key);\n    }\n  }\n\n  mergePrevious(prev: PreloadingAttemptRegistry): void {\n    for (const [id, attempt] of this.map.entries()) {\n      prev.map.set(id, attempt);\n    }\n\n    this.map = prev.map;\n  }\n}\n\nclass SourceRegistry {\n  private map: Map<PreloadingAttemptId, Protocol.Preload.PreloadingAttemptSource> =\n      new Map<PreloadingAttemptId, Protocol.Preload.PreloadingAttemptSource>();\n\n  entries(): IterableIterator<[PreloadingAttemptId, Protocol.Preload.PreloadingAttemptSource]> {\n    return this.map.entries();\n  }\n\n  isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n  getById(id: PreloadingAttemptId): Protocol.Preload.PreloadingAttemptSource|null {\n    return this.map.get(id) || null;\n  }\n\n  update(sources: Protocol.Preload.PreloadingAttemptSource[]): void {\n    this.map = new Map(sources.map(s => [makePreloadingAttemptId(s.key), s]));\n  }\n}\n"],
  "mappings": "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",
  "names": ["Events", "PreloadingStatus"]
}
