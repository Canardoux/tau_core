{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/DebuggerModel.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2010 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the #name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Common from '../common/common.js';\nimport * as Host from '../host/host.js';\nimport * as i18n from '../i18n/i18n.js';\nimport * as Platform from '../platform/platform.js';\nimport * as Root from '../root/root.js';\n\nimport type {PageResourceLoadInitiator} from './PageResourceLoader.js';\nimport {type GetPropertiesResult, type RemoteObject, RemoteObjectProperty, ScopeRef} from './RemoteObject.js';\nimport {Events as ResourceTreeModelEvents, ResourceTreeModel} from './ResourceTreeModel.js';\nimport {type EvaluationOptions, type EvaluationResult, type ExecutionContext, RuntimeModel} from './RuntimeModel.js';\nimport {Script} from './Script.js';\nimport {SDKModel} from './SDKModel.js';\nimport {SourceMapManager} from './SourceMapManager.js';\nimport {Capability, type Target, Type} from './Target.js';\n\nconst UIStrings = {\n  /**\n   *@description Title of a section in the debugger showing local JavaScript variables.\n   */\n  local: 'Local',\n  /**\n   *@description Text that refers to closure as a programming term\n   */\n  closure: 'Closure',\n  /**\n   *@description Noun that represents a section or block of code in the Debugger Model. Shown in the Sources tab, while paused on a breakpoint.\n   */\n  block: 'Block',\n  /**\n   *@description Label for a group of JavaScript files\n   */\n  script: 'Script',\n  /**\n   *@description Title of a section in the debugger showing JavaScript variables from the a 'with'\n   *block. Block here means section of code, 'with' refers to a JavaScript programming concept and\n   *is a fixed term.\n   */\n  withBlock: '`With` block',\n  /**\n   *@description Title of a section in the debugger showing JavaScript variables from the a 'catch'\n   *block. Block here means section of code, 'catch' refers to a JavaScript programming concept and\n   *is a fixed term.\n   */\n  catchBlock: '`Catch` block',\n  /**\n   *@description Title of a section in the debugger showing JavaScript variables from the global scope.\n   */\n  global: 'Global',\n  /**\n   *@description Text for a JavaScript module, the programming concept\n   */\n  module: 'Module',\n  /**\n   *@description Text describing the expression scope in WebAssembly\n   */\n  expression: 'Expression',\n  /**\n   *@description Text in Scope Chain Sidebar Pane of the Sources panel\n   */\n  exception: 'Exception',\n  /**\n   *@description Text in Scope Chain Sidebar Pane of the Sources panel\n   */\n  returnValue: 'Return value',\n};\nconst str_ = i18n.i18n.registerUIStrings('core/sdk/DebuggerModel.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport function sortAndMergeRanges(locationRanges: Protocol.Debugger.LocationRange[]):\n    Protocol.Debugger.LocationRange[] {\n  function compare(p1: Protocol.Debugger.ScriptPosition, p2: Protocol.Debugger.ScriptPosition): number {\n    return (p1.lineNumber - p2.lineNumber) || (p1.columnNumber - p2.columnNumber);\n  }\n  function overlap(r1: Protocol.Debugger.LocationRange, r2: Protocol.Debugger.LocationRange): boolean {\n    if (r1.scriptId !== r2.scriptId) {\n      return false;\n    }\n    const n = compare(r1.start, r2.start);\n    if (n < 0) {\n      return compare(r1.end, r2.start) >= 0;\n    }\n    if (n > 0) {\n      return compare(r1.start, r2.end) <= 0;\n    }\n    return true;\n  }\n\n  if (locationRanges.length === 0) {\n    return [];\n  }\n  locationRanges.sort((r1, r2) => {\n    if (r1.scriptId < r2.scriptId) {\n      return -1;\n    }\n    if (r1.scriptId > r2.scriptId) {\n      return 1;\n    }\n    return compare(r1.start, r2.start) || compare(r1.end, r2.end);\n  });\n  let prev = locationRanges[0];\n  const merged = [];\n  for (let i = 1; i < locationRanges.length; ++i) {\n    const curr = locationRanges[i];\n    if (overlap(prev, curr)) {\n      if (compare(prev.end, curr.end) <= 0) {\n        prev = {...prev, end: curr.end};\n      }\n    } else {\n      merged.push(prev);\n      prev = curr;\n    }\n  }\n  merged.push(prev);\n  return merged;\n}\n\nexport const enum StepMode {\n  STEP_INTO = 'StepInto',\n  STEP_OUT = 'StepOut',\n  STEP_OVER = 'StepOver',\n}\n\nexport const WASM_SYMBOLS_PRIORITY = [\n  Protocol.Debugger.DebugSymbolsType.ExternalDWARF,\n  Protocol.Debugger.DebugSymbolsType.EmbeddedDWARF,\n  Protocol.Debugger.DebugSymbolsType.SourceMap,\n];\n\nexport class DebuggerModel extends SDKModel<EventTypes> {\n  readonly agent: ProtocolProxyApi.DebuggerApi;\n  runtimeModelInternal: RuntimeModel;\n  readonly #sourceMapManagerInternal: SourceMapManager<Script>;\n  #debuggerPausedDetailsInternal: DebuggerPausedDetails|null;\n  readonly #scriptsInternal: Map<string, Script>;\n  readonly #scriptsBySourceURL: Map<string, Script[]>;\n  #discardableScripts: Script[];\n  continueToLocationCallback: ((arg0: DebuggerPausedDetails) => boolean)|null;\n  #selectedCallFrameInternal: CallFrame|null;\n  #debuggerEnabledInternal: boolean;\n  #debuggerId: string|null;\n  #skipAllPausesTimeout: number;\n  #beforePausedCallback: ((arg0: DebuggerPausedDetails, stepOver: Location|null) => Promise<boolean>)|null;\n  #computeAutoStepRangesCallback: ((arg0: StepMode, arg1: CallFrame) => Promise<Array<{\n                                     start: Location,\n                                     end: Location,\n                                   }>>)|null;\n  #expandCallFramesCallback: ((arg0: Array<CallFrame>) => Promise<Array<CallFrame>>)|null;\n  evaluateOnCallFrameCallback: ((arg0: CallFrame, arg1: EvaluationOptions) => Promise<EvaluationResult|null>)|null;\n  #synchronizeBreakpointsCallback: ((script: Script) => Promise<void>)|null;\n  // We need to be able to register listeners for individual breakpoints. As such, we dispatch\n  // on breakpoint ids, which are not statically known. The event #payload will always be a `Location`.\n  readonly #breakpointResolvedEventTarget =\n      new Common.ObjectWrapper.ObjectWrapper<{[breakpointId: string]: Location}>();\n  // When stepping over with autostepping enabled, the context denotes the function to which autostepping is restricted\n  // to by way of its functionLocation (as per Debugger.CallFrame).\n  #autoSteppingContext: Location|null;\n  #isPausingInternal: boolean;\n\n  constructor(target: Target) {\n    super(target);\n\n    target.registerDebuggerDispatcher(new DebuggerDispatcher(this));\n    this.agent = target.debuggerAgent();\n    this.runtimeModelInternal = (target.model(RuntimeModel) as RuntimeModel);\n\n    this.#sourceMapManagerInternal = new SourceMapManager(target);\n\n    this.#debuggerPausedDetailsInternal = null;\n    this.#scriptsInternal = new Map();\n    this.#scriptsBySourceURL = new Map();\n    this.#discardableScripts = [];\n    this.continueToLocationCallback = null;\n    this.#selectedCallFrameInternal = null;\n    this.#debuggerEnabledInternal = false;\n    this.#debuggerId = null;\n    this.#skipAllPausesTimeout = 0;\n    this.#beforePausedCallback = null;\n    this.#computeAutoStepRangesCallback = null;\n    this.#expandCallFramesCallback = null;\n    this.evaluateOnCallFrameCallback = null;\n    this.#synchronizeBreakpointsCallback = null;\n\n    this.#autoSteppingContext = null;\n\n    this.#isPausingInternal = false;\n    Common.Settings.Settings.instance()\n        .moduleSetting('pause-on-exception-enabled')\n        .addChangeListener(this.pauseOnExceptionStateChanged, this);\n    Common.Settings.Settings.instance()\n        .moduleSetting('pause-on-caught-exception')\n        .addChangeListener(this.pauseOnExceptionStateChanged, this);\n    Common.Settings.Settings.instance()\n        .moduleSetting('pause-on-uncaught-exception')\n        .addChangeListener(this.pauseOnExceptionStateChanged, this);\n    Common.Settings.Settings.instance()\n        .moduleSetting('disable-async-stack-traces')\n        .addChangeListener(this.asyncStackTracesStateChanged, this);\n    Common.Settings.Settings.instance()\n        .moduleSetting('breakpoints-active')\n        .addChangeListener(this.breakpointsActiveChanged, this);\n\n    if (!target.suspended()) {\n      void this.enableDebugger();\n    }\n\n    this.#sourceMapManagerInternal.setEnabled(\n        Common.Settings.Settings.instance().moduleSetting('js-source-maps-enabled').get());\n    Common.Settings.Settings.instance()\n        .moduleSetting('js-source-maps-enabled')\n        .addChangeListener(event => this.#sourceMapManagerInternal.setEnabled((event.data as boolean)));\n\n    const resourceTreeModel = (target.model(ResourceTreeModel) as ResourceTreeModel);\n    if (resourceTreeModel) {\n      resourceTreeModel.addEventListener(ResourceTreeModelEvents.FrameNavigated, this.onFrameNavigated, this);\n    }\n  }\n\n  static selectSymbolSource(debugSymbols: Protocol.Debugger.DebugSymbols[]|null): Protocol.Debugger.DebugSymbols|null {\n    if (!debugSymbols || debugSymbols.length === 0) {\n      return null;\n    }\n\n    // Provides backwards compatibility to previous CDP version on Protocol.Debugger.DebugSymbols.\n    // TODO(crbug.com/369515221): Remove extra code as soon as old v8 versions used in Node are no longer supported.\n    if ('type' in debugSymbols) {\n      if (debugSymbols.type === 'None') {\n        return null;\n      }\n      return debugSymbols as Protocol.Debugger.DebugSymbols;\n    }\n\n    let debugSymbolsSource = null;\n    const symbolTypes = new Map(debugSymbols.map(symbol => [symbol.type, symbol]));\n    for (const symbol of WASM_SYMBOLS_PRIORITY) {\n      if (symbolTypes.has(symbol)) {\n        debugSymbolsSource = symbolTypes.get(symbol) || null;\n        break;\n      }\n    }\n\n    console.assert(\n        debugSymbolsSource !== null,\n        'Unknown symbol types. Front-end and back-end should be kept in sync regarding Protocol.Debugger.DebugSymbolTypes');\n    if (debugSymbolsSource && debugSymbols.length > 1) {\n      Common.Console.Console.instance().warn(\n          `Multiple debug symbols for script were found. Using ${debugSymbolsSource.type}`);\n    }\n    return debugSymbolsSource;\n  }\n\n  sourceMapManager(): SourceMapManager<Script> {\n    return this.#sourceMapManagerInternal;\n  }\n\n  runtimeModel(): RuntimeModel {\n    return this.runtimeModelInternal;\n  }\n\n  debuggerEnabled(): boolean {\n    return Boolean(this.#debuggerEnabledInternal);\n  }\n\n  debuggerId(): string|null {\n    return this.#debuggerId;\n  }\n\n  private async enableDebugger(): Promise<void> {\n    if (this.#debuggerEnabledInternal) {\n      return;\n    }\n    this.#debuggerEnabledInternal = true;\n\n    // Set a limit for the total size of collected script sources retained by debugger.\n    // 10MB for remote frontends, 100MB for others.\n    const isRemoteFrontend = Root.Runtime.Runtime.queryParam('remoteFrontend') || Root.Runtime.Runtime.queryParam('ws');\n    const maxScriptsCacheSize = isRemoteFrontend ? 10e6 : 100e6;\n    const enablePromise = this.agent.invoke_enable({maxScriptsCacheSize});\n    let instrumentationPromise: Promise<Protocol.Debugger.SetInstrumentationBreakpointResponse>|undefined;\n    if (Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n      instrumentationPromise = this.agent.invoke_setInstrumentationBreakpoint({\n        instrumentation: Protocol.Debugger.SetInstrumentationBreakpointRequestInstrumentation.BeforeScriptExecution,\n      });\n    }\n    this.pauseOnExceptionStateChanged();\n    void this.asyncStackTracesStateChanged();\n    if (!Common.Settings.Settings.instance().moduleSetting('breakpoints-active').get()) {\n      this.breakpointsActiveChanged();\n    }\n    this.dispatchEventToListeners(Events.DebuggerWasEnabled, this);\n    const [enableResult] = await Promise.all([enablePromise, instrumentationPromise]);\n    this.registerDebugger(enableResult);\n  }\n\n  async syncDebuggerId(): Promise<Protocol.Debugger.EnableResponse> {\n    const isRemoteFrontend = Root.Runtime.Runtime.queryParam('remoteFrontend') || Root.Runtime.Runtime.queryParam('ws');\n    const maxScriptsCacheSize = isRemoteFrontend ? 10e6 : 100e6;\n    const enablePromise = this.agent.invoke_enable({maxScriptsCacheSize});\n    void enablePromise.then(this.registerDebugger.bind(this));\n    return enablePromise;\n  }\n\n  private onFrameNavigated(): void {\n    if (DebuggerModel.shouldResyncDebuggerId) {\n      return;\n    }\n\n    DebuggerModel.shouldResyncDebuggerId = true;\n  }\n\n  private registerDebugger(response: Protocol.Debugger.EnableResponse): void {\n    if (response.getError()) {\n      this.#debuggerEnabledInternal = false;\n      return;\n    }\n    const {debuggerId} = response;\n    debuggerIdToModel.set(debuggerId, this);\n    this.#debuggerId = debuggerId;\n    this.dispatchEventToListeners(Events.DebuggerIsReadyToPause, this);\n  }\n\n  isReadyToPause(): boolean {\n    return Boolean(this.#debuggerId);\n  }\n\n  static async modelForDebuggerId(debuggerId: string): Promise<DebuggerModel|null> {\n    if (DebuggerModel.shouldResyncDebuggerId) {\n      await DebuggerModel.resyncDebuggerIdForModels();\n      DebuggerModel.shouldResyncDebuggerId = false;\n    }\n    return debuggerIdToModel.get(debuggerId) || null;\n  }\n\n  static async resyncDebuggerIdForModels(): Promise<void> {\n    const dbgModels = debuggerIdToModel.values();\n    for (const dbgModel of dbgModels) {\n      if (dbgModel.debuggerEnabled()) {\n        await dbgModel.syncDebuggerId();\n      }\n    }\n  }\n\n  private async disableDebugger(): Promise<void> {\n    if (!this.#debuggerEnabledInternal) {\n      return;\n    }\n    this.#debuggerEnabledInternal = false;\n\n    await this.asyncStackTracesStateChanged();\n    await this.agent.invoke_disable();\n    this.#isPausingInternal = false;\n    this.globalObjectCleared();\n    this.dispatchEventToListeners(Events.DebuggerWasDisabled, this);\n    if (typeof this.#debuggerId === 'string') {\n      debuggerIdToModel.delete(this.#debuggerId);\n    }\n    this.#debuggerId = null;\n  }\n\n  private skipAllPauses(skip: boolean): void {\n    if (this.#skipAllPausesTimeout) {\n      clearTimeout(this.#skipAllPausesTimeout);\n      this.#skipAllPausesTimeout = 0;\n    }\n    void this.agent.invoke_setSkipAllPauses({skip});\n  }\n\n  skipAllPausesUntilReloadOrTimeout(timeout: number): void {\n    if (this.#skipAllPausesTimeout) {\n      clearTimeout(this.#skipAllPausesTimeout);\n    }\n    void this.agent.invoke_setSkipAllPauses({skip: true});\n    // If reload happens before the timeout, the flag will be already unset and the timeout callback won't change anything.\n    this.#skipAllPausesTimeout = window.setTimeout(this.skipAllPauses.bind(this, false), timeout);\n  }\n\n  private pauseOnExceptionStateChanged(): void {\n    const pauseOnCaughtEnabled = Common.Settings.Settings.instance().moduleSetting('pause-on-caught-exception').get();\n    let state: Protocol.Debugger.SetPauseOnExceptionsRequestState;\n\n    const pauseOnUncaughtEnabled =\n        Common.Settings.Settings.instance().moduleSetting('pause-on-uncaught-exception').get();\n    if (pauseOnCaughtEnabled && pauseOnUncaughtEnabled) {\n      state = Protocol.Debugger.SetPauseOnExceptionsRequestState.All;\n    } else if (pauseOnCaughtEnabled) {\n      state = Protocol.Debugger.SetPauseOnExceptionsRequestState.Caught;\n    } else if (pauseOnUncaughtEnabled) {\n      state = Protocol.Debugger.SetPauseOnExceptionsRequestState.Uncaught;\n    } else {\n      state = Protocol.Debugger.SetPauseOnExceptionsRequestState.None;\n    }\n    void this.agent.invoke_setPauseOnExceptions({state});\n  }\n\n  private asyncStackTracesStateChanged(): Promise<Protocol.ProtocolResponseWithError> {\n    const maxAsyncStackChainDepth = 32;\n    const enabled = !Common.Settings.Settings.instance().moduleSetting('disable-async-stack-traces').get() &&\n        this.#debuggerEnabledInternal;\n    const maxDepth = enabled ? maxAsyncStackChainDepth : 0;\n    return this.agent.invoke_setAsyncCallStackDepth({maxDepth});\n  }\n\n  private breakpointsActiveChanged(): void {\n    void this.agent.invoke_setBreakpointsActive(\n        {active: Common.Settings.Settings.instance().moduleSetting('breakpoints-active').get()});\n  }\n\n  setComputeAutoStepRangesCallback(callback: ((arg0: StepMode, arg1: CallFrame) => Promise<LocationRange[]>)|\n                                   null): void {\n    this.#computeAutoStepRangesCallback = callback;\n  }\n\n  private async computeAutoStepSkipList(mode: StepMode): Promise<Protocol.Debugger.LocationRange[]> {\n    let ranges: LocationRange[] = [];\n    if (this.#computeAutoStepRangesCallback && this.#debuggerPausedDetailsInternal &&\n        this.#debuggerPausedDetailsInternal.callFrames.length > 0) {\n      const [callFrame] = this.#debuggerPausedDetailsInternal.callFrames;\n      ranges = await this.#computeAutoStepRangesCallback.call(null, mode, callFrame);\n    }\n    const skipList = ranges.map(({start, end}) => ({\n                                  scriptId: start.scriptId,\n                                  start: {lineNumber: start.lineNumber, columnNumber: start.columnNumber},\n                                  end: {lineNumber: end.lineNumber, columnNumber: end.columnNumber},\n                                }));\n    return sortAndMergeRanges(skipList);\n  }\n\n  async stepInto(): Promise<void> {\n    const skipList = await this.computeAutoStepSkipList(StepMode.STEP_INTO);\n    void this.agent.invoke_stepInto({breakOnAsyncCall: false, skipList});\n  }\n\n  async stepOver(): Promise<void> {\n    this.#autoSteppingContext = this.#debuggerPausedDetailsInternal?.callFrames[0]?.functionLocation() ?? null;\n    const skipList = await this.computeAutoStepSkipList(StepMode.STEP_OVER);\n    void this.agent.invoke_stepOver({skipList});\n  }\n\n  async stepOut(): Promise<void> {\n    const skipList = await this.computeAutoStepSkipList(StepMode.STEP_OUT);\n    if (skipList.length !== 0) {\n      void this.agent.invoke_stepOver({skipList});\n    } else {\n      void this.agent.invoke_stepOut();\n    }\n  }\n\n  scheduleStepIntoAsync(): void {\n    void this.computeAutoStepSkipList(StepMode.STEP_INTO).then(skipList => {\n      void this.agent.invoke_stepInto({breakOnAsyncCall: true, skipList});\n    });\n  }\n\n  resume(): void {\n    void this.agent.invoke_resume({terminateOnResume: false});\n    this.#isPausingInternal = false;\n  }\n\n  pause(): void {\n    this.#isPausingInternal = true;\n    this.skipAllPauses(false);\n    void this.agent.invoke_pause();\n  }\n\n  async setBreakpointByURL(\n      url: Platform.DevToolsPath.UrlString, lineNumber: number, columnNumber?: number,\n      condition?: BackendCondition): Promise<SetBreakpointResult> {\n    // Convert file url to node-js path.\n    let urlRegex;\n    if (this.target().type() === Type.NODE && Common.ParsedURL.schemeIs(url, 'file:')) {\n      const platformPath = Common.ParsedURL.ParsedURL.urlToRawPathString(url, Host.Platform.isWin());\n      urlRegex =\n          `${Platform.StringUtilities.escapeForRegExp(platformPath)}|${Platform.StringUtilities.escapeForRegExp(url)}`;\n      if (Host.Platform.isWin() && platformPath.match(/^.:\\\\/)) {\n        // Match upper or lower case drive letter\n        urlRegex = `[${platformPath[0].toUpperCase()}${platformPath[0].toLowerCase()}]` + urlRegex.substr(1);\n      }\n    }\n    // Adjust column if needed.\n    let minColumnNumber = 0;\n    const scripts = this.#scriptsBySourceURL.get(url) || [];\n    for (let i = 0, l = scripts.length; i < l; ++i) {\n      const script = scripts[i];\n      if (lineNumber === script.lineOffset) {\n        minColumnNumber = minColumnNumber ? Math.min(minColumnNumber, script.columnOffset) : script.columnOffset;\n      }\n    }\n    columnNumber = Math.max(columnNumber || 0, minColumnNumber);\n    const response = await this.agent.invoke_setBreakpointByUrl({\n      lineNumber,\n      url: urlRegex ? undefined : url,\n      urlRegex,\n      columnNumber,\n      condition,\n    });\n    if (response.getError()) {\n      return {locations: [], breakpointId: null};\n    }\n    let locations: Location[] = [];\n    if (response.locations) {\n      locations = response.locations.map(payload => Location.fromPayload(this, payload));\n    }\n    return {locations, breakpointId: response.breakpointId};\n  }\n\n  async setBreakpointInAnonymousScript(\n      scriptHash: string, lineNumber: number, columnNumber?: number,\n      condition?: BackendCondition): Promise<SetBreakpointResult> {\n    const response = await this.agent.invoke_setBreakpointByUrl({lineNumber, scriptHash, columnNumber, condition});\n    if (response.getError()) {\n      return {locations: [], breakpointId: null};\n    }\n    let locations: Location[] = [];\n    if (response.locations) {\n      locations = response.locations.map(payload => Location.fromPayload(this, payload));\n    }\n    return {locations, breakpointId: response.breakpointId};\n  }\n\n  async removeBreakpoint(breakpointId: Protocol.Debugger.BreakpointId): Promise<void> {\n    await this.agent.invoke_removeBreakpoint({breakpointId});\n  }\n\n  async getPossibleBreakpoints(startLocation: Location, endLocation: Location|null, restrictToFunction: boolean):\n      Promise<BreakLocation[]> {\n    const response = await this.agent.invoke_getPossibleBreakpoints({\n      start: startLocation.payload(),\n      end: endLocation ? endLocation.payload() : undefined,\n      restrictToFunction,\n    });\n    if (response.getError() || !response.locations) {\n      return [];\n    }\n    return response.locations.map(location => BreakLocation.fromPayload(this, location));\n  }\n\n  async fetchAsyncStackTrace(stackId: Protocol.Runtime.StackTraceId): Promise<Protocol.Runtime.StackTrace|null> {\n    const response = await this.agent.invoke_getStackTrace({stackTraceId: stackId});\n    return response.getError() ? null : response.stackTrace;\n  }\n\n  breakpointResolved(breakpointId: string, location: Protocol.Debugger.Location): void {\n    this.#breakpointResolvedEventTarget.dispatchEventToListeners(breakpointId, Location.fromPayload(this, location));\n  }\n\n  globalObjectCleared(): void {\n    this.resetDebuggerPausedDetails();\n    this.reset();\n    // TODO(dgozman): move clients to ExecutionContextDestroyed/ScriptCollected events.\n    this.dispatchEventToListeners(Events.GlobalObjectCleared, this);\n  }\n\n  private reset(): void {\n    for (const script of this.#scriptsInternal.values()) {\n      this.#sourceMapManagerInternal.detachSourceMap(script);\n    }\n    this.#scriptsInternal.clear();\n    this.#scriptsBySourceURL.clear();\n    this.#discardableScripts = [];\n    this.#autoSteppingContext = null;\n  }\n\n  scripts(): Script[] {\n    return Array.from(this.#scriptsInternal.values());\n  }\n\n  scriptForId(scriptId: string): Script|null {\n    return this.#scriptsInternal.get(scriptId) || null;\n  }\n\n  /**\n   * Returns all `Script` objects with the same provided `sourceURL`. The\n   * resulting array is sorted by time with the newest `Script` in the front.\n   */\n  scriptsForSourceURL(sourceURL: string): Script[] {\n    return this.#scriptsBySourceURL.get(sourceURL) || [];\n  }\n\n  scriptsForExecutionContext(executionContext: ExecutionContext): Script[] {\n    const result = [];\n    for (const script of this.#scriptsInternal.values()) {\n      if (script.executionContextId === executionContext.id) {\n        result.push(script);\n      }\n    }\n    return result;\n  }\n\n  get callFrames(): CallFrame[]|null {\n    return this.#debuggerPausedDetailsInternal ? this.#debuggerPausedDetailsInternal.callFrames : null;\n  }\n\n  debuggerPausedDetails(): DebuggerPausedDetails|null {\n    return this.#debuggerPausedDetailsInternal;\n  }\n\n  private async setDebuggerPausedDetails(debuggerPausedDetails: DebuggerPausedDetails): Promise<boolean> {\n    this.#isPausingInternal = false;\n    this.#debuggerPausedDetailsInternal = debuggerPausedDetails;\n    if (this.#beforePausedCallback) {\n      if (!await this.#beforePausedCallback.call(null, debuggerPausedDetails, this.#autoSteppingContext)) {\n        return false;\n      }\n    }\n    // If we resolved a location in auto-stepping callback, reset the\n    // auto-step-over context.\n    this.#autoSteppingContext = null;\n    this.dispatchEventToListeners(Events.DebuggerPaused, this);\n    this.setSelectedCallFrame(debuggerPausedDetails.callFrames[0]);\n    return true;\n  }\n\n  private resetDebuggerPausedDetails(): void {\n    this.#isPausingInternal = false;\n    this.#debuggerPausedDetailsInternal = null;\n    this.setSelectedCallFrame(null);\n  }\n\n  setBeforePausedCallback(callback:\n                              ((arg0: DebuggerPausedDetails, autoSteppingContext: Location|null) => Promise<boolean>)|\n                          null): void {\n    this.#beforePausedCallback = callback;\n  }\n\n  setExpandCallFramesCallback(callback: ((arg0: Array<CallFrame>) => Promise<Array<CallFrame>>)|null): void {\n    this.#expandCallFramesCallback = callback;\n  }\n\n  setEvaluateOnCallFrameCallback(callback:\n                                     ((arg0: CallFrame, arg1: EvaluationOptions) => Promise<EvaluationResult|null>)|\n                                 null): void {\n    this.evaluateOnCallFrameCallback = callback;\n  }\n\n  setSynchronizeBreakpointsCallback(callback: ((script: Script) => Promise<void>)|null): void {\n    this.#synchronizeBreakpointsCallback = callback;\n  }\n\n  async pausedScript(\n      callFrames: Protocol.Debugger.CallFrame[], reason: Protocol.Debugger.PausedEventReason, auxData: Object|undefined,\n      breakpointIds: string[], asyncStackTrace?: Protocol.Runtime.StackTrace,\n      asyncStackTraceId?: Protocol.Runtime.StackTraceId): Promise<void> {\n    if (reason === Protocol.Debugger.PausedEventReason.Instrumentation) {\n      const script = this.scriptForId((auxData as PausedOnInstrumentationData).scriptId);\n      if (this.#synchronizeBreakpointsCallback && script) {\n        await this.#synchronizeBreakpointsCallback(script);\n      }\n      this.resume();\n      return;\n    }\n\n    const pausedDetails =\n        new DebuggerPausedDetails(this, callFrames, reason, auxData, breakpointIds, asyncStackTrace, asyncStackTraceId);\n    await this.#expandCallFrames(pausedDetails);\n\n    if (this.continueToLocationCallback) {\n      const callback = this.continueToLocationCallback;\n      this.continueToLocationCallback = null;\n      if (callback(pausedDetails)) {\n        return;\n      }\n    }\n\n    if (!await this.setDebuggerPausedDetails(pausedDetails)) {\n      if (this.#autoSteppingContext) {\n        void this.stepOver();\n      } else {\n        void this.stepInto();\n      }\n    } else {\n      Common.EventTarget.fireEvent('DevTools.DebuggerPaused');\n    }\n  }\n\n  /** Delegates to the DebuggerLanguagePlugin and potential attached source maps to expand inlined call frames */\n  async #expandCallFrames(pausedDetails: DebuggerPausedDetails): Promise<void> {\n    if (this.#expandCallFramesCallback) {\n      pausedDetails.callFrames = await this.#expandCallFramesCallback.call(null, pausedDetails.callFrames);\n    }\n\n    if (!Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.USE_SOURCE_MAP_SCOPES)) {\n      return;\n    }\n\n    // TODO(crbug.com/40277685): Support attaching/detaching source maps after pausing.\n    // Expanding call frames via source maps here is only suitable for the experiment prototype because\n    // we block until all relevant source maps are loaded.\n    // We should change this so the \"Debugger Plugin\" and \"Source Map\" have a bottle neck where they expand\n    // call frames and that bottleneck should support attaching/detaching source maps while paused.\n    const finalFrames: CallFrame[] = [];\n    for (const frame of pausedDetails.callFrames) {\n      const sourceMap = await this.sourceMapManager().sourceMapForClientPromise(frame.script);\n      if (sourceMap?.hasScopeInfo()) {\n        finalFrames.push(...sourceMap.expandCallFrame(frame));\n      } else {\n        finalFrames.push(frame);\n      }\n    }\n    pausedDetails.callFrames = finalFrames;\n  }\n\n  resumedScript(): void {\n    this.resetDebuggerPausedDetails();\n    this.dispatchEventToListeners(Events.DebuggerResumed, this);\n  }\n\n  parsedScriptSource(\n      scriptId: Protocol.Runtime.ScriptId, sourceURL: Platform.DevToolsPath.UrlString, startLine: number,\n      startColumn: number, endLine: number, endColumn: number,\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      executionContextId: number, hash: string, executionContextAuxData: any, isLiveEdit: boolean,\n      sourceMapURL: string|undefined, hasSourceURLComment: boolean, hasSyntaxError: boolean, length: number,\n      isModule: boolean|null, originStackTrace: Protocol.Runtime.StackTrace|null, codeOffset: number|null,\n      scriptLanguage: string|null, debugSymbols: Protocol.Debugger.DebugSymbols[]|null,\n      embedderName: Platform.DevToolsPath.UrlString|null): Script {\n    const knownScript = this.#scriptsInternal.get(scriptId);\n    if (knownScript) {\n      return knownScript;\n    }\n    let isContentScript = false;\n    if (executionContextAuxData && ('isDefault' in executionContextAuxData)) {\n      isContentScript = !executionContextAuxData['isDefault'];\n    }\n\n    const selectedDebugSymbol = DebuggerModel.selectSymbolSource(debugSymbols);\n    const script = new Script(\n        this, scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, hash,\n        isContentScript, isLiveEdit, sourceMapURL, hasSourceURLComment, length, isModule, originStackTrace, codeOffset,\n        scriptLanguage, selectedDebugSymbol, embedderName);\n    this.registerScript(script);\n    this.dispatchEventToListeners(Events.ParsedScriptSource, script);\n\n    if (script.sourceMapURL && !hasSyntaxError) {\n      this.#sourceMapManagerInternal.attachSourceMap(script, script.sourceURL, script.sourceMapURL);\n    }\n\n    const isDiscardable = hasSyntaxError && script.isAnonymousScript();\n    if (isDiscardable) {\n      this.#discardableScripts.push(script);\n      this.collectDiscardedScripts();\n    }\n    return script;\n  }\n\n  setSourceMapURL(script: Script, newSourceMapURL: Platform.DevToolsPath.UrlString): void {\n    // Detach any previous source map from the `script` first.\n    this.#sourceMapManagerInternal.detachSourceMap(script);\n    script.sourceMapURL = newSourceMapURL;\n    this.#sourceMapManagerInternal.attachSourceMap(script, script.sourceURL, script.sourceMapURL);\n  }\n\n  async setDebugInfoURL(script: Script, _externalURL: Platform.DevToolsPath.UrlString): Promise<void> {\n    if (this.#expandCallFramesCallback && this.#debuggerPausedDetailsInternal) {\n      this.#debuggerPausedDetailsInternal.callFrames =\n          await this.#expandCallFramesCallback.call(null, this.#debuggerPausedDetailsInternal.callFrames);\n    }\n    this.dispatchEventToListeners(Events.DebugInfoAttached, script);\n  }\n\n  executionContextDestroyed(executionContext: ExecutionContext): void {\n    for (const script of this.#scriptsInternal.values()) {\n      if (script.executionContextId === executionContext.id) {\n        this.#sourceMapManagerInternal.detachSourceMap(script);\n      }\n    }\n  }\n\n  private registerScript(script: Script): void {\n    this.#scriptsInternal.set(script.scriptId, script);\n    if (script.isAnonymousScript()) {\n      return;\n    }\n\n    let scripts = this.#scriptsBySourceURL.get(script.sourceURL);\n    if (!scripts) {\n      scripts = [];\n      this.#scriptsBySourceURL.set(script.sourceURL, scripts);\n    }\n    // Newer scripts with the same URL should be preferred so we put them in\n    // the front. Consuming code usually will iterate over the array and pick\n    // the first script that works.\n    scripts.unshift(script);\n  }\n\n  private unregisterScript(script: Script): void {\n    console.assert(script.isAnonymousScript());\n    this.#scriptsInternal.delete(script.scriptId);\n  }\n\n  private collectDiscardedScripts(): void {\n    if (this.#discardableScripts.length < 1000) {\n      return;\n    }\n    const scriptsToDiscard = this.#discardableScripts.splice(0, 100);\n    for (const script of scriptsToDiscard) {\n      this.unregisterScript(script);\n      this.dispatchEventToListeners(Events.DiscardedAnonymousScriptSource, script);\n    }\n  }\n\n  createRawLocation(script: Script, lineNumber: number, columnNumber: number, inlineFrameIndex?: number): Location {\n    return this.createRawLocationByScriptId(script.scriptId, lineNumber, columnNumber, inlineFrameIndex);\n  }\n\n  createRawLocationByURL(sourceURL: string, lineNumber: number, columnNumber?: number, inlineFrameIndex?: number):\n      Location|null {\n    for (const script of this.#scriptsBySourceURL.get(sourceURL) || []) {\n      if (script.lineOffset > lineNumber ||\n          (script.lineOffset === lineNumber && columnNumber !== undefined && script.columnOffset > columnNumber)) {\n        continue;\n      }\n      if (script.endLine < lineNumber ||\n          (script.endLine === lineNumber && columnNumber !== undefined && script.endColumn <= columnNumber)) {\n        continue;\n      }\n      return new Location(this, script.scriptId, lineNumber, columnNumber, inlineFrameIndex);\n    }\n    return null;\n  }\n\n  createRawLocationByScriptId(\n      scriptId: Protocol.Runtime.ScriptId, lineNumber: number, columnNumber?: number,\n      inlineFrameIndex?: number): Location {\n    return new Location(this, scriptId, lineNumber, columnNumber, inlineFrameIndex);\n  }\n\n  createRawLocationsByStackTrace(stackTrace: Protocol.Runtime.StackTrace): Location[] {\n    const rawLocations: Location[] = [];\n    for (let current: Protocol.Runtime.StackTrace|undefined = stackTrace; current; current = current.parent) {\n      for (const {scriptId, lineNumber, columnNumber} of current.callFrames) {\n        rawLocations.push(this.createRawLocationByScriptId(scriptId, lineNumber, columnNumber));\n      }\n    }\n    return rawLocations;\n  }\n\n  isPaused(): boolean {\n    return Boolean(this.debuggerPausedDetails());\n  }\n\n  isPausing(): boolean {\n    return this.#isPausingInternal;\n  }\n\n  setSelectedCallFrame(callFrame: CallFrame|null): void {\n    if (this.#selectedCallFrameInternal === callFrame) {\n      return;\n    }\n    this.#selectedCallFrameInternal = callFrame;\n    this.dispatchEventToListeners(Events.CallFrameSelected, this);\n  }\n\n  selectedCallFrame(): CallFrame|null {\n    return this.#selectedCallFrameInternal;\n  }\n\n  async evaluateOnSelectedCallFrame(options: EvaluationOptions): Promise<EvaluationResult> {\n    const callFrame = this.selectedCallFrame();\n    if (!callFrame) {\n      throw new Error('No call frame selected');\n    }\n    return callFrame.evaluate(options);\n  }\n\n  functionDetailsPromise(remoteObject: RemoteObject): Promise<FunctionDetails|null> {\n    return remoteObject.getAllProperties(false /* accessorPropertiesOnly */, false /* generatePreview */)\n        .then(buildDetails.bind(this));\n\n    function buildDetails(this: DebuggerModel, response: GetPropertiesResult): FunctionDetails|null {\n      if (!response) {\n        return null;\n      }\n      let location: (RemoteObject|null|undefined)|null = null;\n      if (response.internalProperties) {\n        for (const prop of response.internalProperties) {\n          if (prop.name === '[[FunctionLocation]]') {\n            location = prop.value;\n          }\n        }\n      }\n      let functionName: RemoteObject|null = null;\n      if (response.properties) {\n        for (const prop of response.properties) {\n          if (prop.name === 'name' && prop.value && prop.value.type === 'string') {\n            functionName = prop.value;\n          }\n        }\n      }\n      let debuggerLocation: Location|null = null;\n      if (location) {\n        debuggerLocation = this.createRawLocationByScriptId(\n            location.value.scriptId, location.value.lineNumber, location.value.columnNumber);\n      }\n      return {location: debuggerLocation, functionName: functionName ? functionName.value as string : ''};\n    }\n  }\n\n  async setVariableValue(\n      scopeNumber: number, variableName: string, newValue: Protocol.Runtime.CallArgument,\n      callFrameId: Protocol.Debugger.CallFrameId): Promise<string|undefined> {\n    const response = await this.agent.invoke_setVariableValue({scopeNumber, variableName, newValue, callFrameId});\n    const error = response.getError();\n    return error;\n  }\n\n  addBreakpointListener(\n      breakpointId: string, listener: (arg0: Common.EventTarget.EventTargetEvent<Location>) => void,\n      thisObject?: Object): void {\n    this.#breakpointResolvedEventTarget.addEventListener(breakpointId, listener, thisObject);\n  }\n\n  removeBreakpointListener(\n      breakpointId: string, listener: (arg0: Common.EventTarget.EventTargetEvent<Location>) => void,\n      thisObject?: Object): void {\n    this.#breakpointResolvedEventTarget.removeEventListener(breakpointId, listener, thisObject);\n  }\n\n  async setBlackboxPatterns(patterns: string[], skipAnonymous: boolean): Promise<boolean> {\n    const response = await this.agent.invoke_setBlackboxPatterns({patterns, skipAnonymous});\n    const error = response.getError();\n    return !error;\n  }\n\n  async setBlackboxExecutionContexts(uniqueIds: string[]): Promise<boolean> {\n    const response = await this.agent.invoke_setBlackboxExecutionContexts({uniqueIds});\n    const error = response.getError();\n    return !error;\n  }\n\n  override dispose(): void {\n    if (this.#debuggerId) {\n      debuggerIdToModel.delete(this.#debuggerId);\n    }\n    Common.Settings.Settings.instance()\n        .moduleSetting('pause-on-exception-enabled')\n        .removeChangeListener(this.pauseOnExceptionStateChanged, this);\n    Common.Settings.Settings.instance()\n        .moduleSetting('pause-on-caught-exception')\n        .removeChangeListener(this.pauseOnExceptionStateChanged, this);\n    Common.Settings.Settings.instance()\n        .moduleSetting('disable-async-stack-traces')\n        .removeChangeListener(this.asyncStackTracesStateChanged, this);\n  }\n\n  override async suspendModel(): Promise<void> {\n    await this.disableDebugger();\n  }\n\n  override async resumeModel(): Promise<void> {\n    await this.enableDebugger();\n  }\n\n  private static shouldResyncDebuggerId = false;\n\n  getContinueToLocationCallback(): ((arg0: DebuggerPausedDetails) => boolean)|null {\n    return this.continueToLocationCallback;\n  }\n\n  getEvaluateOnCallFrameCallback():\n      ((arg0: CallFrame, arg1: EvaluationOptions) => Promise<EvaluationResult|null>)|null {\n    return this.evaluateOnCallFrameCallback;\n  }\n}\n\nconst debuggerIdToModel = new Map<string, DebuggerModel>();\n\n/**\n * Keep these in sync with WebCore::V8Debugger\n */\nexport enum PauseOnExceptionsState {\n  /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n  DontPauseOnExceptions = 'none',\n  PauseOnAllExceptions = 'all',\n  PauseOnCaughtExceptions = 'caught',\n  PauseOnUncaughtExceptions = 'uncaught',\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport enum Events {\n  /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n  DebuggerWasEnabled = 'DebuggerWasEnabled',\n  DebuggerWasDisabled = 'DebuggerWasDisabled',\n  DebuggerPaused = 'DebuggerPaused',\n  DebuggerResumed = 'DebuggerResumed',\n  DebugInfoAttached = 'DebugInfoAttached',\n  ParsedScriptSource = 'ParsedScriptSource',\n  DiscardedAnonymousScriptSource = 'DiscardedAnonymousScriptSource',\n  GlobalObjectCleared = 'GlobalObjectCleared',\n  CallFrameSelected = 'CallFrameSelected',\n  DebuggerIsReadyToPause = 'DebuggerIsReadyToPause',\n  ScriptSourceWasEdited = 'ScriptSourceWasEdited',\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport type EventTypes = {\n  [Events.DebuggerWasEnabled]: DebuggerModel,\n  [Events.DebuggerWasDisabled]: DebuggerModel,\n  [Events.DebuggerPaused]: DebuggerModel,\n  [Events.DebuggerResumed]: DebuggerModel,\n  [Events.ParsedScriptSource]: Script,\n  [Events.DiscardedAnonymousScriptSource]: Script,\n  [Events.GlobalObjectCleared]: DebuggerModel,\n  [Events.CallFrameSelected]: DebuggerModel,\n  [Events.DebuggerIsReadyToPause]: DebuggerModel,\n  [Events.DebugInfoAttached]: Script,\n  [Events.ScriptSourceWasEdited]: {\n    script: Script,\n    status: Protocol.Debugger.SetScriptSourceResponseStatus,\n  },\n};\n\nclass DebuggerDispatcher implements ProtocolProxyApi.DebuggerDispatcher {\n  #debuggerModel: DebuggerModel;\n\n  constructor(debuggerModel: DebuggerModel) {\n    this.#debuggerModel = debuggerModel;\n  }\n\n  paused({callFrames, reason, data, hitBreakpoints, asyncStackTrace, asyncStackTraceId}: Protocol.Debugger.PausedEvent):\n      void {\n    if (!this.#debuggerModel.debuggerEnabled()) {\n      return;\n    }\n    void this.#debuggerModel.pausedScript(\n        callFrames, reason, data, hitBreakpoints || [], asyncStackTrace, asyncStackTraceId);\n  }\n\n  resumed(): void {\n    if (!this.#debuggerModel.debuggerEnabled()) {\n      return;\n    }\n    this.#debuggerModel.resumedScript();\n  }\n\n  scriptParsed({\n    scriptId,\n    url,\n    startLine,\n    startColumn,\n    endLine,\n    endColumn,\n    executionContextId,\n    hash,\n    executionContextAuxData,\n    isLiveEdit,\n    sourceMapURL,\n    hasSourceURL,\n    length,\n    isModule,\n    stackTrace,\n    codeOffset,\n    scriptLanguage,\n    debugSymbols,\n    embedderName,\n  }: Protocol.Debugger.ScriptParsedEvent): void {\n    if (!this.#debuggerModel.debuggerEnabled()) {\n      return;\n    }\n    this.#debuggerModel.parsedScriptSource(\n        scriptId, url as Platform.DevToolsPath.UrlString, startLine, startColumn, endLine, endColumn,\n        executionContextId, hash, executionContextAuxData, Boolean(isLiveEdit), sourceMapURL, Boolean(hasSourceURL),\n        false, length || 0, isModule || null, stackTrace || null, codeOffset || null, scriptLanguage || null,\n        debugSymbols || null, embedderName as Platform.DevToolsPath.UrlString || null);\n  }\n\n  scriptFailedToParse({\n    scriptId,\n    url,\n    startLine,\n    startColumn,\n    endLine,\n    endColumn,\n    executionContextId,\n    hash,\n    executionContextAuxData,\n    sourceMapURL,\n    hasSourceURL,\n    length,\n    isModule,\n    stackTrace,\n    codeOffset,\n    scriptLanguage,\n    embedderName,\n  }: Protocol.Debugger.ScriptFailedToParseEvent): void {\n    if (!this.#debuggerModel.debuggerEnabled()) {\n      return;\n    }\n    this.#debuggerModel.parsedScriptSource(\n        scriptId, url as Platform.DevToolsPath.UrlString, startLine, startColumn, endLine, endColumn,\n        executionContextId, hash, executionContextAuxData, false, sourceMapURL, Boolean(hasSourceURL), true,\n        length || 0, isModule || null, stackTrace || null, codeOffset || null, scriptLanguage || null, null,\n        embedderName as Platform.DevToolsPath.UrlString || null);\n  }\n\n  breakpointResolved({breakpointId, location}: Protocol.Debugger.BreakpointResolvedEvent): void {\n    if (!this.#debuggerModel.debuggerEnabled()) {\n      return;\n    }\n    this.#debuggerModel.breakpointResolved(breakpointId, location);\n  }\n}\n\nexport class Location {\n  debuggerModel: DebuggerModel;\n  scriptId: Protocol.Runtime.ScriptId;\n  lineNumber: number;\n  columnNumber: number;\n  inlineFrameIndex: number;\n\n  constructor(\n      debuggerModel: DebuggerModel, scriptId: Protocol.Runtime.ScriptId, lineNumber: number, columnNumber?: number,\n      inlineFrameIndex?: number) {\n    this.debuggerModel = debuggerModel;\n    this.scriptId = scriptId;\n    this.lineNumber = lineNumber;\n    this.columnNumber = columnNumber || 0;\n    this.inlineFrameIndex = inlineFrameIndex || 0;\n  }\n\n  static fromPayload(debuggerModel: DebuggerModel, payload: Protocol.Debugger.Location, inlineFrameIndex?: number):\n      Location {\n    return new Location(debuggerModel, payload.scriptId, payload.lineNumber, payload.columnNumber, inlineFrameIndex);\n  }\n\n  payload(): Protocol.Debugger.Location {\n    return {scriptId: this.scriptId, lineNumber: this.lineNumber, columnNumber: this.columnNumber};\n  }\n\n  script(): Script|null {\n    return this.debuggerModel.scriptForId(this.scriptId);\n  }\n\n  continueToLocation(pausedCallback?: (() => void)): void {\n    if (pausedCallback) {\n      this.debuggerModel.continueToLocationCallback = this.paused.bind(this, pausedCallback);\n    }\n    void this.debuggerModel.agent.invoke_continueToLocation({\n      location: this.payload(),\n      targetCallFrames: Protocol.Debugger.ContinueToLocationRequestTargetCallFrames.Current,\n    });\n  }\n\n  private paused(pausedCallback: () => void|undefined, debuggerPausedDetails: DebuggerPausedDetails): boolean {\n    const location = debuggerPausedDetails.callFrames[0].location();\n    if (location.scriptId === this.scriptId && location.lineNumber === this.lineNumber &&\n        location.columnNumber === this.columnNumber) {\n      pausedCallback();\n      return true;\n    }\n    return false;\n  }\n\n  id(): string {\n    return this.debuggerModel.target().id() + ':' + this.scriptId + ':' + this.lineNumber + ':' + this.columnNumber;\n  }\n}\n\nexport interface LocationRange {\n  start: Location;\n  end: Location;\n}\n\nexport class BreakLocation extends Location {\n  type: Protocol.Debugger.BreakLocationType|undefined;\n  constructor(\n      debuggerModel: DebuggerModel, scriptId: Protocol.Runtime.ScriptId, lineNumber: number, columnNumber?: number,\n      type?: Protocol.Debugger.BreakLocationType) {\n    super(debuggerModel, scriptId, lineNumber, columnNumber);\n    if (type) {\n      this.type = type;\n    }\n  }\n\n  static override fromPayload(debuggerModel: DebuggerModel, payload: Protocol.Debugger.BreakLocation): BreakLocation {\n    return new BreakLocation(debuggerModel, payload.scriptId, payload.lineNumber, payload.columnNumber, payload.type);\n  }\n}\n\nexport interface MissingDebugFiles {\n  resourceUrl: Platform.DevToolsPath.UrlString;\n  initiator: PageResourceLoadInitiator;\n}\n\nexport interface MissingDebugInfoDetails {\n  details: string;\n  resources: MissingDebugFiles[];\n}\n\nexport class CallFrame {\n  debuggerModel: DebuggerModel;\n  readonly script: Script;\n  payload: Protocol.Debugger.CallFrame;\n  readonly #locationInternal: Location;\n  readonly #scopeChainInternal: Scope[];\n  readonly #localScopeInternal: Scope|null;\n  readonly inlineFrameIndex: number;\n  readonly functionName: string;\n  readonly #functionLocationInternal: Location|undefined;\n  #returnValueInternal: RemoteObject|null;\n  missingDebugInfoDetails: MissingDebugInfoDetails|null;\n  readonly exception: RemoteObject|null;\n\n  readonly canBeRestarted: boolean;\n\n  constructor(\n      debuggerModel: DebuggerModel, script: Script, payload: Protocol.Debugger.CallFrame, inlineFrameIndex?: number,\n      functionName?: string, exception: RemoteObject|null = null) {\n    this.debuggerModel = debuggerModel;\n    this.script = script;\n    this.payload = payload;\n    this.#locationInternal = Location.fromPayload(debuggerModel, payload.location, inlineFrameIndex);\n    this.#scopeChainInternal = [];\n    this.#localScopeInternal = null;\n    this.inlineFrameIndex = inlineFrameIndex || 0;\n    this.functionName = functionName ?? payload.functionName;\n    this.missingDebugInfoDetails = null;\n    this.canBeRestarted = Boolean(payload.canBeRestarted);\n    this.exception = exception;\n    for (let i = 0; i < payload.scopeChain.length; ++i) {\n      const scope = new Scope(this, i);\n      this.#scopeChainInternal.push(scope);\n      if (scope.type() === Protocol.Debugger.ScopeType.Local) {\n        this.#localScopeInternal = scope;\n      }\n    }\n    if (payload.functionLocation) {\n      this.#functionLocationInternal = Location.fromPayload(debuggerModel, payload.functionLocation);\n    }\n    this.#returnValueInternal =\n        payload.returnValue ? this.debuggerModel.runtimeModel().createRemoteObject(payload.returnValue) : null;\n  }\n\n  static fromPayloadArray(\n      debuggerModel: DebuggerModel, callFrames: Protocol.Debugger.CallFrame[],\n      exception: RemoteObject|null): CallFrame[] {\n    const result = [];\n    for (let i = 0; i < callFrames.length; ++i) {\n      const callFrame = callFrames[i];\n      const script = debuggerModel.scriptForId(callFrame.location.scriptId);\n      if (script) {\n        const ex = i === 0 ? exception : null;\n        result.push(new CallFrame(debuggerModel, script, callFrame, undefined, undefined, ex));\n      }\n    }\n    return result;\n  }\n\n  createVirtualCallFrame(inlineFrameIndex: number, name: string): CallFrame {\n    return new CallFrame(this.debuggerModel, this.script, this.payload, inlineFrameIndex, name, this.exception);\n  }\n\n  get id(): Protocol.Debugger.CallFrameId {\n    return this.payload.callFrameId;\n  }\n\n  scopeChain(): Scope[] {\n    return this.#scopeChainInternal;\n  }\n\n  localScope(): Scope|null {\n    return this.#localScopeInternal;\n  }\n\n  thisObject(): RemoteObject|null {\n    return this.payload.this ? this.debuggerModel.runtimeModel().createRemoteObject(this.payload.this) : null;\n  }\n\n  returnValue(): RemoteObject|null {\n    return this.#returnValueInternal;\n  }\n\n  async setReturnValue(expression: string): Promise<RemoteObject|null> {\n    if (!this.#returnValueInternal) {\n      return null;\n    }\n\n    const evaluateResponse = await this.debuggerModel.agent.invoke_evaluateOnCallFrame(\n        {callFrameId: this.id, expression, silent: true, objectGroup: 'backtrace'});\n    if (evaluateResponse.getError() || evaluateResponse.exceptionDetails) {\n      return null;\n    }\n    const response = await this.debuggerModel.agent.invoke_setReturnValue({newValue: evaluateResponse.result});\n    if (response.getError()) {\n      return null;\n    }\n    this.#returnValueInternal = this.debuggerModel.runtimeModel().createRemoteObject(evaluateResponse.result);\n    return this.#returnValueInternal;\n  }\n\n  location(): Location {\n    return this.#locationInternal;\n  }\n\n  functionLocation(): Location|null {\n    return this.#functionLocationInternal || null;\n  }\n\n  async evaluate(options: EvaluationOptions): Promise<EvaluationResult> {\n    const debuggerModel = this.debuggerModel;\n    const runtimeModel = debuggerModel.runtimeModel();\n\n    const evaluateOnCallFrameCallback = debuggerModel.getEvaluateOnCallFrameCallback();\n    if (evaluateOnCallFrameCallback) {\n      const result = await evaluateOnCallFrameCallback(this, options);\n      if (result) {\n        return result;\n      }\n    }\n\n    const response = await this.debuggerModel.agent.invoke_evaluateOnCallFrame({\n      callFrameId: this.id,\n      expression: options.expression,\n      objectGroup: options.objectGroup,\n      includeCommandLineAPI: options.includeCommandLineAPI,\n      silent: options.silent,\n      returnByValue: options.returnByValue,\n      generatePreview: options.generatePreview,\n      throwOnSideEffect: options.throwOnSideEffect,\n      timeout: options.timeout,\n    });\n    const error = response.getError();\n    if (error) {\n      return {error};\n    }\n    return {object: runtimeModel.createRemoteObject(response.result), exceptionDetails: response.exceptionDetails};\n  }\n\n  async restart(): Promise<void> {\n    console.assert(this.canBeRestarted, 'This frame can not be restarted.');\n    // Note that even if `canBeRestarted` is true, the restart frame call can still fail.\n    // The user can evaluate arbitrary code between pausing and restarting the frame that\n    // could mess with the call stack.\n    await this.debuggerModel.agent.invoke_restartFrame(\n        {callFrameId: this.id, mode: Protocol.Debugger.RestartFrameRequestMode.StepInto});\n  }\n\n  getPayload(): Protocol.Debugger.CallFrame {\n    return this.payload;\n  }\n}\n\nexport interface ScopeChainEntry {\n  callFrame(): CallFrame;\n\n  type(): string;\n\n  typeName(): string;\n\n  name(): string|undefined;\n\n  range(): LocationRange|null;\n\n  object(): RemoteObject;\n\n  description(): string;\n\n  icon(): string|undefined;\n\n  /**\n   * Extra and/or synthetic properties that should be added to the `RemoteObject`\n   * returned by {@link ScopeChainEntry.object}.\n   */\n  extraProperties(): RemoteObjectProperty[];\n}\n\nexport class Scope implements ScopeChainEntry {\n  #callFrameInternal: CallFrame;\n  #payload: Protocol.Debugger.Scope;\n  readonly #typeInternal: Protocol.Debugger.ScopeType;\n  readonly #nameInternal: string|undefined;\n  #ordinal: number;\n  readonly #locationRange: LocationRange|null;\n  #objectInternal: RemoteObject|null;\n  constructor(callFrame: CallFrame, ordinal: number) {\n    this.#callFrameInternal = callFrame;\n    this.#payload = callFrame.getPayload().scopeChain[ordinal];\n    this.#typeInternal = this.#payload.type;\n    this.#nameInternal = this.#payload.name;\n    this.#ordinal = ordinal;\n    this.#objectInternal = null;\n\n    const start =\n        this.#payload.startLocation ? Location.fromPayload(callFrame.debuggerModel, this.#payload.startLocation) : null;\n    const end =\n        this.#payload.endLocation ? Location.fromPayload(callFrame.debuggerModel, this.#payload.endLocation) : null;\n    if (start && end && start.scriptId === end.scriptId) {\n      this.#locationRange = {start, end};\n    } else {\n      this.#locationRange = null;\n    }\n  }\n\n  callFrame(): CallFrame {\n    return this.#callFrameInternal;\n  }\n\n  type(): string {\n    return this.#typeInternal;\n  }\n\n  typeName(): string {\n    switch (this.#typeInternal) {\n      case Protocol.Debugger.ScopeType.Local:\n        return i18nString(UIStrings.local);\n      case Protocol.Debugger.ScopeType.Closure:\n        return i18nString(UIStrings.closure);\n      case Protocol.Debugger.ScopeType.Catch:\n        return i18nString(UIStrings.catchBlock);\n      case Protocol.Debugger.ScopeType.Eval:\n        return i18n.i18n.lockedString('Eval');\n      case Protocol.Debugger.ScopeType.Block:\n        return i18nString(UIStrings.block);\n      case Protocol.Debugger.ScopeType.Script:\n        return i18nString(UIStrings.script);\n      case Protocol.Debugger.ScopeType.With:\n        return i18nString(UIStrings.withBlock);\n      case Protocol.Debugger.ScopeType.Global:\n        return i18nString(UIStrings.global);\n      case Protocol.Debugger.ScopeType.Module:\n        return i18nString(UIStrings.module);\n      case Protocol.Debugger.ScopeType.WasmExpressionStack:\n        return i18nString(UIStrings.expression);\n    }\n    return '';\n  }\n\n  name(): string|undefined {\n    return this.#nameInternal;\n  }\n\n  range(): LocationRange|null {\n    return this.#locationRange;\n  }\n\n  object(): RemoteObject {\n    if (this.#objectInternal) {\n      return this.#objectInternal;\n    }\n    const runtimeModel = this.#callFrameInternal.debuggerModel.runtimeModel();\n\n    const declarativeScope = this.#typeInternal !== Protocol.Debugger.ScopeType.With &&\n        this.#typeInternal !== Protocol.Debugger.ScopeType.Global;\n    if (declarativeScope) {\n      this.#objectInternal = runtimeModel.createScopeRemoteObject(\n          this.#payload.object, new ScopeRef(this.#ordinal, this.#callFrameInternal.id));\n    } else {\n      this.#objectInternal = runtimeModel.createRemoteObject(this.#payload.object);\n    }\n\n    return this.#objectInternal;\n  }\n\n  description(): string {\n    const declarativeScope = this.#typeInternal !== Protocol.Debugger.ScopeType.With &&\n        this.#typeInternal !== Protocol.Debugger.ScopeType.Global;\n    return declarativeScope ? '' : (this.#payload.object.description || '');\n  }\n\n  icon(): undefined {\n    return undefined;\n  }\n\n  extraProperties(): RemoteObjectProperty[] {\n    if (this.#ordinal !== 0 || this.#typeInternal !== Protocol.Debugger.ScopeType.Local ||\n        this.#callFrameInternal.script.isWasm()) {\n      return [];\n    }\n\n    const extraProperties = [];\n    const exception = this.#callFrameInternal.exception;\n    if (exception) {\n      extraProperties.push(new RemoteObjectProperty(\n          i18nString(UIStrings.exception), exception, undefined, undefined, undefined, undefined, undefined,\n          /* synthetic */ true));\n    }\n    const returnValue = this.#callFrameInternal.returnValue();\n    if (returnValue) {\n      extraProperties.push(new RemoteObjectProperty(\n          i18nString(UIStrings.returnValue), returnValue, undefined, undefined, undefined, undefined, undefined,\n          /* synthetic */ true, this.#callFrameInternal.setReturnValue.bind(this.#callFrameInternal)));\n    }\n    return extraProperties;\n  }\n}\n\nexport class DebuggerPausedDetails {\n  debuggerModel: DebuggerModel;\n  callFrames: CallFrame[];\n  reason: Protocol.Debugger.PausedEventReason;\n  auxData: {\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [x: string]: any,\n  }|undefined;\n  breakpointIds: string[];\n  asyncStackTrace: Protocol.Runtime.StackTrace|undefined;\n  asyncStackTraceId: Protocol.Runtime.StackTraceId|undefined;\n  constructor(\n      debuggerModel: DebuggerModel, callFrames: Protocol.Debugger.CallFrame[],\n      reason: Protocol.Debugger.PausedEventReason, auxData: {\n        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        [x: string]: any,\n      }|undefined,\n      breakpointIds: string[], asyncStackTrace?: Protocol.Runtime.StackTrace,\n      asyncStackTraceId?: Protocol.Runtime.StackTraceId) {\n    this.debuggerModel = debuggerModel;\n    this.reason = reason;\n    this.auxData = auxData;\n    this.breakpointIds = breakpointIds;\n    if (asyncStackTrace) {\n      this.asyncStackTrace = this.cleanRedundantFrames(asyncStackTrace);\n    }\n    this.asyncStackTraceId = asyncStackTraceId;\n    this.callFrames = CallFrame.fromPayloadArray(debuggerModel, callFrames, this.exception());\n  }\n\n  private exception(): RemoteObject|null {\n    if (this.reason !== Protocol.Debugger.PausedEventReason.Exception &&\n        this.reason !== Protocol.Debugger.PausedEventReason.PromiseRejection) {\n      return null;\n    }\n    return this.debuggerModel.runtimeModel().createRemoteObject((this.auxData as Protocol.Runtime.RemoteObject));\n  }\n\n  private cleanRedundantFrames(asyncStackTrace: Protocol.Runtime.StackTrace): Protocol.Runtime.StackTrace {\n    let stack: (Protocol.Runtime.StackTrace|undefined)|Protocol.Runtime.StackTrace = asyncStackTrace;\n    let previous: Protocol.Runtime.StackTrace|null = null;\n    while (stack) {\n      if (previous && !stack.callFrames.length) {\n        previous.parent = stack.parent;\n      } else {\n        previous = stack;\n      }\n      stack = stack.parent;\n    }\n    return asyncStackTrace;\n  }\n}\n\nSDKModel.register(DebuggerModel, {capabilities: Capability.JS, autostart: true});\n\nexport interface FunctionDetails {\n  location: Location|null;\n  functionName: string;\n}\nexport interface SetBreakpointResult {\n  breakpointId: Protocol.Debugger.BreakpointId|null;\n  locations: Location[];\n}\n\ninterface PausedOnInstrumentationData {\n  scriptId: Protocol.Runtime.ScriptId;\n}\n\nexport interface EventListenerPausedDetailsAuxData {\n  eventName: string;\n  targetName?: string;\n  webglErrorName?: string;\n  directiveText?: string;\n}\n\nexport const enum BreakpointType {\n  LOGPOINT = 'LOGPOINT',\n  CONDITIONAL_BREAKPOINT = 'CONDITIONAL_BREAKPOINT',\n  REGULAR_BREAKPOINT = 'REGULAR_BREAKPOINT',\n}\n\n/**\n * A breakpoint condition as sent to V8. This helps distinguish\n * the breakpoint condition as it is entered by the user.\n */\nexport type BackendCondition = Platform.Brand.Brand<string, 'BackendCondition'>;\n\nexport const LOGPOINT_SOURCE_URL = 'debugger://logpoint';\nexport const COND_BREAKPOINT_SOURCE_URL = 'debugger://breakpoint';\n"],
  "mappings": "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",
  "names": ["StepMode", "PauseOnExceptionsState", "Events", "BreakpointType"]
}
