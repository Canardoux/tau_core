{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/CSSProperty.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../generated/protocol.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Common from '../common/common.js';\nimport * as HostModule from '../host/host.js';\nimport * as Platform from '../platform/platform.js';\n\nimport {cssMetadata, GridAreaRowRegex} from './CSSMetadata.js';\nimport type {Edit} from './CSSModel.js';\nimport {stripComments} from './CSSPropertyParser.js';\nimport type {CSSStyleDeclaration} from './CSSStyleDeclaration.js';\n\nexport class CSSProperty {\n  ownerStyle: CSSStyleDeclaration;\n  index: number;\n  name: string;\n  value: string;\n  important: boolean;\n  disabled: boolean;\n  parsedOk: boolean;\n  implicit: boolean;\n  text: string|null|undefined;\n  range: TextUtils.TextRange.TextRange|null;\n  #active: boolean;\n  #nameRangeInternal: TextUtils.TextRange.TextRange|null;\n  #valueRangeInternal: TextUtils.TextRange.TextRange|null;\n  #invalidString?: Common.UIString.LocalizedString;\n  #longhandProperties: CSSProperty[] = [];\n\n  constructor(\n      ownerStyle: CSSStyleDeclaration, index: number, name: string, value: string, important: boolean,\n      disabled: boolean, parsedOk: boolean, implicit: boolean, text?: string|null, range?: Protocol.CSS.SourceRange,\n      longhandProperties?: Protocol.CSS.CSSProperty[]) {\n    this.ownerStyle = ownerStyle;\n    this.index = index;\n    this.name = name;\n    this.value = value;\n    this.important = important;\n    this.disabled = disabled;\n    this.parsedOk = parsedOk;\n    this.implicit = implicit;  // A longhand, implicitly set by missing values of shorthand.\n    this.text = text;\n    this.range = range ? TextUtils.TextRange.TextRange.fromObject(range) : null;\n    this.#active = true;\n    this.#nameRangeInternal = null;\n    this.#valueRangeInternal = null;\n\n    if (longhandProperties && longhandProperties.length > 0) {\n      for (const property of longhandProperties) {\n        this.#longhandProperties.push(\n            new CSSProperty(ownerStyle, ++index, property.name, property.value, important, disabled, parsedOk, true));\n      }\n    } else {\n      // Blink would not parse shorthands containing 'var()' functions:\n      // https://drafts.csswg.org/css-variables/#variables-in-shorthands).\n      // Therefore we manually check if the current property is a shorthand,\n      // and fills its longhand components with empty values.\n      const longhandNames = cssMetadata().getLonghands(name);\n      for (const longhandName of longhandNames || []) {\n        this.#longhandProperties.push(\n            new CSSProperty(ownerStyle, ++index, longhandName, '', important, disabled, parsedOk, true));\n      }\n    }\n  }\n\n  static parsePayload(ownerStyle: CSSStyleDeclaration, index: number, payload: Protocol.CSS.CSSProperty): CSSProperty {\n    // The following default field values are used in the payload:\n    // important: false\n    // parsedOk: true\n    // implicit: false\n    // disabled: false\n    const result = new CSSProperty(\n        ownerStyle, index, payload.name, payload.value, payload.important || false, payload.disabled || false,\n        ('parsedOk' in payload) ? Boolean(payload.parsedOk) : true, Boolean(payload.implicit), payload.text,\n        payload.range, payload.longhandProperties);\n    return result;\n  }\n\n  private ensureRanges(): void {\n    if (this.#nameRangeInternal && this.#valueRangeInternal) {\n      return;\n    }\n    const range = this.range;\n    const text = this.text ? new TextUtils.Text.Text(this.text) : null;\n    if (!range || !text) {\n      return;\n    }\n\n    const nameIndex = text.value().indexOf(this.name);\n    const valueIndex = text.value().lastIndexOf(this.value);\n    if (nameIndex === -1 || valueIndex === -1 || nameIndex > valueIndex) {\n      return;\n    }\n\n    const nameSourceRange = new TextUtils.TextRange.SourceRange(nameIndex, this.name.length);\n    const valueSourceRange = new TextUtils.TextRange.SourceRange(valueIndex, this.value.length);\n\n    this.#nameRangeInternal = rebase(text.toTextRange(nameSourceRange), range.startLine, range.startColumn);\n    this.#valueRangeInternal = rebase(text.toTextRange(valueSourceRange), range.startLine, range.startColumn);\n\n    function rebase(oneLineRange: TextUtils.TextRange.TextRange, lineOffset: number, columnOffset: number):\n        TextUtils.TextRange.TextRange {\n      if (oneLineRange.startLine === 0) {\n        oneLineRange.startColumn += columnOffset;\n        oneLineRange.endColumn += columnOffset;\n      }\n      oneLineRange.startLine += lineOffset;\n      oneLineRange.endLine += lineOffset;\n      return oneLineRange;\n    }\n  }\n\n  nameRange(): TextUtils.TextRange.TextRange|null {\n    this.ensureRanges();\n    return this.#nameRangeInternal;\n  }\n\n  valueRange(): TextUtils.TextRange.TextRange|null {\n    this.ensureRanges();\n    return this.#valueRangeInternal;\n  }\n\n  rebase(edit: Edit): void {\n    if (this.ownerStyle.styleSheetId !== edit.styleSheetId) {\n      return;\n    }\n    if (this.range) {\n      this.range = this.range.rebaseAfterTextEdit(edit.oldRange, edit.newRange);\n    }\n  }\n\n  setActive(active: boolean): void {\n    this.#active = active;\n  }\n\n  get propertyText(): string|null {\n    if (this.text !== undefined) {\n      return this.text;\n    }\n\n    if (this.name === '') {\n      return '';\n    }\n    return this.name + ': ' + this.value + (this.important ? ' !important' : '') + ';';\n  }\n\n  activeInStyle(): boolean {\n    return this.#active;\n  }\n\n  trimmedValueWithoutImportant(): string {\n    const important = '!important';\n    return this.value.endsWith(important) ? this.value.slice(0, -important.length).trim() : this.value.trim();\n  }\n\n  async setText(propertyText: string, majorChange: boolean, overwrite?: boolean): Promise<boolean> {\n    if (!this.ownerStyle) {\n      throw new Error('No ownerStyle for property');\n    }\n\n    if (!this.ownerStyle.styleSheetId) {\n      throw new Error('No owner style id');\n    }\n\n    if (!this.range || !this.ownerStyle.range) {\n      throw new Error('Style not editable');\n    }\n\n    if (majorChange) {\n      HostModule.userMetrics.actionTaken(HostModule.UserMetrics.Action.StyleRuleEdited);\n      if (this.ownerStyle.parentRule?.isKeyframeRule()) {\n        HostModule.userMetrics.actionTaken(HostModule.UserMetrics.Action.StylePropertyInsideKeyframeEdited);\n      }\n\n      if (this.name.startsWith('--')) {\n        HostModule.userMetrics.actionTaken(HostModule.UserMetrics.Action.CustomPropertyEdited);\n      }\n    }\n\n    if (overwrite && propertyText === this.propertyText) {\n      this.ownerStyle.cssModel().domModel().markUndoableState(!majorChange);\n      return true;\n    }\n\n    const range = this.range.relativeTo(this.ownerStyle.range.startLine, this.ownerStyle.range.startColumn);\n    const indentation = this.ownerStyle.cssText ?\n        this.detectIndentation(this.ownerStyle.cssText) :\n        Common.Settings.Settings.instance().moduleSetting('text-editor-indent').get();\n    const endIndentation = this.ownerStyle.cssText ? indentation.substring(0, this.ownerStyle.range.endColumn) : '';\n    const text = new TextUtils.Text.Text(this.ownerStyle.cssText || '');\n    const newStyleText = text.replaceRange(range, Platform.StringUtilities.sprintf(';%s;', propertyText));\n    const styleText = await CSSProperty.formatStyle(newStyleText, indentation, endIndentation);\n    return this.ownerStyle.setText(styleText, majorChange);\n  }\n\n  static async formatStyle(styleText: string, indentation: string, endIndentation: string): Promise<string> {\n    const doubleIndent = indentation.substring(endIndentation.length) + indentation;\n    if (indentation) {\n      indentation = '\\n' + indentation;\n    }\n    let result = '';\n    let propertyName = '';\n    let propertyText = '';\n    let insideProperty = false;\n    let needsSemi = false;\n    const tokenize = TextUtils.CodeMirrorUtils.createCssTokenizer();\n\n    await tokenize('*{' + styleText + '}', processToken);\n    if (insideProperty) {\n      result += propertyText;\n    }\n    result = result.substring(2, result.length - 1).trimEnd();\n    return result + (indentation ? '\\n' + endIndentation : '');\n\n    function processToken(token: string, tokenType: string|null): void {\n      if (!insideProperty) {\n        const disabledProperty = tokenType?.includes('comment') && isDisabledProperty(token);\n        const isPropertyStart =\n            (tokenType?.includes('def') || tokenType?.includes('string') || tokenType?.includes('meta') ||\n             tokenType?.includes('property') ||\n             (tokenType?.includes('variableName') && tokenType !== ('variableName.function')));\n        if (disabledProperty) {\n          result = result.trimEnd() + indentation + token;\n        } else if (isPropertyStart) {\n          insideProperty = true;\n          propertyText = token;\n        } else if (token !== ';' || needsSemi) {\n          result += token;\n          if (token.trim() && !(tokenType?.includes('comment'))) {\n            needsSemi = token !== ';';\n          }\n        }\n        if (token === '{' && !tokenType) {\n          needsSemi = false;\n        }\n        return;\n      }\n\n      if (token === '}' || token === ';') {\n        // While `propertyText` can generally be trimmed, doing so\n        // breaks valid CSS declarations such as `--foo:  ;` which would\n        // then produce invalid CSS of the form `--foo:;`. This\n        // implementation takes special care to restore a single\n        // whitespace token in this edge case. https://crbug.com/1071296\n        const trimmedPropertyText = propertyText.trim();\n        result = result.trimEnd() + indentation + trimmedPropertyText + (trimmedPropertyText.endsWith(':') ? ' ' : '') +\n            token;\n        needsSemi = false;\n        insideProperty = false;\n        propertyName = '';\n        return;\n      }\n      if (cssMetadata().isGridAreaDefiningProperty(propertyName)) {\n        const rowResult = GridAreaRowRegex.exec(token);\n        if (rowResult && rowResult.index === 0 && !propertyText.trimEnd().endsWith(']')) {\n          propertyText = propertyText.trimEnd() + '\\n' + doubleIndent;\n        }\n      }\n      if (!propertyName && token === ':') {\n        propertyName = propertyText;\n      }\n      propertyText += token;\n    }\n\n    function isDisabledProperty(text: string): boolean {\n      const colon = text.indexOf(':');\n      if (colon === -1) {\n        return false;\n      }\n      const propertyName = text.substring(2, colon).trim();\n      return cssMetadata().isCSSPropertyName(propertyName);\n    }\n  }\n\n  private detectIndentation(text: string): string {\n    const lines = text.split('\\n');\n    if (lines.length < 2) {\n      return '';\n    }\n    return TextUtils.TextUtils.Utils.lineIndent(lines[1]);\n  }\n\n  setValue(newValue: string, majorChange: boolean, overwrite: boolean, userCallback?: ((arg0: boolean) => void)): void {\n    const text = this.name + ': ' + newValue + (this.important ? ' !important' : '') + ';';\n    void this.setText(text, majorChange, overwrite).then(userCallback);\n  }\n\n  async setDisabled(disabled: boolean): Promise<boolean> {\n    if (!this.ownerStyle) {\n      return false;\n    }\n    if (disabled === this.disabled) {\n      return true;\n    }\n    if (!this.text) {\n      return true;\n    }\n    const propertyText = this.text.trim();\n    // Ensure that if we try to enable/disable a property that has no semicolon (which is only legal\n    // in the last position of a css rule), we add it. This ensures that if we then later try\n    // to re-enable/-disable the rule, we end up with legal syntax (if the user adds more properties\n    // after the disabled rule).\n    const appendSemicolonIfMissing = (propertyText: string): string =>\n        propertyText + (propertyText.endsWith(';') ? '' : ';');\n    let text: string;\n    if (disabled) {\n      // We remove comments before wrapping comment tags around propertyText, because otherwise it will\n      // create an unmatched trailing `*/`, making the text invalid. This will result in disabled\n      // CSSProperty losing its original comments, but since escaping comments will result in the parser\n      // to completely ignore and then lose this declaration, this is the best compromise so far.\n      text = '/* ' + appendSemicolonIfMissing(stripComments(propertyText)) + ' */';\n    } else {\n      text = appendSemicolonIfMissing(this.text.substring(2, propertyText.length - 2).trim());\n    }\n    return this.setText(text, true, true);\n  }\n\n  /**\n   * This stores the warning string when a CSS Property is improperly parsed.\n   */\n  setDisplayedStringForInvalidProperty(invalidString: Common.UIString.LocalizedString): void {\n    this.#invalidString = invalidString;\n  }\n\n  /**\n   * Retrieve the warning string for a screen reader to announce when editing the property.\n   */\n  getInvalidStringForInvalidProperty(): Common.UIString.LocalizedString|undefined {\n    return this.#invalidString;\n  }\n\n  getLonghandProperties(): CSSProperty[] {\n    return this.#longhandProperties;\n  }\n}\n"],
  "mappings": "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",
  "names": ["propertyName", "propertyText"]
}
