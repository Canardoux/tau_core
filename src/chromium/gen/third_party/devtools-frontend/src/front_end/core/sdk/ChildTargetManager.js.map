{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/ChildTargetManager.ts"],
  "sourcesContent": ["// Copyright 2018 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport type * as Protocol from '../../generated/protocol.js';\nimport * as Common from '../common/common.js';\nimport * as Host from '../host/host.js';\nimport type * as ProtocolClient from '../protocol_client/protocol_client.js';\n\nimport {ParallelConnection} from './Connections.js';\nimport {PrimaryPageChangeType, ResourceTreeModel} from './ResourceTreeModel.js';\nimport {SDKModel} from './SDKModel.js';\nimport {Capability, type Target, Type} from './Target.js';\nimport {Events as TargetManagerEvents, TargetManager} from './TargetManager.js';\n\nconst UIStrings = {\n  /**\n   * @description Text that refers to the main target. The main target is the primary webpage that\n   * DevTools is connected to. This text is used in various places in the UI as a label/name to inform\n   * the user which target/webpage they are currently connected to, as DevTools may connect to multiple\n   * targets at the same time in some scenarios.\n   */\n  main: 'Main',\n};\nconst str_ = i18n.i18n.registerUIStrings('core/sdk/ChildTargetManager.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class ChildTargetManager extends SDKModel<EventTypes> implements ProtocolProxyApi.TargetDispatcher {\n  readonly #targetManager: TargetManager;\n  #parentTarget: Target;\n  readonly #targetAgent: ProtocolProxyApi.TargetApi;\n  readonly #targetInfosInternal: Map<Protocol.Target.TargetID, Protocol.Target.TargetInfo> = new Map();\n  readonly #childTargetsBySessionId: Map<Protocol.Target.SessionID, Target> = new Map();\n  readonly #childTargetsById: Map<Protocol.Target.TargetID|'main', Target> = new Map();\n  readonly #parallelConnections: Map<string, ProtocolClient.InspectorBackend.Connection> = new Map();\n  #parentTargetId: Protocol.Target.TargetID|null = null;\n\n  constructor(parentTarget: Target) {\n    super(parentTarget);\n    this.#targetManager = parentTarget.targetManager();\n    this.#parentTarget = parentTarget;\n    this.#targetAgent = parentTarget.targetAgent();\n    parentTarget.registerTargetDispatcher(this);\n    const browserTarget = this.#targetManager.browserTarget();\n    if (browserTarget) {\n      if (browserTarget !== parentTarget) {\n        void browserTarget.targetAgent().invoke_autoAttachRelated(\n            {targetId: parentTarget.id() as Protocol.Target.TargetID, waitForDebuggerOnStart: true});\n      }\n    } else {\n      void this.#targetAgent.invoke_setAutoAttach({autoAttach: true, waitForDebuggerOnStart: true, flatten: true});\n    }\n\n    if (parentTarget.parentTarget()?.type() !== Type.FRAME && !Host.InspectorFrontendHost.isUnderTest()) {\n      void this.#targetAgent.invoke_setDiscoverTargets({discover: true});\n      void this.#targetAgent.invoke_setRemoteLocations({locations: [{host: 'localhost', port: 9229}]});\n    }\n  }\n\n  static install(attachCallback?: ((arg0: {\n                                     target: Target,\n                                     waitingForDebugger: boolean,\n                                   }) => Promise<void>)): void {\n    ChildTargetManager.attachCallback = attachCallback;\n    SDKModel.register(ChildTargetManager, {capabilities: Capability.TARGET, autostart: true});\n  }\n\n  childTargets(): Target[] {\n    return Array.from(this.#childTargetsBySessionId.values());\n  }\n\n  override async suspendModel(): Promise<void> {\n    await this.#targetAgent.invoke_setAutoAttach({autoAttach: true, waitForDebuggerOnStart: false, flatten: true});\n  }\n\n  override async resumeModel(): Promise<void> {\n    await this.#targetAgent.invoke_setAutoAttach({autoAttach: true, waitForDebuggerOnStart: true, flatten: true});\n  }\n\n  override dispose(): void {\n    for (const sessionId of this.#childTargetsBySessionId.keys()) {\n      this.detachedFromTarget({sessionId, targetId: undefined});\n    }\n  }\n\n  targetCreated({targetInfo}: Protocol.Target.TargetCreatedEvent): void {\n    this.#targetInfosInternal.set(targetInfo.targetId, targetInfo);\n    this.fireAvailableTargetsChanged();\n    this.dispatchEventToListeners(Events.TARGET_CREATED, targetInfo);\n  }\n\n  targetInfoChanged({targetInfo}: Protocol.Target.TargetInfoChangedEvent): void {\n    this.#targetInfosInternal.set(targetInfo.targetId, targetInfo);\n    const target = this.#childTargetsById.get(targetInfo.targetId);\n    if (target) {\n      if (target.targetInfo()?.subtype === 'prerender' && !targetInfo.subtype) {\n        const resourceTreeModel = target.model(ResourceTreeModel);\n        target.updateTargetInfo(targetInfo);\n        if (resourceTreeModel && resourceTreeModel.mainFrame) {\n          resourceTreeModel.primaryPageChanged(resourceTreeModel.mainFrame, PrimaryPageChangeType.ACTIVATION);\n        }\n        target.setName(i18nString(UIStrings.main));\n      } else {\n        target.updateTargetInfo(targetInfo);\n      }\n    }\n    this.fireAvailableTargetsChanged();\n    this.dispatchEventToListeners(Events.TARGET_INFO_CHANGED, targetInfo);\n  }\n\n  targetDestroyed({targetId}: Protocol.Target.TargetDestroyedEvent): void {\n    this.#targetInfosInternal.delete(targetId);\n    this.fireAvailableTargetsChanged();\n    this.dispatchEventToListeners(Events.TARGET_DESTROYED, targetId);\n  }\n\n  targetCrashed({targetId}: Protocol.Target.TargetCrashedEvent): void {\n    this.#targetInfosInternal.delete(targetId);\n    const target = this.#childTargetsById.get(targetId);\n    if (target) {\n      target.dispose('targetCrashed event from CDP');\n    }\n    this.fireAvailableTargetsChanged();\n    this.dispatchEventToListeners(Events.TARGET_DESTROYED, targetId);\n  }\n\n  private fireAvailableTargetsChanged(): void {\n    TargetManager.instance().dispatchEventToListeners(\n        TargetManagerEvents.AVAILABLE_TARGETS_CHANGED, [...this.#targetInfosInternal.values()]);\n  }\n\n  async getParentTargetId(): Promise<Protocol.Target.TargetID> {\n    if (!this.#parentTargetId) {\n      this.#parentTargetId = (await this.#parentTarget.targetAgent().invoke_getTargetInfo({})).targetInfo.targetId;\n    }\n    return this.#parentTargetId;\n  }\n\n  async getTargetInfo(): Promise<Protocol.Target.TargetInfo> {\n    return (await this.#parentTarget.targetAgent().invoke_getTargetInfo({})).targetInfo;\n  }\n\n  async attachedToTarget({sessionId, targetInfo, waitingForDebugger}: Protocol.Target.AttachedToTargetEvent):\n      Promise<void> {\n    if (this.#parentTargetId === targetInfo.targetId) {\n      return;\n    }\n    let type = Type.BROWSER;\n    let targetName = '';\n    if (targetInfo.type === 'worker' && targetInfo.title && targetInfo.title !== targetInfo.url) {\n      targetName = targetInfo.title;\n    } else if (!['page', 'iframe', 'webview'].includes(targetInfo.type)) {\n      const KNOWN_FRAME_PATTERNS = [\n        '^chrome://print/$',\n        '^chrome://file-manager/',\n        '^chrome://feedback/',\n        '^chrome://.*\\\\.top-chrome/$',\n        '^chrome://view-cert/$',\n        '^devtools://',\n      ];\n      if (KNOWN_FRAME_PATTERNS.some(p => targetInfo.url.match(p))) {\n        type = Type.FRAME;\n      } else {\n        const parsedURL = Common.ParsedURL.ParsedURL.fromString(targetInfo.url);\n        targetName =\n            parsedURL ? parsedURL.lastPathComponentWithFragment() : '#' + (++ChildTargetManager.lastAnonymousTargetId);\n      }\n    }\n\n    if (targetInfo.type === 'iframe' || targetInfo.type === 'webview') {\n      type = Type.FRAME;\n    } else if (targetInfo.type === 'background_page' || targetInfo.type === 'app' || targetInfo.type === 'popup_page') {\n      type = Type.FRAME;\n    }\n    else if (targetInfo.type === 'page') {\n      type = Type.FRAME;\n    } else if (targetInfo.type === 'worker') {\n      type = Type.Worker;\n    } else if (targetInfo.type === 'worklet') {\n      type = Type.WORKLET;\n    } else if (targetInfo.type === 'shared_worker') {\n      type = Type.SHARED_WORKER;\n    } else if (targetInfo.type === 'shared_storage_worklet') {\n      type = Type.SHARED_STORAGE_WORKLET;\n    } else if (targetInfo.type === 'service_worker') {\n      type = Type.ServiceWorker;\n    } else if (targetInfo.type === 'auction_worklet') {\n      type = Type.AUCTION_WORKLET;\n    }\n    const target = this.#targetManager.createTarget(\n        targetInfo.targetId, targetName, type, this.#parentTarget, sessionId, undefined, undefined, targetInfo);\n    this.#childTargetsBySessionId.set(sessionId, target);\n    this.#childTargetsById.set(target.id(), target);\n\n    if (ChildTargetManager.attachCallback) {\n      await ChildTargetManager.attachCallback({target, waitingForDebugger});\n    }\n\n    // [crbug/1423096] Invoking this on a worker session that is not waiting for the debugger can force the worker\n    // to resume even if there is another session waiting for the debugger.\n    if (waitingForDebugger) {\n      void target.runtimeAgent().invoke_runIfWaitingForDebugger();\n    }\n  }\n\n  detachedFromTarget({sessionId}: Protocol.Target.DetachedFromTargetEvent): void {\n    if (this.#parallelConnections.has(sessionId)) {\n      this.#parallelConnections.delete(sessionId);\n    } else {\n      const target = this.#childTargetsBySessionId.get(sessionId);\n      if (target) {\n        target.dispose('target terminated');\n        this.#childTargetsBySessionId.delete(sessionId);\n        this.#childTargetsById.delete(target.id());\n      }\n    }\n  }\n\n  receivedMessageFromTarget({}: Protocol.Target.ReceivedMessageFromTargetEvent): void {\n    // We use flatten protocol.\n  }\n\n  async createParallelConnection(onMessage: (arg0: (Object|string)) => void):\n      Promise<{connection: ProtocolClient.InspectorBackend.Connection, sessionId: string}> {\n    // The main Target id is actually just `main`, instead of the real targetId.\n    // Get the real id (requires an async operation) so that it can be used synchronously later.\n    const targetId = await this.getParentTargetId();\n    const {connection, sessionId} =\n        await this.createParallelConnectionAndSessionForTarget(this.#parentTarget, targetId);\n    connection.setOnMessage(onMessage);\n    this.#parallelConnections.set(sessionId, connection);\n    return {connection, sessionId};\n  }\n\n  private async createParallelConnectionAndSessionForTarget(target: Target, targetId: Protocol.Target.TargetID):\n      Promise<{\n        connection: ProtocolClient.InspectorBackend.Connection,\n        sessionId: string,\n      }> {\n    const targetAgent = target.targetAgent();\n    const targetRouter = (target.router() as ProtocolClient.InspectorBackend.SessionRouter);\n    const sessionId = (await targetAgent.invoke_attachToTarget({targetId, flatten: true})).sessionId;\n    const connection = new ParallelConnection(targetRouter.connection(), sessionId);\n    targetRouter.registerSession(target, sessionId, connection);\n    connection.setOnDisconnect(() => {\n      targetRouter.unregisterSession(sessionId);\n      void targetAgent.invoke_detachFromTarget({sessionId});\n    });\n    return {connection, sessionId};\n  }\n\n  targetInfos(): Protocol.Target.TargetInfo[] {\n    return Array.from(this.#targetInfosInternal.values());\n  }\n\n  private static lastAnonymousTargetId = 0;\n\n  private static attachCallback?: ((arg0: {\n                                     target: Target,\n                                     waitingForDebugger: boolean,\n                                   }) => Promise<void>);\n}\n\nexport const enum Events {\n  TARGET_CREATED = 'TargetCreated',\n  TARGET_DESTROYED = 'TargetDestroyed',\n  TARGET_INFO_CHANGED = 'TargetInfoChanged',\n}\n\nexport type EventTypes = {\n  [Events.TARGET_CREATED]: Protocol.Target.TargetInfo,\n  [Events.TARGET_DESTROYED]: Protocol.Target.TargetID,\n  [Events.TARGET_INFO_CHANGED]: Protocol.Target.TargetInfo,\n};\n"],
  "mappings": "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",
  "names": ["Events"]
}
