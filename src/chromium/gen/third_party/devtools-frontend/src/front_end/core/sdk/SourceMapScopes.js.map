{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/SourceMapScopes.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * @fileoverview This file implements the current state of the \"Scopes\" proposal\n * for the source map spec.\n *\n * See https://github.com/tc39/source-map-rfc/blob/main/proposals/scopes.md.\n *\n * The proposal is still being worked on so we expect the implementation details\n * in this file to change frequently.\n */\n\nimport {TokenIterator} from './SourceMap.js';\n\n/**\n * A scope in the authored source.\n */\nexport interface OriginalScope {\n  start: Position;\n  end: Position;\n\n  /**\n   * JavaScript-like languages are encouraged to use 'global', 'class', 'function' and 'block'.\n   * Other languages might require language-specific scope kinds, in which case we'll print the\n   * kind as-is.\n   */\n  kind?: string;\n  name?: string;\n  isStackFrame: boolean;\n  variables: string[];\n  children: OriginalScope[];\n  parent?: OriginalScope;\n}\n\n/**\n * A range (can be a scope) in the generated JavaScript.\n */\nexport interface GeneratedRange {\n  start: Position;\n  end: Position;\n  originalScope?: OriginalScope;\n\n  /**\n   * Whether this generated range is an actual JavaScript function in the generated code.\n   */\n  isStackFrame: boolean;\n  /**\n   * Whether calls to this generated range should be hidden from stack traces even if\n   * this range has an `originalScope`.\n   */\n  isHidden: boolean;\n\n  /**\n   * If this `GeneratedRange` is the result of inlining `originalScope`, then `callsite`\n   * refers to where `originalScope` was called in the original (\"authored\") code.\n   */\n  callsite?: OriginalPosition;\n\n  /**\n   * Expressions that compute the values of the variables of this OriginalScope. The length\n   * of `values` must match the length of `originalScope.variables`.\n   *\n   * For each variable this can either be a single expression (valid for the full `GeneratedRange`),\n   * or an array of `BindingRange`s, e.g. if computing the value requires different expressions\n   * throughout the range or if the variable is only available in parts of the `GeneratedRange`.\n   *\n   * `undefined` denotes that the value of a variable is unavailble in the whole range.\n   * This can happen e.g. if the variable was optimized out and can't be recomputed.\n   */\n  values: (string|undefined|BindingRange[])[];\n  children: GeneratedRange[];\n}\n\nexport interface BindingRange {\n  value?: string;\n  from: Position;\n  to: Position;\n}\n\nexport interface Position {\n  line: number;\n  column: number;\n}\n\nexport interface OriginalPosition extends Position {\n  sourceIndex: number;\n}\n\ninterface OriginalScopeTree {\n  readonly root: OriginalScope;\n  readonly scopeForItemIndex: Map<number, OriginalScope>;\n}\n\nexport function decodeOriginalScopes(encodedOriginalScopes: string[], names: string[]): OriginalScopeTree[] {\n  return encodedOriginalScopes.map(scope => decodeOriginalScope(scope, names));\n}\n\nfunction decodeOriginalScope(encodedOriginalScope: string, names: string[]): OriginalScopeTree {\n  const scopeForItemIndex = new Map<number, OriginalScope>();\n  const scopeStack: OriginalScope[] = [];\n  let line = 0;\n  let kindIdx = 0;\n\n  for (const [index, item] of decodeOriginalScopeItems(encodedOriginalScope)) {\n    line += item.line;\n    const {column} = item;\n    if (isStart(item)) {\n      let kind: string|undefined;\n      if (item.kind !== undefined) {\n        kindIdx += item.kind;\n        kind = resolveName(kindIdx, names);\n      }\n      const name = resolveName(item.name, names);\n      const variables = item.variables.map(idx => names[idx]);\n      const scope: OriginalScope = {\n        start: {line, column},\n        end: {line, column},\n        kind,\n        name,\n        isStackFrame: Boolean(item.flags & EncodedOriginalScopeFlag.IS_STACK_FRAME),\n        variables,\n        children: [],\n      };\n      scopeStack.push(scope);\n      scopeForItemIndex.set(index, scope);\n    } else {\n      const scope = scopeStack.pop();\n      if (!scope) {\n        throw new Error('Scope items not nested properly: encountered \"end\" item without \"start\" item');\n      }\n      scope.end = {line, column};\n\n      if (scopeStack.length === 0) {\n        // We are done. There might be more top-level scopes but we only allow one.\n        return {root: scope, scopeForItemIndex};\n      }\n      scope.parent = scopeStack[scopeStack.length - 1];\n      scopeStack[scopeStack.length - 1].children.push(scope);\n    }\n  }\n  throw new Error('Malformed original scope encoding');\n}\n\ninterface EncodedOriginalScopeStart {\n  line: number;\n  column: number;\n  flags: number;\n  name?: number;\n  kind?: number;\n  variables: number[];\n}\n\nexport const enum EncodedOriginalScopeFlag {\n  HAS_NAME = 0x1,\n  HAS_KIND = 0x2,\n  IS_STACK_FRAME = 0x4,\n}\n\ninterface EncodedOriginalScopeEnd {\n  line: number;\n  column: number;\n}\n\nfunction isStart(item: EncodedOriginalScopeStart|EncodedOriginalScopeEnd): item is EncodedOriginalScopeStart {\n  return 'flags' in item;\n}\n\nfunction*\n    decodeOriginalScopeItems(encodedOriginalScope: string):\n        Generator<[number, EncodedOriginalScopeStart | EncodedOriginalScopeEnd]> {\n  const iter = new TokenIterator(encodedOriginalScope);\n  let prevColumn = 0;\n  let itemCount = 0;\n\n  while (iter.hasNext()) {\n    if (iter.peek() === ',') {\n      iter.next();  // Consume ','.\n    }\n\n    const [line, column] = [iter.nextVLQ(), iter.nextVLQ()];\n    if (line === 0 && column < prevColumn) {\n      throw new Error('Malformed original scope encoding: start/end items must be ordered w.r.t. source positions');\n    }\n    prevColumn = column;\n\n    if (!iter.hasNext() || iter.peek() === ',') {\n      yield [itemCount++, {line, column}];\n      continue;\n    }\n\n    const startItem: EncodedOriginalScopeStart = {\n      line,\n      column,\n      flags: iter.nextVLQ(),\n      variables: [],\n    };\n\n    if (startItem.flags & EncodedOriginalScopeFlag.HAS_NAME) {\n      startItem.name = iter.nextVLQ();\n    }\n    if (startItem.flags & EncodedOriginalScopeFlag.HAS_KIND) {\n      startItem.kind = iter.nextVLQ();\n    }\n\n    while (iter.hasNext() && iter.peek() !== ',') {\n      startItem.variables.push(iter.nextVLQ());\n    }\n\n    yield [itemCount++, startItem];\n  }\n}\n\nexport function decodeGeneratedRanges(\n    encodedGeneratedRange: string, originalScopeTrees: OriginalScopeTree[], names: string[]): GeneratedRange[] {\n  // We insert a pseudo range as there could be multiple top-level ranges and we need a root range those can be attached to.\n  const rangeStack: GeneratedRange[] = [{\n    start: {line: 0, column: 0},\n    end: {line: 0, column: 0},\n    isStackFrame: false,\n    isHidden: false,\n    children: [],\n    values: [],\n  }];\n  const rangeToStartItem = new Map<GeneratedRange, EncodedGeneratedRangeStart>();\n\n  for (const item of decodeGeneratedRangeItems(encodedGeneratedRange)) {\n    if (isRangeStart(item)) {\n      const range: GeneratedRange = {\n        start: {line: item.line, column: item.column},\n        end: {line: item.line, column: item.column},\n        isStackFrame: Boolean(item.flags & EncodedGeneratedRangeFlag.IS_STACK_FRAME),\n        isHidden: Boolean(item.flags & EncodedGeneratedRangeFlag.IS_HIDDEN),\n        values: [],\n        children: [],\n      };\n\n      if (item.definition) {\n        const {scopeIdx, sourceIdx} = item.definition;\n        if (!originalScopeTrees[sourceIdx]) {\n          throw new Error('Invalid source index!');\n        }\n        const originalScope = originalScopeTrees[sourceIdx].scopeForItemIndex.get(scopeIdx);\n        if (!originalScope) {\n          throw new Error('Invalid original scope index!');\n        }\n        range.originalScope = originalScope;\n      }\n\n      if (item.callsite) {\n        const {sourceIdx, line, column} = item.callsite;\n        if (!originalScopeTrees[sourceIdx]) {\n          throw new Error('Invalid source index!');\n        }\n        range.callsite = {\n          sourceIndex: sourceIdx,\n          line,\n          column,\n        };\n      }\n\n      rangeToStartItem.set(range, item);\n      rangeStack.push(range);\n    } else {\n      const range = rangeStack.pop();\n      if (!range) {\n        throw new Error('Range items not nested properly: encountered \"end\" item without \"start\" item');\n      }\n      range.end = {line: item.line, column: item.column};\n      resolveBindings(range, names, rangeToStartItem.get(range)?.bindings);\n      rangeStack[rangeStack.length - 1].children.push(range);\n    }\n  }\n\n  if (rangeStack.length !== 1) {\n    throw new Error('Malformed generated range encoding');\n  }\n  return rangeStack[0].children;\n}\n\nfunction resolveBindings(\n    range: GeneratedRange, names: string[],\n    bindingsForAllVars: EncodedGeneratedRangeStart['bindings']|undefined): void {\n  if (bindingsForAllVars === undefined) {\n    return;\n  }\n\n  range.values = bindingsForAllVars.map(bindings => {\n    if (bindings.length === 1) {\n      return resolveName(bindings[0].nameIdx, names);\n    }\n\n    const bindingRanges: BindingRange[] = bindings.map(binding => ({\n                                                         from: {line: binding.line, column: binding.column},\n                                                         to: {line: binding.line, column: binding.column},\n                                                         value: resolveName(binding.nameIdx, names),\n                                                       }));\n    for (let i = 1; i < bindingRanges.length; ++i) {\n      bindingRanges[i - 1].to = {...bindingRanges[i].from};\n    }\n    bindingRanges[bindingRanges.length - 1].to = {...range.end};\n    return bindingRanges;\n  });\n}\n\ninterface EncodedGeneratedRangeStart {\n  line: number;\n  column: number;\n  flags: number;\n  definition?: {\n    sourceIdx: number,\n    scopeIdx: number,\n  };\n  callsite?: {\n    sourceIdx: number,\n    line: number,\n    column: number,\n  };\n  bindings: {\n    line: number,\n    column: number,\n    nameIdx: number,\n  }[][];\n}\n\ninterface EncodedGeneratedRangeEnd {\n  line: number;\n  column: number;\n}\n\nexport const enum EncodedGeneratedRangeFlag {\n  HAS_DEFINITION = 0x1,\n  HAS_CALLSITE = 0x2,\n  IS_STACK_FRAME = 0x4,\n  IS_HIDDEN = 0x8,\n}\n\nfunction isRangeStart(item: EncodedGeneratedRangeStart|EncodedGeneratedRangeEnd): item is EncodedGeneratedRangeStart {\n  return 'flags' in item;\n}\n\nfunction*\n    decodeGeneratedRangeItems(encodedGeneratedRange: string):\n        Generator<EncodedGeneratedRangeStart|EncodedGeneratedRangeEnd> {\n  const iter = new TokenIterator(encodedGeneratedRange);\n  let line = 0;\n\n  // The state are the fields of the last produced item, tracked because many\n  // are relative to the preceeding item.\n  const state = {\n    line: 0,\n    column: 0,\n    defSourceIdx: 0,\n    defScopeIdx: 0,\n    callsiteSourceIdx: 0,\n    callsiteLine: 0,\n    callsiteColumn: 0,\n  };\n\n  while (iter.hasNext()) {\n    if (iter.peek() === ';') {\n      iter.next();  // Consume ';'.\n      ++line;\n      continue;\n    } else if (iter.peek() === ',') {\n      iter.next();  // Consume ','.\n      continue;\n    }\n\n    state.column = iter.nextVLQ() + (line === state.line ? state.column : 0);\n    state.line = line;\n    if (iter.peekVLQ() === null) {\n      yield {line, column: state.column};\n      continue;\n    }\n\n    const startItem: EncodedGeneratedRangeStart = {\n      line,\n      column: state.column,\n      flags: iter.nextVLQ(),\n      bindings: [],\n    };\n\n    if (startItem.flags & EncodedGeneratedRangeFlag.HAS_DEFINITION) {\n      const sourceIdx = iter.nextVLQ();\n      const scopeIdx = iter.nextVLQ();\n      state.defScopeIdx = scopeIdx + (sourceIdx === 0 ? state.defScopeIdx : 0);\n      state.defSourceIdx += sourceIdx;\n      startItem.definition = {\n        sourceIdx: state.defSourceIdx,\n        scopeIdx: state.defScopeIdx,\n      };\n    }\n\n    if (startItem.flags & EncodedGeneratedRangeFlag.HAS_CALLSITE) {\n      const sourceIdx = iter.nextVLQ();\n      const line = iter.nextVLQ();\n      const column = iter.nextVLQ();\n      state.callsiteColumn = column + (line === 0 && sourceIdx === 0 ? state.callsiteColumn : 0);\n      state.callsiteLine = line + (sourceIdx === 0 ? state.callsiteLine : 0);\n      state.callsiteSourceIdx += sourceIdx;\n      startItem.callsite = {\n        sourceIdx: state.callsiteSourceIdx,\n        line: state.callsiteLine,\n        column: state.callsiteColumn,\n      };\n    }\n\n    while (iter.hasNext() && iter.peek() !== ';' && iter.peek() !== ',') {\n      const bindings: EncodedGeneratedRangeStart['bindings'][number] = [];\n      startItem.bindings.push(bindings);\n\n      const idxOrSubrangeCount = iter.nextVLQ();\n      if (idxOrSubrangeCount >= -1) {\n        // Variable is available under the same expression in the whole range, or it's unavailable in the whole range.\n        bindings.push({line: startItem.line, column: startItem.column, nameIdx: idxOrSubrangeCount});\n        continue;\n      }\n\n      // Variable is available under different expressions in this range or unavailable in parts of this range.\n      bindings.push({line: startItem.line, column: startItem.column, nameIdx: iter.nextVLQ()});\n      const rangeCount = -idxOrSubrangeCount;\n      for (let i = 0; i < rangeCount - 1; ++i) {\n        // line, column, valueOffset\n        const line = iter.nextVLQ();\n        const column = iter.nextVLQ();\n        const nameIdx = iter.nextVLQ();\n\n        const lastLine = bindings.at(-1)?.line ?? 0;      // Only to make TS happy. `bindings` has one entry guaranteed.\n        const lastColumn = bindings.at(-1)?.column ?? 0;  // Only to make TS happy. `bindings` has one entry guaranteed.\n\n        bindings.push({\n          line: line + lastLine,\n          column: column + (line === 0 ? lastColumn : 0),\n          nameIdx,\n        });\n      }\n    }\n\n    yield startItem;\n  }\n}\n\nfunction resolveName(idx: number|undefined, names: string[]): string|undefined {\n  if (idx === undefined || idx < 0) {\n    return undefined;\n  }\n  return names[idx];\n}\n"],
  "mappings": ";AAcA,SAAQ,qBAAoB;AAiFrB,gBAAS,qBAAqB,uBAAiC,OAAsC;AAC1G,SAAO,sBAAsB,IAAI,WAAS,oBAAoB,OAAO,KAAK,CAAC;AAC7E;AAEA,SAAS,oBAAoB,sBAA8B,OAAoC;AAC7F,QAAM,oBAAoB,oBAAI,IAA2B;AACzD,QAAM,aAA8B,CAAC;AACrC,MAAI,OAAO;AACX,MAAI,UAAU;AAEd,aAAW,CAAC,OAAO,IAAI,KAAK,yBAAyB,oBAAoB,GAAG;AAC1E,YAAQ,KAAK;AACb,UAAM,EAAC,OAAM,IAAI;AACjB,QAAI,QAAQ,IAAI,GAAG;AACjB,UAAI;AACJ,UAAI,KAAK,SAAS,QAAW;AAC3B,mBAAW,KAAK;AAChB,eAAO,YAAY,SAAS,KAAK;AAAA,MACnC;AACA,YAAM,OAAO,YAAY,KAAK,MAAM,KAAK;AACzC,YAAM,YAAY,KAAK,UAAU,IAAI,SAAO,MAAM,GAAG,CAAC;AACtD,YAAM,QAAuB;AAAA,QAC3B,OAAO,EAAC,MAAM,OAAM;AAAA,QACpB,KAAK,EAAC,MAAM,OAAM;AAAA,QAClB;AAAA,QACA;AAAA,QACA,cAAc,QAAQ,KAAK,QAAQ,sBAAuC;AAAA,QAC1E;AAAA,QACA,UAAU,CAAC;AAAA,MACb;AACA,iBAAW,KAAK,KAAK;AACrB,wBAAkB,IAAI,OAAO,KAAK;AAAA,IACpC,OAAO;AACL,YAAM,QAAQ,WAAW,IAAI;AAC7B,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,8EAA8E;AAAA,MAChG;AACA,YAAM,MAAM,EAAC,MAAM,OAAM;AAEzB,UAAI,WAAW,WAAW,GAAG;AAE3B,eAAO,EAAC,MAAM,OAAO,kBAAiB;AAAA,MACxC;AACA,YAAM,SAAS,WAAW,WAAW,SAAS,CAAC;AAC/C,iBAAW,WAAW,SAAS,CAAC,EAAE,SAAS,KAAK,KAAK;AAAA,IACvD;AAAA,EACF;AACA,QAAM,IAAI,MAAM,mCAAmC;AACrD;AAWO,WAAW,2BAAX,kBAAWA,8BAAX;AACL,EAAAA,oDAAA,cAAW,KAAX;AACA,EAAAA,oDAAA,cAAW,KAAX;AACA,EAAAA,oDAAA,oBAAiB,KAAjB;AAHgB,SAAAA;AAAA,GAAA;AAWlB,SAAS,QAAQ,MAA4F;AAC3G,SAAO,WAAW;AACpB;AAEA,UACI,yBAAyB,sBACoD;AAC/E,QAAM,OAAO,IAAI,cAAc,oBAAoB;AACnD,MAAI,aAAa;AACjB,MAAI,YAAY;AAEhB,SAAO,KAAK,QAAQ,GAAG;AACrB,QAAI,KAAK,KAAK,MAAM,KAAK;AACvB,WAAK,KAAK;AAAA,IACZ;AAEA,UAAM,CAAC,MAAM,MAAM,IAAI,CAAC,KAAK,QAAQ,GAAG,KAAK,QAAQ,CAAC;AACtD,QAAI,SAAS,KAAK,SAAS,YAAY;AACrC,YAAM,IAAI,MAAM,4FAA4F;AAAA,IAC9G;AACA,iBAAa;AAEb,QAAI,CAAC,KAAK,QAAQ,KAAK,KAAK,KAAK,MAAM,KAAK;AAC1C,YAAM,CAAC,aAAa,EAAC,MAAM,OAAM,CAAC;AAClC;AAAA,IACF;AAEA,UAAM,YAAuC;AAAA,MAC3C;AAAA,MACA;AAAA,MACA,OAAO,KAAK,QAAQ;AAAA,MACpB,WAAW,CAAC;AAAA,IACd;AAEA,QAAI,UAAU,QAAQ,kBAAmC;AACvD,gBAAU,OAAO,KAAK,QAAQ;AAAA,IAChC;AACA,QAAI,UAAU,QAAQ,kBAAmC;AACvD,gBAAU,OAAO,KAAK,QAAQ;AAAA,IAChC;AAEA,WAAO,KAAK,QAAQ,KAAK,KAAK,KAAK,MAAM,KAAK;AAC5C,gBAAU,UAAU,KAAK,KAAK,QAAQ,CAAC;AAAA,IACzC;AAEA,UAAM,CAAC,aAAa,SAAS;AAAA,EAC/B;AACF;AAEO,gBAAS,sBACZ,uBAA+B,oBAAyC,OAAmC;AAE7G,QAAM,aAA+B,CAAC;AAAA,IACpC,OAAO,EAAC,MAAM,GAAG,QAAQ,EAAC;AAAA,IAC1B,KAAK,EAAC,MAAM,GAAG,QAAQ,EAAC;AAAA,IACxB,cAAc;AAAA,IACd,UAAU;AAAA,IACV,UAAU,CAAC;AAAA,IACX,QAAQ,CAAC;AAAA,EACX,CAAC;AACD,QAAM,mBAAmB,oBAAI,IAAgD;AAE7E,aAAW,QAAQ,0BAA0B,qBAAqB,GAAG;AACnE,QAAI,aAAa,IAAI,GAAG;AACtB,YAAM,QAAwB;AAAA,QAC5B,OAAO,EAAC,MAAM,KAAK,MAAM,QAAQ,KAAK,OAAM;AAAA,QAC5C,KAAK,EAAC,MAAM,KAAK,MAAM,QAAQ,KAAK,OAAM;AAAA,QAC1C,cAAc,QAAQ,KAAK,QAAQ,sBAAwC;AAAA,QAC3E,UAAU,QAAQ,KAAK,QAAQ,iBAAmC;AAAA,QAClE,QAAQ,CAAC;AAAA,QACT,UAAU,CAAC;AAAA,MACb;AAEA,UAAI,KAAK,YAAY;AACnB,cAAM,EAAC,UAAU,UAAS,IAAI,KAAK;AACnC,YAAI,CAAC,mBAAmB,SAAS,GAAG;AAClC,gBAAM,IAAI,MAAM,uBAAuB;AAAA,QACzC;AACA,cAAM,gBAAgB,mBAAmB,SAAS,EAAE,kBAAkB,IAAI,QAAQ;AAClF,YAAI,CAAC,eAAe;AAClB,gBAAM,IAAI,MAAM,+BAA+B;AAAA,QACjD;AACA,cAAM,gBAAgB;AAAA,MACxB;AAEA,UAAI,KAAK,UAAU;AACjB,cAAM,EAAC,WAAW,MAAM,OAAM,IAAI,KAAK;AACvC,YAAI,CAAC,mBAAmB,SAAS,GAAG;AAClC,gBAAM,IAAI,MAAM,uBAAuB;AAAA,QACzC;AACA,cAAM,WAAW;AAAA,UACf,aAAa;AAAA,UACb;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,uBAAiB,IAAI,OAAO,IAAI;AAChC,iBAAW,KAAK,KAAK;AAAA,IACvB,OAAO;AACL,YAAM,QAAQ,WAAW,IAAI;AAC7B,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,8EAA8E;AAAA,MAChG;AACA,YAAM,MAAM,EAAC,MAAM,KAAK,MAAM,QAAQ,KAAK,OAAM;AACjD,sBAAgB,OAAO,OAAO,iBAAiB,IAAI,KAAK,GAAG,QAAQ;AACnE,iBAAW,WAAW,SAAS,CAAC,EAAE,SAAS,KAAK,KAAK;AAAA,IACvD;AAAA,EACF;AAEA,MAAI,WAAW,WAAW,GAAG;AAC3B,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACtD;AACA,SAAO,WAAW,CAAC,EAAE;AACvB;AAEA,SAAS,gBACL,OAAuB,OACvB,oBAA4E;AAC9E,MAAI,uBAAuB,QAAW;AACpC;AAAA,EACF;AAEA,QAAM,SAAS,mBAAmB,IAAI,cAAY;AAChD,QAAI,SAAS,WAAW,GAAG;AACzB,aAAO,YAAY,SAAS,CAAC,EAAE,SAAS,KAAK;AAAA,IAC/C;AAEA,UAAM,gBAAgC,SAAS,IAAI,cAAY;AAAA,MACV,MAAM,EAAC,MAAM,QAAQ,MAAM,QAAQ,QAAQ,OAAM;AAAA,MACjD,IAAI,EAAC,MAAM,QAAQ,MAAM,QAAQ,QAAQ,OAAM;AAAA,MAC/C,OAAO,YAAY,QAAQ,SAAS,KAAK;AAAA,IAC3C,EAAE;AACrD,aAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,EAAE,GAAG;AAC7C,oBAAc,IAAI,CAAC,EAAE,KAAK,EAAC,GAAG,cAAc,CAAC,EAAE,KAAI;AAAA,IACrD;AACA,kBAAc,cAAc,SAAS,CAAC,EAAE,KAAK,EAAC,GAAG,MAAM,IAAG;AAC1D,WAAO;AAAA,EACT,CAAC;AACH;AA2BO,WAAW,4BAAX,kBAAWC,+BAAX;AACL,EAAAA,sDAAA,oBAAiB,KAAjB;AACA,EAAAA,sDAAA,kBAAe,KAAf;AACA,EAAAA,sDAAA,oBAAiB,KAAjB;AACA,EAAAA,sDAAA,eAAY,KAAZ;AAJgB,SAAAA;AAAA,GAAA;AAOlB,SAAS,aAAa,MAA+F;AACnH,SAAO,WAAW;AACpB;AAEA,UACI,0BAA0B,uBACyC;AACrE,QAAM,OAAO,IAAI,cAAc,qBAAqB;AACpD,MAAI,OAAO;AAIX,QAAM,QAAQ;AAAA,IACZ,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,cAAc;AAAA,IACd,aAAa;AAAA,IACb,mBAAmB;AAAA,IACnB,cAAc;AAAA,IACd,gBAAgB;AAAA,EAClB;AAEA,SAAO,KAAK,QAAQ,GAAG;AACrB,QAAI,KAAK,KAAK,MAAM,KAAK;AACvB,WAAK,KAAK;AACV,QAAE;AACF;AAAA,IACF,WAAW,KAAK,KAAK,MAAM,KAAK;AAC9B,WAAK,KAAK;AACV;AAAA,IACF;AAEA,UAAM,SAAS,KAAK,QAAQ,KAAK,SAAS,MAAM,OAAO,MAAM,SAAS;AACtE,UAAM,OAAO;AACb,QAAI,KAAK,QAAQ,MAAM,MAAM;AAC3B,YAAM,EAAC,MAAM,QAAQ,MAAM,OAAM;AACjC;AAAA,IACF;AAEA,UAAM,YAAwC;AAAA,MAC5C;AAAA,MACA,QAAQ,MAAM;AAAA,MACd,OAAO,KAAK,QAAQ;AAAA,MACpB,UAAU,CAAC;AAAA,IACb;AAEA,QAAI,UAAU,QAAQ,wBAA0C;AAC9D,YAAM,YAAY,KAAK,QAAQ;AAC/B,YAAM,WAAW,KAAK,QAAQ;AAC9B,YAAM,cAAc,YAAY,cAAc,IAAI,MAAM,cAAc;AACtE,YAAM,gBAAgB;AACtB,gBAAU,aAAa;AAAA,QACrB,WAAW,MAAM;AAAA,QACjB,UAAU,MAAM;AAAA,MAClB;AAAA,IACF;AAEA,QAAI,UAAU,QAAQ,sBAAwC;AAC5D,YAAM,YAAY,KAAK,QAAQ;AAC/B,YAAMC,QAAO,KAAK,QAAQ;AAC1B,YAAM,SAAS,KAAK,QAAQ;AAC5B,YAAM,iBAAiB,UAAUA,UAAS,KAAK,cAAc,IAAI,MAAM,iBAAiB;AACxF,YAAM,eAAeA,SAAQ,cAAc,IAAI,MAAM,eAAe;AACpE,YAAM,qBAAqB;AAC3B,gBAAU,WAAW;AAAA,QACnB,WAAW,MAAM;AAAA,QACjB,MAAM,MAAM;AAAA,QACZ,QAAQ,MAAM;AAAA,MAChB;AAAA,IACF;AAEA,WAAO,KAAK,QAAQ,KAAK,KAAK,KAAK,MAAM,OAAO,KAAK,KAAK,MAAM,KAAK;AACnE,YAAM,WAA2D,CAAC;AAClE,gBAAU,SAAS,KAAK,QAAQ;AAEhC,YAAM,qBAAqB,KAAK,QAAQ;AACxC,UAAI,sBAAsB,IAAI;AAE5B,iBAAS,KAAK,EAAC,MAAM,UAAU,MAAM,QAAQ,UAAU,QAAQ,SAAS,mBAAkB,CAAC;AAC3F;AAAA,MACF;AAGA,eAAS,KAAK,EAAC,MAAM,UAAU,MAAM,QAAQ,UAAU,QAAQ,SAAS,KAAK,QAAQ,EAAC,CAAC;AACvF,YAAM,aAAa,CAAC;AACpB,eAAS,IAAI,GAAG,IAAI,aAAa,GAAG,EAAE,GAAG;AAEvC,cAAMA,QAAO,KAAK,QAAQ;AAC1B,cAAM,SAAS,KAAK,QAAQ;AAC5B,cAAM,UAAU,KAAK,QAAQ;AAE7B,cAAM,WAAW,SAAS,GAAG,EAAE,GAAG,QAAQ;AAC1C,cAAM,aAAa,SAAS,GAAG,EAAE,GAAG,UAAU;AAE9C,iBAAS,KAAK;AAAA,UACZ,MAAMA,QAAO;AAAA,UACb,QAAQ,UAAUA,UAAS,IAAI,aAAa;AAAA,UAC5C;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM;AAAA,EACR;AACF;AAEA,SAAS,YAAY,KAAuB,OAAmC;AAC7E,MAAI,QAAQ,UAAa,MAAM,GAAG;AAChC,WAAO;AAAA,EACT;AACA,SAAO,MAAM,GAAG;AAClB;",
  "names": ["EncodedOriginalScopeFlag", "EncodedGeneratedRangeFlag", "line"]
}
