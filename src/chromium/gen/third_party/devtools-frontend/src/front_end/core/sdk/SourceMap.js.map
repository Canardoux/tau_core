{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/core/sdk/SourceMap.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the #name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Common from '../common/common.js';\nimport * as Platform from '../platform/platform.js';\nimport * as Root from '../root/root.js';\n\nimport type {CallFrame, ScopeChainEntry} from './DebuggerModel.js';\nimport {SourceMapScopesInfo} from './SourceMapScopesInfo.js';\n\n/**\n * Type of the base source map JSON object, which contains the sources and the mappings at the very least, plus\n * some additional fields.\n *\n * @see {@link SourceMapV3}\n * @see {@link https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k Source Map Revision 3 Proposal}\n */\nexport type SourceMapV3Object = {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  'version': number,\n  'sources': string[],\n  'mappings': string,\n\n  'file'?: string,\n  'sourceRoot'?: string,\n  'sourcesContent'?: (string|null)[],\n\n  'names'?: string[],\n  'ignoreList'?: number[],\n  'originalScopes'?: string[],\n  'generatedRanges'?: string,\n  'x_google_linecount'?: number,\n  'x_google_ignoreList'?: number[],\n  'x_com_bloomberg_sourcesFunctionMappings'?: string[],\n  /* eslint-enable @typescript-eslint/naming-convention */\n};\n\n/**\n * Type of JSON objects that classify as valid sourcemaps per version 3 of the specification.\n *\n * We support both possible formats, the traditional source map object (represented by the {@link SourceMapV3Object} type),\n * as well as the index map format, which consists of a sequence of sections that each hold source maps objects themselves\n * or URLs to external source map files.\n *\n * @see {@link SourceMapV3Object}\n * @see {@link https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k Source Map Revision 3 Proposal}\n */\nexport type SourceMapV3 = SourceMapV3Object|{\n  // clang-format off\n  'version': number,\n  'file'?: string,\n  'sections': ({\n    'offset': {line: number, column: number},\n    'map': SourceMapV3Object,\n  } | {\n    'offset': {line: number, column: number},\n    'url': string,\n  })[],\n  // clang-format on\n};\n\n/**\n * Parses the {@link content} as JSON, ignoring BOM markers in the beginning, and\n * also handling the CORB bypass prefix correctly.\n *\n * @param content the string representation of a sourcemap.\n * @returns the {@link SourceMapV3} representation of the {@link content}.\n */\nexport function parseSourceMap(content: string): SourceMapV3 {\n  if (content.startsWith(')]}')) {\n    content = content.substring(content.indexOf('\\n'));\n  }\n  if (content.charCodeAt(0) === 0xFEFF) {\n    // Strip BOM at the beginning before parsing the JSON.\n    content = content.slice(1);\n  }\n  return JSON.parse(content) as SourceMapV3;\n}\n\nexport class SourceMapEntry {\n  readonly lineNumber: number;\n  readonly columnNumber: number;\n  readonly sourceIndex?: number;\n  readonly sourceURL: Platform.DevToolsPath.UrlString|undefined;\n  readonly sourceLineNumber: number;\n  readonly sourceColumnNumber: number;\n  readonly name: string|undefined;\n\n  constructor(\n      lineNumber: number, columnNumber: number, sourceIndex?: number, sourceURL?: Platform.DevToolsPath.UrlString,\n      sourceLineNumber?: number, sourceColumnNumber?: number, name?: string) {\n    this.lineNumber = lineNumber;\n    this.columnNumber = columnNumber;\n    this.sourceIndex = sourceIndex;\n    this.sourceURL = sourceURL;\n    this.sourceLineNumber = (sourceLineNumber as number);\n    this.sourceColumnNumber = (sourceColumnNumber as number);\n    this.name = name;\n  }\n\n  static compare(entry1: SourceMapEntry, entry2: SourceMapEntry): number {\n    if (entry1.lineNumber !== entry2.lineNumber) {\n      return entry1.lineNumber - entry2.lineNumber;\n    }\n    return entry1.columnNumber - entry2.columnNumber;\n  }\n}\n\ninterface Position {\n  lineNumber: number;\n  columnNumber: number;\n}\n\nfunction comparePositions(a: Position, b: Position): number {\n  return a.lineNumber - b.lineNumber || a.columnNumber - b.columnNumber;\n}\n\nexport interface ScopeEntry {\n  scopeName(): string;\n  start(): Position;\n  end(): Position;\n}\n\nclass ScopeTreeEntry implements ScopeEntry {\n  children: ScopeTreeEntry[] = [];\n\n  constructor(\n      readonly startLineNumber: number, readonly startColumnNumber: number, readonly endLineNumber: number,\n      readonly endColumnNumber: number, readonly name: string) {\n  }\n\n  scopeName(): string {\n    return this.name;\n  }\n\n  start(): Position {\n    return {lineNumber: this.startLineNumber, columnNumber: this.startColumnNumber};\n  }\n\n  end(): Position {\n    return {lineNumber: this.endLineNumber, columnNumber: this.endColumnNumber};\n  }\n}\n\nconst sourceMapToSourceList = new WeakMap<SourceMapV3, Platform.DevToolsPath.UrlString[]>();\n\ninterface SourceInfo {\n  content: string|null;\n  ignoreListHint: boolean;\n  reverseMappings: number[]|null;\n  scopeTree: ScopeTreeEntry[]|null;\n}\n\nexport class SourceMap {\n  #json: SourceMapV3|null;\n  readonly #compiledURLInternal: Platform.DevToolsPath.UrlString;\n  readonly #sourceMappingURL: Platform.DevToolsPath.UrlString;\n  readonly #baseURL: Platform.DevToolsPath.UrlString;\n  #mappingsInternal: SourceMapEntry[]|null;\n  readonly #sourceInfos: Map<Platform.DevToolsPath.UrlString, SourceInfo>;\n\n  /* eslint-disable-next-line no-unused-private-class-members */\n  #scopesInfo: SourceMapScopesInfo|null = null;\n\n  /**\n   * Implements Source Map V3 model. See https://github.com/google/closure-compiler/wiki/Source-Maps\n   * for format description.\n   */\n  constructor(\n      compiledURL: Platform.DevToolsPath.UrlString, sourceMappingURL: Platform.DevToolsPath.UrlString,\n      payload: SourceMapV3) {\n    this.#json = payload;\n    this.#compiledURLInternal = compiledURL;\n    this.#sourceMappingURL = sourceMappingURL;\n    this.#baseURL = (Common.ParsedURL.schemeIs(sourceMappingURL, 'data:')) ? compiledURL : sourceMappingURL;\n\n    this.#mappingsInternal = null;\n    this.#sourceInfos = new Map();\n    if ('sections' in this.#json) {\n      if (this.#json.sections.find(section => 'url' in section)) {\n        Common.Console.Console.instance().warn(\n            `SourceMap \"${sourceMappingURL}\" contains unsupported \"URL\" field in one of its sections.`);\n      }\n    }\n    this.eachSection(this.parseSources.bind(this));\n  }\n\n  compiledURL(): Platform.DevToolsPath.UrlString {\n    return this.#compiledURLInternal;\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.#sourceMappingURL;\n  }\n\n  sourceURLs(): Platform.DevToolsPath.UrlString[] {\n    return [...this.#sourceInfos.keys()];\n  }\n\n  embeddedContentByURL(sourceURL: Platform.DevToolsPath.UrlString): string|null {\n    const entry = this.#sourceInfos.get(sourceURL);\n    if (!entry) {\n      return null;\n    }\n    return entry.content;\n  }\n\n  hasScopeInfo(): boolean {\n    this.#ensureMappingsProcessed();\n    return this.#scopesInfo !== null;\n  }\n\n  findEntry(lineNumber: number, columnNumber: number, inlineFrameIndex?: number): SourceMapEntry|null {\n    this.#ensureMappingsProcessed();\n    if (inlineFrameIndex && this.#scopesInfo !== null) {\n      // For inlineFrameIndex != 0 we use the callsite info for the corresponding inlining site.\n      // Note that the callsite for \"inlineFrameIndex\" is actually in the previous frame.\n      const {inlinedFunctions} = this.#scopesInfo.findInlinedFunctions(lineNumber, columnNumber);\n      const {callsite} = inlinedFunctions[inlineFrameIndex - 1];\n      if (!callsite) {\n        console.error('Malformed source map. Expected to have a callsite info for index', inlineFrameIndex);\n        return null;\n      }\n      return {\n        lineNumber,\n        columnNumber,\n        sourceIndex: callsite.sourceIndex,\n        sourceURL: this.sourceURLs()[callsite.sourceIndex],\n        sourceLineNumber: callsite.line,\n        sourceColumnNumber: callsite.column,\n        name: undefined,\n      };\n    }\n    const mappings = this.mappings();\n    const index = Platform.ArrayUtilities.upperBound(\n        mappings, undefined, (unused, entry) => lineNumber - entry.lineNumber || columnNumber - entry.columnNumber);\n    return index ? mappings[index - 1] : null;\n  }\n\n  findEntryRanges(lineNumber: number, columnNumber: number): {\n    range: TextUtils.TextRange.TextRange,\n    sourceRange: TextUtils.TextRange.TextRange,\n    sourceURL: Platform.DevToolsPath.UrlString,\n  }|null {\n    const mappings = this.mappings();\n    const endIndex = Platform.ArrayUtilities.upperBound(\n        mappings, undefined, (unused, entry) => lineNumber - entry.lineNumber || columnNumber - entry.columnNumber);\n    if (!endIndex) {\n      // If the line and column are preceding all the entries, then there is nothing to map.\n      return null;\n    }\n    // startIndex must be within mappings range because endIndex must be not falsy\n    const startIndex = endIndex - 1;\n    const sourceURL = mappings[startIndex].sourceURL;\n    if (!sourceURL) {\n      return null;\n    }\n\n    // Let us compute the range that contains the source position in the compiled code.\n    const endLine = endIndex < mappings.length ? mappings[endIndex].lineNumber : 2 ** 31 - 1;\n    const endColumn = endIndex < mappings.length ? mappings[endIndex].columnNumber : 2 ** 31 - 1;\n    const range = new TextUtils.TextRange.TextRange(\n        mappings[startIndex].lineNumber, mappings[startIndex].columnNumber, endLine, endColumn);\n\n    // Now try to find the corresponding token in the original code.\n    const reverseMappings = this.reversedMappings(sourceURL);\n    const startSourceLine = mappings[startIndex].sourceLineNumber;\n    const startSourceColumn = mappings[startIndex].sourceColumnNumber;\n    const endReverseIndex = Platform.ArrayUtilities.upperBound(\n        reverseMappings, undefined,\n        (unused, i) =>\n            startSourceLine - mappings[i].sourceLineNumber || startSourceColumn - mappings[i].sourceColumnNumber);\n    if (!endReverseIndex) {\n      return null;\n    }\n    const endSourceLine = endReverseIndex < reverseMappings.length ?\n        mappings[reverseMappings[endReverseIndex]].sourceLineNumber :\n        2 ** 31 - 1;\n    const endSourceColumn = endReverseIndex < reverseMappings.length ?\n        mappings[reverseMappings[endReverseIndex]].sourceColumnNumber :\n        2 ** 31 - 1;\n\n    const sourceRange =\n        new TextUtils.TextRange.TextRange(startSourceLine, startSourceColumn, endSourceLine, endSourceColumn);\n    return {range, sourceRange, sourceURL};\n  }\n\n  sourceLineMapping(sourceURL: Platform.DevToolsPath.UrlString, lineNumber: number, columnNumber: number):\n      SourceMapEntry|null {\n    const mappings = this.mappings();\n    const reverseMappings = this.reversedMappings(sourceURL);\n    const first = Platform.ArrayUtilities.lowerBound(reverseMappings, lineNumber, lineComparator);\n    const last = Platform.ArrayUtilities.upperBound(reverseMappings, lineNumber, lineComparator);\n    if (first >= reverseMappings.length || mappings[reverseMappings[first]].sourceLineNumber !== lineNumber) {\n      return null;\n    }\n    const columnMappings = reverseMappings.slice(first, last);\n    if (!columnMappings.length) {\n      return null;\n    }\n    const index = Platform.ArrayUtilities.lowerBound(\n        columnMappings, columnNumber, (columnNumber, i) => columnNumber - mappings[i].sourceColumnNumber);\n    return index >= columnMappings.length ? mappings[columnMappings[columnMappings.length - 1]] :\n                                            mappings[columnMappings[index]];\n\n    function lineComparator(lineNumber: number, i: number): number {\n      return lineNumber - mappings[i].sourceLineNumber;\n    }\n  }\n\n  private findReverseIndices(sourceURL: Platform.DevToolsPath.UrlString, lineNumber: number, columnNumber: number):\n      number[] {\n    const mappings = this.mappings();\n    const reverseMappings = this.reversedMappings(sourceURL);\n    const endIndex = Platform.ArrayUtilities.upperBound(\n        reverseMappings, undefined,\n        (unused, i) => lineNumber - mappings[i].sourceLineNumber || columnNumber - mappings[i].sourceColumnNumber);\n    let startIndex = endIndex;\n    while (startIndex > 0 &&\n           mappings[reverseMappings[startIndex - 1]].sourceLineNumber ===\n               mappings[reverseMappings[endIndex - 1]].sourceLineNumber &&\n           mappings[reverseMappings[startIndex - 1]].sourceColumnNumber ===\n               mappings[reverseMappings[endIndex - 1]].sourceColumnNumber) {\n      --startIndex;\n    }\n\n    return reverseMappings.slice(startIndex, endIndex);\n  }\n\n  findReverseEntries(sourceURL: Platform.DevToolsPath.UrlString, lineNumber: number, columnNumber: number):\n      SourceMapEntry[] {\n    const mappings = this.mappings();\n    return this.findReverseIndices(sourceURL, lineNumber, columnNumber).map(i => mappings[i]);\n  }\n\n  findReverseRanges(sourceURL: Platform.DevToolsPath.UrlString, lineNumber: number, columnNumber: number):\n      TextUtils.TextRange.TextRange[] {\n    const mappings = this.mappings();\n    const indices = this.findReverseIndices(sourceURL, lineNumber, columnNumber);\n    const ranges: TextUtils.TextRange.TextRange[] = [];\n\n    for (let i = 0; i < indices.length; ++i) {\n      const startIndex = indices[i];\n\n      // Merge adjacent ranges.\n      let endIndex = startIndex + 1;\n      while (i + 1 < indices.length && endIndex === indices[i + 1]) {\n        ++endIndex;\n        ++i;\n      }\n\n      // Source maps don't contain end positions for entries, but each entry is assumed to\n      // span until the following entry. This doesn't work however in case of the last\n      // entry, where there's no following entry. We also don't know the number of lines\n      // and columns in the original source code (which might not be available at all), so\n      // for that case we store the maximum signed 32-bit integer, which is definitely going\n      // to be larger than any script we can process and can safely be serialized as part of\n      // the skip list we send to V8 with `Debugger.stepOver` (http://crbug.com/1305956).\n      const startLine = mappings[startIndex].lineNumber;\n      const startColumn = mappings[startIndex].columnNumber;\n      const endLine = endIndex < mappings.length ? mappings[endIndex].lineNumber : 2 ** 31 - 1;\n      const endColumn = endIndex < mappings.length ? mappings[endIndex].columnNumber : 2 ** 31 - 1;\n      ranges.push(new TextUtils.TextRange.TextRange(startLine, startColumn, endLine, endColumn));\n    }\n\n    return ranges;\n  }\n\n  mappings(): SourceMapEntry[] {\n    this.#ensureMappingsProcessed();\n    return this.#mappingsInternal ?? [];\n  }\n\n  private reversedMappings(sourceURL: Platform.DevToolsPath.UrlString): number[] {\n    this.#ensureMappingsProcessed();\n    return this.#sourceInfos.get(sourceURL)?.reverseMappings ?? [];\n  }\n\n  #ensureMappingsProcessed(): void {\n    if (this.#mappingsInternal === null) {\n      this.#mappingsInternal = [];\n      try {\n        this.eachSection(this.parseMap.bind(this));\n      } catch (e) {\n        console.error('Failed to parse source map', e);\n        this.#mappingsInternal = [];\n      }\n\n      // As per spec, mappings are not necessarily sorted.\n      this.mappings().sort(SourceMapEntry.compare);\n\n      this.#computeReverseMappings(this.#mappingsInternal);\n      this.#json = null;\n    }\n  }\n\n  #computeReverseMappings(mappings: SourceMapEntry[]): void {\n    const reverseMappingsPerUrl = new Map<Platform.DevToolsPath.UrlString, number[]>();\n    for (let i = 0; i < mappings.length; i++) {\n      const entryUrl = mappings[i].sourceURL;\n      if (!entryUrl) {\n        continue;\n      }\n      let reverseMap = reverseMappingsPerUrl.get(entryUrl);\n      if (!reverseMap) {\n        reverseMap = [];\n        reverseMappingsPerUrl.set(entryUrl, reverseMap);\n      }\n      reverseMap.push(i);\n    }\n\n    for (const [url, reverseMap] of reverseMappingsPerUrl.entries()) {\n      const info = this.#sourceInfos.get(url);\n      if (!info) {\n        continue;\n      }\n      reverseMap.sort(sourceMappingComparator);\n      info.reverseMappings = reverseMap;\n    }\n\n    function sourceMappingComparator(indexA: number, indexB: number): number {\n      const a = mappings[indexA];\n      const b = mappings[indexB];\n      return a.sourceLineNumber - b.sourceLineNumber || a.sourceColumnNumber - b.sourceColumnNumber ||\n          a.lineNumber - b.lineNumber || a.columnNumber - b.columnNumber;\n    }\n  }\n\n  private eachSection(callback: (arg0: SourceMapV3Object, arg1: number, arg2: number) => void): void {\n    if (!this.#json) {\n      return;\n    }\n    if ('sections' in this.#json) {\n      for (const section of this.#json.sections) {\n        if ('map' in section) {\n          callback(section.map, section.offset.line, section.offset.column);\n        }\n      }\n    } else {\n      callback(this.#json, 0, 0);\n    }\n  }\n\n  private parseSources(sourceMap: SourceMapV3Object): void {\n    const sourcesList = [];\n    const sourceRoot = sourceMap.sourceRoot ?? '';\n    const ignoreList = new Set(sourceMap.ignoreList ?? sourceMap.x_google_ignoreList);\n    for (let i = 0; i < sourceMap.sources.length; ++i) {\n      let href = sourceMap.sources[i];\n      // The source map v3 proposal says to prepend the sourceRoot to the source URL\n      // and if the resulting URL is not absolute, then resolve the source URL against\n      // the source map URL. Prepending the sourceRoot (if one exists) is not likely to\n      // be meaningful or useful if the source URL is already absolute though. In this\n      // case, use the source URL as is without prepending the sourceRoot.\n      if (Common.ParsedURL.ParsedURL.isRelativeURL(href)) {\n        if (sourceRoot && !sourceRoot.endsWith('/') && href && !href.startsWith('/')) {\n          href = sourceRoot.concat('/', href);\n        } else {\n          href = sourceRoot.concat(href);\n        }\n      }\n      const url =\n          Common.ParsedURL.ParsedURL.completeURL(this.#baseURL, href) || (href as Platform.DevToolsPath.UrlString);\n      const source = sourceMap.sourcesContent && sourceMap.sourcesContent[i];\n      sourcesList.push(url);\n      if (!this.#sourceInfos.has(url)) {\n        const content = source ?? null;\n        const ignoreListHint = ignoreList.has(i);\n        this.#sourceInfos.set(url, {content, ignoreListHint, reverseMappings: null, scopeTree: null});\n      }\n    }\n    sourceMapToSourceList.set(sourceMap, sourcesList);\n  }\n\n  private parseMap(map: SourceMapV3Object, lineNumber: number, columnNumber: number): void {\n    let sourceIndex = 0;\n    let sourceLineNumber = 0;\n    let sourceColumnNumber = 0;\n    let nameIndex = 0;\n    // TODO(crbug.com/1011811): refactor away map.\n    // `sources` can be undefined if it wasn't previously\n    // processed and added to the list. However, that\n    // is not WAI and we should make sure that we can\n    // only reach this point when we are certain\n    // we have the list available.\n    const sources = sourceMapToSourceList.get(map);\n    const names = map.names ?? [];\n    const tokenIter = new TokenIterator(map.mappings);\n    let sourceURL: Platform.DevToolsPath.UrlString|undefined = sources && sources[sourceIndex];\n\n    while (true) {\n      if (tokenIter.peek() === ',') {\n        tokenIter.next();\n      } else {\n        while (tokenIter.peek() === ';') {\n          lineNumber += 1;\n          columnNumber = 0;\n          tokenIter.next();\n        }\n        if (!tokenIter.hasNext()) {\n          break;\n        }\n      }\n\n      columnNumber += tokenIter.nextVLQ();\n      if (!tokenIter.hasNext() || this.isSeparator(tokenIter.peek())) {\n        this.mappings().push(new SourceMapEntry(lineNumber, columnNumber));\n        continue;\n      }\n\n      const sourceIndexDelta = tokenIter.nextVLQ();\n      if (sourceIndexDelta) {\n        sourceIndex += sourceIndexDelta;\n        if (sources) {\n          sourceURL = sources[sourceIndex];\n        }\n      }\n      sourceLineNumber += tokenIter.nextVLQ();\n      sourceColumnNumber += tokenIter.nextVLQ();\n\n      if (!tokenIter.hasNext() || this.isSeparator(tokenIter.peek())) {\n        this.mappings().push(\n            new SourceMapEntry(lineNumber, columnNumber, sourceIndex, sourceURL, sourceLineNumber, sourceColumnNumber));\n        continue;\n      }\n\n      nameIndex += tokenIter.nextVLQ();\n      this.mappings().push(new SourceMapEntry(\n          lineNumber, columnNumber, sourceIndex, sourceURL, sourceLineNumber, sourceColumnNumber, names[nameIndex]));\n    }\n\n    if (Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.USE_SOURCE_MAP_SCOPES)) {\n      this.parseBloombergScopes(map);\n      this.#parseScopes(map);\n    }\n  }\n\n  private parseBloombergScopes(map: SourceMapV3Object): void {\n    if (!map.x_com_bloomberg_sourcesFunctionMappings) {\n      return;\n    }\n    const sources = sourceMapToSourceList.get(map);\n    if (!sources) {\n      return;\n    }\n    const names = map.names ?? [];\n    const scopeList = map.x_com_bloomberg_sourcesFunctionMappings;\n\n    for (let i = 0; i < sources?.length; i++) {\n      if (!scopeList[i] || !sources[i]) {\n        continue;\n      }\n      const sourceInfo = this.#sourceInfos.get(sources[i]);\n      if (!sourceInfo) {\n        continue;\n      }\n      const scopes = scopeList[i];\n\n      let nameIndex = 0;\n      let startLineNumber = 0;\n      let startColumnNumber = 0;\n      let endLineNumber = 0;\n      let endColumnNumber = 0;\n\n      const tokenIter = new TokenIterator(scopes);\n      const entries: ScopeTreeEntry[] = [];\n      let atStart = true;\n      while (tokenIter.hasNext()) {\n        if (atStart) {\n          atStart = false;\n        } else if (tokenIter.peek() === ',') {\n          tokenIter.next();\n        } else {\n          // Unexpected character.\n          return;\n        }\n        nameIndex += tokenIter.nextVLQ();\n        startLineNumber += tokenIter.nextVLQ();\n        startColumnNumber += tokenIter.nextVLQ();\n        endLineNumber += tokenIter.nextVLQ();\n        endColumnNumber += tokenIter.nextVLQ();\n        entries.push(new ScopeTreeEntry(\n            startLineNumber, startColumnNumber, endLineNumber, endColumnNumber, names[nameIndex] ?? '<invalid>'));\n      }\n      sourceInfo.scopeTree = this.buildScopeTree(entries);\n    }\n  }\n\n  private buildScopeTree(entries: ScopeTreeEntry[]): ScopeTreeEntry[] {\n    const toplevel: ScopeTreeEntry[] = [];\n    entries.sort((l, r) => comparePositions(l.start(), r.start()));\n\n    const stack: ScopeTreeEntry[] = [];\n\n    for (const entry of entries) {\n      const start = entry.start();\n      // Pop all the scopes that precede the current entry.\n      while (stack.length > 0) {\n        const top = stack[stack.length - 1];\n        if (comparePositions(top.end(), start) < 0) {\n          stack.pop();\n        } else {\n          break;\n        }\n      }\n\n      if (stack.length > 0) {\n        stack[stack.length - 1].children.push(entry);\n      } else {\n        toplevel.push(entry);\n      }\n      stack.push(entry);\n    }\n    return toplevel;\n  }\n\n  #parseScopes(map: SourceMapV3Object): void {\n    if (map.originalScopes && map.generatedRanges) {\n      this.#scopesInfo = SourceMapScopesInfo.parseFromMap(this, map);\n    }\n  }\n\n  findScopeEntry(sourceURL: Platform.DevToolsPath.UrlString, sourceLineNumber: number, sourceColumnNumber: number):\n      ScopeEntry|null {\n    const sourceInfo = this.#sourceInfos.get(sourceURL);\n    if (!sourceInfo || !sourceInfo.scopeTree) {\n      return null;\n    }\n    const position: Position = {lineNumber: sourceLineNumber, columnNumber: sourceColumnNumber};\n\n    let current: ScopeTreeEntry|null = null;\n    while (true) {\n      const children: ScopeTreeEntry[] = current?.children ?? sourceInfo.scopeTree;\n      const match = children.find(\n          child => comparePositions(child.start(), position) <= 0 && comparePositions(position, child.end()) <= 0);\n      if (!match) {\n        return current;\n      }\n      current = match;\n    }\n  }\n\n  private isSeparator(char: string): boolean {\n    return char === ',' || char === ';';\n  }\n\n  /**\n   * Finds all the reverse mappings that intersect with the given `textRange` within the\n   * source entity identified by the `url`. If the `url` does not have any reverse mappings\n   * within this source map, an empty array is returned.\n   *\n   * @param url the URL of the source entity to query.\n   * @param textRange the range of text within the entity to check, considered `[start,end[`.\n   * @returns the list of ranges in the generated file that map to locations overlapping the\n   *          {@link textRange} in the source file identified by the {@link url}, or `[]`\n   *          if the {@link url} does not identify an entity in this source map.\n   */\n  reverseMapTextRanges(url: Platform.DevToolsPath.UrlString, textRange: TextUtils.TextRange.TextRange):\n      TextUtils.TextRange.TextRange[] {\n    const reverseMappings = this.reversedMappings(url);\n    const mappings = this.mappings();\n    if (reverseMappings.length === 0) {\n      return [];\n    }\n\n    // Determine the first reverse mapping that contains the starting point of the `textRange`.\n    let startReverseIndex =\n        Platform.ArrayUtilities.lowerBound(reverseMappings, textRange, ({startLine, startColumn}, index) => {\n          const {sourceLineNumber, sourceColumnNumber} = mappings[index];\n          return startLine - sourceLineNumber || startColumn - sourceColumnNumber;\n        });\n\n    // Check if the current mapping does not start on the exact start of the `textRange`, and if\n    // so we know that a previous mapping entry (if any) would also overlap. If we reach the end\n    // of the reverse mappings table, we just take the last entry and report that.\n    while (startReverseIndex === reverseMappings.length ||\n           startReverseIndex > 0 &&\n               (mappings[reverseMappings[startReverseIndex]].sourceLineNumber > textRange.startLine ||\n                mappings[reverseMappings[startReverseIndex]].sourceColumnNumber > textRange.startColumn)) {\n      startReverseIndex--;\n    }\n\n    // Determine the last reverse mapping that contains the end point of the `textRange`.\n    let endReverseIndex = startReverseIndex + 1;\n    for (; endReverseIndex < reverseMappings.length; ++endReverseIndex) {\n      const {sourceLineNumber, sourceColumnNumber} = mappings[reverseMappings[endReverseIndex]];\n      if (sourceLineNumber < textRange.endLine ||\n          (sourceLineNumber === textRange.endLine && sourceColumnNumber < textRange.endColumn)) {\n        continue;\n      }\n      break;\n    }\n\n    // Create the ranges...\n    const ranges = [];\n    for (let reverseIndex = startReverseIndex; reverseIndex < endReverseIndex; ++reverseIndex) {\n      const startIndex = reverseMappings[reverseIndex], endIndex = startIndex + 1;\n      const range = TextUtils.TextRange.TextRange.createUnboundedFromLocation(\n          mappings[startIndex].lineNumber, mappings[startIndex].columnNumber);\n      if (endIndex < mappings.length) {\n        range.endLine = mappings[endIndex].lineNumber;\n        range.endColumn = mappings[endIndex].columnNumber;\n      }\n      ranges.push(range);\n    }\n\n    // ...sort them...\n    ranges.sort(TextUtils.TextRange.TextRange.comparator);\n\n    // ...and ensure they are maximally merged.\n    let j = 0;\n    for (let i = 1; i < ranges.length; ++i) {\n      if (ranges[j].immediatelyPrecedes(ranges[i])) {\n        ranges[j].endLine = ranges[i].endLine;\n        ranges[j].endColumn = ranges[i].endColumn;\n      } else {\n        ranges[++j] = ranges[i];\n      }\n    }\n    ranges.length = j + 1;\n\n    return ranges;\n  }\n\n  mapsOrigin(): boolean {\n    const mappings = this.mappings();\n    if (mappings.length > 0) {\n      const firstEntry = mappings[0];\n      return firstEntry?.lineNumber === 0 || firstEntry.columnNumber === 0;\n    }\n    return false;\n  }\n\n  hasIgnoreListHint(sourceURL: Platform.DevToolsPath.UrlString): boolean {\n    return this.#sourceInfos.get(sourceURL)?.ignoreListHint ?? false;\n  }\n\n  /**\n   * Returns a list of ranges in the generated script for original sources that\n   * match a predicate. Each range is a [begin, end) pair, meaning that code at\n   * the beginning location, up to but not including the end location, matches\n   * the predicate.\n   */\n  findRanges(predicate: (sourceURL: Platform.DevToolsPath.UrlString) => boolean, options?: {isStartMatching: boolean}):\n      TextUtils.TextRange.TextRange[] {\n    const mappings = this.mappings();\n    const ranges = [];\n\n    if (!mappings.length) {\n      return [];\n    }\n\n    let current: TextUtils.TextRange.TextRange|null = null;\n\n    // If the first mapping isn't at the beginning of the original source, it's\n    // up to the caller to decide if it should be considered matching the\n    // predicate or not. By default, it's not.\n    if ((mappings[0].lineNumber !== 0 || mappings[0].columnNumber !== 0) && options?.isStartMatching) {\n      current = TextUtils.TextRange.TextRange.createUnboundedFromLocation(0, 0);\n      ranges.push(current);\n    }\n\n    for (const {sourceURL, lineNumber, columnNumber} of mappings) {\n      const ignoreListHint = sourceURL && predicate(sourceURL);\n\n      if (!current && ignoreListHint) {\n        current = TextUtils.TextRange.TextRange.createUnboundedFromLocation(lineNumber, columnNumber);\n        ranges.push(current);\n        continue;\n      }\n      if (current && !ignoreListHint) {\n        current.endLine = lineNumber;\n        current.endColumn = columnNumber;\n        current = null;\n      }\n    }\n\n    return ranges;\n  }\n\n  /**\n   * Determines whether this and the {@link other} `SourceMap` agree on content and ignore-list hint\n   * with respect to the {@link sourceURL}.\n   *\n   * @param sourceURL the URL to test for (might not be provided by either of the sourcemaps).\n   * @param other the other `SourceMap` to check.\n   * @returns `true` if both this and the {@link other} `SourceMap` either both have the ignore-list\n   *          hint for {@link sourceURL} or neither, and if both of them either provide the same\n   *          content for the {@link sourceURL} inline or both provide no `sourcesContent` entry\n   *          for it.\n   */\n  compatibleForURL(sourceURL: Platform.DevToolsPath.UrlString, other: SourceMap): boolean {\n    return this.embeddedContentByURL(sourceURL) === other.embeddedContentByURL(sourceURL) &&\n        this.hasIgnoreListHint(sourceURL) === other.hasIgnoreListHint(sourceURL);\n  }\n\n  expandCallFrame(frame: CallFrame): CallFrame[] {\n    this.#ensureMappingsProcessed();\n    if (this.#scopesInfo === null) {\n      return [frame];\n    }\n\n    return this.#scopesInfo.expandCallFrame(frame);\n  }\n\n  resolveScopeChain(frame: CallFrame): ScopeChainEntry[]|null {\n    this.#ensureMappingsProcessed();\n    if (this.#scopesInfo === null) {\n      return null;\n    }\n\n    return this.#scopesInfo.resolveMappedScopeChain(frame);\n  }\n}\n\nconst VLQ_BASE_SHIFT = 5;\nconst VLQ_BASE_MASK = (1 << 5) - 1;\nconst VLQ_CONTINUATION_MASK = 1 << 5;\n\nexport class TokenIterator {\n  readonly #string: string;\n  #position: number;\n\n  constructor(string: string) {\n    this.#string = string;\n    this.#position = 0;\n  }\n\n  next(): string {\n    return this.#string.charAt(this.#position++);\n  }\n\n  /** Returns the unicode value of the next character and advances the iterator  */\n  nextCharCode(): number {\n    return this.#string.charCodeAt(this.#position++);\n  }\n\n  peek(): string {\n    return this.#string.charAt(this.#position);\n  }\n\n  hasNext(): boolean {\n    return this.#position < this.#string.length;\n  }\n\n  nextVLQ(): number {\n    // Read unsigned value.\n    let result = 0;\n    let shift = 0;\n    let digit: number = VLQ_CONTINUATION_MASK;\n    while (digit & VLQ_CONTINUATION_MASK) {\n      if (!this.hasNext()) {\n        throw new Error('Unexpected end of input while decodling VLQ number!');\n      }\n      const charCode = this.nextCharCode();\n      digit = Common.Base64.BASE64_CODES[charCode];\n      if (charCode !== 65 /* 'A' */ && digit === 0) {\n        throw new Error(`Unexpected char '${String.fromCharCode(charCode)}' encountered while decoding`);\n      }\n      result += (digit & VLQ_BASE_MASK) << shift;\n      shift += VLQ_BASE_SHIFT;\n    }\n\n    // Fix the sign.\n    const negative = result & 1;\n    result >>= 1;\n    return negative ? -result : result;\n  }\n\n  /**\n   * @returns the next VLQ number without iterating further. Or returns null if\n   * the iterator is at the end or it's not a valid number.\n   */\n  peekVLQ(): null|number {\n    const pos = this.#position;\n    try {\n      return this.nextVLQ();\n    } catch {\n      return null;\n    } finally {\n      this.#position = pos;  // Reset the iterator.\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["columnNumber", "lineNumber"]
}
