{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/entrypoints/formatter_worker/ScopeParser.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Acorn from '../../third_party/acorn/acorn.js';\n\nimport {ECMA_VERSION} from './AcornTokenizer.js';\n\nimport {DefinitionKind, type ScopeTreeNode} from './FormatterActions.js';\n\nexport function parseScopes(expression: string, sourceType: 'module'|'script' = 'script'): Scope|null {\n  // Parse the expression and find variables and scopes.\n  let root: Acorn.ESTree.Node|null = null;\n  try {\n    root = Acorn.parse(\n               expression, {ecmaVersion: ECMA_VERSION, allowAwaitOutsideFunction: true, ranges: false, sourceType}) as\n        Acorn.ESTree.Node;\n  } catch {\n    return null;\n  }\n  return new ScopeVariableAnalysis(root).run();\n}\n\nexport interface Use {\n  offset: number;\n  scope: Scope;\n  isShorthandAssignmentProperty: boolean;\n}\n\nexport interface VariableUses {\n  definitionKind: DefinitionKind;\n  uses: Use[];\n}\n\nexport class Scope {\n  readonly variables = new Map<string, VariableUses>();\n  readonly parent: Scope|null;\n  readonly start: number;\n  readonly end: number;\n  readonly children: Scope[] = [];\n\n  constructor(start: number, end: number, parent: Scope|null) {\n    this.start = start;\n    this.end = end;\n    this.parent = parent;\n    if (parent) {\n      parent.children.push(this);\n    }\n  }\n\n  export(): ScopeTreeNode {\n    const variables = [];\n    for (const variable of this.variables) {\n      const offsets = [];\n      for (const use of variable[1].uses) {\n        offsets.push(use.offset);\n      }\n      variables.push({name: variable[0], kind: variable[1].definitionKind, offsets});\n    }\n    const children = this.children.map(c => c.export());\n    return {\n      start: this.start,\n      end: this.end,\n      variables,\n      children,\n    };\n  }\n\n  addVariable(name: string, offset: number, definitionKind: DefinitionKind, isShorthandAssignmentProperty: boolean):\n      void {\n    const variable = this.variables.get(name);\n    const use = {offset, scope: this, isShorthandAssignmentProperty};\n    if (!variable) {\n      this.variables.set(name, {definitionKind, uses: [use]});\n      return;\n    }\n    if (variable.definitionKind === DefinitionKind.NONE) {\n      variable.definitionKind = definitionKind;\n    }\n    variable.uses.push(use);\n  }\n\n  findBinders(name: string): VariableUses[] {\n    const result = [];\n    let scope: Scope|null = this;\n    while (scope !== null) {\n      const defUse = scope.variables.get(name);\n      if (defUse && defUse.definitionKind !== DefinitionKind.NONE) {\n        result.push(defUse);\n      }\n      scope = scope.parent;\n    }\n    return result;\n  }\n\n  #mergeChildDefUses(name: string, defUses: VariableUses): void {\n    const variable = this.variables.get(name);\n    if (!variable) {\n      this.variables.set(name, defUses);\n      return;\n    }\n    variable.uses.push(...defUses.uses);\n    if (defUses.definitionKind === DefinitionKind.VAR) {\n      console.assert(variable.definitionKind !== DefinitionKind.LET);\n      if (variable.definitionKind === DefinitionKind.NONE) {\n        variable.definitionKind = defUses.definitionKind;\n      }\n    } else {\n      console.assert(defUses.definitionKind === DefinitionKind.NONE);\n    }\n  }\n\n  finalizeToParent(isFunctionScope: boolean): void {\n    if (!this.parent) {\n      console.error('Internal error: wrong nesting in scope analysis.');\n      throw new Error('Internal error');\n    }\n\n    // Move all unbound variables to the parent (also move var-bound variables\n    // if the parent is not a function).\n    const keysToRemove = [];\n    for (const [name, defUse] of this.variables.entries()) {\n      if (defUse.definitionKind === DefinitionKind.NONE ||\n          (defUse.definitionKind === DefinitionKind.VAR && !isFunctionScope)) {\n        this.parent.#mergeChildDefUses(name, defUse);\n        keysToRemove.push(name);\n      }\n    }\n    keysToRemove.forEach(k => this.variables.delete(k));\n  }\n}\n\nexport class ScopeVariableAnalysis {\n  readonly #rootScope: Scope;\n  readonly #allNames = new Set<string>();\n  #currentScope: Scope;\n  readonly #rootNode: Acorn.ESTree.Node;\n\n  constructor(node: Acorn.ESTree.Node) {\n    this.#rootNode = node;\n    this.#rootScope = new Scope(node.start, node.end, null);\n    this.#currentScope = this.#rootScope;\n  }\n\n  run(): Scope {\n    this.#processNode(this.#rootNode);\n    return this.#rootScope;\n  }\n\n  #processNode(node: Acorn.ESTree.Node|null): void {\n    if (node === null) {\n      return;\n    }\n    switch (node.type) {\n      case 'AwaitExpression':\n        this.#processNode(node.argument);\n        break;\n      case 'ArrayExpression':\n        node.elements.forEach(item => this.#processNode(item));\n        break;\n      case 'ExpressionStatement':\n        this.#processNode(node.expression);\n        break;\n      case 'Program':\n        console.assert(this.#currentScope === this.#rootScope);\n        node.body.forEach(item => this.#processNode(item));\n        console.assert(this.#currentScope === this.#rootScope);\n        break;\n      case 'ArrayPattern':\n        node.elements.forEach(item => this.#processNode(item));\n        break;\n      case 'ArrowFunctionExpression': {\n        this.#pushScope(node.start, node.end);\n        node.params.forEach(this.#processNodeAsDefinition.bind(this, DefinitionKind.VAR, false));\n        if (node.body.type === 'BlockStatement') {\n          // Include the body of the arrow function in the same scope as the arguments.\n          node.body.body.forEach(this.#processNode.bind(this));\n        } else {\n          this.#processNode(node.body);\n        }\n        this.#popScope(true);\n        break;\n      }\n      case 'AssignmentExpression':\n      case 'AssignmentPattern':\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        this.#processNode(node.left);\n        this.#processNode(node.right);\n        break;\n      case 'BlockStatement':\n        this.#pushScope(node.start, node.end);\n        node.body.forEach(this.#processNode.bind(this));\n        this.#popScope(false);\n        break;\n      case 'CallExpression':\n        this.#processNode(node.callee);\n        node.arguments.forEach(this.#processNode.bind(this));\n        break;\n      case 'VariableDeclaration': {\n        const definitionKind = node.kind === 'var' ? DefinitionKind.VAR : DefinitionKind.LET;\n        node.declarations.forEach(this.#processVariableDeclarator.bind(this, definitionKind));\n        break;\n      }\n      case 'CatchClause':\n        this.#pushScope(node.start, node.end);\n        this.#processNodeAsDefinition(DefinitionKind.LET, false, node.param);\n        this.#processNode(node.body);\n        this.#popScope(false);\n        break;\n      case 'ClassBody':\n        node.body.forEach(this.#processNode.bind(this));\n        break;\n      case 'ClassDeclaration':\n        this.#processNodeAsDefinition(DefinitionKind.LET, false, node.id);\n        this.#processNode(node.superClass ?? null);\n        this.#processNode(node.body);\n        break;\n      case 'ClassExpression':\n        // Intentionally ignore the id.\n        this.#processNode(node.superClass ?? null);\n        this.#processNode(node.body);\n        break;\n      case 'ChainExpression':\n        this.#processNode(node.expression);\n        break;\n      case 'ConditionalExpression':\n        this.#processNode(node.test);\n        this.#processNode(node.consequent);\n        this.#processNode(node.alternate);\n        break;\n      case 'DoWhileStatement':\n        this.#processNode(node.body);\n        this.#processNode(node.test);\n        break;\n      case 'ForInStatement':\n      case 'ForOfStatement':\n        this.#pushScope(node.start, node.end);\n        this.#processNode(node.left);\n        this.#processNode(node.right);\n        this.#processNode(node.body);\n        this.#popScope(false);\n        break;\n      case 'ForStatement':\n        this.#pushScope(node.start, node.end);\n        this.#processNode(node.init ?? null);\n        this.#processNode(node.test ?? null);\n        this.#processNode(node.update ?? null);\n        this.#processNode(node.body);\n        this.#popScope(false);\n        break;\n      case 'FunctionDeclaration':\n        this.#processNodeAsDefinition(DefinitionKind.VAR, false, node.id);\n        this.#pushScope(node.id?.end ?? node.start, node.end);\n        this.#addVariable('this', node.start, DefinitionKind.FIXED);\n        this.#addVariable('arguments', node.start, DefinitionKind.FIXED);\n        node.params.forEach(this.#processNodeAsDefinition.bind(this, DefinitionKind.LET, false));\n        // Process the body of the block statement directly to avoid creating new scope.\n        node.body.body.forEach(this.#processNode.bind(this));\n        this.#popScope(true);\n        break;\n      case 'FunctionExpression':\n        this.#pushScope(node.id?.end ?? node.start, node.end);\n        this.#addVariable('this', node.start, DefinitionKind.FIXED);\n        this.#addVariable('arguments', node.start, DefinitionKind.FIXED);\n        node.params.forEach(this.#processNodeAsDefinition.bind(this, DefinitionKind.LET, false));\n        // Process the body of the block statement directly to avoid creating new scope.\n        node.body.body.forEach(this.#processNode.bind(this));\n        this.#popScope(true);\n        break;\n      case 'Identifier':\n        this.#addVariable(node.name, node.start);\n        break;\n      case 'IfStatement':\n        this.#processNode(node.test);\n        this.#processNode(node.consequent);\n        this.#processNode(node.alternate ?? null);\n        break;\n      case 'LabeledStatement':\n        this.#processNode(node.body);\n        break;\n      case 'MetaProperty':\n        break;\n      case 'MethodDefinition':\n        if (node.computed) {\n          this.#processNode(node.key);\n        }\n        this.#processNode(node.value);\n        break;\n      case 'NewExpression':\n        this.#processNode(node.callee);\n        node.arguments.forEach(this.#processNode.bind(this));\n        break;\n      case 'MemberExpression':\n        this.#processNode(node.object);\n        if (node.computed) {\n          this.#processNode(node.property);\n        }\n        break;\n      case 'ObjectExpression':\n        node.properties.forEach(this.#processNode.bind(this));\n        break;\n      case 'ObjectPattern':\n        node.properties.forEach(this.#processNode.bind(this));\n        break;\n      case 'PrivateIdentifier':\n        break;\n      case 'PropertyDefinition':\n        if (node.computed) {\n          this.#processNode(node.key);\n        }\n        this.#processNode(node.value ?? null);\n        break;\n      case 'Property':\n        if (node.shorthand) {\n          console.assert(node.value.type === 'Identifier');\n          console.assert(node.key.type === 'Identifier');\n          console.assert((node.value as Acorn.ESTree.Identifier).name === (node.key as Acorn.ESTree.Identifier).name);\n          this.#addVariable((node.value as Acorn.ESTree.Identifier).name, node.value.start, DefinitionKind.NONE, true);\n        } else {\n          if (node.computed) {\n            this.#processNode(node.key);\n          }\n          this.#processNode(node.value);\n        }\n        break;\n      case 'RestElement':\n        this.#processNodeAsDefinition(DefinitionKind.LET, false, node.argument);\n        break;\n      case 'ReturnStatement':\n        this.#processNode(node.argument ?? null);\n        break;\n      case 'SequenceExpression':\n        node.expressions.forEach(this.#processNode.bind(this));\n        break;\n      case 'SpreadElement':\n        this.#processNode(node.argument);\n        break;\n      case 'SwitchCase':\n        this.#processNode(node.test ?? null);\n        node.consequent.forEach(this.#processNode.bind(this));\n        break;\n      case 'SwitchStatement':\n        this.#processNode(node.discriminant);\n        node.cases.forEach(this.#processNode.bind(this));\n        break;\n      case 'TaggedTemplateExpression':\n        this.#processNode(node.tag);\n        this.#processNode(node.quasi);\n        break;\n      case 'TemplateLiteral':\n        node.expressions.forEach(this.#processNode.bind(this));\n        break;\n      case 'ThisExpression':\n        this.#addVariable('this', node.start);\n        break;\n      case 'ThrowStatement':\n        this.#processNode(node.argument);\n        break;\n      case 'TryStatement':\n        this.#processNode(node.block);\n        this.#processNode(node.handler ?? null);\n        this.#processNode(node.finalizer ?? null);\n        break;\n      case 'WithStatement':\n        this.#processNode(node.object);\n        // TODO jarin figure how to treat the with body.\n        this.#processNode(node.body);\n        break;\n      case 'YieldExpression':\n        this.#processNode(node.argument ?? null);\n        break;\n      case 'UnaryExpression':\n      case 'UpdateExpression':\n        this.#processNode(node.argument);\n        break;\n      case 'WhileStatement':\n        this.#processNode(node.test);\n        this.#processNode(node.body);\n        break;\n\n      // Ignore, no expressions involved.\n      case 'BreakStatement':\n      case 'ContinueStatement':\n      case 'DebuggerStatement':\n      case 'EmptyStatement':\n      case 'Literal':\n      case 'Super':\n      case 'TemplateElement':\n        break;\n        // Ignore, cannot be used outside of a module.\n      case 'ImportDeclaration':\n      case 'ImportDefaultSpecifier':\n      case 'ImportNamespaceSpecifier':\n      case 'ImportSpecifier':\n      case 'ImportExpression':\n      case 'ExportAllDeclaration':\n      case 'ExportDefaultDeclaration':\n      case 'ExportNamedDeclaration':\n      case 'ExportSpecifier':\n        break;\n\n      case 'VariableDeclarator':\n        console.error('Should not encounter VariableDeclarator in general traversal.');\n        break;\n    }\n  }\n\n  getFreeVariables(): Map<string, Use[]> {\n    const result = new Map<string, Use[]>();\n    for (const [name, defUse] of this.#rootScope.variables) {\n      if (defUse.definitionKind !== DefinitionKind.NONE) {\n        // Skip bound variables.\n        continue;\n      }\n      result.set(name, defUse.uses);\n    }\n    return result;\n  }\n\n  getAllNames(): Set<string> {\n    return this.#allNames;\n  }\n\n  #pushScope(start: number, end: number): void {\n    this.#currentScope = new Scope(start, end, this.#currentScope);\n  }\n\n  #popScope(isFunctionContext: boolean): void {\n    if (this.#currentScope.parent === null) {\n      console.error('Internal error: wrong nesting in scope analysis.');\n      throw new Error('Internal error');\n    }\n    this.#currentScope.finalizeToParent(isFunctionContext);\n    this.#currentScope = this.#currentScope.parent;\n  }\n\n  #addVariable(\n      name: string, offset: number, definitionKind: DefinitionKind = DefinitionKind.NONE,\n      isShorthandAssignmentProperty: boolean = false): void {\n    this.#allNames.add(name);\n    this.#currentScope.addVariable(name, offset, definitionKind, isShorthandAssignmentProperty);\n  }\n\n  #processNodeAsDefinition(\n      definitionKind: DefinitionKind.LET|DefinitionKind.VAR, isShorthandAssignmentProperty: boolean,\n      node: Acorn.ESTree.Pattern|Acorn.ESTree.AssignmentProperty|null): void {\n    if (node === null) {\n      return;\n    }\n    switch (node.type) {\n      case 'ArrayPattern':\n        node.elements.forEach(this.#processNodeAsDefinition.bind(this, definitionKind, false));\n        break;\n      case 'AssignmentPattern':\n        this.#processNodeAsDefinition(definitionKind, isShorthandAssignmentProperty, node.left);\n        this.#processNode(node.right);\n        break;\n      case 'Identifier':\n        this.#addVariable(node.name, node.start, definitionKind, isShorthandAssignmentProperty);\n        break;\n      case 'MemberExpression':\n        this.#processNode(node.object);\n        if (node.computed) {\n          this.#processNode(node.property);\n        }\n        break;\n      case 'ObjectPattern':\n        node.properties.forEach(this.#processNodeAsDefinition.bind(this, definitionKind, false));\n        break;\n      case 'Property':\n        if (node.computed) {\n          this.#processNode(node.key);\n        }\n        this.#processNodeAsDefinition(definitionKind, node.shorthand, node.value);\n        break;\n      case 'RestElement':\n        this.#processNodeAsDefinition(definitionKind, false, node.argument);\n        break;\n    }\n  }\n\n  #processVariableDeclarator(\n      definitionKind: DefinitionKind.LET|DefinitionKind.VAR, decl: Acorn.ESTree.VariableDeclarator): void {\n    this.#processNodeAsDefinition(definitionKind, false, decl.id);\n    this.#processNode(decl.init ?? null);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
