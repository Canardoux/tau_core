{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/entrypoints/formatter_worker/HTMLFormatter.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {CSSFormatter} from './CSSFormatter.js';\nimport type {FormattedContentBuilder} from './FormattedContentBuilder.js';\nimport {AbortTokenization, createTokenizer} from './FormatterWorker.js';\nimport {JavaScriptFormatter} from './JavaScriptFormatter.js';\nimport {JSONFormatter} from './JSONFormatter.js';\n\nexport class HTMLFormatter {\n  readonly #builder: FormattedContentBuilder;\n  readonly #jsFormatter: JavaScriptFormatter;\n  readonly #jsonFormatter: JSONFormatter;\n  readonly #cssFormatter: CSSFormatter;\n  #text?: string;\n  #lineEndings?: number[];\n  #model?: HTMLModel;\n\n  constructor(builder: FormattedContentBuilder) {\n    this.#builder = builder;\n    this.#jsFormatter = new JavaScriptFormatter(builder);\n    this.#jsonFormatter = new JSONFormatter(builder);\n    this.#cssFormatter = new CSSFormatter(builder);\n  }\n\n  format(text: string, lineEndings: number[]): void {\n    this.#text = text;\n    this.#lineEndings = lineEndings;\n    this.#model = new HTMLModel(text);\n    this.#walk(this.#model.document());\n  }\n\n  #formatTokensTill(element: FormatterElement, offset: number): void {\n    if (!this.#model) {\n      return;\n    }\n\n    let nextToken = this.#model.peekToken();\n    while (nextToken && nextToken.startOffset < offset) {\n      const token = (this.#model.nextToken() as Token);\n      this.#formatToken(element, token);\n      nextToken = this.#model.peekToken();\n    }\n  }\n\n  #walk(element: FormatterElement): void {\n    if (!element.openTag || !element.closeTag) {\n      throw new Error('Element is missing open or close tag');\n    }\n\n    if (element.parent) {\n      this.#formatTokensTill(element.parent, element.openTag.startOffset);\n    }\n    this.#beforeOpenTag(element);\n    this.#formatTokensTill(element, element.openTag.endOffset);\n    this.#afterOpenTag(element);\n    for (let i = 0; i < element.children.length; ++i) {\n      this.#walk(element.children[i]);\n    }\n\n    this.#formatTokensTill(element, element.closeTag.startOffset);\n    this.#beforeCloseTag(element);\n    this.#formatTokensTill(element, element.closeTag.endOffset);\n    this.#afterCloseTag(element);\n  }\n\n  #beforeOpenTag(element: FormatterElement): void {\n    if (!this.#model) {\n      return;\n    }\n\n    if (!element.children.length || element === this.#model.document()) {\n      return;\n    }\n    this.#builder.addNewLine();\n  }\n\n  #afterOpenTag(element: FormatterElement): void {\n    if (!this.#model) {\n      return;\n    }\n\n    if (!element.children.length || element === this.#model.document()) {\n      return;\n    }\n    this.#builder.increaseNestingLevel();\n    this.#builder.addNewLine();\n  }\n\n  #beforeCloseTag(element: FormatterElement): void {\n    if (!this.#model) {\n      return;\n    }\n\n    if (!element.children.length || element === this.#model.document()) {\n      return;\n    }\n    this.#builder.decreaseNestingLevel();\n    this.#builder.addNewLine();\n  }\n\n  #afterCloseTag(_element: FormatterElement): void {\n    this.#builder.addNewLine();\n  }\n\n  #formatToken(element: FormatterElement, token: Token): void {\n    if (Platform.StringUtilities.isWhitespace(token.value)) {\n      return;\n    }\n    if (hasTokenInSet(token.type, 'comment') || hasTokenInSet(token.type, 'meta')) {\n      this.#builder.addNewLine();\n      this.#builder.addToken(token.value.trim(), token.startOffset);\n      this.#builder.addNewLine();\n      return;\n    }\n\n    if (!element.openTag || !element.closeTag) {\n      return;\n    }\n\n    const isBodyToken =\n        element.openTag.endOffset <= token.startOffset && token.startOffset < element.closeTag.startOffset;\n    if (isBodyToken && element.name === 'style') {\n      this.#builder.addNewLine();\n      this.#builder.increaseNestingLevel();\n      this.#cssFormatter.format(this.#text || '', this.#lineEndings || [], token.startOffset, token.endOffset);\n      this.#builder.decreaseNestingLevel();\n      return;\n    }\n    if (isBodyToken && element.name === 'script') {\n      this.#builder.addNewLine();\n      this.#builder.increaseNestingLevel();\n      if (scriptTagIsJavaScript(element)) {\n        this.#jsFormatter.format(this.#text || '', this.#lineEndings || [], token.startOffset, token.endOffset);\n      } else if (scriptTagIsJSON(element)) {\n        this.#jsonFormatter.format(this.#text || '', this.#lineEndings || [], token.startOffset, token.endOffset);\n      } else {\n        this.#builder.addToken(token.value, token.startOffset);\n        this.#builder.addNewLine();\n      }\n      this.#builder.decreaseNestingLevel();\n      return;\n    }\n\n    if (!isBodyToken && hasTokenInSet(token.type, 'attribute')) {\n      this.#builder.addSoftSpace();\n    }\n\n    this.#builder.addToken(token.value, token.startOffset);\n  }\n}\n\nfunction scriptTagIsJavaScript(element: FormatterElement): boolean {\n  if (!element.openTag) {\n    return true;\n  }\n\n  if (!element.openTag.attributes.has('type')) {\n    return true;\n  }\n\n  let type = element.openTag.attributes.get('type');\n  if (!type) {\n    return true;\n  }\n\n  type = type.toLowerCase();\n  const isWrappedInQuotes = /^([\"\\'])(.*)\\1$/.exec(type.trim());\n  if (isWrappedInQuotes) {\n    type = isWrappedInQuotes[2];\n  }\n  return [\n    'application/ecmascript',\n    'application/javascript',\n    'application/x-ecmascript',\n    'application/x-javascript',\n    'module',\n    'text/ecmascript',\n    'text/javascript',\n    'text/javascript1.0',\n    'text/javascript1.1',\n    'text/javascript1.2',\n    'text/javascript1.3',\n    'text/javascript1.4',\n    'text/javascript1.5',\n    'text/jscript',\n    'text/livescript',\n    'text/x-ecmascript',\n    'text/x-javascript',\n  ].includes(type.trim());\n}\n\nfunction scriptTagIsJSON(element: FormatterElement): boolean {\n  if (!element.openTag) {\n    return false;\n  }\n\n  let type = element.openTag.attributes.get('type');\n  if (!type) {\n    return false;\n  }\n\n  type = type.toLowerCase();\n  const isWrappedInQuotes = /^([\"\\'])(.*)\\1$/.exec(type.trim());\n  if (isWrappedInQuotes) {\n    type = isWrappedInQuotes[2];\n  }\n  const isSubtype = /^application\\/\\w+\\+json$/.exec(type.trim());\n  if (isSubtype) {\n    type = 'application/json';\n  }\n  return [\n    'application/json',\n    'importmap',\n    'speculationrules',\n  ].includes(type.trim());\n}\n\nfunction hasTokenInSet(tokenTypes: Set<string>, type: string): boolean {\n  // We prefix the CodeMirror HTML tokenizer with the xml- prefix\n  // in a full version. When running in a worker context, this\n  // prefix is not appended, as the global is only overridden\n  // in CodeMirrorTextEditor.js.\n  return tokenTypes.has(type) || tokenTypes.has(`xml-${type}`);\n}\n\nexport class HTMLModel {\n  #state: ParseState;\n  readonly #documentInternal: FormatterElement;\n  #stack: FormatterElement[];\n  readonly #tokens: Token[];\n  #tokenIndex: number;\n  #attributes: Map<string, string>;\n  #attributeName: string;\n  #tagName: string;\n  #isOpenTag: boolean;\n  #tagStartOffset?: number|null;\n  #tagEndOffset?: number|null;\n\n  constructor(text: string) {\n    this.#state = ParseState.INITIAL;\n    this.#documentInternal = new FormatterElement('document');\n    this.#documentInternal.openTag = new Tag('document', 0, 0, new Map(), true, false);\n    this.#documentInternal.closeTag = new Tag('document', text.length, text.length, new Map(), false, false);\n\n    this.#stack = [this.#documentInternal];\n\n    this.#tokens = [];\n    this.#tokenIndex = 0;\n    this.#build(text);\n\n    this.#attributes = new Map();\n    this.#attributeName = '';\n    this.#tagName = '';\n    this.#isOpenTag = false;\n  }\n\n  #build(text: string): void {\n    const tokenizer = createTokenizer('text/html');\n    let baseOffset = 0, lastOffset = 0;\n    let pendingToken: Token|null = null;\n\n    const pushToken = (token: Token): Object|undefined => {\n      this.#tokens.push(token);\n      this.#updateDOM(token);\n\n      const element = this.#stack[this.#stack.length - 1];\n      if (element && (element.name === 'script' || element.name === 'style') && element.openTag &&\n          element.openTag.endOffset === lastOffset) {\n        return AbortTokenization;\n      }\n\n      return;\n    };\n\n    const processToken = (\n        tokenValue: string,\n        type: string|null,\n        tokenStart: number,\n        tokenEnd: number,\n        ): Object|undefined => {\n      tokenStart += baseOffset;\n      tokenEnd += baseOffset;\n      lastOffset = tokenEnd;\n\n      const tokenType = type ? new Set<string>(type.split(' ')) : new Set<string>();\n      const token = new Token(tokenValue, tokenType, tokenStart, tokenEnd);\n\n      // This is a pretty horrible work-around for two bugs in the CodeMirror 5 HTML\n      // tokenizer, which aren't easy to fix because it shares this code with the\n      // XML parser[^1], and which is also not actively maintained anymore. The\n      // real fix here is to migrate off of CodeMirror 5 also for formatting and\n      // pretty printing and use CodeMirror 6 instead, but that's a bigger\n      // project.\n      //\n      // For now we ducktape the first problem by merging a '/' token\n      // following a string token in the HTML formatter, which does the trick, and\n      // also merging the error tokens for unescaped ampersands with text tokens\n      // (where `type` is `null`) preceeding and following the error tokens.\n      //\n      // [^1]: https://github.com/codemirror/codemirror5/blob/742627a/mode/xml/xml.js#L137\n      //\n      if (pendingToken) {\n        if (tokenValue === '/' && type === 'attribute' && pendingToken.type.has('string')) {\n          token.startOffset = pendingToken.startOffset;\n          token.value = `${pendingToken.value}${tokenValue}`;\n          token.type = pendingToken.type;\n        } else if (\n            (tokenValue.startsWith('&') && type === 'error' && pendingToken.type.size === 0) ||\n            (type === null && pendingToken.type.has('error'))) {\n          pendingToken.endOffset = token.endOffset;\n          pendingToken.value += tokenValue;\n          pendingToken.type = token.type;\n          return;\n        } else if (pushToken(pendingToken) === AbortTokenization) {\n          return AbortTokenization;\n        }\n        pendingToken = null;\n      }\n      if (type === 'string' || type === null) {\n        pendingToken = token;\n        return;\n      }\n\n      return pushToken(token);\n    };\n\n    while (true) {\n      baseOffset = lastOffset;\n      tokenizer(text.substring(lastOffset), processToken);\n      if (pendingToken) {\n        pushToken(pendingToken);\n        pendingToken = null;\n      }\n      if (lastOffset >= text.length) {\n        break;\n      }\n      const element = this.#stack[this.#stack.length - 1];\n      if (!element) {\n        break;\n      }\n\n      while (true) {\n        lastOffset = text.indexOf('</', lastOffset);\n        if (lastOffset === -1) {\n          lastOffset = text.length;\n          break;\n        }\n        if (text.substring(lastOffset + 2).toLowerCase().startsWith(element.name)) {\n          break;\n        }\n        lastOffset += 2;\n      }\n\n      if (!element.openTag) {\n        break;\n      }\n\n      const tokenStart = element.openTag.endOffset;\n      const tokenEnd = lastOffset;\n      const tokenValue = text.substring(tokenStart, tokenEnd);\n      this.#tokens.push(new Token(tokenValue, new Set(), tokenStart, tokenEnd));\n    }\n\n    while (this.#stack.length > 1) {\n      const element = this.#stack[this.#stack.length - 1];\n      if (!element) {\n        break;\n      }\n\n      this.#popElement(new Tag(element.name, text.length, text.length, new Map(), false, false));\n    }\n  }\n\n  #updateDOM(token: Token): void {\n    const value = token.value;\n    const type = token.type;\n    switch (this.#state) {\n      case ParseState.INITIAL:\n        if (hasTokenInSet(type, 'bracket') && (value === '<' || value === '</')) {\n          this.#onStartTag(token);\n          this.#state = ParseState.TAG;\n        }\n        return;\n      case ParseState.TAG:\n        if (hasTokenInSet(type, 'tag') && !hasTokenInSet(type, 'bracket')) {\n          this.#tagName = value.trim().toLowerCase();\n        } else if (hasTokenInSet(type, 'attribute')) {\n          this.#attributeName = value.trim().toLowerCase();\n          this.#attributes.set(this.#attributeName, '');\n          this.#state = ParseState.ATTRIBUTE_NAME;\n        } else if (hasTokenInSet(type, 'bracket') && (value === '>' || value === '/>')) {\n          this.#onEndTag(token);\n          this.#state = ParseState.INITIAL;\n        }\n        return;\n      case ParseState.ATTRIBUTE_NAME:\n        if (!type.size && value === '=') {\n          this.#state = ParseState.ATTRIBUTE_VALUE;\n        } else if (hasTokenInSet(type, 'bracket') && (value === '>' || value === '/>')) {\n          this.#onEndTag(token);\n          this.#state = ParseState.INITIAL;\n        }\n        return;\n      case ParseState.ATTRIBUTE_VALUE:\n        if (hasTokenInSet(type, 'string')) {\n          this.#attributes.set(this.#attributeName, value);\n          this.#state = ParseState.TAG;\n        } else if (hasTokenInSet(type, 'bracket') && (value === '>' || value === '/>')) {\n          this.#onEndTag(token);\n          this.#state = ParseState.INITIAL;\n        }\n        return;\n    }\n  }\n\n  #onStartTag(token: Token): void {\n    this.#tagName = '';\n    this.#tagStartOffset = token.startOffset;\n    this.#tagEndOffset = null;\n    this.#attributes = new Map();\n    this.#attributeName = '';\n    this.#isOpenTag = token.value === '<';\n  }\n\n  #onEndTag(token: Token): void {\n    this.#tagEndOffset = token.endOffset;\n    const selfClosingTag = token.value === '/>' || SelfClosingTags.has(this.#tagName);\n    const tag = new Tag(\n        this.#tagName, this.#tagStartOffset || 0, this.#tagEndOffset, this.#attributes, this.#isOpenTag,\n        selfClosingTag);\n    this.#onTagComplete(tag);\n  }\n\n  #onTagComplete(tag: Tag): void {\n    if (tag.isOpenTag) {\n      const topElement = this.#stack[this.#stack.length - 1];\n      if (topElement) {\n        const tagSet = AutoClosingTags.get(topElement.name);\n        if (topElement !== this.#documentInternal && topElement.openTag && topElement.openTag.selfClosingTag) {\n          this.#popElement(autocloseTag(topElement, topElement.openTag.endOffset));\n        } else if (tagSet && tagSet.has(tag.name)) {\n          this.#popElement(autocloseTag(topElement, tag.startOffset));\n        }\n        this.#pushElement(tag);\n      }\n      return;\n    }\n\n    let lastTag = this.#stack[this.#stack.length - 1];\n    while (this.#stack.length > 1 && lastTag && lastTag.name !== tag.name) {\n      this.#popElement(autocloseTag(lastTag, tag.startOffset));\n      lastTag = this.#stack[this.#stack.length - 1];\n    }\n    if (this.#stack.length === 1) {\n      return;\n    }\n    this.#popElement(tag);\n\n    function autocloseTag(element: FormatterElement, offset: number): Tag {\n      return new Tag(element.name, offset, offset, new Map(), false, false);\n    }\n  }\n\n  #popElement(closeTag: Tag): void {\n    const element = this.#stack.pop();\n    if (!element) {\n      return;\n    }\n    element.closeTag = closeTag;\n  }\n\n  #pushElement(openTag: Tag): void {\n    const topElement = this.#stack[this.#stack.length - 1];\n    const newElement = new FormatterElement(openTag.name);\n    if (topElement) {\n      newElement.parent = topElement;\n      topElement.children.push(newElement);\n    }\n    newElement.openTag = openTag;\n    this.#stack.push(newElement);\n  }\n\n  peekToken(): Token|null {\n    return this.#tokenIndex < this.#tokens.length ? this.#tokens[this.#tokenIndex] : null;\n  }\n\n  nextToken(): Token|null {\n    return this.#tokens[this.#tokenIndex++];\n  }\n\n  document(): FormatterElement {\n    return this.#documentInternal;\n  }\n}\n\nconst SelfClosingTags = new Set<string>([\n  'area',\n  'base',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n]);\n\n// @see https://www.w3.org/TR/html/syntax.html 8.1.2.4 Optional tags\nconst AutoClosingTags = new Map([\n  ['head', new Set(['body'])],\n  ['li', new Set(['li'])],\n  ['dt', new Set(['dt', 'dd'])],\n  ['dd', new Set(['dt', 'dd'])],\n  [\n    'p',\n    new Set([\n      'address', 'article', 'aside', 'blockquote', 'div', 'dl',      'fieldset', 'footer', 'form',\n      'h1',      'h2',      'h3',    'h4',         'h5',  'h6',      'header',   'hgroup', 'hr',\n      'main',    'nav',     'ol',    'p',          'pre', 'section', 'table',    'ul',\n    ]),\n  ],\n  ['rb', new Set(['rb', 'rt', 'rtc', 'rp'])],\n  ['rt', new Set(['rb', 'rt', 'rtc', 'rp'])],\n  ['rtc', new Set(['rb', 'rtc', 'rp'])],\n  ['rp', new Set(['rb', 'rt', 'rtc', 'rp'])],\n  ['optgroup', new Set(['optgroup'])],\n  ['option', new Set(['option', 'optgroup'])],\n  ['colgroup', new Set(['colgroup'])],\n  ['thead', new Set(['tbody', 'tfoot'])],\n  ['tbody', new Set(['tbody', 'tfoot'])],\n  ['tfoot', new Set(['tbody'])],\n  ['tr', new Set(['tr'])],\n  ['td', new Set(['td', 'th'])],\n  ['th', new Set(['td', 'th'])],\n]);\n\nconst enum ParseState {\n  INITIAL = 'Initial',\n  TAG = 'Tag',\n  ATTRIBUTE_NAME = 'AttributeName',\n  ATTRIBUTE_VALUE = 'AttributeValue',\n}\n\nclass Token {\n  value: string;\n  type: Set<string>;\n  startOffset: number;\n  endOffset: number;\n\n  constructor(value: string, type: Set<string>, startOffset: number, endOffset: number) {\n    this.value = value;\n    this.type = type;\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n  }\n}\n\nclass Tag {\n  name: string;\n  startOffset: number;\n  endOffset: number;\n  attributes: Map<string, string>;\n  isOpenTag: boolean;\n  selfClosingTag: boolean;\n\n  constructor(\n      name: string, startOffset: number, endOffset: number, attributes: Map<string, string>, isOpenTag: boolean,\n      selfClosingTag: boolean) {\n    this.name = name;\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.attributes = attributes;\n    this.isOpenTag = isOpenTag;\n    this.selfClosingTag = selfClosingTag;\n  }\n}\n\nclass FormatterElement {\n  name: string;\n  children: FormatterElement[] = [];\n  parent: FormatterElement|null = null;\n  openTag: Tag|null = null;\n  closeTag: Tag|null = null;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n"],
  "mappings": "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",
  "names": ["ParseState"]
}
