{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/entrypoints/formatter_worker/JavaScriptFormatter.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Acorn from '../../third_party/acorn/acorn.js';\n\nimport {AcornTokenizer, ECMA_VERSION, type TokenOrComment} from './AcornTokenizer.js';\nimport {ESTreeWalker} from './ESTreeWalker.js';\nimport type {FormattedContentBuilder} from './FormattedContentBuilder.js';\n\nexport class JavaScriptFormatter {\n  readonly #builder: FormattedContentBuilder;\n  #tokenizer!: AcornTokenizer;\n  #content!: string;\n  #fromOffset!: number;\n  #lastLineNumber!: number;\n  #toOffset?: number;\n  constructor(builder: FormattedContentBuilder) {\n    this.#builder = builder;\n  }\n\n  format(text: string, lineEndings: number[], fromOffset: number, toOffset: number): void {\n    this.#fromOffset = fromOffset;\n    this.#toOffset = toOffset;\n    this.#content = text.substring(this.#fromOffset, this.#toOffset);\n    this.#lastLineNumber = 0;\n    const tokens: (Acorn.Token|Acorn.Comment)[] = [];\n    const ast = Acorn.parse(this.#content, {\n      ranges: false,\n      preserveParens: true,\n      allowAwaitOutsideFunction: true,\n      allowImportExportEverywhere: true,\n      ecmaVersion: ECMA_VERSION,\n      allowHashBang: true,\n      onToken: tokens as Acorn.Token[],\n      onComment: tokens as Acorn.Comment[],\n    });\n    this.#tokenizer = new AcornTokenizer(this.#content, tokens);\n    const walker = new ESTreeWalker(this.#beforeVisit.bind(this), this.#afterVisit.bind(this));\n    // @ts-ignore Technically, the acorn Node type is a subclass of Acorn.ESTree.Node.\n    // However, the acorn package currently exports its type without specifying\n    // this relationship. So while this is allowed on runtime, we can't properly\n    // typecheck it.\n    walker.walk(ast);\n  }\n\n  #push(token: Acorn.Token|Acorn.Comment|null, format: string): void {\n    for (let i = 0; i < format.length; ++i) {\n      if (format[i] === 's') {\n        this.#builder.addSoftSpace();\n      } else if (format[i] === 'S') {\n        this.#builder.addHardSpace();\n      } else if (format[i] === 'n') {\n        this.#builder.addNewLine();\n      } else if (format[i] === '>') {\n        this.#builder.increaseNestingLevel();\n      } else if (format[i] === '<') {\n        this.#builder.decreaseNestingLevel();\n      } else if (format[i] === 't') {\n        if (this.#tokenizer.tokenLineStart() - this.#lastLineNumber > 1) {\n          this.#builder.addNewLine(true);\n        }\n        this.#lastLineNumber = this.#tokenizer.tokenLineEnd();\n        if (token) {\n          this.#builder.addToken(this.#content.substring(token.start, token.end), this.#fromOffset + token.start);\n        }\n      }\n    }\n  }\n\n  #beforeVisit(node: Acorn.ESTree.Node): undefined {\n    if (!node.parent) {\n      return;\n    }\n    if (node.type === 'TemplateLiteral') {\n      this.#builder.setEnforceSpaceBetweenWords(false);\n    }\n    let token;\n    while ((token = this.#tokenizer.peekToken()) && token.start < node.start) {\n      const token = (this.#tokenizer.nextToken() as TokenOrComment);\n      // @ts-ignore Same reason as above about Acorn types and ESTree types\n      const format = this.#formatToken(node.parent, token);\n      this.#push(token, format);\n    }\n  }\n\n  #afterVisit(node: Acorn.ESTree.Node): void {\n    let token;\n    while ((token = this.#tokenizer.peekToken()) && token.start < node.end) {\n      const token = (this.#tokenizer.nextToken() as TokenOrComment);\n      const format = this.#formatToken(node, token);\n      this.#push(token, format);\n    }\n    this.#push(null, this.#finishNode(node));\n    if (node.type === 'TemplateLiteral') {\n      this.#builder.setEnforceSpaceBetweenWords(true);\n    }\n  }\n\n  #inForLoopHeader(node: Acorn.ESTree.Node): boolean {\n    const parent = node.parent;\n    if (!parent) {\n      return false;\n    }\n    if (parent.type === 'ForStatement') {\n      const parentNode = (parent as Acorn.ESTree.ForStatement);\n      return node === parentNode.init || node === parentNode.test || node === parentNode.update;\n    }\n    if (parent.type === 'ForInStatement' || parent.type === 'ForOfStatement') {\n      const parentNode = (parent as Acorn.ESTree.ForInStatement | Acorn.ESTree.ForOfStatement);\n      return node === parentNode.left || node === parentNode.right;\n    }\n    return false;\n  }\n\n  #formatToken(node: Acorn.ESTree.Node, tokenOrComment: TokenOrComment): string {\n    const AT = AcornTokenizer;\n    if (AT.lineComment(tokenOrComment)) {\n      return 'tn';\n    }\n    if (AT.blockComment(tokenOrComment)) {\n      return 'tn';\n    }\n    const token = (tokenOrComment as Acorn.Token);\n    const nodeType = node.type;\n    if (nodeType === 'ContinueStatement' || nodeType === 'BreakStatement') {\n      return node.label && AT.keyword(token) ? 'ts' : 't';\n    }\n    if (nodeType === 'Identifier') {\n      return 't';\n    }\n    if (nodeType === 'PrivateIdentifier') {\n      return 't';\n    }\n    if (nodeType === 'ReturnStatement') {\n      if (AT.punctuator(token, ';')) {\n        return 't';\n      }\n      return node.argument ? 'ts' : 't';\n    }\n    if (nodeType === 'AwaitExpression') {\n      if (AT.punctuator(token, ';')) {\n        return 't';\n      }\n      return node.argument ? 'ts' : 't';\n    }\n    if (nodeType === 'Property') {\n      if (AT.punctuator(token, ':')) {\n        return 'ts';\n      }\n      return 't';\n    }\n    if (nodeType === 'ArrayExpression') {\n      if (AT.punctuator(token, ',')) {\n        return 'ts';\n      }\n      return 't';\n    }\n    if (nodeType === 'LabeledStatement') {\n      if (AT.punctuator(token, ':')) {\n        return 'ts';\n      }\n    } else if (\n        nodeType === 'LogicalExpression' || nodeType === 'AssignmentExpression' || nodeType === 'BinaryExpression') {\n      if (AT.punctuator(token) && !AT.punctuator(token, '()')) {\n        return 'sts';\n      }\n    } else if (nodeType === 'ConditionalExpression') {\n      if (AT.punctuator(token, '?:')) {\n        return 'sts';\n      }\n    } else if (nodeType === 'VariableDeclarator') {\n      if (AT.punctuator(token, '=')) {\n        return 'sts';\n      }\n    } else if (nodeType === 'ObjectPattern') {\n      if (node.parent && node.parent.type === 'VariableDeclarator' && AT.punctuator(token, '{')) {\n        return 'st';\n      }\n      if (AT.punctuator(token, ',')) {\n        return 'ts';\n      }\n    } else if (nodeType === 'FunctionDeclaration') {\n      if (AT.punctuator(token, ',)')) {\n        return 'ts';\n      }\n    } else if (nodeType === 'FunctionExpression') {\n      if (AT.punctuator(token, ',)')) {\n        return 'ts';\n      }\n      if (AT.keyword(token, 'function')) {\n        return node.id ? 'ts' : 't';\n      }\n    } else if (nodeType === 'ArrowFunctionExpression') {\n      if (AT.punctuator(token, ',)')) {\n        return 'ts';\n      }\n      if (AT.punctuator(token, '(')) {\n        return 'st';\n      }\n      if (AT.arrowIdentifier(token, '=>')) {\n        return 'sts';\n      }\n    } else if (nodeType === 'WithStatement') {\n      if (AT.punctuator(token, ')')) {\n        return node.body && node.body.type === 'BlockStatement' ? 'ts' : 'tn>';\n      }\n    } else if (nodeType === 'SwitchStatement') {\n      if (AT.punctuator(token, '{')) {\n        return 'tn>';\n      }\n      if (AT.punctuator(token, '}')) {\n        return 'n<tn';\n      }\n      if (AT.punctuator(token, ')')) {\n        return 'ts';\n      }\n    } else if (nodeType === 'SwitchCase') {\n      if (AT.keyword(token, 'case')) {\n        return 'n<ts';\n      }\n      if (AT.keyword(token, 'default')) {\n        return 'n<t';\n      }\n      if (AT.punctuator(token, ':')) {\n        return 'tn>';\n      }\n    } else if (nodeType === 'VariableDeclaration') {\n      if (AT.punctuator(token, ',')) {\n        let allVariablesInitialized = true;\n        const declarations = (node.declarations as Acorn.ESTree.Node[]);\n        for (let i = 0; i < declarations.length; ++i) {\n          // @ts-ignore We are doing a subtype check, without properly checking whether\n          // it exists. We can't fix that, unless we use proper typechecking\n          allVariablesInitialized = allVariablesInitialized && Boolean(declarations[i].init);\n        }\n        return !this.#inForLoopHeader(node) && allVariablesInitialized ? 'nSSts' : 'ts';\n      }\n    } else if (nodeType === 'PropertyDefinition') {\n      if (AT.punctuator(token, '=')) {\n        return 'sts';\n      }\n      if (AT.punctuator(token, ';')) {\n        return 'tn';\n      }\n    } else if (nodeType === 'BlockStatement') {\n      if (AT.punctuator(token, '{')) {\n        return node.body.length ? 'tn>' : 't';\n      }\n      if (AT.punctuator(token, '}')) {\n        return node.body.length ? 'n<t' : 't';\n      }\n    } else if (nodeType === 'CatchClause') {\n      if (AT.punctuator(token, ')')) {\n        return 'ts';\n      }\n    } else if (nodeType === 'ObjectExpression') {\n      if (!node.properties.length) {\n        return 't';\n      }\n      if (AT.punctuator(token, '{')) {\n        return 'tn>';\n      }\n      if (AT.punctuator(token, '}')) {\n        return 'n<t';\n      }\n      if (AT.punctuator(token, ',')) {\n        return 'tn';\n      }\n    } else if (nodeType === 'IfStatement') {\n      if (AT.punctuator(token, ')')) {\n        return node.consequent && node.consequent.type === 'BlockStatement' ? 'ts' : 'tn>';\n      }\n\n      if (AT.keyword(token, 'else')) {\n        const preFormat = node.consequent && node.consequent.type === 'BlockStatement' ? 'st' : 'n<t';\n        let postFormat = 'n>';\n        if (node.alternate && (node.alternate.type === 'BlockStatement' || node.alternate.type === 'IfStatement')) {\n          postFormat = 's';\n        }\n        return preFormat + postFormat;\n      }\n    } else if (nodeType === 'CallExpression') {\n      if (AT.punctuator(token, ',')) {\n        return 'ts';\n      }\n    } else if (nodeType === 'SequenceExpression' && AT.punctuator(token, ',')) {\n      return node.parent && node.parent.type === 'SwitchCase' ? 'ts' : 'tn';\n    } else if (nodeType === 'ForStatement' || nodeType === 'ForOfStatement' || nodeType === 'ForInStatement') {\n      if (AT.punctuator(token, ';')) {\n        return 'ts';\n      }\n      if (AT.keyword(token, 'in') || AT.identifier(token, 'of')) {\n        return 'sts';\n      }\n\n      if (AT.punctuator(token, ')')) {\n        return node.body && node.body.type === 'BlockStatement' ? 'ts' : 'tn>';\n      }\n    } else if (nodeType === 'WhileStatement') {\n      if (AT.punctuator(token, ')')) {\n        return node.body && node.body.type === 'BlockStatement' ? 'ts' : 'tn>';\n      }\n    } else if (nodeType === 'DoWhileStatement') {\n      const blockBody = node.body && node.body.type === 'BlockStatement';\n      if (AT.keyword(token, 'do')) {\n        return blockBody ? 'ts' : 'tn>';\n      }\n      if (AT.keyword(token, 'while')) {\n        return blockBody ? 'sts' : 'n<ts';\n      }\n      if (AT.punctuator(token, ';')) {\n        return 'tn';\n      }\n    } else if (nodeType === 'ClassBody') {\n      if (AT.punctuator(token, '{')) {\n        return 'stn>';\n      }\n      if (AT.punctuator(token, '}')) {\n        return '<ntn';\n      }\n      return 't';\n    } else if (nodeType === 'YieldExpression') {\n      return 't';\n    } else if (nodeType === 'Super') {\n      return 't';\n    } else if (nodeType === 'ImportExpression') {\n      return 't';\n    } else if (nodeType === 'ExportAllDeclaration') {\n      if (AT.punctuator(token, '*')) {\n        return 'sts';\n      }\n      return 't';\n    } else if (nodeType === 'ExportNamedDeclaration' || nodeType === 'ImportDeclaration') {\n      if (AT.punctuator(token, '{')) {\n        return 'st';\n      }\n      if (AT.punctuator(token, ',')) {\n        return 'ts';\n      }\n      if (AT.punctuator(token, '}')) {\n        return node.source ? 'ts' : 't';\n      }\n      if (AT.punctuator(token, '*')) {\n        return 'sts';\n      }\n      return 't';\n    }\n    return AT.keyword(token) && !AT.keyword(token, 'this') ? 'ts' : 't';\n  }\n\n  #finishNode(node: Acorn.ESTree.Node): string {\n    const nodeType = node.type;\n    if (nodeType === 'WithStatement') {\n      if (node.body && node.body.type !== 'BlockStatement') {\n        return 'n<';\n      }\n    } else if (nodeType === 'VariableDeclaration') {\n      if (!this.#inForLoopHeader(node)) {\n        return 'n';\n      }\n    } else if (nodeType === 'ForStatement' || nodeType === 'ForOfStatement' || nodeType === 'ForInStatement') {\n      if (node.body && node.body.type !== 'BlockStatement') {\n        return 'n<';\n      }\n    } else if (nodeType === 'BlockStatement') {\n      if (node.parent && node.parent.type === 'IfStatement') {\n        const parentNode = (node.parent as Acorn.ESTree.IfStatement);\n        if (parentNode.alternate && parentNode.consequent === node) {\n          return '';\n        }\n      }\n      if (node.parent && node.parent.type === 'FunctionExpression' && node.parent.parent &&\n          node.parent.parent.type === 'Property') {\n        return '';\n      }\n      if (node.parent && node.parent.type === 'FunctionExpression' && node.parent.parent &&\n          node.parent.parent.type === 'VariableDeclarator') {\n        return '';\n      }\n      if (node.parent && node.parent.type === 'FunctionExpression' && node.parent.parent &&\n          node.parent.parent.type === 'CallExpression') {\n        return '';\n      }\n      if (node.parent && node.parent.type === 'DoWhileStatement') {\n        return '';\n      }\n      if (node.parent && node.parent.type === 'TryStatement') {\n        const parentNode = (node.parent as Acorn.ESTree.TryStatement);\n        if (parentNode.block === node) {\n          return 's';\n        }\n      }\n      if (node.parent && node.parent.type === 'CatchClause') {\n        const parentNode = (node.parent as Acorn.ESTree.CatchClause);\n        // @ts-ignore We are doing a subtype check, without properly checking whether\n        // it exists. We can't fix that, unless we use proper typechecking\n        if (parentNode.parent && parentNode.parent.finalizer) {\n          return 's';\n        }\n      }\n      return 'n';\n    } else if (nodeType === 'WhileStatement') {\n      if (node.body && node.body.type !== 'BlockStatement') {\n        return 'n<';\n      }\n    } else if (nodeType === 'IfStatement') {\n      if (node.alternate) {\n        if (node.alternate.type !== 'BlockStatement' && node.alternate.type !== 'IfStatement') {\n          return '<';\n        }\n      } else if (node.consequent) {\n        if (node.consequent.type !== 'BlockStatement') {\n          return '<';\n        }\n      }\n    } else if (\n        nodeType === 'BreakStatement' || nodeType === 'ContinueStatement' || nodeType === 'ThrowStatement' ||\n        nodeType === 'ReturnStatement' || nodeType === 'ExpressionStatement') {\n      return 'n';\n    } else if (\n        nodeType === 'ImportDeclaration' || nodeType === 'ExportAllDeclaration' ||\n        nodeType === 'ExportDefaultDeclaration' || nodeType === 'ExportNamedDeclaration') {\n      return 'n';\n    }\n    return '';\n  }\n}\n"],
  "mappings": "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",
  "names": ["token"]
}
