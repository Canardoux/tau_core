{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/entrypoints/formatter_worker/Substitute.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Acorn from '../../third_party/acorn/acorn.js';\n\nimport {ECMA_VERSION} from './AcornTokenizer.js';\nimport {DefinitionKind} from './FormatterActions.js';\nimport {ScopeVariableAnalysis} from './ScopeParser.js';\n\nexport function substituteExpression(expression: string, nameMap: Map<string, string|null>): string {\n  const replacements = computeSubstitution(expression, nameMap);\n  return applySubstitution(expression, replacements);\n}\n\ninterface Replacement {\n  from: string;\n  to: string;\n  offset: number;\n  isShorthandAssignmentProperty: boolean;\n}\n\n// Given an |expression| and a mapping from names to new names, the |computeSubstitution|\n// function returns a list of replacements sorted by the offset. The function throws if\n// it cannot parse the expression or the substitution is impossible to perform (for example\n// if the substitution target is 'this' within a function, it would become bound there).\nfunction computeSubstitution(expression: string, nameMap: Map<string, string|null>): Replacement[] {\n  // Parse the expression and find variables and scopes.\n  const root = Acorn.parse(expression, {\n    ecmaVersion: ECMA_VERSION,\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    checkPrivateFields: false,\n    ranges: false,\n  } as acorn.Options) as Acorn.ESTree.Node;\n  const scopeVariables = new ScopeVariableAnalysis(root);\n  scopeVariables.run();\n  const freeVariables = scopeVariables.getFreeVariables();\n  const result: Replacement[] = [];\n\n  // Prepare the machinery for generating fresh names (to avoid variable captures).\n  const allNames = scopeVariables.getAllNames();\n  for (const rename of nameMap.values()) {\n    if (rename) {\n      allNames.add(rename);\n    }\n  }\n  function getNewName(base: string): string {\n    let i = 1;\n    while (allNames.has(`${base}_${i}`)) {\n      i++;\n    }\n    const newName = `${base}_${i}`;\n    allNames.add(newName);\n    return newName;\n  }\n\n  // Perform the substitutions.\n  for (const [name, rename] of nameMap.entries()) {\n    const defUse = freeVariables.get(name);\n    if (!defUse) {\n      continue;\n    }\n\n    if (rename === null) {\n      throw new Error(`Cannot substitute '${name}' as the underlying variable '${rename}' is unavailable`);\n    }\n\n    const binders = [];\n    for (const use of defUse) {\n      result.push({\n        from: name,\n        to: rename,\n        offset: use.offset,\n        isShorthandAssignmentProperty: use.isShorthandAssignmentProperty,\n      });\n      binders.push(...use.scope.findBinders(rename));\n    }\n    // If there is a capturing binder, rename the bound variable.\n    for (const binder of binders) {\n      if (binder.definitionKind === DefinitionKind.FIXED) {\n        // If the identifier is bound to a fixed name, such as 'this',\n        // then refuse to do the substitution.\n        throw new Error(`Cannot avoid capture of '${rename}'`);\n      }\n      const newName = getNewName(rename);\n      for (const use of binder.uses) {\n        result.push({\n          from: rename,\n          to: newName,\n          offset: use.offset,\n          isShorthandAssignmentProperty: use.isShorthandAssignmentProperty,\n        });\n      }\n    }\n  }\n  result.sort((l, r) => l.offset - r.offset);\n  return result;\n}\n\nfunction applySubstitution(expression: string, replacements: Replacement[]): string {\n  const accumulator = [];\n  let last = 0;\n  for (const r of replacements) {\n    accumulator.push(expression.slice(last, r.offset));\n    let replacement = r.to;\n    if (r.isShorthandAssignmentProperty) {\n      // Let us expand the shorthand to full assignment.\n      replacement = `${r.from}: ${r.to}`;\n    }\n    accumulator.push(replacement);\n    last = r.offset + r.from.length;\n  }\n  accumulator.push(expression.slice(last));\n  return accumulator.join('');\n}\n"],
  "mappings": ";AAIA,YAAY,WAAW;AAEvB,SAAQ,oBAAmB;AAC3B,SAAQ,sBAAqB;AAC7B,SAAQ,6BAA4B;AAE7B,gBAAS,qBAAqB,YAAoB,SAA2C;AAClG,QAAM,eAAe,oBAAoB,YAAY,OAAO;AAC5D,SAAO,kBAAkB,YAAY,YAAY;AACnD;AAaA,SAAS,oBAAoB,YAAoB,SAAkD;AAEjG,QAAM,OAAO,MAAM,MAAM,YAAY;AAAA,IACnC,aAAa;AAAA,IACb,2BAA2B;AAAA,IAC3B,6BAA6B;AAAA,IAC7B,oBAAoB;AAAA,IACpB,QAAQ;AAAA,EACV,CAAkB;AAClB,QAAM,iBAAiB,IAAI,sBAAsB,IAAI;AACrD,iBAAe,IAAI;AACnB,QAAM,gBAAgB,eAAe,iBAAiB;AACtD,QAAM,SAAwB,CAAC;AAG/B,QAAM,WAAW,eAAe,YAAY;AAC5C,aAAW,UAAU,QAAQ,OAAO,GAAG;AACrC,QAAI,QAAQ;AACV,eAAS,IAAI,MAAM;AAAA,IACrB;AAAA,EACF;AACA,WAAS,WAAW,MAAsB;AACxC,QAAI,IAAI;AACR,WAAO,SAAS,IAAI,GAAG,IAAI,IAAI,CAAC,EAAE,GAAG;AACnC;AAAA,IACF;AACA,UAAM,UAAU,GAAG,IAAI,IAAI,CAAC;AAC5B,aAAS,IAAI,OAAO;AACpB,WAAO;AAAA,EACT;AAGA,aAAW,CAAC,MAAM,MAAM,KAAK,QAAQ,QAAQ,GAAG;AAC9C,UAAM,SAAS,cAAc,IAAI,IAAI;AACrC,QAAI,CAAC,QAAQ;AACX;AAAA,IACF;AAEA,QAAI,WAAW,MAAM;AACnB,YAAM,IAAI,MAAM,sBAAsB,IAAI,iCAAiC,MAAM,kBAAkB;AAAA,IACrG;AAEA,UAAM,UAAU,CAAC;AACjB,eAAW,OAAO,QAAQ;AACxB,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,IAAI;AAAA,QACJ,QAAQ,IAAI;AAAA,QACZ,+BAA+B,IAAI;AAAA,MACrC,CAAC;AACD,cAAQ,KAAK,GAAG,IAAI,MAAM,YAAY,MAAM,CAAC;AAAA,IAC/C;AAEA,eAAW,UAAU,SAAS;AAC5B,UAAI,OAAO,mBAAmB,eAAe,OAAO;AAGlD,cAAM,IAAI,MAAM,4BAA4B,MAAM,GAAG;AAAA,MACvD;AACA,YAAM,UAAU,WAAW,MAAM;AACjC,iBAAW,OAAO,OAAO,MAAM;AAC7B,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,IAAI;AAAA,UACJ,QAAQ,IAAI;AAAA,UACZ,+BAA+B,IAAI;AAAA,QACrC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,SAAO,KAAK,CAAC,GAAG,MAAM,EAAE,SAAS,EAAE,MAAM;AACzC,SAAO;AACT;AAEA,SAAS,kBAAkB,YAAoB,cAAqC;AAClF,QAAM,cAAc,CAAC;AACrB,MAAI,OAAO;AACX,aAAW,KAAK,cAAc;AAC5B,gBAAY,KAAK,WAAW,MAAM,MAAM,EAAE,MAAM,CAAC;AACjD,QAAI,cAAc,EAAE;AACpB,QAAI,EAAE,+BAA+B;AAEnC,oBAAc,GAAG,EAAE,IAAI,KAAK,EAAE,EAAE;AAAA,IAClC;AACA,gBAAY,KAAK,WAAW;AAC5B,WAAO,EAAE,SAAS,EAAE,KAAK;AAAA,EAC3B;AACA,cAAY,KAAK,WAAW,MAAM,IAAI,CAAC;AACvC,SAAO,YAAY,KAAK,EAAE;AAC5B;",
  "names": []
}
