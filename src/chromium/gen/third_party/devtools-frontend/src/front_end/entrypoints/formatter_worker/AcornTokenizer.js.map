{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/entrypoints/formatter_worker/AcornTokenizer.ts"],
  "sourcesContent": ["// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Acorn from '../../third_party/acorn/acorn.js';\n\nexport type TokenOrComment = Acorn.Token|Acorn.Comment;\n\n/**\n * The tokenizer in Acorn does not allow you to peek into the next token.\n * We use the peekToken method to determine when to stop formatting a\n * particular block of code.\n *\n * To remedy the situation, we implement the peeking of tokens ourselves.\n * To do so, whenever we call `nextToken`, we already retrieve the token\n * after it (in `bufferedToken`), so that `_peekToken` can check if there\n * is more work to do.\n *\n * There are 2 catches:\n *\n * 1. in the constructor we need to start the initialize the buffered token,\n *    such that `peekToken` on the first call is able to retrieve it. However,\n * 2. comments and tokens can arrive intermixed from the tokenizer. This usually\n *    happens when comments are the first comments of a file. In the scenario that\n *    the first comment in a file is a line comment attached to a token, we first\n *    receive the token and after that we receive the comment. However, when tokenizing\n *    we should reverse the order and return the comment, before the token.\n *\n * All that is to say that the `bufferedToken` is only used for *true* tokens.\n * We mimic comments to be tokens to fix the reordering issue, but we store these\n * separately to keep track of them. Any call to `nextTokenInternal` will figure\n * out whether the next token should be the preceding comment or not.\n */\nexport class AcornTokenizer {\n  #textCursor: TextUtils.TextCursor.TextCursor;\n  #tokenLineStartInternal: number;\n  #tokenLineEndInternal: number;\n  #tokens: (Acorn.Comment|Acorn.Token)[];\n  #idx = 0;\n\n  constructor(content: string, tokens: (Acorn.Comment|Acorn.Token)[]) {\n    this.#tokens = tokens;\n    const contentLineEndings = Platform.StringUtilities.findLineEndingIndexes(content);\n    this.#textCursor = new TextUtils.TextCursor.TextCursor(contentLineEndings);\n    this.#tokenLineStartInternal = 0;\n    this.#tokenLineEndInternal = 0;\n  }\n\n  static punctuator(token: Acorn.Token, values?: string): boolean {\n    return token.type !== Acorn.tokTypes.num && token.type !== Acorn.tokTypes.regexp &&\n        token.type !== Acorn.tokTypes.string && token.type !== Acorn.tokTypes.name && !token.type.keyword &&\n        (!values || (token.type.label.length === 1 && values.indexOf(token.type.label) !== -1));\n  }\n\n  static keyword(token: Acorn.Token, keyword?: string): boolean {\n    return Boolean(token.type.keyword) && token.type !== Acorn.tokTypes['_true'] &&\n        token.type !== Acorn.tokTypes['_false'] && token.type !== Acorn.tokTypes['_null'] &&\n        (!keyword || token.type.keyword === keyword);\n  }\n\n  static identifier(token: TokenOrComment, identifier?: string): boolean {\n    return token.type === Acorn.tokTypes.name && (!identifier || token.value === identifier);\n  }\n\n  static arrowIdentifier(token: TokenOrComment, identifier?: string): boolean {\n    return token.type === Acorn.tokTypes.arrow && (!identifier || token.type.label === identifier);\n  }\n\n  static lineComment(token: TokenOrComment): boolean {\n    return token.type === 'Line';\n  }\n\n  static blockComment(token: TokenOrComment): boolean {\n    return token.type === 'Block';\n  }\n\n  nextToken(): TokenOrComment|null {\n    const token = this.#tokens[this.#idx++];\n    if (!token || token.type === Acorn.tokTypes.eof) {\n      return null;\n    }\n\n    this.#textCursor.advance(token.start);\n    this.#tokenLineStartInternal = this.#textCursor.lineNumber();\n\n    this.#textCursor.advance(token.end);\n    this.#tokenLineEndInternal = this.#textCursor.lineNumber();\n    return token;\n  }\n\n  peekToken(): TokenOrComment|null {\n    const token = this.#tokens[this.#idx];\n    if (!token || token.type === Acorn.tokTypes.eof) {\n      return null;\n    }\n    return token;\n  }\n\n  tokenLineStart(): number {\n    return this.#tokenLineStartInternal;\n  }\n\n  tokenLineEnd(): number {\n    return this.#tokenLineEndInternal;\n  }\n}\n\nexport const ECMA_VERSION = 2022;\n"],
  "mappings": ";AAIA,YAAY,cAAc;AAC1B,YAAY,eAAe;AAC3B,YAAY,WAAW;AA6BhB,aAAM,eAAe;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAO;AAAA,EAEP,YAAY,SAAiB,QAAuC;AAClE,SAAK,UAAU;AACf,UAAM,qBAAqB,SAAS,gBAAgB,sBAAsB,OAAO;AACjF,SAAK,cAAc,IAAI,UAAU,WAAW,WAAW,kBAAkB;AACzE,SAAK,0BAA0B;AAC/B,SAAK,wBAAwB;AAAA,EAC/B;AAAA,EAEA,OAAO,WAAW,OAAoB,QAA0B;AAC9D,WAAO,MAAM,SAAS,MAAM,SAAS,OAAO,MAAM,SAAS,MAAM,SAAS,UACtE,MAAM,SAAS,MAAM,SAAS,UAAU,MAAM,SAAS,MAAM,SAAS,QAAQ,CAAC,MAAM,KAAK,YACzF,CAAC,UAAW,MAAM,KAAK,MAAM,WAAW,KAAK,OAAO,QAAQ,MAAM,KAAK,KAAK,MAAM;AAAA,EACzF;AAAA,EAEA,OAAO,QAAQ,OAAoB,SAA2B;AAC5D,WAAO,QAAQ,MAAM,KAAK,OAAO,KAAK,MAAM,SAAS,MAAM,SAAS,OAAO,KACvE,MAAM,SAAS,MAAM,SAAS,QAAQ,KAAK,MAAM,SAAS,MAAM,SAAS,OAAO,MAC/E,CAAC,WAAW,MAAM,KAAK,YAAY;AAAA,EAC1C;AAAA,EAEA,OAAO,WAAW,OAAuB,YAA8B;AACrE,WAAO,MAAM,SAAS,MAAM,SAAS,SAAS,CAAC,cAAc,MAAM,UAAU;AAAA,EAC/E;AAAA,EAEA,OAAO,gBAAgB,OAAuB,YAA8B;AAC1E,WAAO,MAAM,SAAS,MAAM,SAAS,UAAU,CAAC,cAAc,MAAM,KAAK,UAAU;AAAA,EACrF;AAAA,EAEA,OAAO,YAAY,OAAgC;AACjD,WAAO,MAAM,SAAS;AAAA,EACxB;AAAA,EAEA,OAAO,aAAa,OAAgC;AAClD,WAAO,MAAM,SAAS;AAAA,EACxB;AAAA,EAEA,YAAiC;AAC/B,UAAM,QAAQ,KAAK,QAAQ,KAAK,MAAM;AACtC,QAAI,CAAC,SAAS,MAAM,SAAS,MAAM,SAAS,KAAK;AAC/C,aAAO;AAAA,IACT;AAEA,SAAK,YAAY,QAAQ,MAAM,KAAK;AACpC,SAAK,0BAA0B,KAAK,YAAY,WAAW;AAE3D,SAAK,YAAY,QAAQ,MAAM,GAAG;AAClC,SAAK,wBAAwB,KAAK,YAAY,WAAW;AACzD,WAAO;AAAA,EACT;AAAA,EAEA,YAAiC;AAC/B,UAAM,QAAQ,KAAK,QAAQ,KAAK,IAAI;AACpC,QAAI,CAAC,SAAS,MAAM,SAAS,MAAM,SAAS,KAAK;AAC/C,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAEA,iBAAyB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,eAAuB;AACrB,WAAO,KAAK;AAAA,EACd;AACF;AAEO,aAAM,eAAe;",
  "names": []
}
