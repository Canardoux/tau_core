{
  "version": 3,
  "sources": ["../../../../../../../../../third_party/devtools-frontend/src/front_end/entrypoints/formatter_worker/CSSRuleParser.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {createTokenizer, type Chunk, type ChunkCallback} from './FormatterWorker.js';\n\nexport const CSSParserStates = {\n  Initial: 'Initial',\n  Selector: 'Selector',\n  Style: 'Style',\n  PropertyName: 'PropertyName',\n  PropertyValue: 'PropertyValue',\n  AtRule: 'AtRule',\n};\n\n// TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Rule = any;\n\ninterface Property {\n  name: string;\n  value: string;\n  range: Range;\n  nameRange: Range;\n  valueRange?: Range;\n}\n\ninterface Range {\n  startLine: number;\n  startColumn: number;\n  endLine: number;\n  endColumn: number;\n}\n\nexport function parseCSS(text: string, chunkCallback: ChunkCallback): void {\n  const chunkSize = 100000;  // characters per data chunk\n  const lines = text.split('\\n');\n  let rules: Rule[] = [];\n  let processedChunkCharacters = 0;\n\n  let state: string = CSSParserStates.Initial;\n  let rule: Rule;\n  let property: Property;\n  const UndefTokenType = new Set();\n\n  let disabledRules: Rule[] = [];\n\n  function disabledRulesCallback(chunk: Chunk): void {\n    disabledRules = disabledRules.concat(chunk.chunk);\n  }\n\n  function cssTrim(tokenValue: string): string {\n    // https://drafts.csswg.org/css-syntax/#whitespace\n    const re = /^(?:\\r?\\n|[\\t\\f\\r ])+|(?:\\r?\\n|[\\t\\f\\r ])+$/g;\n    return tokenValue.replace(re, '');\n  }\n\n  function processToken(tokenValue: string, tokenTypes: string|null, column: number, newColumn: number): void {\n    const tokenType = tokenTypes ? new Set(tokenTypes.split(' ')) : UndefTokenType;\n    switch (state) {\n      case CSSParserStates.Initial:\n        if (tokenType.has('qualifier') || tokenType.has('builtin') || tokenType.has('tag')) {\n          rule = {\n            selectorText: tokenValue,\n            lineNumber,\n            columnNumber: column,\n            properties: [],\n          };\n          state = CSSParserStates.Selector;\n        } else if (tokenType.has('def')) {\n          rule = {\n            atRule: tokenValue,\n            lineNumber,\n            columnNumber: column,\n          };\n          state = CSSParserStates.AtRule;\n        }\n        break;\n      case CSSParserStates.Selector:\n        if (tokenValue === '{' && tokenType === UndefTokenType) {\n          rule.selectorText = cssTrim(rule.selectorText);\n          rule.styleRange = createRange(lineNumber, newColumn);\n          state = CSSParserStates.Style;\n        } else {\n          rule.selectorText += tokenValue;\n        }\n        break;\n      case CSSParserStates.AtRule:\n        if ((tokenValue === ';' || tokenValue === '{') && tokenType === UndefTokenType) {\n          rule.atRule = cssTrim(rule.atRule);\n          rules.push(rule);\n          state = CSSParserStates.Initial;\n        } else {\n          rule.atRule += tokenValue;\n        }\n        break;\n      case CSSParserStates.Style:\n        if (tokenType.has('meta') || tokenType.has('property') || tokenType.has('variable-2')) {\n          property = {\n            name: tokenValue,\n            value: '',\n            range: createRange(lineNumber, column),\n            nameRange: createRange(lineNumber, column),\n          };\n          state = CSSParserStates.PropertyName;\n        } else if (tokenValue === '}' && tokenType === UndefTokenType) {\n          rule.styleRange.endLine = lineNumber;\n          rule.styleRange.endColumn = column;\n          rules.push(rule);\n          state = CSSParserStates.Initial;\n        } else if (tokenType.has('comment')) {\n          // The |processToken| is called per-line, so no token spans more than one line.\n          // Support only a one-line comments.\n          if (tokenValue.substring(0, 2) !== '/*' || tokenValue.substring(tokenValue.length - 2) !== '*/') {\n            break;\n          }\n          const uncommentedText = tokenValue.substring(2, tokenValue.length - 2);\n          const fakeRule = 'a{\\n' + uncommentedText + '}';\n          disabledRules = [];\n          parseCSS(fakeRule, disabledRulesCallback);\n          if (disabledRules.length === 1 && disabledRules[0].properties.length === 1) {\n            const disabledProperty = disabledRules[0].properties[0];\n            disabledProperty.disabled = true;\n            disabledProperty.range = createRange(lineNumber, column);\n            disabledProperty.range.endColumn = newColumn;\n            const lineOffset = lineNumber - 1;\n            const columnOffset = column + 2;\n            disabledProperty.nameRange.startLine += lineOffset;\n            disabledProperty.nameRange.startColumn += columnOffset;\n            disabledProperty.nameRange.endLine += lineOffset;\n            disabledProperty.nameRange.endColumn += columnOffset;\n            disabledProperty.valueRange.startLine += lineOffset;\n            disabledProperty.valueRange.startColumn += columnOffset;\n            disabledProperty.valueRange.endLine += lineOffset;\n            disabledProperty.valueRange.endColumn += columnOffset;\n            rule.properties.push(disabledProperty);\n          }\n        }\n        break;\n      case CSSParserStates.PropertyName:\n        if (tokenValue === ':' && tokenType === UndefTokenType) {\n          property.name = property.name;\n          property.nameRange.endLine = lineNumber;\n          property.nameRange.endColumn = column;\n          property.valueRange = createRange(lineNumber, newColumn);\n          state = CSSParserStates.PropertyValue;\n        } else if (tokenType.has('property')) {\n          property.name += tokenValue;\n        }\n        break;\n      case CSSParserStates.PropertyValue:\n        if ((tokenValue === ';' || tokenValue === '}') && tokenType === UndefTokenType) {\n          property.value = property.value;\n          // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n          // @ts-expect-error\n          property.valueRange.endLine = lineNumber;\n          // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n          // @ts-expect-error\n          property.valueRange.endColumn = column;\n          property.range.endLine = lineNumber;\n          property.range.endColumn = tokenValue === ';' ? newColumn : column;\n          rule.properties.push(property);\n          if (tokenValue === '}') {\n            rule.styleRange.endLine = lineNumber;\n            rule.styleRange.endColumn = column;\n            rules.push(rule);\n            state = CSSParserStates.Initial;\n          } else {\n            state = CSSParserStates.Style;\n          }\n        } else if (!tokenType.has('comment')) {\n          property.value += tokenValue;\n        }\n        break;\n      default:\n        console.assert(false, 'Unknown CSS parser state.');\n    }\n    processedChunkCharacters += newColumn - column;\n    if (processedChunkCharacters > chunkSize) {\n      chunkCallback({chunk: rules, isLastChunk: false});\n      rules = [];\n      processedChunkCharacters = 0;\n    }\n  }\n  const tokenizer = createTokenizer('text/css');\n  let lineNumber: number;\n  for (lineNumber = 0; lineNumber < lines.length; ++lineNumber) {\n    const line = lines[lineNumber];\n    tokenizer(line, processToken);\n    processToken('\\n', null, line.length, line.length + 1);\n  }\n  chunkCallback({chunk: rules, isLastChunk: true});\n\n  function createRange(lineNumber: number, columnNumber: number): Range {\n    return {startLine: lineNumber, startColumn: columnNumber, endLine: lineNumber, endColumn: columnNumber};\n  }\n}\n"],
  "mappings": "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",
  "names": ["lineNumber"]
}
