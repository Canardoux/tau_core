// third_party/blink/public/mojom/tokens/tokens.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_SHARED_INTERNAL_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_SHARED_INTERNAL_H_
#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"
#include "base/component_export.h"



namespace mojo {
namespace internal {
class ValidationContext;
}
}


namespace blink::mojom {
namespace internal {
class DocumentToken_Data;
class LocalFrameToken_Data;
class RemoteFrameToken_Data;
class DedicatedWorkerToken_Data;
class ServiceWorkerToken_Data;
class SharedWorkerToken_Data;
class AnimationWorkletToken_Data;
class AudioWorkletToken_Data;
class LayoutWorkletToken_Data;
class PaintWorkletToken_Data;
class SharedStorageWorkletToken_Data;
class ShadowRealmToken_Data;
class AttributionSrcToken_Data;
class ClipboardSequenceNumberToken_Data;
class SameDocNavigationScreenshotDestinationToken_Data;
class V8ContextToken_Data;
class ViewTransitionToken_Data;
class WebNNContextToken_Data;
class WebNNPendingConstantToken_Data;
class WebNNTensorToken_Data;
class FrameToken_Data;
class WorkerToken_Data;
class WorkletToken_Data;
class ExecutionContextToken_Data;
class WebGPUExecutionContextToken_Data;

#pragma pack(push, 1)


class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) FrameToken_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  FrameToken_Data() = default;
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~FrameToken_Data() = default;

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<FrameToken_Tag>(0);
    data.unknown = 0U;
  }

  // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
  // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
  // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
  // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
  enum class FrameToken_Tag : uint32_t {

    
    kLocalFrameToken,
    
    kRemoteFrameToken,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::LocalFrameToken_Data> f_local_frame_token;
    mojo::internal::Pointer<internal::RemoteFrameToken_Data> f_remote_frame_token;
    uint64_t unknown;
  };

  uint32_t size;
  FrameToken_Tag tag;
  Union_ data;
};
static_assert(sizeof(FrameToken_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(FrameToken_Data)");


class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WorkerToken_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  WorkerToken_Data() = default;
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~WorkerToken_Data() = default;

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<WorkerToken_Tag>(0);
    data.unknown = 0U;
  }

  // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
  // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
  // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
  // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
  enum class WorkerToken_Tag : uint32_t {

    
    kDedicatedWorkerToken,
    
    kServiceWorkerToken,
    
    kSharedWorkerToken,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::DedicatedWorkerToken_Data> f_dedicated_worker_token;
    mojo::internal::Pointer<internal::ServiceWorkerToken_Data> f_service_worker_token;
    mojo::internal::Pointer<internal::SharedWorkerToken_Data> f_shared_worker_token;
    uint64_t unknown;
  };

  uint32_t size;
  WorkerToken_Tag tag;
  Union_ data;
};
static_assert(sizeof(WorkerToken_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(WorkerToken_Data)");


class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WorkletToken_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  WorkletToken_Data() = default;
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~WorkletToken_Data() = default;

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<WorkletToken_Tag>(0);
    data.unknown = 0U;
  }

  // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
  // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
  // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
  // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
  enum class WorkletToken_Tag : uint32_t {

    
    kAnimationWorkletToken,
    
    kAudioWorkletToken,
    
    kLayoutWorkletToken,
    
    kPaintWorkletToken,
    
    kSharedStorageWorkletToken,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::AnimationWorkletToken_Data> f_animation_worklet_token;
    mojo::internal::Pointer<internal::AudioWorkletToken_Data> f_audio_worklet_token;
    mojo::internal::Pointer<internal::LayoutWorkletToken_Data> f_layout_worklet_token;
    mojo::internal::Pointer<internal::PaintWorkletToken_Data> f_paint_worklet_token;
    mojo::internal::Pointer<internal::SharedStorageWorkletToken_Data> f_shared_storage_worklet_token;
    uint64_t unknown;
  };

  uint32_t size;
  WorkletToken_Tag tag;
  Union_ data;
};
static_assert(sizeof(WorkletToken_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(WorkletToken_Data)");


class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ExecutionContextToken_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  ExecutionContextToken_Data() = default;
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~ExecutionContextToken_Data() = default;

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<ExecutionContextToken_Tag>(0);
    data.unknown = 0U;
  }

  // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
  // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
  // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
  // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
  enum class ExecutionContextToken_Tag : uint32_t {

    
    kLocalFrameToken,
    
    kDedicatedWorkerToken,
    
    kServiceWorkerToken,
    
    kSharedWorkerToken,
    
    kAnimationWorkletToken,
    
    kAudioWorkletToken,
    
    kLayoutWorkletToken,
    
    kPaintWorkletToken,
    
    kSharedStorageWorkletToken,
    
    kShadowRealmToken,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::LocalFrameToken_Data> f_local_frame_token;
    mojo::internal::Pointer<internal::DedicatedWorkerToken_Data> f_dedicated_worker_token;
    mojo::internal::Pointer<internal::ServiceWorkerToken_Data> f_service_worker_token;
    mojo::internal::Pointer<internal::SharedWorkerToken_Data> f_shared_worker_token;
    mojo::internal::Pointer<internal::AnimationWorkletToken_Data> f_animation_worklet_token;
    mojo::internal::Pointer<internal::AudioWorkletToken_Data> f_audio_worklet_token;
    mojo::internal::Pointer<internal::LayoutWorkletToken_Data> f_layout_worklet_token;
    mojo::internal::Pointer<internal::PaintWorkletToken_Data> f_paint_worklet_token;
    mojo::internal::Pointer<internal::SharedStorageWorkletToken_Data> f_shared_storage_worklet_token;
    mojo::internal::Pointer<internal::ShadowRealmToken_Data> f_shadow_realm_token;
    uint64_t unknown;
  };

  uint32_t size;
  ExecutionContextToken_Tag tag;
  Union_ data;
};
static_assert(sizeof(ExecutionContextToken_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(ExecutionContextToken_Data)");


class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WebGPUExecutionContextToken_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  WebGPUExecutionContextToken_Data() = default;
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~WebGPUExecutionContextToken_Data() = default;

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<WebGPUExecutionContextToken_Tag>(0);
    data.unknown = 0U;
  }

  // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
  // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
  // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
  // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
  enum class WebGPUExecutionContextToken_Tag : uint32_t {

    
    kDocumentToken,
    
    kDedicatedWorkerToken,
    
    kSharedWorkerToken,
    
    kServiceWorkerToken,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::DocumentToken_Data> f_document_token;
    mojo::internal::Pointer<internal::DedicatedWorkerToken_Data> f_dedicated_worker_token;
    mojo::internal::Pointer<internal::SharedWorkerToken_Data> f_shared_worker_token;
    mojo::internal::Pointer<internal::ServiceWorkerToken_Data> f_service_worker_token;
    uint64_t unknown;
  };

  uint32_t size;
  WebGPUExecutionContextToken_Tag tag;
  Union_ data;
};
static_assert(sizeof(WebGPUExecutionContextToken_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(WebGPUExecutionContextToken_Data)");
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) DocumentToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<DocumentToken_Data>;

  DocumentToken_Data();
  ~DocumentToken_Data() = delete;
};
static_assert(sizeof(DocumentToken_Data) == 16,
              "Bad sizeof(DocumentToken_Data)");
// Used by DocumentToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct DocumentToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  DocumentToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~DocumentToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<DocumentToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    DocumentToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) LocalFrameToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<LocalFrameToken_Data>;

  LocalFrameToken_Data();
  ~LocalFrameToken_Data() = delete;
};
static_assert(sizeof(LocalFrameToken_Data) == 16,
              "Bad sizeof(LocalFrameToken_Data)");
// Used by LocalFrameToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct LocalFrameToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  LocalFrameToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~LocalFrameToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<LocalFrameToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    LocalFrameToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) RemoteFrameToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<RemoteFrameToken_Data>;

  RemoteFrameToken_Data();
  ~RemoteFrameToken_Data() = delete;
};
static_assert(sizeof(RemoteFrameToken_Data) == 16,
              "Bad sizeof(RemoteFrameToken_Data)");
// Used by RemoteFrameToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct RemoteFrameToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  RemoteFrameToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~RemoteFrameToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<RemoteFrameToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    RemoteFrameToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) DedicatedWorkerToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<DedicatedWorkerToken_Data>;

  DedicatedWorkerToken_Data();
  ~DedicatedWorkerToken_Data() = delete;
};
static_assert(sizeof(DedicatedWorkerToken_Data) == 16,
              "Bad sizeof(DedicatedWorkerToken_Data)");
// Used by DedicatedWorkerToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct DedicatedWorkerToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  DedicatedWorkerToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~DedicatedWorkerToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<DedicatedWorkerToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    DedicatedWorkerToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ServiceWorkerToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<ServiceWorkerToken_Data>;

  ServiceWorkerToken_Data();
  ~ServiceWorkerToken_Data() = delete;
};
static_assert(sizeof(ServiceWorkerToken_Data) == 16,
              "Bad sizeof(ServiceWorkerToken_Data)");
// Used by ServiceWorkerToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ServiceWorkerToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ServiceWorkerToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ServiceWorkerToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ServiceWorkerToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ServiceWorkerToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) SharedWorkerToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<SharedWorkerToken_Data>;

  SharedWorkerToken_Data();
  ~SharedWorkerToken_Data() = delete;
};
static_assert(sizeof(SharedWorkerToken_Data) == 16,
              "Bad sizeof(SharedWorkerToken_Data)");
// Used by SharedWorkerToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SharedWorkerToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  SharedWorkerToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~SharedWorkerToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<SharedWorkerToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    SharedWorkerToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) AnimationWorkletToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<AnimationWorkletToken_Data>;

  AnimationWorkletToken_Data();
  ~AnimationWorkletToken_Data() = delete;
};
static_assert(sizeof(AnimationWorkletToken_Data) == 16,
              "Bad sizeof(AnimationWorkletToken_Data)");
// Used by AnimationWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AnimationWorkletToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  AnimationWorkletToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~AnimationWorkletToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<AnimationWorkletToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    AnimationWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) AudioWorkletToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<AudioWorkletToken_Data>;

  AudioWorkletToken_Data();
  ~AudioWorkletToken_Data() = delete;
};
static_assert(sizeof(AudioWorkletToken_Data) == 16,
              "Bad sizeof(AudioWorkletToken_Data)");
// Used by AudioWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AudioWorkletToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  AudioWorkletToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~AudioWorkletToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<AudioWorkletToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    AudioWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) LayoutWorkletToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<LayoutWorkletToken_Data>;

  LayoutWorkletToken_Data();
  ~LayoutWorkletToken_Data() = delete;
};
static_assert(sizeof(LayoutWorkletToken_Data) == 16,
              "Bad sizeof(LayoutWorkletToken_Data)");
// Used by LayoutWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct LayoutWorkletToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  LayoutWorkletToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~LayoutWorkletToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<LayoutWorkletToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    LayoutWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) PaintWorkletToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<PaintWorkletToken_Data>;

  PaintWorkletToken_Data();
  ~PaintWorkletToken_Data() = delete;
};
static_assert(sizeof(PaintWorkletToken_Data) == 16,
              "Bad sizeof(PaintWorkletToken_Data)");
// Used by PaintWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PaintWorkletToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  PaintWorkletToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~PaintWorkletToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<PaintWorkletToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    PaintWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) SharedStorageWorkletToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<SharedStorageWorkletToken_Data>;

  SharedStorageWorkletToken_Data();
  ~SharedStorageWorkletToken_Data() = delete;
};
static_assert(sizeof(SharedStorageWorkletToken_Data) == 16,
              "Bad sizeof(SharedStorageWorkletToken_Data)");
// Used by SharedStorageWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SharedStorageWorkletToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  SharedStorageWorkletToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~SharedStorageWorkletToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<SharedStorageWorkletToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    SharedStorageWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ShadowRealmToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<ShadowRealmToken_Data>;

  ShadowRealmToken_Data();
  ~ShadowRealmToken_Data() = delete;
};
static_assert(sizeof(ShadowRealmToken_Data) == 16,
              "Bad sizeof(ShadowRealmToken_Data)");
// Used by ShadowRealmToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ShadowRealmToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ShadowRealmToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ShadowRealmToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ShadowRealmToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ShadowRealmToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) AttributionSrcToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<AttributionSrcToken_Data>;

  AttributionSrcToken_Data();
  ~AttributionSrcToken_Data() = delete;
};
static_assert(sizeof(AttributionSrcToken_Data) == 16,
              "Bad sizeof(AttributionSrcToken_Data)");
// Used by AttributionSrcToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AttributionSrcToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  AttributionSrcToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~AttributionSrcToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<AttributionSrcToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    AttributionSrcToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ClipboardSequenceNumberToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<ClipboardSequenceNumberToken_Data>;

  ClipboardSequenceNumberToken_Data();
  ~ClipboardSequenceNumberToken_Data() = delete;
};
static_assert(sizeof(ClipboardSequenceNumberToken_Data) == 16,
              "Bad sizeof(ClipboardSequenceNumberToken_Data)");
// Used by ClipboardSequenceNumberToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ClipboardSequenceNumberToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ClipboardSequenceNumberToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ClipboardSequenceNumberToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ClipboardSequenceNumberToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ClipboardSequenceNumberToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) SameDocNavigationScreenshotDestinationToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<SameDocNavigationScreenshotDestinationToken_Data>;

  SameDocNavigationScreenshotDestinationToken_Data();
  ~SameDocNavigationScreenshotDestinationToken_Data() = delete;
};
static_assert(sizeof(SameDocNavigationScreenshotDestinationToken_Data) == 16,
              "Bad sizeof(SameDocNavigationScreenshotDestinationToken_Data)");
// Used by SameDocNavigationScreenshotDestinationToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<SameDocNavigationScreenshotDestinationToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) V8ContextToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<V8ContextToken_Data>;

  V8ContextToken_Data();
  ~V8ContextToken_Data() = delete;
};
static_assert(sizeof(V8ContextToken_Data) == 16,
              "Bad sizeof(V8ContextToken_Data)");
// Used by V8ContextToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct V8ContextToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  V8ContextToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~V8ContextToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<V8ContextToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    V8ContextToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ViewTransitionToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<ViewTransitionToken_Data>;

  ViewTransitionToken_Data();
  ~ViewTransitionToken_Data() = delete;
};
static_assert(sizeof(ViewTransitionToken_Data) == 16,
              "Bad sizeof(ViewTransitionToken_Data)");
// Used by ViewTransitionToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ViewTransitionToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ViewTransitionToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ViewTransitionToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ViewTransitionToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ViewTransitionToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WebNNContextToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<WebNNContextToken_Data>;

  WebNNContextToken_Data();
  ~WebNNContextToken_Data() = delete;
};
static_assert(sizeof(WebNNContextToken_Data) == 16,
              "Bad sizeof(WebNNContextToken_Data)");
// Used by WebNNContextToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct WebNNContextToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  WebNNContextToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~WebNNContextToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<WebNNContextToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    WebNNContextToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WebNNPendingConstantToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<WebNNPendingConstantToken_Data>;

  WebNNPendingConstantToken_Data();
  ~WebNNPendingConstantToken_Data() = delete;
};
static_assert(sizeof(WebNNPendingConstantToken_Data) == 16,
              "Bad sizeof(WebNNPendingConstantToken_Data)");
// Used by WebNNPendingConstantToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct WebNNPendingConstantToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  WebNNPendingConstantToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~WebNNPendingConstantToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<WebNNPendingConstantToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    WebNNPendingConstantToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WebNNTensorToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

 private:
  friend class mojo::internal::MessageFragment<WebNNTensorToken_Data>;

  WebNNTensorToken_Data();
  ~WebNNTensorToken_Data() = delete;
};
static_assert(sizeof(WebNNTensorToken_Data) == 16,
              "Bad sizeof(WebNNTensorToken_Data)");
// Used by WebNNTensorToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct WebNNTensorToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  WebNNTensorToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~WebNNTensorToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<WebNNTensorToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    WebNNTensorToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

}  // namespace internal

}  // blink::mojom

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_SHARED_INTERNAL_H_