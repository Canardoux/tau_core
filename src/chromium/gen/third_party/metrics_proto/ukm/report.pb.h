// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ukm/report.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ukm_2freport_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ukm_2freport_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "ukm/aggregate.pb.h"
#include "ukm/entry.pb.h"
#include "ukm/source.pb.h"
#include "ukm/web_features.pb.h"
#include "chrome_user_metrics_extension.pb.h"
#include "system_profile.pb.h"
#include "user_demographics.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ukm_2freport_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ukm_2freport_2eproto {
  static const uint32_t offsets[];
};
namespace ukm {
class Report;
struct ReportDefaultTypeInternal;
extern ReportDefaultTypeInternal _Report_default_instance_;
class Report_DownsamplingRate;
struct Report_DownsamplingRateDefaultTypeInternal;
extern Report_DownsamplingRateDefaultTypeInternal _Report_DownsamplingRate_default_instance_;
class Report_SourceCounts;
struct Report_SourceCountsDefaultTypeInternal;
extern Report_SourceCountsDefaultTypeInternal _Report_SourceCounts_default_instance_;
}  // namespace ukm
PROTOBUF_NAMESPACE_OPEN
template<> ::ukm::Report* Arena::CreateMaybeMessage<::ukm::Report>(Arena*);
template<> ::ukm::Report_DownsamplingRate* Arena::CreateMaybeMessage<::ukm::Report_DownsamplingRate>(Arena*);
template<> ::ukm::Report_SourceCounts* Arena::CreateMaybeMessage<::ukm::Report_SourceCounts>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ukm {

enum Report_LogRotationReason : int {
  Report_LogRotationReason_UNKNOWN = 0,
  Report_LogRotationReason_SCHEDULED_ROTATION = 1,
  Report_LogRotationReason_BACKGROUNDED = 2,
  Report_LogRotationReason_SHUTDOWN = 3
};
bool Report_LogRotationReason_IsValid(int value);
constexpr Report_LogRotationReason Report_LogRotationReason_LogRotationReason_MIN = Report_LogRotationReason_UNKNOWN;
constexpr Report_LogRotationReason Report_LogRotationReason_LogRotationReason_MAX = Report_LogRotationReason_SHUTDOWN;
constexpr int Report_LogRotationReason_LogRotationReason_ARRAYSIZE = Report_LogRotationReason_LogRotationReason_MAX + 1;

const std::string& Report_LogRotationReason_Name(Report_LogRotationReason value);
template<typename T>
inline const std::string& Report_LogRotationReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Report_LogRotationReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Report_LogRotationReason_Name.");
  return Report_LogRotationReason_Name(static_cast<Report_LogRotationReason>(enum_t_value));
}
bool Report_LogRotationReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Report_LogRotationReason* value);
// ===================================================================

class Report_SourceCounts final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ukm.Report.SourceCounts) */ {
 public:
  inline Report_SourceCounts() : Report_SourceCounts(nullptr) {}
  ~Report_SourceCounts() override;
  explicit PROTOBUF_CONSTEXPR Report_SourceCounts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Report_SourceCounts(const Report_SourceCounts& from);
  Report_SourceCounts(Report_SourceCounts&& from) noexcept
    : Report_SourceCounts() {
    *this = ::std::move(from);
  }

  inline Report_SourceCounts& operator=(const Report_SourceCounts& from) {
    CopyFrom(from);
    return *this;
  }
  inline Report_SourceCounts& operator=(Report_SourceCounts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Report_SourceCounts& default_instance() {
    return *internal_default_instance();
  }
  static inline const Report_SourceCounts* internal_default_instance() {
    return reinterpret_cast<const Report_SourceCounts*>(
               &_Report_SourceCounts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Report_SourceCounts& a, Report_SourceCounts& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Report_SourceCounts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Report_SourceCounts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Report_SourceCounts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Report_SourceCounts>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Report_SourceCounts& from);
  void MergeFrom(const Report_SourceCounts& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Report_SourceCounts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ukm.Report.SourceCounts";
  }
  protected:
  explicit Report_SourceCounts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObservedFieldNumber = 1,
    kNavigationSourcesFieldNumber = 2,
    kUnmatchedSourcesFieldNumber = 3,
    kCarryoverSourcesFieldNumber = 4,
    kDeferredSourcesFieldNumber = 5,
    kEntrylessSourcesFieldNumber = 6,
    kPrunedSourcesAgeSecondsFieldNumber = 7,
  };
  // optional int32 observed = 1;
  bool has_observed() const;
  private:
  bool _internal_has_observed() const;
  public:
  void clear_observed();
  int32_t observed() const;
  void set_observed(int32_t value);
  private:
  int32_t _internal_observed() const;
  void _internal_set_observed(int32_t value);
  public:

  // optional int32 navigation_sources = 2;
  bool has_navigation_sources() const;
  private:
  bool _internal_has_navigation_sources() const;
  public:
  void clear_navigation_sources();
  int32_t navigation_sources() const;
  void set_navigation_sources(int32_t value);
  private:
  int32_t _internal_navigation_sources() const;
  void _internal_set_navigation_sources(int32_t value);
  public:

  // optional int32 unmatched_sources = 3;
  bool has_unmatched_sources() const;
  private:
  bool _internal_has_unmatched_sources() const;
  public:
  void clear_unmatched_sources();
  int32_t unmatched_sources() const;
  void set_unmatched_sources(int32_t value);
  private:
  int32_t _internal_unmatched_sources() const;
  void _internal_set_unmatched_sources(int32_t value);
  public:

  // optional int32 carryover_sources = 4;
  bool has_carryover_sources() const;
  private:
  bool _internal_has_carryover_sources() const;
  public:
  void clear_carryover_sources();
  int32_t carryover_sources() const;
  void set_carryover_sources(int32_t value);
  private:
  int32_t _internal_carryover_sources() const;
  void _internal_set_carryover_sources(int32_t value);
  public:

  // optional int32 deferred_sources = 5;
  bool has_deferred_sources() const;
  private:
  bool _internal_has_deferred_sources() const;
  public:
  void clear_deferred_sources();
  int32_t deferred_sources() const;
  void set_deferred_sources(int32_t value);
  private:
  int32_t _internal_deferred_sources() const;
  void _internal_set_deferred_sources(int32_t value);
  public:

  // optional int32 entryless_sources = 6;
  bool has_entryless_sources() const;
  private:
  bool _internal_has_entryless_sources() const;
  public:
  void clear_entryless_sources();
  int32_t entryless_sources() const;
  void set_entryless_sources(int32_t value);
  private:
  int32_t _internal_entryless_sources() const;
  void _internal_set_entryless_sources(int32_t value);
  public:

  // optional int32 pruned_sources_age_seconds = 7;
  bool has_pruned_sources_age_seconds() const;
  private:
  bool _internal_has_pruned_sources_age_seconds() const;
  public:
  void clear_pruned_sources_age_seconds();
  int32_t pruned_sources_age_seconds() const;
  void set_pruned_sources_age_seconds(int32_t value);
  private:
  int32_t _internal_pruned_sources_age_seconds() const;
  void _internal_set_pruned_sources_age_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ukm.Report.SourceCounts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t observed_;
    int32_t navigation_sources_;
    int32_t unmatched_sources_;
    int32_t carryover_sources_;
    int32_t deferred_sources_;
    int32_t entryless_sources_;
    int32_t pruned_sources_age_seconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ukm_2freport_2eproto;
};
// -------------------------------------------------------------------

class Report_DownsamplingRate final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ukm.Report.DownsamplingRate) */ {
 public:
  inline Report_DownsamplingRate() : Report_DownsamplingRate(nullptr) {}
  ~Report_DownsamplingRate() override;
  explicit PROTOBUF_CONSTEXPR Report_DownsamplingRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Report_DownsamplingRate(const Report_DownsamplingRate& from);
  Report_DownsamplingRate(Report_DownsamplingRate&& from) noexcept
    : Report_DownsamplingRate() {
    *this = ::std::move(from);
  }

  inline Report_DownsamplingRate& operator=(const Report_DownsamplingRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Report_DownsamplingRate& operator=(Report_DownsamplingRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Report_DownsamplingRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Report_DownsamplingRate* internal_default_instance() {
    return reinterpret_cast<const Report_DownsamplingRate*>(
               &_Report_DownsamplingRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Report_DownsamplingRate& a, Report_DownsamplingRate& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Report_DownsamplingRate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Report_DownsamplingRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Report_DownsamplingRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Report_DownsamplingRate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Report_DownsamplingRate& from);
  void MergeFrom(const Report_DownsamplingRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Report_DownsamplingRate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ukm.Report.DownsamplingRate";
  }
  protected:
  explicit Report_DownsamplingRate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventHashFieldNumber = 1,
    kStandardRateFieldNumber = 2,
    kCustomRateFieldNumber = 3,
  };
  // optional fixed64 event_hash = 1;
  bool has_event_hash() const;
  private:
  bool _internal_has_event_hash() const;
  public:
  void clear_event_hash();
  uint64_t event_hash() const;
  void set_event_hash(uint64_t value);
  private:
  uint64_t _internal_event_hash() const;
  void _internal_set_event_hash(uint64_t value);
  public:

  // optional uint32 standard_rate = 2;
  bool has_standard_rate() const;
  private:
  bool _internal_has_standard_rate() const;
  public:
  void clear_standard_rate();
  uint32_t standard_rate() const;
  void set_standard_rate(uint32_t value);
  private:
  uint32_t _internal_standard_rate() const;
  void _internal_set_standard_rate(uint32_t value);
  public:

  // optional uint32 custom_rate = 3;
  bool has_custom_rate() const;
  private:
  bool _internal_has_custom_rate() const;
  public:
  void clear_custom_rate();
  uint32_t custom_rate() const;
  void set_custom_rate(uint32_t value);
  private:
  uint32_t _internal_custom_rate() const;
  void _internal_set_custom_rate(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ukm.Report.DownsamplingRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t event_hash_;
    uint32_t standard_rate_;
    uint32_t custom_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ukm_2freport_2eproto;
};
// -------------------------------------------------------------------

class Report final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ukm.Report) */ {
 public:
  inline Report() : Report(nullptr) {}
  ~Report() override;
  explicit PROTOBUF_CONSTEXPR Report(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Report(const Report& from);
  Report(Report&& from) noexcept
    : Report() {
    *this = ::std::move(from);
  }

  inline Report& operator=(const Report& from) {
    CopyFrom(from);
    return *this;
  }
  inline Report& operator=(Report&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Report& default_instance() {
    return *internal_default_instance();
  }
  static inline const Report* internal_default_instance() {
    return reinterpret_cast<const Report*>(
               &_Report_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Report& a, Report& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Report* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Report* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Report* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Report>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Report& from);
  void MergeFrom(const Report& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Report* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ukm.Report";
  }
  protected:
  explicit Report(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Report_SourceCounts SourceCounts;
  typedef Report_DownsamplingRate DownsamplingRate;

  typedef Report_LogRotationReason LogRotationReason;
  static constexpr LogRotationReason UNKNOWN =
    Report_LogRotationReason_UNKNOWN;
  static constexpr LogRotationReason SCHEDULED_ROTATION =
    Report_LogRotationReason_SCHEDULED_ROTATION;
  static constexpr LogRotationReason BACKGROUNDED =
    Report_LogRotationReason_BACKGROUNDED;
  static constexpr LogRotationReason SHUTDOWN =
    Report_LogRotationReason_SHUTDOWN;
  static inline bool LogRotationReason_IsValid(int value) {
    return Report_LogRotationReason_IsValid(value);
  }
  static constexpr LogRotationReason LogRotationReason_MIN =
    Report_LogRotationReason_LogRotationReason_MIN;
  static constexpr LogRotationReason LogRotationReason_MAX =
    Report_LogRotationReason_LogRotationReason_MAX;
  static constexpr int LogRotationReason_ARRAYSIZE =
    Report_LogRotationReason_LogRotationReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LogRotationReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogRotationReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogRotationReason_Name.");
    return Report_LogRotationReason_Name(enum_t_value);
  }
  static inline bool LogRotationReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LogRotationReason* value) {
    return Report_LogRotationReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSourcesFieldNumber = 3,
    kEntriesFieldNumber = 4,
    kAggregatesFieldNumber = 7,
    kWebFeaturesFieldNumber = 13,
    kDownsamplingRatesFieldNumber = 14,
    kSystemProfileFieldNumber = 2,
    kSourceCountsFieldNumber = 10,
    kUserDemographicsFieldNumber = 11,
    kClientIdFieldNumber = 1,
    kSessionIdFieldNumber = 5,
    kReportIdFieldNumber = 6,
    kIsContinuousFieldNumber = 8,
    kLogRotationReasonFieldNumber = 9,
    kProductFieldNumber = 12,
  };
  // repeated .ukm.Source sources = 3;
  int sources_size() const;
  private:
  int _internal_sources_size() const;
  public:
  void clear_sources();
  ::ukm::Source* mutable_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source >*
      mutable_sources();
  private:
  const ::ukm::Source& _internal_sources(int index) const;
  ::ukm::Source* _internal_add_sources();
  public:
  const ::ukm::Source& sources(int index) const;
  ::ukm::Source* add_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source >&
      sources() const;

  // repeated .ukm.Entry entries = 4;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::ukm::Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry >*
      mutable_entries();
  private:
  const ::ukm::Entry& _internal_entries(int index) const;
  ::ukm::Entry* _internal_add_entries();
  public:
  const ::ukm::Entry& entries(int index) const;
  ::ukm::Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry >&
      entries() const;

  // repeated .ukm.Aggregate aggregates = 7;
  int aggregates_size() const;
  private:
  int _internal_aggregates_size() const;
  public:
  void clear_aggregates();
  ::ukm::Aggregate* mutable_aggregates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate >*
      mutable_aggregates();
  private:
  const ::ukm::Aggregate& _internal_aggregates(int index) const;
  ::ukm::Aggregate* _internal_add_aggregates();
  public:
  const ::ukm::Aggregate& aggregates(int index) const;
  ::ukm::Aggregate* add_aggregates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate >&
      aggregates() const;

  // repeated .ukm.HighLevelWebFeatures web_features = 13;
  int web_features_size() const;
  private:
  int _internal_web_features_size() const;
  public:
  void clear_web_features();
  ::ukm::HighLevelWebFeatures* mutable_web_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::HighLevelWebFeatures >*
      mutable_web_features();
  private:
  const ::ukm::HighLevelWebFeatures& _internal_web_features(int index) const;
  ::ukm::HighLevelWebFeatures* _internal_add_web_features();
  public:
  const ::ukm::HighLevelWebFeatures& web_features(int index) const;
  ::ukm::HighLevelWebFeatures* add_web_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::HighLevelWebFeatures >&
      web_features() const;

  // repeated .ukm.Report.DownsamplingRate downsampling_rates = 14;
  int downsampling_rates_size() const;
  private:
  int _internal_downsampling_rates_size() const;
  public:
  void clear_downsampling_rates();
  ::ukm::Report_DownsamplingRate* mutable_downsampling_rates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Report_DownsamplingRate >*
      mutable_downsampling_rates();
  private:
  const ::ukm::Report_DownsamplingRate& _internal_downsampling_rates(int index) const;
  ::ukm::Report_DownsamplingRate* _internal_add_downsampling_rates();
  public:
  const ::ukm::Report_DownsamplingRate& downsampling_rates(int index) const;
  ::ukm::Report_DownsamplingRate* add_downsampling_rates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Report_DownsamplingRate >&
      downsampling_rates() const;

  // optional .metrics.SystemProfileProto system_profile = 2;
  bool has_system_profile() const;
  private:
  bool _internal_has_system_profile() const;
  public:
  void clear_system_profile();
  const ::metrics::SystemProfileProto& system_profile() const;
  PROTOBUF_NODISCARD ::metrics::SystemProfileProto* release_system_profile();
  ::metrics::SystemProfileProto* mutable_system_profile();
  void set_allocated_system_profile(::metrics::SystemProfileProto* system_profile);
  private:
  const ::metrics::SystemProfileProto& _internal_system_profile() const;
  ::metrics::SystemProfileProto* _internal_mutable_system_profile();
  public:
  void unsafe_arena_set_allocated_system_profile(
      ::metrics::SystemProfileProto* system_profile);
  ::metrics::SystemProfileProto* unsafe_arena_release_system_profile();

  // optional .ukm.Report.SourceCounts source_counts = 10;
  bool has_source_counts() const;
  private:
  bool _internal_has_source_counts() const;
  public:
  void clear_source_counts();
  const ::ukm::Report_SourceCounts& source_counts() const;
  PROTOBUF_NODISCARD ::ukm::Report_SourceCounts* release_source_counts();
  ::ukm::Report_SourceCounts* mutable_source_counts();
  void set_allocated_source_counts(::ukm::Report_SourceCounts* source_counts);
  private:
  const ::ukm::Report_SourceCounts& _internal_source_counts() const;
  ::ukm::Report_SourceCounts* _internal_mutable_source_counts();
  public:
  void unsafe_arena_set_allocated_source_counts(
      ::ukm::Report_SourceCounts* source_counts);
  ::ukm::Report_SourceCounts* unsafe_arena_release_source_counts();

  // optional .metrics.UserDemographicsProto user_demographics = 11;
  bool has_user_demographics() const;
  private:
  bool _internal_has_user_demographics() const;
  public:
  void clear_user_demographics();
  const ::metrics::UserDemographicsProto& user_demographics() const;
  PROTOBUF_NODISCARD ::metrics::UserDemographicsProto* release_user_demographics();
  ::metrics::UserDemographicsProto* mutable_user_demographics();
  void set_allocated_user_demographics(::metrics::UserDemographicsProto* user_demographics);
  private:
  const ::metrics::UserDemographicsProto& _internal_user_demographics() const;
  ::metrics::UserDemographicsProto* _internal_mutable_user_demographics();
  public:
  void unsafe_arena_set_allocated_user_demographics(
      ::metrics::UserDemographicsProto* user_demographics);
  ::metrics::UserDemographicsProto* unsafe_arena_release_user_demographics();

  // optional fixed64 client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // optional int32 session_id = 5;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  int32_t session_id() const;
  void set_session_id(int32_t value);
  private:
  int32_t _internal_session_id() const;
  void _internal_set_session_id(int32_t value);
  public:

  // optional int32 report_id = 6;
  bool has_report_id() const;
  private:
  bool _internal_has_report_id() const;
  public:
  void clear_report_id();
  int32_t report_id() const;
  void set_report_id(int32_t value);
  private:
  int32_t _internal_report_id() const;
  void _internal_set_report_id(int32_t value);
  public:

  // optional bool is_continuous = 8;
  bool has_is_continuous() const;
  private:
  bool _internal_has_is_continuous() const;
  public:
  void clear_is_continuous();
  bool is_continuous() const;
  void set_is_continuous(bool value);
  private:
  bool _internal_is_continuous() const;
  void _internal_set_is_continuous(bool value);
  public:

  // optional .ukm.Report.LogRotationReason log_rotation_reason = 9;
  bool has_log_rotation_reason() const;
  private:
  bool _internal_has_log_rotation_reason() const;
  public:
  void clear_log_rotation_reason();
  ::ukm::Report_LogRotationReason log_rotation_reason() const;
  void set_log_rotation_reason(::ukm::Report_LogRotationReason value);
  private:
  ::ukm::Report_LogRotationReason _internal_log_rotation_reason() const;
  void _internal_set_log_rotation_reason(::ukm::Report_LogRotationReason value);
  public:

  // optional .metrics.ChromeUserMetricsExtension.Product product = 12 [default = CHROME];
  bool has_product() const;
  private:
  bool _internal_has_product() const;
  public:
  void clear_product();
  ::metrics::ChromeUserMetricsExtension_Product product() const;
  void set_product(::metrics::ChromeUserMetricsExtension_Product value);
  private:
  ::metrics::ChromeUserMetricsExtension_Product _internal_product() const;
  void _internal_set_product(::metrics::ChromeUserMetricsExtension_Product value);
  public:

  // @@protoc_insertion_point(class_scope:ukm.Report)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source > sources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry > entries_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate > aggregates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::HighLevelWebFeatures > web_features_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Report_DownsamplingRate > downsampling_rates_;
    ::metrics::SystemProfileProto* system_profile_;
    ::ukm::Report_SourceCounts* source_counts_;
    ::metrics::UserDemographicsProto* user_demographics_;
    uint64_t client_id_;
    int32_t session_id_;
    int32_t report_id_;
    bool is_continuous_;
    int log_rotation_reason_;
    int product_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ukm_2freport_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Report_SourceCounts

// optional int32 observed = 1;
inline bool Report_SourceCounts::_internal_has_observed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Report_SourceCounts::has_observed() const {
  return _internal_has_observed();
}
inline void Report_SourceCounts::clear_observed() {
  _impl_.observed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Report_SourceCounts::_internal_observed() const {
  return _impl_.observed_;
}
inline int32_t Report_SourceCounts::observed() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.observed)
  return _internal_observed();
}
inline void Report_SourceCounts::_internal_set_observed(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.observed_ = value;
}
inline void Report_SourceCounts::set_observed(int32_t value) {
  _internal_set_observed(value);
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.observed)
}

// optional int32 navigation_sources = 2;
inline bool Report_SourceCounts::_internal_has_navigation_sources() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Report_SourceCounts::has_navigation_sources() const {
  return _internal_has_navigation_sources();
}
inline void Report_SourceCounts::clear_navigation_sources() {
  _impl_.navigation_sources_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Report_SourceCounts::_internal_navigation_sources() const {
  return _impl_.navigation_sources_;
}
inline int32_t Report_SourceCounts::navigation_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.navigation_sources)
  return _internal_navigation_sources();
}
inline void Report_SourceCounts::_internal_set_navigation_sources(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.navigation_sources_ = value;
}
inline void Report_SourceCounts::set_navigation_sources(int32_t value) {
  _internal_set_navigation_sources(value);
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.navigation_sources)
}

// optional int32 unmatched_sources = 3;
inline bool Report_SourceCounts::_internal_has_unmatched_sources() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Report_SourceCounts::has_unmatched_sources() const {
  return _internal_has_unmatched_sources();
}
inline void Report_SourceCounts::clear_unmatched_sources() {
  _impl_.unmatched_sources_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Report_SourceCounts::_internal_unmatched_sources() const {
  return _impl_.unmatched_sources_;
}
inline int32_t Report_SourceCounts::unmatched_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.unmatched_sources)
  return _internal_unmatched_sources();
}
inline void Report_SourceCounts::_internal_set_unmatched_sources(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.unmatched_sources_ = value;
}
inline void Report_SourceCounts::set_unmatched_sources(int32_t value) {
  _internal_set_unmatched_sources(value);
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.unmatched_sources)
}

// optional int32 carryover_sources = 4;
inline bool Report_SourceCounts::_internal_has_carryover_sources() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Report_SourceCounts::has_carryover_sources() const {
  return _internal_has_carryover_sources();
}
inline void Report_SourceCounts::clear_carryover_sources() {
  _impl_.carryover_sources_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Report_SourceCounts::_internal_carryover_sources() const {
  return _impl_.carryover_sources_;
}
inline int32_t Report_SourceCounts::carryover_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.carryover_sources)
  return _internal_carryover_sources();
}
inline void Report_SourceCounts::_internal_set_carryover_sources(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.carryover_sources_ = value;
}
inline void Report_SourceCounts::set_carryover_sources(int32_t value) {
  _internal_set_carryover_sources(value);
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.carryover_sources)
}

// optional int32 deferred_sources = 5;
inline bool Report_SourceCounts::_internal_has_deferred_sources() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Report_SourceCounts::has_deferred_sources() const {
  return _internal_has_deferred_sources();
}
inline void Report_SourceCounts::clear_deferred_sources() {
  _impl_.deferred_sources_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Report_SourceCounts::_internal_deferred_sources() const {
  return _impl_.deferred_sources_;
}
inline int32_t Report_SourceCounts::deferred_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.deferred_sources)
  return _internal_deferred_sources();
}
inline void Report_SourceCounts::_internal_set_deferred_sources(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.deferred_sources_ = value;
}
inline void Report_SourceCounts::set_deferred_sources(int32_t value) {
  _internal_set_deferred_sources(value);
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.deferred_sources)
}

// optional int32 entryless_sources = 6;
inline bool Report_SourceCounts::_internal_has_entryless_sources() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Report_SourceCounts::has_entryless_sources() const {
  return _internal_has_entryless_sources();
}
inline void Report_SourceCounts::clear_entryless_sources() {
  _impl_.entryless_sources_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t Report_SourceCounts::_internal_entryless_sources() const {
  return _impl_.entryless_sources_;
}
inline int32_t Report_SourceCounts::entryless_sources() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.entryless_sources)
  return _internal_entryless_sources();
}
inline void Report_SourceCounts::_internal_set_entryless_sources(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.entryless_sources_ = value;
}
inline void Report_SourceCounts::set_entryless_sources(int32_t value) {
  _internal_set_entryless_sources(value);
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.entryless_sources)
}

// optional int32 pruned_sources_age_seconds = 7;
inline bool Report_SourceCounts::_internal_has_pruned_sources_age_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Report_SourceCounts::has_pruned_sources_age_seconds() const {
  return _internal_has_pruned_sources_age_seconds();
}
inline void Report_SourceCounts::clear_pruned_sources_age_seconds() {
  _impl_.pruned_sources_age_seconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t Report_SourceCounts::_internal_pruned_sources_age_seconds() const {
  return _impl_.pruned_sources_age_seconds_;
}
inline int32_t Report_SourceCounts::pruned_sources_age_seconds() const {
  // @@protoc_insertion_point(field_get:ukm.Report.SourceCounts.pruned_sources_age_seconds)
  return _internal_pruned_sources_age_seconds();
}
inline void Report_SourceCounts::_internal_set_pruned_sources_age_seconds(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.pruned_sources_age_seconds_ = value;
}
inline void Report_SourceCounts::set_pruned_sources_age_seconds(int32_t value) {
  _internal_set_pruned_sources_age_seconds(value);
  // @@protoc_insertion_point(field_set:ukm.Report.SourceCounts.pruned_sources_age_seconds)
}

// -------------------------------------------------------------------

// Report_DownsamplingRate

// optional fixed64 event_hash = 1;
inline bool Report_DownsamplingRate::_internal_has_event_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Report_DownsamplingRate::has_event_hash() const {
  return _internal_has_event_hash();
}
inline void Report_DownsamplingRate::clear_event_hash() {
  _impl_.event_hash_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Report_DownsamplingRate::_internal_event_hash() const {
  return _impl_.event_hash_;
}
inline uint64_t Report_DownsamplingRate::event_hash() const {
  // @@protoc_insertion_point(field_get:ukm.Report.DownsamplingRate.event_hash)
  return _internal_event_hash();
}
inline void Report_DownsamplingRate::_internal_set_event_hash(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.event_hash_ = value;
}
inline void Report_DownsamplingRate::set_event_hash(uint64_t value) {
  _internal_set_event_hash(value);
  // @@protoc_insertion_point(field_set:ukm.Report.DownsamplingRate.event_hash)
}

// optional uint32 standard_rate = 2;
inline bool Report_DownsamplingRate::_internal_has_standard_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Report_DownsamplingRate::has_standard_rate() const {
  return _internal_has_standard_rate();
}
inline void Report_DownsamplingRate::clear_standard_rate() {
  _impl_.standard_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Report_DownsamplingRate::_internal_standard_rate() const {
  return _impl_.standard_rate_;
}
inline uint32_t Report_DownsamplingRate::standard_rate() const {
  // @@protoc_insertion_point(field_get:ukm.Report.DownsamplingRate.standard_rate)
  return _internal_standard_rate();
}
inline void Report_DownsamplingRate::_internal_set_standard_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.standard_rate_ = value;
}
inline void Report_DownsamplingRate::set_standard_rate(uint32_t value) {
  _internal_set_standard_rate(value);
  // @@protoc_insertion_point(field_set:ukm.Report.DownsamplingRate.standard_rate)
}

// optional uint32 custom_rate = 3;
inline bool Report_DownsamplingRate::_internal_has_custom_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Report_DownsamplingRate::has_custom_rate() const {
  return _internal_has_custom_rate();
}
inline void Report_DownsamplingRate::clear_custom_rate() {
  _impl_.custom_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Report_DownsamplingRate::_internal_custom_rate() const {
  return _impl_.custom_rate_;
}
inline uint32_t Report_DownsamplingRate::custom_rate() const {
  // @@protoc_insertion_point(field_get:ukm.Report.DownsamplingRate.custom_rate)
  return _internal_custom_rate();
}
inline void Report_DownsamplingRate::_internal_set_custom_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.custom_rate_ = value;
}
inline void Report_DownsamplingRate::set_custom_rate(uint32_t value) {
  _internal_set_custom_rate(value);
  // @@protoc_insertion_point(field_set:ukm.Report.DownsamplingRate.custom_rate)
}

// -------------------------------------------------------------------

// Report

// optional fixed64 client_id = 1;
inline bool Report::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Report::has_client_id() const {
  return _internal_has_client_id();
}
inline void Report::clear_client_id() {
  _impl_.client_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t Report::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint64_t Report::client_id() const {
  // @@protoc_insertion_point(field_get:ukm.Report.client_id)
  return _internal_client_id();
}
inline void Report::_internal_set_client_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.client_id_ = value;
}
inline void Report::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:ukm.Report.client_id)
}

// optional .metrics.ChromeUserMetricsExtension.Product product = 12 [default = CHROME];
inline bool Report::_internal_has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Report::has_product() const {
  return _internal_has_product();
}
inline void Report::clear_product() {
  _impl_.product_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::metrics::ChromeUserMetricsExtension_Product Report::_internal_product() const {
  return static_cast< ::metrics::ChromeUserMetricsExtension_Product >(_impl_.product_);
}
inline ::metrics::ChromeUserMetricsExtension_Product Report::product() const {
  // @@protoc_insertion_point(field_get:ukm.Report.product)
  return _internal_product();
}
inline void Report::_internal_set_product(::metrics::ChromeUserMetricsExtension_Product value) {
  assert(::metrics::ChromeUserMetricsExtension_Product_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.product_ = value;
}
inline void Report::set_product(::metrics::ChromeUserMetricsExtension_Product value) {
  _internal_set_product(value);
  // @@protoc_insertion_point(field_set:ukm.Report.product)
}

// optional int32 session_id = 5;
inline bool Report::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Report::has_session_id() const {
  return _internal_has_session_id();
}
inline void Report::clear_session_id() {
  _impl_.session_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Report::_internal_session_id() const {
  return _impl_.session_id_;
}
inline int32_t Report::session_id() const {
  // @@protoc_insertion_point(field_get:ukm.Report.session_id)
  return _internal_session_id();
}
inline void Report::_internal_set_session_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.session_id_ = value;
}
inline void Report::set_session_id(int32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:ukm.Report.session_id)
}

// optional int32 report_id = 6;
inline bool Report::_internal_has_report_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Report::has_report_id() const {
  return _internal_has_report_id();
}
inline void Report::clear_report_id() {
  _impl_.report_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t Report::_internal_report_id() const {
  return _impl_.report_id_;
}
inline int32_t Report::report_id() const {
  // @@protoc_insertion_point(field_get:ukm.Report.report_id)
  return _internal_report_id();
}
inline void Report::_internal_set_report_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.report_id_ = value;
}
inline void Report::set_report_id(int32_t value) {
  _internal_set_report_id(value);
  // @@protoc_insertion_point(field_set:ukm.Report.report_id)
}

// optional bool is_continuous = 8;
inline bool Report::_internal_has_is_continuous() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Report::has_is_continuous() const {
  return _internal_has_is_continuous();
}
inline void Report::clear_is_continuous() {
  _impl_.is_continuous_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Report::_internal_is_continuous() const {
  return _impl_.is_continuous_;
}
inline bool Report::is_continuous() const {
  // @@protoc_insertion_point(field_get:ukm.Report.is_continuous)
  return _internal_is_continuous();
}
inline void Report::_internal_set_is_continuous(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.is_continuous_ = value;
}
inline void Report::set_is_continuous(bool value) {
  _internal_set_is_continuous(value);
  // @@protoc_insertion_point(field_set:ukm.Report.is_continuous)
}

// optional .ukm.Report.LogRotationReason log_rotation_reason = 9;
inline bool Report::_internal_has_log_rotation_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Report::has_log_rotation_reason() const {
  return _internal_has_log_rotation_reason();
}
inline void Report::clear_log_rotation_reason() {
  _impl_.log_rotation_reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::ukm::Report_LogRotationReason Report::_internal_log_rotation_reason() const {
  return static_cast< ::ukm::Report_LogRotationReason >(_impl_.log_rotation_reason_);
}
inline ::ukm::Report_LogRotationReason Report::log_rotation_reason() const {
  // @@protoc_insertion_point(field_get:ukm.Report.log_rotation_reason)
  return _internal_log_rotation_reason();
}
inline void Report::_internal_set_log_rotation_reason(::ukm::Report_LogRotationReason value) {
  assert(::ukm::Report_LogRotationReason_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.log_rotation_reason_ = value;
}
inline void Report::set_log_rotation_reason(::ukm::Report_LogRotationReason value) {
  _internal_set_log_rotation_reason(value);
  // @@protoc_insertion_point(field_set:ukm.Report.log_rotation_reason)
}

// optional .metrics.SystemProfileProto system_profile = 2;
inline bool Report::_internal_has_system_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_profile_ != nullptr);
  return value;
}
inline bool Report::has_system_profile() const {
  return _internal_has_system_profile();
}
inline const ::metrics::SystemProfileProto& Report::_internal_system_profile() const {
  const ::metrics::SystemProfileProto* p = _impl_.system_profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::metrics::SystemProfileProto&>(
      ::metrics::_SystemProfileProto_default_instance_);
}
inline const ::metrics::SystemProfileProto& Report::system_profile() const {
  // @@protoc_insertion_point(field_get:ukm.Report.system_profile)
  return _internal_system_profile();
}
inline void Report::unsafe_arena_set_allocated_system_profile(
    ::metrics::SystemProfileProto* system_profile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_profile_);
  }
  _impl_.system_profile_ = system_profile;
  if (system_profile) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ukm.Report.system_profile)
}
inline ::metrics::SystemProfileProto* Report::release_system_profile() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::metrics::SystemProfileProto* temp = _impl_.system_profile_;
  _impl_.system_profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::metrics::SystemProfileProto* Report::unsafe_arena_release_system_profile() {
  // @@protoc_insertion_point(field_release:ukm.Report.system_profile)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::metrics::SystemProfileProto* temp = _impl_.system_profile_;
  _impl_.system_profile_ = nullptr;
  return temp;
}
inline ::metrics::SystemProfileProto* Report::_internal_mutable_system_profile() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.system_profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::metrics::SystemProfileProto>(GetArenaForAllocation());
    _impl_.system_profile_ = p;
  }
  return _impl_.system_profile_;
}
inline ::metrics::SystemProfileProto* Report::mutable_system_profile() {
  ::metrics::SystemProfileProto* _msg = _internal_mutable_system_profile();
  // @@protoc_insertion_point(field_mutable:ukm.Report.system_profile)
  return _msg;
}
inline void Report::set_allocated_system_profile(::metrics::SystemProfileProto* system_profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_profile_);
  }
  if (system_profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_profile));
    if (message_arena != submessage_arena) {
      system_profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_profile, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.system_profile_ = system_profile;
  // @@protoc_insertion_point(field_set_allocated:ukm.Report.system_profile)
}

// optional .metrics.UserDemographicsProto user_demographics = 11;
inline bool Report::_internal_has_user_demographics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_demographics_ != nullptr);
  return value;
}
inline bool Report::has_user_demographics() const {
  return _internal_has_user_demographics();
}
inline const ::metrics::UserDemographicsProto& Report::_internal_user_demographics() const {
  const ::metrics::UserDemographicsProto* p = _impl_.user_demographics_;
  return p != nullptr ? *p : reinterpret_cast<const ::metrics::UserDemographicsProto&>(
      ::metrics::_UserDemographicsProto_default_instance_);
}
inline const ::metrics::UserDemographicsProto& Report::user_demographics() const {
  // @@protoc_insertion_point(field_get:ukm.Report.user_demographics)
  return _internal_user_demographics();
}
inline void Report::unsafe_arena_set_allocated_user_demographics(
    ::metrics::UserDemographicsProto* user_demographics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_demographics_);
  }
  _impl_.user_demographics_ = user_demographics;
  if (user_demographics) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ukm.Report.user_demographics)
}
inline ::metrics::UserDemographicsProto* Report::release_user_demographics() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::metrics::UserDemographicsProto* temp = _impl_.user_demographics_;
  _impl_.user_demographics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::metrics::UserDemographicsProto* Report::unsafe_arena_release_user_demographics() {
  // @@protoc_insertion_point(field_release:ukm.Report.user_demographics)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::metrics::UserDemographicsProto* temp = _impl_.user_demographics_;
  _impl_.user_demographics_ = nullptr;
  return temp;
}
inline ::metrics::UserDemographicsProto* Report::_internal_mutable_user_demographics() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.user_demographics_ == nullptr) {
    auto* p = CreateMaybeMessage<::metrics::UserDemographicsProto>(GetArenaForAllocation());
    _impl_.user_demographics_ = p;
  }
  return _impl_.user_demographics_;
}
inline ::metrics::UserDemographicsProto* Report::mutable_user_demographics() {
  ::metrics::UserDemographicsProto* _msg = _internal_mutable_user_demographics();
  // @@protoc_insertion_point(field_mutable:ukm.Report.user_demographics)
  return _msg;
}
inline void Report::set_allocated_user_demographics(::metrics::UserDemographicsProto* user_demographics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_demographics_);
  }
  if (user_demographics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_demographics));
    if (message_arena != submessage_arena) {
      user_demographics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_demographics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.user_demographics_ = user_demographics;
  // @@protoc_insertion_point(field_set_allocated:ukm.Report.user_demographics)
}

// repeated .ukm.Source sources = 3;
inline int Report::_internal_sources_size() const {
  return _impl_.sources_.size();
}
inline int Report::sources_size() const {
  return _internal_sources_size();
}
inline ::ukm::Source* Report::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:ukm.Report.sources)
  return _impl_.sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source >*
Report::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:ukm.Report.sources)
  return &_impl_.sources_;
}
inline const ::ukm::Source& Report::_internal_sources(int index) const {
  return _impl_.sources_.Get(index);
}
inline const ::ukm::Source& Report::sources(int index) const {
  // @@protoc_insertion_point(field_get:ukm.Report.sources)
  return _internal_sources(index);
}
inline ::ukm::Source* Report::_internal_add_sources() {
  return _impl_.sources_.Add();
}
inline ::ukm::Source* Report::add_sources() {
  ::ukm::Source* _add = _internal_add_sources();
  // @@protoc_insertion_point(field_add:ukm.Report.sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Source >&
Report::sources() const {
  // @@protoc_insertion_point(field_list:ukm.Report.sources)
  return _impl_.sources_;
}

// optional .ukm.Report.SourceCounts source_counts = 10;
inline bool Report::_internal_has_source_counts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_counts_ != nullptr);
  return value;
}
inline bool Report::has_source_counts() const {
  return _internal_has_source_counts();
}
inline void Report::clear_source_counts() {
  if (_impl_.source_counts_ != nullptr) _impl_.source_counts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ukm::Report_SourceCounts& Report::_internal_source_counts() const {
  const ::ukm::Report_SourceCounts* p = _impl_.source_counts_;
  return p != nullptr ? *p : reinterpret_cast<const ::ukm::Report_SourceCounts&>(
      ::ukm::_Report_SourceCounts_default_instance_);
}
inline const ::ukm::Report_SourceCounts& Report::source_counts() const {
  // @@protoc_insertion_point(field_get:ukm.Report.source_counts)
  return _internal_source_counts();
}
inline void Report::unsafe_arena_set_allocated_source_counts(
    ::ukm::Report_SourceCounts* source_counts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_counts_);
  }
  _impl_.source_counts_ = source_counts;
  if (source_counts) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ukm.Report.source_counts)
}
inline ::ukm::Report_SourceCounts* Report::release_source_counts() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ukm::Report_SourceCounts* temp = _impl_.source_counts_;
  _impl_.source_counts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ukm::Report_SourceCounts* Report::unsafe_arena_release_source_counts() {
  // @@protoc_insertion_point(field_release:ukm.Report.source_counts)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ukm::Report_SourceCounts* temp = _impl_.source_counts_;
  _impl_.source_counts_ = nullptr;
  return temp;
}
inline ::ukm::Report_SourceCounts* Report::_internal_mutable_source_counts() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_counts_ == nullptr) {
    auto* p = CreateMaybeMessage<::ukm::Report_SourceCounts>(GetArenaForAllocation());
    _impl_.source_counts_ = p;
  }
  return _impl_.source_counts_;
}
inline ::ukm::Report_SourceCounts* Report::mutable_source_counts() {
  ::ukm::Report_SourceCounts* _msg = _internal_mutable_source_counts();
  // @@protoc_insertion_point(field_mutable:ukm.Report.source_counts)
  return _msg;
}
inline void Report::set_allocated_source_counts(::ukm::Report_SourceCounts* source_counts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_counts_;
  }
  if (source_counts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_counts);
    if (message_arena != submessage_arena) {
      source_counts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_counts, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.source_counts_ = source_counts;
  // @@protoc_insertion_point(field_set_allocated:ukm.Report.source_counts)
}

// repeated .ukm.Entry entries = 4;
inline int Report::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int Report::entries_size() const {
  return _internal_entries_size();
}
inline ::ukm::Entry* Report::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:ukm.Report.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry >*
Report::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:ukm.Report.entries)
  return &_impl_.entries_;
}
inline const ::ukm::Entry& Report::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::ukm::Entry& Report::entries(int index) const {
  // @@protoc_insertion_point(field_get:ukm.Report.entries)
  return _internal_entries(index);
}
inline ::ukm::Entry* Report::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::ukm::Entry* Report::add_entries() {
  ::ukm::Entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:ukm.Report.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Entry >&
Report::entries() const {
  // @@protoc_insertion_point(field_list:ukm.Report.entries)
  return _impl_.entries_;
}

// repeated .ukm.HighLevelWebFeatures web_features = 13;
inline int Report::_internal_web_features_size() const {
  return _impl_.web_features_.size();
}
inline int Report::web_features_size() const {
  return _internal_web_features_size();
}
inline ::ukm::HighLevelWebFeatures* Report::mutable_web_features(int index) {
  // @@protoc_insertion_point(field_mutable:ukm.Report.web_features)
  return _impl_.web_features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::HighLevelWebFeatures >*
Report::mutable_web_features() {
  // @@protoc_insertion_point(field_mutable_list:ukm.Report.web_features)
  return &_impl_.web_features_;
}
inline const ::ukm::HighLevelWebFeatures& Report::_internal_web_features(int index) const {
  return _impl_.web_features_.Get(index);
}
inline const ::ukm::HighLevelWebFeatures& Report::web_features(int index) const {
  // @@protoc_insertion_point(field_get:ukm.Report.web_features)
  return _internal_web_features(index);
}
inline ::ukm::HighLevelWebFeatures* Report::_internal_add_web_features() {
  return _impl_.web_features_.Add();
}
inline ::ukm::HighLevelWebFeatures* Report::add_web_features() {
  ::ukm::HighLevelWebFeatures* _add = _internal_add_web_features();
  // @@protoc_insertion_point(field_add:ukm.Report.web_features)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::HighLevelWebFeatures >&
Report::web_features() const {
  // @@protoc_insertion_point(field_list:ukm.Report.web_features)
  return _impl_.web_features_;
}

// repeated .ukm.Aggregate aggregates = 7;
inline int Report::_internal_aggregates_size() const {
  return _impl_.aggregates_.size();
}
inline int Report::aggregates_size() const {
  return _internal_aggregates_size();
}
inline ::ukm::Aggregate* Report::mutable_aggregates(int index) {
  // @@protoc_insertion_point(field_mutable:ukm.Report.aggregates)
  return _impl_.aggregates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate >*
Report::mutable_aggregates() {
  // @@protoc_insertion_point(field_mutable_list:ukm.Report.aggregates)
  return &_impl_.aggregates_;
}
inline const ::ukm::Aggregate& Report::_internal_aggregates(int index) const {
  return _impl_.aggregates_.Get(index);
}
inline const ::ukm::Aggregate& Report::aggregates(int index) const {
  // @@protoc_insertion_point(field_get:ukm.Report.aggregates)
  return _internal_aggregates(index);
}
inline ::ukm::Aggregate* Report::_internal_add_aggregates() {
  return _impl_.aggregates_.Add();
}
inline ::ukm::Aggregate* Report::add_aggregates() {
  ::ukm::Aggregate* _add = _internal_add_aggregates();
  // @@protoc_insertion_point(field_add:ukm.Report.aggregates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Aggregate >&
Report::aggregates() const {
  // @@protoc_insertion_point(field_list:ukm.Report.aggregates)
  return _impl_.aggregates_;
}

// repeated .ukm.Report.DownsamplingRate downsampling_rates = 14;
inline int Report::_internal_downsampling_rates_size() const {
  return _impl_.downsampling_rates_.size();
}
inline int Report::downsampling_rates_size() const {
  return _internal_downsampling_rates_size();
}
inline void Report::clear_downsampling_rates() {
  _impl_.downsampling_rates_.Clear();
}
inline ::ukm::Report_DownsamplingRate* Report::mutable_downsampling_rates(int index) {
  // @@protoc_insertion_point(field_mutable:ukm.Report.downsampling_rates)
  return _impl_.downsampling_rates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Report_DownsamplingRate >*
Report::mutable_downsampling_rates() {
  // @@protoc_insertion_point(field_mutable_list:ukm.Report.downsampling_rates)
  return &_impl_.downsampling_rates_;
}
inline const ::ukm::Report_DownsamplingRate& Report::_internal_downsampling_rates(int index) const {
  return _impl_.downsampling_rates_.Get(index);
}
inline const ::ukm::Report_DownsamplingRate& Report::downsampling_rates(int index) const {
  // @@protoc_insertion_point(field_get:ukm.Report.downsampling_rates)
  return _internal_downsampling_rates(index);
}
inline ::ukm::Report_DownsamplingRate* Report::_internal_add_downsampling_rates() {
  return _impl_.downsampling_rates_.Add();
}
inline ::ukm::Report_DownsamplingRate* Report::add_downsampling_rates() {
  ::ukm::Report_DownsamplingRate* _add = _internal_add_downsampling_rates();
  // @@protoc_insertion_point(field_add:ukm.Report.downsampling_rates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ukm::Report_DownsamplingRate >&
Report::downsampling_rates() const {
  // @@protoc_insertion_point(field_list:ukm.Report.downsampling_rates)
  return _impl_.downsampling_rates_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ukm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ukm::Report_LogRotationReason> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ukm_2freport_2eproto
