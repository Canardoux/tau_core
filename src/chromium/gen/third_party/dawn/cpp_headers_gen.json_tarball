{"include/dawn/webgpu_cpp.h": "// Copyright 2017 The Dawn & Tint Authors\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n#ifdef __EMSCRIPTEN__\n#error \"Do not include this header. Emscripten already provides headers needed for WebGPU.\"\n#endif\n\n#ifndef WEBGPU_CPP_H_\n#define WEBGPU_CPP_H_\n\n#include <cassert>\n#include <cmath>\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n#include <optional>\n#include <functional>\n#include <string_view>\n#include <type_traits>\n#include <utility>\n\n#include \"webgpu/webgpu.h\"\n#include \"webgpu/webgpu_cpp_chained_struct.h\"\n#include \"webgpu/webgpu_enum_class_bitmasks.h\"  // IWYU pragma: export\n\nnamespace wgpu {\n\nstatic constexpr uint32_t kArrayLayerCountUndefined = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\nstatic constexpr uint32_t kCopyStrideUndefined = WGPU_COPY_STRIDE_UNDEFINED;\nstatic constexpr uint32_t kDepthSliceUndefined = WGPU_DEPTH_SLICE_UNDEFINED;\nstatic constexpr uint32_t kLimitU32Undefined = WGPU_LIMIT_U32_UNDEFINED;\nstatic constexpr uint64_t kLimitU64Undefined = WGPU_LIMIT_U64_UNDEFINED;\nstatic constexpr uint32_t kMipLevelCountUndefined = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\nstatic constexpr uint32_t kQuerySetIndexUndefined = WGPU_QUERY_SET_INDEX_UNDEFINED;\nstatic constexpr size_t kStrlen = WGPU_STRLEN;\nstatic constexpr size_t kWholeMapSize = WGPU_WHOLE_MAP_SIZE;\nstatic constexpr uint64_t kWholeSize = WGPU_WHOLE_SIZE;\nenum class WGSLFeatureName : uint32_t {\n    ReadonlyAndReadwriteStorageTextures = WGPUWGSLFeatureName_ReadonlyAndReadwriteStorageTextures,\n    Packed4x8IntegerDotProduct = WGPUWGSLFeatureName_Packed4x8IntegerDotProduct,\n    UnrestrictedPointerParameters = WGPUWGSLFeatureName_UnrestrictedPointerParameters,\n    PointerCompositeAccess = WGPUWGSLFeatureName_PointerCompositeAccess,\n    ChromiumTestingUnimplemented = WGPUWGSLFeatureName_ChromiumTestingUnimplemented,\n    ChromiumTestingUnsafeExperimental = WGPUWGSLFeatureName_ChromiumTestingUnsafeExperimental,\n    ChromiumTestingExperimental = WGPUWGSLFeatureName_ChromiumTestingExperimental,\n    ChromiumTestingShippedWithKillswitch = WGPUWGSLFeatureName_ChromiumTestingShippedWithKillswitch,\n    ChromiumTestingShipped = WGPUWGSLFeatureName_ChromiumTestingShipped,\n};\nstatic_assert(sizeof(WGSLFeatureName) == sizeof(WGPUWGSLFeatureName), \"sizeof mismatch for WGSLFeatureName\");\nstatic_assert(alignof(WGSLFeatureName) == alignof(WGPUWGSLFeatureName), \"alignof mismatch for WGSLFeatureName\");\n\nenum class AdapterType : uint32_t {\n    DiscreteGPU = WGPUAdapterType_DiscreteGPU,\n    IntegratedGPU = WGPUAdapterType_IntegratedGPU,\n    CPU = WGPUAdapterType_CPU,\n    Unknown = WGPUAdapterType_Unknown,\n};\nstatic_assert(sizeof(AdapterType) == sizeof(WGPUAdapterType), \"sizeof mismatch for AdapterType\");\nstatic_assert(alignof(AdapterType) == alignof(WGPUAdapterType), \"alignof mismatch for AdapterType\");\n\nenum class AddressMode : uint32_t {\n    Undefined = WGPUAddressMode_Undefined,\n    ClampToEdge = WGPUAddressMode_ClampToEdge,\n    Repeat = WGPUAddressMode_Repeat,\n    MirrorRepeat = WGPUAddressMode_MirrorRepeat,\n};\nstatic_assert(sizeof(AddressMode) == sizeof(WGPUAddressMode), \"sizeof mismatch for AddressMode\");\nstatic_assert(alignof(AddressMode) == alignof(WGPUAddressMode), \"alignof mismatch for AddressMode\");\n\nenum class AlphaMode : uint32_t {\n    Opaque = WGPUAlphaMode_Opaque,\n    Premultiplied = WGPUAlphaMode_Premultiplied,\n    Unpremultiplied = WGPUAlphaMode_Unpremultiplied,\n};\nstatic_assert(sizeof(AlphaMode) == sizeof(WGPUAlphaMode), \"sizeof mismatch for AlphaMode\");\nstatic_assert(alignof(AlphaMode) == alignof(WGPUAlphaMode), \"alignof mismatch for AlphaMode\");\n\nenum class BackendType : uint32_t {\n    Undefined = WGPUBackendType_Undefined,\n    Null = WGPUBackendType_Null,\n    WebGPU = WGPUBackendType_WebGPU,\n    D3D11 = WGPUBackendType_D3D11,\n    D3D12 = WGPUBackendType_D3D12,\n    Metal = WGPUBackendType_Metal,\n    Vulkan = WGPUBackendType_Vulkan,\n    OpenGL = WGPUBackendType_OpenGL,\n    OpenGLES = WGPUBackendType_OpenGLES,\n};\nstatic_assert(sizeof(BackendType) == sizeof(WGPUBackendType), \"sizeof mismatch for BackendType\");\nstatic_assert(alignof(BackendType) == alignof(WGPUBackendType), \"alignof mismatch for BackendType\");\n\nenum class BlendFactor : uint32_t {\n    Undefined = WGPUBlendFactor_Undefined,\n    Zero = WGPUBlendFactor_Zero,\n    One = WGPUBlendFactor_One,\n    Src = WGPUBlendFactor_Src,\n    OneMinusSrc = WGPUBlendFactor_OneMinusSrc,\n    SrcAlpha = WGPUBlendFactor_SrcAlpha,\n    OneMinusSrcAlpha = WGPUBlendFactor_OneMinusSrcAlpha,\n    Dst = WGPUBlendFactor_Dst,\n    OneMinusDst = WGPUBlendFactor_OneMinusDst,\n    DstAlpha = WGPUBlendFactor_DstAlpha,\n    OneMinusDstAlpha = WGPUBlendFactor_OneMinusDstAlpha,\n    SrcAlphaSaturated = WGPUBlendFactor_SrcAlphaSaturated,\n    Constant = WGPUBlendFactor_Constant,\n    OneMinusConstant = WGPUBlendFactor_OneMinusConstant,\n    Src1 = WGPUBlendFactor_Src1,\n    OneMinusSrc1 = WGPUBlendFactor_OneMinusSrc1,\n    Src1Alpha = WGPUBlendFactor_Src1Alpha,\n    OneMinusSrc1Alpha = WGPUBlendFactor_OneMinusSrc1Alpha,\n};\nstatic_assert(sizeof(BlendFactor) == sizeof(WGPUBlendFactor), \"sizeof mismatch for BlendFactor\");\nstatic_assert(alignof(BlendFactor) == alignof(WGPUBlendFactor), \"alignof mismatch for BlendFactor\");\n\nenum class BlendOperation : uint32_t {\n    Undefined = WGPUBlendOperation_Undefined,\n    Add = WGPUBlendOperation_Add,\n    Subtract = WGPUBlendOperation_Subtract,\n    ReverseSubtract = WGPUBlendOperation_ReverseSubtract,\n    Min = WGPUBlendOperation_Min,\n    Max = WGPUBlendOperation_Max,\n};\nstatic_assert(sizeof(BlendOperation) == sizeof(WGPUBlendOperation), \"sizeof mismatch for BlendOperation\");\nstatic_assert(alignof(BlendOperation) == alignof(WGPUBlendOperation), \"alignof mismatch for BlendOperation\");\n\nenum class BufferBindingType : uint32_t {\n    BindingNotUsed = WGPUBufferBindingType_BindingNotUsed,\n    Uniform = WGPUBufferBindingType_Uniform,\n    Storage = WGPUBufferBindingType_Storage,\n    ReadOnlyStorage = WGPUBufferBindingType_ReadOnlyStorage,\n};\nstatic_assert(sizeof(BufferBindingType) == sizeof(WGPUBufferBindingType), \"sizeof mismatch for BufferBindingType\");\nstatic_assert(alignof(BufferBindingType) == alignof(WGPUBufferBindingType), \"alignof mismatch for BufferBindingType\");\n\nenum class BufferMapAsyncStatus : uint32_t {\n    Success = WGPUBufferMapAsyncStatus_Success,\n    InstanceDropped = WGPUBufferMapAsyncStatus_InstanceDropped,\n    ValidationError = WGPUBufferMapAsyncStatus_ValidationError,\n    Unknown = WGPUBufferMapAsyncStatus_Unknown,\n    DeviceLost = WGPUBufferMapAsyncStatus_DeviceLost,\n    DestroyedBeforeCallback = WGPUBufferMapAsyncStatus_DestroyedBeforeCallback,\n    UnmappedBeforeCallback = WGPUBufferMapAsyncStatus_UnmappedBeforeCallback,\n    MappingAlreadyPending = WGPUBufferMapAsyncStatus_MappingAlreadyPending,\n    OffsetOutOfRange = WGPUBufferMapAsyncStatus_OffsetOutOfRange,\n    SizeOutOfRange = WGPUBufferMapAsyncStatus_SizeOutOfRange,\n};\nstatic_assert(sizeof(BufferMapAsyncStatus) == sizeof(WGPUBufferMapAsyncStatus), \"sizeof mismatch for BufferMapAsyncStatus\");\nstatic_assert(alignof(BufferMapAsyncStatus) == alignof(WGPUBufferMapAsyncStatus), \"alignof mismatch for BufferMapAsyncStatus\");\n\nenum class BufferMapState : uint32_t {\n    Unmapped = WGPUBufferMapState_Unmapped,\n    Pending = WGPUBufferMapState_Pending,\n    Mapped = WGPUBufferMapState_Mapped,\n};\nstatic_assert(sizeof(BufferMapState) == sizeof(WGPUBufferMapState), \"sizeof mismatch for BufferMapState\");\nstatic_assert(alignof(BufferMapState) == alignof(WGPUBufferMapState), \"alignof mismatch for BufferMapState\");\n\nenum class CallbackMode : uint32_t {\n    WaitAnyOnly = WGPUCallbackMode_WaitAnyOnly,\n    AllowProcessEvents = WGPUCallbackMode_AllowProcessEvents,\n    AllowSpontaneous = WGPUCallbackMode_AllowSpontaneous,\n};\nstatic_assert(sizeof(CallbackMode) == sizeof(WGPUCallbackMode), \"sizeof mismatch for CallbackMode\");\nstatic_assert(alignof(CallbackMode) == alignof(WGPUCallbackMode), \"alignof mismatch for CallbackMode\");\n\nenum class CompareFunction : uint32_t {\n    Undefined = WGPUCompareFunction_Undefined,\n    Never = WGPUCompareFunction_Never,\n    Less = WGPUCompareFunction_Less,\n    Equal = WGPUCompareFunction_Equal,\n    LessEqual = WGPUCompareFunction_LessEqual,\n    Greater = WGPUCompareFunction_Greater,\n    NotEqual = WGPUCompareFunction_NotEqual,\n    GreaterEqual = WGPUCompareFunction_GreaterEqual,\n    Always = WGPUCompareFunction_Always,\n};\nstatic_assert(sizeof(CompareFunction) == sizeof(WGPUCompareFunction), \"sizeof mismatch for CompareFunction\");\nstatic_assert(alignof(CompareFunction) == alignof(WGPUCompareFunction), \"alignof mismatch for CompareFunction\");\n\nenum class CompilationInfoRequestStatus : uint32_t {\n    Success = WGPUCompilationInfoRequestStatus_Success,\n    InstanceDropped = WGPUCompilationInfoRequestStatus_InstanceDropped,\n    Error = WGPUCompilationInfoRequestStatus_Error,\n    DeviceLost = WGPUCompilationInfoRequestStatus_DeviceLost,\n    Unknown = WGPUCompilationInfoRequestStatus_Unknown,\n};\nstatic_assert(sizeof(CompilationInfoRequestStatus) == sizeof(WGPUCompilationInfoRequestStatus), \"sizeof mismatch for CompilationInfoRequestStatus\");\nstatic_assert(alignof(CompilationInfoRequestStatus) == alignof(WGPUCompilationInfoRequestStatus), \"alignof mismatch for CompilationInfoRequestStatus\");\n\nenum class CompilationMessageType : uint32_t {\n    Error = WGPUCompilationMessageType_Error,\n    Warning = WGPUCompilationMessageType_Warning,\n    Info = WGPUCompilationMessageType_Info,\n};\nstatic_assert(sizeof(CompilationMessageType) == sizeof(WGPUCompilationMessageType), \"sizeof mismatch for CompilationMessageType\");\nstatic_assert(alignof(CompilationMessageType) == alignof(WGPUCompilationMessageType), \"alignof mismatch for CompilationMessageType\");\n\nenum class CompositeAlphaMode : uint32_t {\n    Auto = WGPUCompositeAlphaMode_Auto,\n    Opaque = WGPUCompositeAlphaMode_Opaque,\n    Premultiplied = WGPUCompositeAlphaMode_Premultiplied,\n    Unpremultiplied = WGPUCompositeAlphaMode_Unpremultiplied,\n    Inherit = WGPUCompositeAlphaMode_Inherit,\n};\nstatic_assert(sizeof(CompositeAlphaMode) == sizeof(WGPUCompositeAlphaMode), \"sizeof mismatch for CompositeAlphaMode\");\nstatic_assert(alignof(CompositeAlphaMode) == alignof(WGPUCompositeAlphaMode), \"alignof mismatch for CompositeAlphaMode\");\n\nenum class CreatePipelineAsyncStatus : uint32_t {\n    Success = WGPUCreatePipelineAsyncStatus_Success,\n    InstanceDropped = WGPUCreatePipelineAsyncStatus_InstanceDropped,\n    ValidationError = WGPUCreatePipelineAsyncStatus_ValidationError,\n    InternalError = WGPUCreatePipelineAsyncStatus_InternalError,\n    DeviceLost = WGPUCreatePipelineAsyncStatus_DeviceLost,\n    DeviceDestroyed = WGPUCreatePipelineAsyncStatus_DeviceDestroyed,\n    Unknown = WGPUCreatePipelineAsyncStatus_Unknown,\n};\nstatic_assert(sizeof(CreatePipelineAsyncStatus) == sizeof(WGPUCreatePipelineAsyncStatus), \"sizeof mismatch for CreatePipelineAsyncStatus\");\nstatic_assert(alignof(CreatePipelineAsyncStatus) == alignof(WGPUCreatePipelineAsyncStatus), \"alignof mismatch for CreatePipelineAsyncStatus\");\n\nenum class CullMode : uint32_t {\n    Undefined = WGPUCullMode_Undefined,\n    None = WGPUCullMode_None,\n    Front = WGPUCullMode_Front,\n    Back = WGPUCullMode_Back,\n};\nstatic_assert(sizeof(CullMode) == sizeof(WGPUCullMode), \"sizeof mismatch for CullMode\");\nstatic_assert(alignof(CullMode) == alignof(WGPUCullMode), \"alignof mismatch for CullMode\");\n\nenum class DeviceLostReason : uint32_t {\n    Unknown = WGPUDeviceLostReason_Unknown,\n    Destroyed = WGPUDeviceLostReason_Destroyed,\n    InstanceDropped = WGPUDeviceLostReason_InstanceDropped,\n    FailedCreation = WGPUDeviceLostReason_FailedCreation,\n};\nstatic_assert(sizeof(DeviceLostReason) == sizeof(WGPUDeviceLostReason), \"sizeof mismatch for DeviceLostReason\");\nstatic_assert(alignof(DeviceLostReason) == alignof(WGPUDeviceLostReason), \"alignof mismatch for DeviceLostReason\");\n\nenum class ErrorFilter : uint32_t {\n    Validation = WGPUErrorFilter_Validation,\n    OutOfMemory = WGPUErrorFilter_OutOfMemory,\n    Internal = WGPUErrorFilter_Internal,\n};\nstatic_assert(sizeof(ErrorFilter) == sizeof(WGPUErrorFilter), \"sizeof mismatch for ErrorFilter\");\nstatic_assert(alignof(ErrorFilter) == alignof(WGPUErrorFilter), \"alignof mismatch for ErrorFilter\");\n\nenum class ErrorType : uint32_t {\n    NoError = WGPUErrorType_NoError,\n    Validation = WGPUErrorType_Validation,\n    OutOfMemory = WGPUErrorType_OutOfMemory,\n    Internal = WGPUErrorType_Internal,\n    Unknown = WGPUErrorType_Unknown,\n    DeviceLost = WGPUErrorType_DeviceLost,\n};\nstatic_assert(sizeof(ErrorType) == sizeof(WGPUErrorType), \"sizeof mismatch for ErrorType\");\nstatic_assert(alignof(ErrorType) == alignof(WGPUErrorType), \"alignof mismatch for ErrorType\");\n\nenum class ExternalTextureRotation : uint32_t {\n    Rotate0Degrees = WGPUExternalTextureRotation_Rotate0Degrees,\n    Rotate90Degrees = WGPUExternalTextureRotation_Rotate90Degrees,\n    Rotate180Degrees = WGPUExternalTextureRotation_Rotate180Degrees,\n    Rotate270Degrees = WGPUExternalTextureRotation_Rotate270Degrees,\n};\nstatic_assert(sizeof(ExternalTextureRotation) == sizeof(WGPUExternalTextureRotation), \"sizeof mismatch for ExternalTextureRotation\");\nstatic_assert(alignof(ExternalTextureRotation) == alignof(WGPUExternalTextureRotation), \"alignof mismatch for ExternalTextureRotation\");\n\nenum class FeatureName : uint32_t {\n    DepthClipControl = WGPUFeatureName_DepthClipControl,\n    Depth32FloatStencil8 = WGPUFeatureName_Depth32FloatStencil8,\n    TimestampQuery = WGPUFeatureName_TimestampQuery,\n    TextureCompressionBC = WGPUFeatureName_TextureCompressionBC,\n    TextureCompressionETC2 = WGPUFeatureName_TextureCompressionETC2,\n    TextureCompressionASTC = WGPUFeatureName_TextureCompressionASTC,\n    IndirectFirstInstance = WGPUFeatureName_IndirectFirstInstance,\n    ShaderF16 = WGPUFeatureName_ShaderF16,\n    RG11B10UfloatRenderable = WGPUFeatureName_RG11B10UfloatRenderable,\n    BGRA8UnormStorage = WGPUFeatureName_BGRA8UnormStorage,\n    Float32Filterable = WGPUFeatureName_Float32Filterable,\n    Float32Blendable = WGPUFeatureName_Float32Blendable,\n    Subgroups = WGPUFeatureName_Subgroups,\n    SubgroupsF16 = WGPUFeatureName_SubgroupsF16,\n    DawnInternalUsages = WGPUFeatureName_DawnInternalUsages,\n    DawnMultiPlanarFormats = WGPUFeatureName_DawnMultiPlanarFormats,\n    DawnNative = WGPUFeatureName_DawnNative,\n    ChromiumExperimentalTimestampQueryInsidePasses = WGPUFeatureName_ChromiumExperimentalTimestampQueryInsidePasses,\n    ImplicitDeviceSynchronization = WGPUFeatureName_ImplicitDeviceSynchronization,\n    ChromiumExperimentalImmediateData = WGPUFeatureName_ChromiumExperimentalImmediateData,\n    TransientAttachments = WGPUFeatureName_TransientAttachments,\n    MSAARenderToSingleSampled = WGPUFeatureName_MSAARenderToSingleSampled,\n    DualSourceBlending = WGPUFeatureName_DualSourceBlending,\n    D3D11MultithreadProtected = WGPUFeatureName_D3D11MultithreadProtected,\n    ANGLETextureSharing = WGPUFeatureName_ANGLETextureSharing,\n    PixelLocalStorageCoherent = WGPUFeatureName_PixelLocalStorageCoherent,\n    PixelLocalStorageNonCoherent = WGPUFeatureName_PixelLocalStorageNonCoherent,\n    Unorm16TextureFormats = WGPUFeatureName_Unorm16TextureFormats,\n    Snorm16TextureFormats = WGPUFeatureName_Snorm16TextureFormats,\n    MultiPlanarFormatExtendedUsages = WGPUFeatureName_MultiPlanarFormatExtendedUsages,\n    MultiPlanarFormatP010 = WGPUFeatureName_MultiPlanarFormatP010,\n    HostMappedPointer = WGPUFeatureName_HostMappedPointer,\n    MultiPlanarRenderTargets = WGPUFeatureName_MultiPlanarRenderTargets,\n    MultiPlanarFormatNv12a = WGPUFeatureName_MultiPlanarFormatNv12a,\n    FramebufferFetch = WGPUFeatureName_FramebufferFetch,\n    BufferMapExtendedUsages = WGPUFeatureName_BufferMapExtendedUsages,\n    AdapterPropertiesMemoryHeaps = WGPUFeatureName_AdapterPropertiesMemoryHeaps,\n    AdapterPropertiesD3D = WGPUFeatureName_AdapterPropertiesD3D,\n    AdapterPropertiesVk = WGPUFeatureName_AdapterPropertiesVk,\n    R8UnormStorage = WGPUFeatureName_R8UnormStorage,\n    FormatCapabilities = WGPUFeatureName_FormatCapabilities,\n    DrmFormatCapabilities = WGPUFeatureName_DrmFormatCapabilities,\n    Norm16TextureFormats = WGPUFeatureName_Norm16TextureFormats,\n    MultiPlanarFormatNv16 = WGPUFeatureName_MultiPlanarFormatNv16,\n    MultiPlanarFormatNv24 = WGPUFeatureName_MultiPlanarFormatNv24,\n    MultiPlanarFormatP210 = WGPUFeatureName_MultiPlanarFormatP210,\n    MultiPlanarFormatP410 = WGPUFeatureName_MultiPlanarFormatP410,\n    SharedTextureMemoryVkDedicatedAllocation = WGPUFeatureName_SharedTextureMemoryVkDedicatedAllocation,\n    SharedTextureMemoryAHardwareBuffer = WGPUFeatureName_SharedTextureMemoryAHardwareBuffer,\n    SharedTextureMemoryDmaBuf = WGPUFeatureName_SharedTextureMemoryDmaBuf,\n    SharedTextureMemoryOpaqueFD = WGPUFeatureName_SharedTextureMemoryOpaqueFD,\n    SharedTextureMemoryZirconHandle = WGPUFeatureName_SharedTextureMemoryZirconHandle,\n    SharedTextureMemoryDXGISharedHandle = WGPUFeatureName_SharedTextureMemoryDXGISharedHandle,\n    SharedTextureMemoryD3D11Texture2D = WGPUFeatureName_SharedTextureMemoryD3D11Texture2D,\n    SharedTextureMemoryIOSurface = WGPUFeatureName_SharedTextureMemoryIOSurface,\n    SharedTextureMemoryEGLImage = WGPUFeatureName_SharedTextureMemoryEGLImage,\n    SharedFenceVkSemaphoreOpaqueFD = WGPUFeatureName_SharedFenceVkSemaphoreOpaqueFD,\n    SharedFenceSyncFD = WGPUFeatureName_SharedFenceSyncFD,\n    SharedFenceVkSemaphoreZirconHandle = WGPUFeatureName_SharedFenceVkSemaphoreZirconHandle,\n    SharedFenceDXGISharedHandle = WGPUFeatureName_SharedFenceDXGISharedHandle,\n    SharedFenceMTLSharedEvent = WGPUFeatureName_SharedFenceMTLSharedEvent,\n    SharedBufferMemoryD3D12Resource = WGPUFeatureName_SharedBufferMemoryD3D12Resource,\n    StaticSamplers = WGPUFeatureName_StaticSamplers,\n    YCbCrVulkanSamplers = WGPUFeatureName_YCbCrVulkanSamplers,\n    ShaderModuleCompilationOptions = WGPUFeatureName_ShaderModuleCompilationOptions,\n    DawnLoadResolveTexture = WGPUFeatureName_DawnLoadResolveTexture,\n    DawnPartialLoadResolveTexture = WGPUFeatureName_DawnPartialLoadResolveTexture,\n    MultiDrawIndirect = WGPUFeatureName_MultiDrawIndirect,\n    ClipDistances = WGPUFeatureName_ClipDistances,\n    DawnTexelCopyBufferRowAlignment = WGPUFeatureName_DawnTexelCopyBufferRowAlignment,\n};\nstatic_assert(sizeof(FeatureName) == sizeof(WGPUFeatureName), \"sizeof mismatch for FeatureName\");\nstatic_assert(alignof(FeatureName) == alignof(WGPUFeatureName), \"alignof mismatch for FeatureName\");\n\nenum class FilterMode : uint32_t {\n    Undefined = WGPUFilterMode_Undefined,\n    Nearest = WGPUFilterMode_Nearest,\n    Linear = WGPUFilterMode_Linear,\n};\nstatic_assert(sizeof(FilterMode) == sizeof(WGPUFilterMode), \"sizeof mismatch for FilterMode\");\nstatic_assert(alignof(FilterMode) == alignof(WGPUFilterMode), \"alignof mismatch for FilterMode\");\n\nenum class FrontFace : uint32_t {\n    Undefined = WGPUFrontFace_Undefined,\n    CCW = WGPUFrontFace_CCW,\n    CW = WGPUFrontFace_CW,\n};\nstatic_assert(sizeof(FrontFace) == sizeof(WGPUFrontFace), \"sizeof mismatch for FrontFace\");\nstatic_assert(alignof(FrontFace) == alignof(WGPUFrontFace), \"alignof mismatch for FrontFace\");\n\nenum class IndexFormat : uint32_t {\n    Undefined = WGPUIndexFormat_Undefined,\n    Uint16 = WGPUIndexFormat_Uint16,\n    Uint32 = WGPUIndexFormat_Uint32,\n};\nstatic_assert(sizeof(IndexFormat) == sizeof(WGPUIndexFormat), \"sizeof mismatch for IndexFormat\");\nstatic_assert(alignof(IndexFormat) == alignof(WGPUIndexFormat), \"alignof mismatch for IndexFormat\");\n\nenum class LoadOp : uint32_t {\n    Undefined = WGPULoadOp_Undefined,\n    Load = WGPULoadOp_Load,\n    Clear = WGPULoadOp_Clear,\n    ExpandResolveTexture = WGPULoadOp_ExpandResolveTexture,\n};\nstatic_assert(sizeof(LoadOp) == sizeof(WGPULoadOp), \"sizeof mismatch for LoadOp\");\nstatic_assert(alignof(LoadOp) == alignof(WGPULoadOp), \"alignof mismatch for LoadOp\");\n\nenum class LoggingType : uint32_t {\n    Verbose = WGPULoggingType_Verbose,\n    Info = WGPULoggingType_Info,\n    Warning = WGPULoggingType_Warning,\n    Error = WGPULoggingType_Error,\n};\nstatic_assert(sizeof(LoggingType) == sizeof(WGPULoggingType), \"sizeof mismatch for LoggingType\");\nstatic_assert(alignof(LoggingType) == alignof(WGPULoggingType), \"alignof mismatch for LoggingType\");\n\nenum class MapAsyncStatus : uint32_t {\n    Success = WGPUMapAsyncStatus_Success,\n    InstanceDropped = WGPUMapAsyncStatus_InstanceDropped,\n    Error = WGPUMapAsyncStatus_Error,\n    Aborted = WGPUMapAsyncStatus_Aborted,\n    Unknown = WGPUMapAsyncStatus_Unknown,\n};\nstatic_assert(sizeof(MapAsyncStatus) == sizeof(WGPUMapAsyncStatus), \"sizeof mismatch for MapAsyncStatus\");\nstatic_assert(alignof(MapAsyncStatus) == alignof(WGPUMapAsyncStatus), \"alignof mismatch for MapAsyncStatus\");\n\nenum class MipmapFilterMode : uint32_t {\n    Undefined = WGPUMipmapFilterMode_Undefined,\n    Nearest = WGPUMipmapFilterMode_Nearest,\n    Linear = WGPUMipmapFilterMode_Linear,\n};\nstatic_assert(sizeof(MipmapFilterMode) == sizeof(WGPUMipmapFilterMode), \"sizeof mismatch for MipmapFilterMode\");\nstatic_assert(alignof(MipmapFilterMode) == alignof(WGPUMipmapFilterMode), \"alignof mismatch for MipmapFilterMode\");\n\nenum class PopErrorScopeStatus : uint32_t {\n    Success = WGPUPopErrorScopeStatus_Success,\n    InstanceDropped = WGPUPopErrorScopeStatus_InstanceDropped,\n};\nstatic_assert(sizeof(PopErrorScopeStatus) == sizeof(WGPUPopErrorScopeStatus), \"sizeof mismatch for PopErrorScopeStatus\");\nstatic_assert(alignof(PopErrorScopeStatus) == alignof(WGPUPopErrorScopeStatus), \"alignof mismatch for PopErrorScopeStatus\");\n\nenum class PowerPreference : uint32_t {\n    Undefined = WGPUPowerPreference_Undefined,\n    LowPower = WGPUPowerPreference_LowPower,\n    HighPerformance = WGPUPowerPreference_HighPerformance,\n};\nstatic_assert(sizeof(PowerPreference) == sizeof(WGPUPowerPreference), \"sizeof mismatch for PowerPreference\");\nstatic_assert(alignof(PowerPreference) == alignof(WGPUPowerPreference), \"alignof mismatch for PowerPreference\");\n\nenum class PresentMode : uint32_t {\n    Fifo = WGPUPresentMode_Fifo,\n    FifoRelaxed = WGPUPresentMode_FifoRelaxed,\n    Immediate = WGPUPresentMode_Immediate,\n    Mailbox = WGPUPresentMode_Mailbox,\n};\nstatic_assert(sizeof(PresentMode) == sizeof(WGPUPresentMode), \"sizeof mismatch for PresentMode\");\nstatic_assert(alignof(PresentMode) == alignof(WGPUPresentMode), \"alignof mismatch for PresentMode\");\n\nenum class PrimitiveTopology : uint32_t {\n    Undefined = WGPUPrimitiveTopology_Undefined,\n    PointList = WGPUPrimitiveTopology_PointList,\n    LineList = WGPUPrimitiveTopology_LineList,\n    LineStrip = WGPUPrimitiveTopology_LineStrip,\n    TriangleList = WGPUPrimitiveTopology_TriangleList,\n    TriangleStrip = WGPUPrimitiveTopology_TriangleStrip,\n};\nstatic_assert(sizeof(PrimitiveTopology) == sizeof(WGPUPrimitiveTopology), \"sizeof mismatch for PrimitiveTopology\");\nstatic_assert(alignof(PrimitiveTopology) == alignof(WGPUPrimitiveTopology), \"alignof mismatch for PrimitiveTopology\");\n\nenum class QueryType : uint32_t {\n    Occlusion = WGPUQueryType_Occlusion,\n    Timestamp = WGPUQueryType_Timestamp,\n};\nstatic_assert(sizeof(QueryType) == sizeof(WGPUQueryType), \"sizeof mismatch for QueryType\");\nstatic_assert(alignof(QueryType) == alignof(WGPUQueryType), \"alignof mismatch for QueryType\");\n\nenum class QueueWorkDoneStatus : uint32_t {\n    Success = WGPUQueueWorkDoneStatus_Success,\n    InstanceDropped = WGPUQueueWorkDoneStatus_InstanceDropped,\n    Error = WGPUQueueWorkDoneStatus_Error,\n    Unknown = WGPUQueueWorkDoneStatus_Unknown,\n    DeviceLost = WGPUQueueWorkDoneStatus_DeviceLost,\n};\nstatic_assert(sizeof(QueueWorkDoneStatus) == sizeof(WGPUQueueWorkDoneStatus), \"sizeof mismatch for QueueWorkDoneStatus\");\nstatic_assert(alignof(QueueWorkDoneStatus) == alignof(WGPUQueueWorkDoneStatus), \"alignof mismatch for QueueWorkDoneStatus\");\n\nenum class RequestAdapterStatus : uint32_t {\n    Success = WGPURequestAdapterStatus_Success,\n    InstanceDropped = WGPURequestAdapterStatus_InstanceDropped,\n    Unavailable = WGPURequestAdapterStatus_Unavailable,\n    Error = WGPURequestAdapterStatus_Error,\n    Unknown = WGPURequestAdapterStatus_Unknown,\n};\nstatic_assert(sizeof(RequestAdapterStatus) == sizeof(WGPURequestAdapterStatus), \"sizeof mismatch for RequestAdapterStatus\");\nstatic_assert(alignof(RequestAdapterStatus) == alignof(WGPURequestAdapterStatus), \"alignof mismatch for RequestAdapterStatus\");\n\nenum class RequestDeviceStatus : uint32_t {\n    Success = WGPURequestDeviceStatus_Success,\n    InstanceDropped = WGPURequestDeviceStatus_InstanceDropped,\n    Error = WGPURequestDeviceStatus_Error,\n    Unknown = WGPURequestDeviceStatus_Unknown,\n};\nstatic_assert(sizeof(RequestDeviceStatus) == sizeof(WGPURequestDeviceStatus), \"sizeof mismatch for RequestDeviceStatus\");\nstatic_assert(alignof(RequestDeviceStatus) == alignof(WGPURequestDeviceStatus), \"alignof mismatch for RequestDeviceStatus\");\n\nenum class SType : uint32_t {\n    ShaderSourceSPIRV = WGPUSType_ShaderSourceSPIRV,\n    ShaderSourceWGSL = WGPUSType_ShaderSourceWGSL,\n    RenderPassMaxDrawCount = WGPUSType_RenderPassMaxDrawCount,\n    SurfaceSourceMetalLayer = WGPUSType_SurfaceSourceMetalLayer,\n    SurfaceSourceWindowsHWND = WGPUSType_SurfaceSourceWindowsHWND,\n    SurfaceSourceXlibWindow = WGPUSType_SurfaceSourceXlibWindow,\n    SurfaceSourceWaylandSurface = WGPUSType_SurfaceSourceWaylandSurface,\n    SurfaceSourceAndroidNativeWindow = WGPUSType_SurfaceSourceAndroidNativeWindow,\n    SurfaceSourceXCBWindow = WGPUSType_SurfaceSourceXCBWindow,\n    AdapterPropertiesSubgroups = WGPUSType_AdapterPropertiesSubgroups,\n    TextureBindingViewDimensionDescriptor = WGPUSType_TextureBindingViewDimensionDescriptor,\n    SurfaceSourceCanvasHTMLSelector_Emscripten = WGPUSType_SurfaceSourceCanvasHTMLSelector_Emscripten,\n    SurfaceDescriptorFromWindowsCoreWindow = WGPUSType_SurfaceDescriptorFromWindowsCoreWindow,\n    ExternalTextureBindingEntry = WGPUSType_ExternalTextureBindingEntry,\n    ExternalTextureBindingLayout = WGPUSType_ExternalTextureBindingLayout,\n    SurfaceDescriptorFromWindowsSwapChainPanel = WGPUSType_SurfaceDescriptorFromWindowsSwapChainPanel,\n    DawnTextureInternalUsageDescriptor = WGPUSType_DawnTextureInternalUsageDescriptor,\n    DawnEncoderInternalUsageDescriptor = WGPUSType_DawnEncoderInternalUsageDescriptor,\n    DawnInstanceDescriptor = WGPUSType_DawnInstanceDescriptor,\n    DawnCacheDeviceDescriptor = WGPUSType_DawnCacheDeviceDescriptor,\n    DawnAdapterPropertiesPowerPreference = WGPUSType_DawnAdapterPropertiesPowerPreference,\n    DawnBufferDescriptorErrorInfoFromWireClient = WGPUSType_DawnBufferDescriptorErrorInfoFromWireClient,\n    DawnTogglesDescriptor = WGPUSType_DawnTogglesDescriptor,\n    DawnShaderModuleSPIRVOptionsDescriptor = WGPUSType_DawnShaderModuleSPIRVOptionsDescriptor,\n    RequestAdapterOptionsLUID = WGPUSType_RequestAdapterOptionsLUID,\n    RequestAdapterOptionsGetGLProc = WGPUSType_RequestAdapterOptionsGetGLProc,\n    RequestAdapterOptionsD3D11Device = WGPUSType_RequestAdapterOptionsD3D11Device,\n    DawnRenderPassColorAttachmentRenderToSingleSampled = WGPUSType_DawnRenderPassColorAttachmentRenderToSingleSampled,\n    RenderPassPixelLocalStorage = WGPUSType_RenderPassPixelLocalStorage,\n    PipelineLayoutPixelLocalStorage = WGPUSType_PipelineLayoutPixelLocalStorage,\n    BufferHostMappedPointer = WGPUSType_BufferHostMappedPointer,\n    DawnExperimentalSubgroupLimits = WGPUSType_DawnExperimentalSubgroupLimits,\n    AdapterPropertiesMemoryHeaps = WGPUSType_AdapterPropertiesMemoryHeaps,\n    AdapterPropertiesD3D = WGPUSType_AdapterPropertiesD3D,\n    AdapterPropertiesVk = WGPUSType_AdapterPropertiesVk,\n    DawnWireWGSLControl = WGPUSType_DawnWireWGSLControl,\n    DawnWGSLBlocklist = WGPUSType_DawnWGSLBlocklist,\n    DrmFormatCapabilities = WGPUSType_DrmFormatCapabilities,\n    ShaderModuleCompilationOptions = WGPUSType_ShaderModuleCompilationOptions,\n    ColorTargetStateExpandResolveTextureDawn = WGPUSType_ColorTargetStateExpandResolveTextureDawn,\n    RenderPassDescriptorExpandResolveRect = WGPUSType_RenderPassDescriptorExpandResolveRect,\n    SharedTextureMemoryVkDedicatedAllocationDescriptor = WGPUSType_SharedTextureMemoryVkDedicatedAllocationDescriptor,\n    SharedTextureMemoryAHardwareBufferDescriptor = WGPUSType_SharedTextureMemoryAHardwareBufferDescriptor,\n    SharedTextureMemoryDmaBufDescriptor = WGPUSType_SharedTextureMemoryDmaBufDescriptor,\n    SharedTextureMemoryOpaqueFDDescriptor = WGPUSType_SharedTextureMemoryOpaqueFDDescriptor,\n    SharedTextureMemoryZirconHandleDescriptor = WGPUSType_SharedTextureMemoryZirconHandleDescriptor,\n    SharedTextureMemoryDXGISharedHandleDescriptor = WGPUSType_SharedTextureMemoryDXGISharedHandleDescriptor,\n    SharedTextureMemoryD3D11Texture2DDescriptor = WGPUSType_SharedTextureMemoryD3D11Texture2DDescriptor,\n    SharedTextureMemoryIOSurfaceDescriptor = WGPUSType_SharedTextureMemoryIOSurfaceDescriptor,\n    SharedTextureMemoryEGLImageDescriptor = WGPUSType_SharedTextureMemoryEGLImageDescriptor,\n    SharedTextureMemoryInitializedBeginState = WGPUSType_SharedTextureMemoryInitializedBeginState,\n    SharedTextureMemoryInitializedEndState = WGPUSType_SharedTextureMemoryInitializedEndState,\n    SharedTextureMemoryVkImageLayoutBeginState = WGPUSType_SharedTextureMemoryVkImageLayoutBeginState,\n    SharedTextureMemoryVkImageLayoutEndState = WGPUSType_SharedTextureMemoryVkImageLayoutEndState,\n    SharedTextureMemoryD3DSwapchainBeginState = WGPUSType_SharedTextureMemoryD3DSwapchainBeginState,\n    SharedFenceVkSemaphoreOpaqueFDDescriptor = WGPUSType_SharedFenceVkSemaphoreOpaqueFDDescriptor,\n    SharedFenceVkSemaphoreOpaqueFDExportInfo = WGPUSType_SharedFenceVkSemaphoreOpaqueFDExportInfo,\n    SharedFenceSyncFDDescriptor = WGPUSType_SharedFenceSyncFDDescriptor,\n    SharedFenceSyncFDExportInfo = WGPUSType_SharedFenceSyncFDExportInfo,\n    SharedFenceVkSemaphoreZirconHandleDescriptor = WGPUSType_SharedFenceVkSemaphoreZirconHandleDescriptor,\n    SharedFenceVkSemaphoreZirconHandleExportInfo = WGPUSType_SharedFenceVkSemaphoreZirconHandleExportInfo,\n    SharedFenceDXGISharedHandleDescriptor = WGPUSType_SharedFenceDXGISharedHandleDescriptor,\n    SharedFenceDXGISharedHandleExportInfo = WGPUSType_SharedFenceDXGISharedHandleExportInfo,\n    SharedFenceMTLSharedEventDescriptor = WGPUSType_SharedFenceMTLSharedEventDescriptor,\n    SharedFenceMTLSharedEventExportInfo = WGPUSType_SharedFenceMTLSharedEventExportInfo,\n    SharedBufferMemoryD3D12ResourceDescriptor = WGPUSType_SharedBufferMemoryD3D12ResourceDescriptor,\n    StaticSamplerBindingLayout = WGPUSType_StaticSamplerBindingLayout,\n    YCbCrVkDescriptor = WGPUSType_YCbCrVkDescriptor,\n    SharedTextureMemoryAHardwareBufferProperties = WGPUSType_SharedTextureMemoryAHardwareBufferProperties,\n    AHardwareBufferProperties = WGPUSType_AHardwareBufferProperties,\n    DawnExperimentalImmediateDataLimits = WGPUSType_DawnExperimentalImmediateDataLimits,\n    DawnTexelCopyBufferRowAlignmentLimits = WGPUSType_DawnTexelCopyBufferRowAlignmentLimits,\n};\nstatic_assert(sizeof(SType) == sizeof(WGPUSType), \"sizeof mismatch for SType\");\nstatic_assert(alignof(SType) == alignof(WGPUSType), \"alignof mismatch for SType\");\n\nenum class SamplerBindingType : uint32_t {\n    BindingNotUsed = WGPUSamplerBindingType_BindingNotUsed,\n    Filtering = WGPUSamplerBindingType_Filtering,\n    NonFiltering = WGPUSamplerBindingType_NonFiltering,\n    Comparison = WGPUSamplerBindingType_Comparison,\n};\nstatic_assert(sizeof(SamplerBindingType) == sizeof(WGPUSamplerBindingType), \"sizeof mismatch for SamplerBindingType\");\nstatic_assert(alignof(SamplerBindingType) == alignof(WGPUSamplerBindingType), \"alignof mismatch for SamplerBindingType\");\n\nenum class SharedFenceType : uint32_t {\n    VkSemaphoreOpaqueFD = WGPUSharedFenceType_VkSemaphoreOpaqueFD,\n    SyncFD = WGPUSharedFenceType_SyncFD,\n    VkSemaphoreZirconHandle = WGPUSharedFenceType_VkSemaphoreZirconHandle,\n    DXGISharedHandle = WGPUSharedFenceType_DXGISharedHandle,\n    MTLSharedEvent = WGPUSharedFenceType_MTLSharedEvent,\n};\nstatic_assert(sizeof(SharedFenceType) == sizeof(WGPUSharedFenceType), \"sizeof mismatch for SharedFenceType\");\nstatic_assert(alignof(SharedFenceType) == alignof(WGPUSharedFenceType), \"alignof mismatch for SharedFenceType\");\n\nenum class Status : uint32_t {\n    Success = WGPUStatus_Success,\n    Error = WGPUStatus_Error,\n};\nstatic_assert(sizeof(Status) == sizeof(WGPUStatus), \"sizeof mismatch for Status\");\nstatic_assert(alignof(Status) == alignof(WGPUStatus), \"alignof mismatch for Status\");\n\nenum class StencilOperation : uint32_t {\n    Undefined = WGPUStencilOperation_Undefined,\n    Keep = WGPUStencilOperation_Keep,\n    Zero = WGPUStencilOperation_Zero,\n    Replace = WGPUStencilOperation_Replace,\n    Invert = WGPUStencilOperation_Invert,\n    IncrementClamp = WGPUStencilOperation_IncrementClamp,\n    DecrementClamp = WGPUStencilOperation_DecrementClamp,\n    IncrementWrap = WGPUStencilOperation_IncrementWrap,\n    DecrementWrap = WGPUStencilOperation_DecrementWrap,\n};\nstatic_assert(sizeof(StencilOperation) == sizeof(WGPUStencilOperation), \"sizeof mismatch for StencilOperation\");\nstatic_assert(alignof(StencilOperation) == alignof(WGPUStencilOperation), \"alignof mismatch for StencilOperation\");\n\nenum class StorageTextureAccess : uint32_t {\n    BindingNotUsed = WGPUStorageTextureAccess_BindingNotUsed,\n    WriteOnly = WGPUStorageTextureAccess_WriteOnly,\n    ReadOnly = WGPUStorageTextureAccess_ReadOnly,\n    ReadWrite = WGPUStorageTextureAccess_ReadWrite,\n};\nstatic_assert(sizeof(StorageTextureAccess) == sizeof(WGPUStorageTextureAccess), \"sizeof mismatch for StorageTextureAccess\");\nstatic_assert(alignof(StorageTextureAccess) == alignof(WGPUStorageTextureAccess), \"alignof mismatch for StorageTextureAccess\");\n\nenum class StoreOp : uint32_t {\n    Undefined = WGPUStoreOp_Undefined,\n    Store = WGPUStoreOp_Store,\n    Discard = WGPUStoreOp_Discard,\n};\nstatic_assert(sizeof(StoreOp) == sizeof(WGPUStoreOp), \"sizeof mismatch for StoreOp\");\nstatic_assert(alignof(StoreOp) == alignof(WGPUStoreOp), \"alignof mismatch for StoreOp\");\n\nenum class SurfaceGetCurrentTextureStatus : uint32_t {\n    Success = WGPUSurfaceGetCurrentTextureStatus_Success,\n    Timeout = WGPUSurfaceGetCurrentTextureStatus_Timeout,\n    Outdated = WGPUSurfaceGetCurrentTextureStatus_Outdated,\n    Lost = WGPUSurfaceGetCurrentTextureStatus_Lost,\n    OutOfMemory = WGPUSurfaceGetCurrentTextureStatus_OutOfMemory,\n    DeviceLost = WGPUSurfaceGetCurrentTextureStatus_DeviceLost,\n    Error = WGPUSurfaceGetCurrentTextureStatus_Error,\n};\nstatic_assert(sizeof(SurfaceGetCurrentTextureStatus) == sizeof(WGPUSurfaceGetCurrentTextureStatus), \"sizeof mismatch for SurfaceGetCurrentTextureStatus\");\nstatic_assert(alignof(SurfaceGetCurrentTextureStatus) == alignof(WGPUSurfaceGetCurrentTextureStatus), \"alignof mismatch for SurfaceGetCurrentTextureStatus\");\n\nenum class TextureAspect : uint32_t {\n    Undefined = WGPUTextureAspect_Undefined,\n    All = WGPUTextureAspect_All,\n    StencilOnly = WGPUTextureAspect_StencilOnly,\n    DepthOnly = WGPUTextureAspect_DepthOnly,\n    Plane0Only = WGPUTextureAspect_Plane0Only,\n    Plane1Only = WGPUTextureAspect_Plane1Only,\n    Plane2Only = WGPUTextureAspect_Plane2Only,\n};\nstatic_assert(sizeof(TextureAspect) == sizeof(WGPUTextureAspect), \"sizeof mismatch for TextureAspect\");\nstatic_assert(alignof(TextureAspect) == alignof(WGPUTextureAspect), \"alignof mismatch for TextureAspect\");\n\nenum class TextureDimension : uint32_t {\n    Undefined = WGPUTextureDimension_Undefined,\n    e1D = WGPUTextureDimension_1D,\n    e2D = WGPUTextureDimension_2D,\n    e3D = WGPUTextureDimension_3D,\n};\nstatic_assert(sizeof(TextureDimension) == sizeof(WGPUTextureDimension), \"sizeof mismatch for TextureDimension\");\nstatic_assert(alignof(TextureDimension) == alignof(WGPUTextureDimension), \"alignof mismatch for TextureDimension\");\n\nenum class TextureFormat : uint32_t {\n    Undefined = WGPUTextureFormat_Undefined,\n    R8Unorm = WGPUTextureFormat_R8Unorm,\n    R8Snorm = WGPUTextureFormat_R8Snorm,\n    R8Uint = WGPUTextureFormat_R8Uint,\n    R8Sint = WGPUTextureFormat_R8Sint,\n    R16Uint = WGPUTextureFormat_R16Uint,\n    R16Sint = WGPUTextureFormat_R16Sint,\n    R16Float = WGPUTextureFormat_R16Float,\n    RG8Unorm = WGPUTextureFormat_RG8Unorm,\n    RG8Snorm = WGPUTextureFormat_RG8Snorm,\n    RG8Uint = WGPUTextureFormat_RG8Uint,\n    RG8Sint = WGPUTextureFormat_RG8Sint,\n    R32Float = WGPUTextureFormat_R32Float,\n    R32Uint = WGPUTextureFormat_R32Uint,\n    R32Sint = WGPUTextureFormat_R32Sint,\n    RG16Uint = WGPUTextureFormat_RG16Uint,\n    RG16Sint = WGPUTextureFormat_RG16Sint,\n    RG16Float = WGPUTextureFormat_RG16Float,\n    RGBA8Unorm = WGPUTextureFormat_RGBA8Unorm,\n    RGBA8UnormSrgb = WGPUTextureFormat_RGBA8UnormSrgb,\n    RGBA8Snorm = WGPUTextureFormat_RGBA8Snorm,\n    RGBA8Uint = WGPUTextureFormat_RGBA8Uint,\n    RGBA8Sint = WGPUTextureFormat_RGBA8Sint,\n    BGRA8Unorm = WGPUTextureFormat_BGRA8Unorm,\n    BGRA8UnormSrgb = WGPUTextureFormat_BGRA8UnormSrgb,\n    RGB10A2Uint = WGPUTextureFormat_RGB10A2Uint,\n    RGB10A2Unorm = WGPUTextureFormat_RGB10A2Unorm,\n    RG11B10Ufloat = WGPUTextureFormat_RG11B10Ufloat,\n    RGB9E5Ufloat = WGPUTextureFormat_RGB9E5Ufloat,\n    RG32Float = WGPUTextureFormat_RG32Float,\n    RG32Uint = WGPUTextureFormat_RG32Uint,\n    RG32Sint = WGPUTextureFormat_RG32Sint,\n    RGBA16Uint = WGPUTextureFormat_RGBA16Uint,\n    RGBA16Sint = WGPUTextureFormat_RGBA16Sint,\n    RGBA16Float = WGPUTextureFormat_RGBA16Float,\n    RGBA32Float = WGPUTextureFormat_RGBA32Float,\n    RGBA32Uint = WGPUTextureFormat_RGBA32Uint,\n    RGBA32Sint = WGPUTextureFormat_RGBA32Sint,\n    Stencil8 = WGPUTextureFormat_Stencil8,\n    Depth16Unorm = WGPUTextureFormat_Depth16Unorm,\n    Depth24Plus = WGPUTextureFormat_Depth24Plus,\n    Depth24PlusStencil8 = WGPUTextureFormat_Depth24PlusStencil8,\n    Depth32Float = WGPUTextureFormat_Depth32Float,\n    Depth32FloatStencil8 = WGPUTextureFormat_Depth32FloatStencil8,\n    BC1RGBAUnorm = WGPUTextureFormat_BC1RGBAUnorm,\n    BC1RGBAUnormSrgb = WGPUTextureFormat_BC1RGBAUnormSrgb,\n    BC2RGBAUnorm = WGPUTextureFormat_BC2RGBAUnorm,\n    BC2RGBAUnormSrgb = WGPUTextureFormat_BC2RGBAUnormSrgb,\n    BC3RGBAUnorm = WGPUTextureFormat_BC3RGBAUnorm,\n    BC3RGBAUnormSrgb = WGPUTextureFormat_BC3RGBAUnormSrgb,\n    BC4RUnorm = WGPUTextureFormat_BC4RUnorm,\n    BC4RSnorm = WGPUTextureFormat_BC4RSnorm,\n    BC5RGUnorm = WGPUTextureFormat_BC5RGUnorm,\n    BC5RGSnorm = WGPUTextureFormat_BC5RGSnorm,\n    BC6HRGBUfloat = WGPUTextureFormat_BC6HRGBUfloat,\n    BC6HRGBFloat = WGPUTextureFormat_BC6HRGBFloat,\n    BC7RGBAUnorm = WGPUTextureFormat_BC7RGBAUnorm,\n    BC7RGBAUnormSrgb = WGPUTextureFormat_BC7RGBAUnormSrgb,\n    ETC2RGB8Unorm = WGPUTextureFormat_ETC2RGB8Unorm,\n    ETC2RGB8UnormSrgb = WGPUTextureFormat_ETC2RGB8UnormSrgb,\n    ETC2RGB8A1Unorm = WGPUTextureFormat_ETC2RGB8A1Unorm,\n    ETC2RGB8A1UnormSrgb = WGPUTextureFormat_ETC2RGB8A1UnormSrgb,\n    ETC2RGBA8Unorm = WGPUTextureFormat_ETC2RGBA8Unorm,\n    ETC2RGBA8UnormSrgb = WGPUTextureFormat_ETC2RGBA8UnormSrgb,\n    EACR11Unorm = WGPUTextureFormat_EACR11Unorm,\n    EACR11Snorm = WGPUTextureFormat_EACR11Snorm,\n    EACRG11Unorm = WGPUTextureFormat_EACRG11Unorm,\n    EACRG11Snorm = WGPUTextureFormat_EACRG11Snorm,\n    ASTC4x4Unorm = WGPUTextureFormat_ASTC4x4Unorm,\n    ASTC4x4UnormSrgb = WGPUTextureFormat_ASTC4x4UnormSrgb,\n    ASTC5x4Unorm = WGPUTextureFormat_ASTC5x4Unorm,\n    ASTC5x4UnormSrgb = WGPUTextureFormat_ASTC5x4UnormSrgb,\n    ASTC5x5Unorm = WGPUTextureFormat_ASTC5x5Unorm,\n    ASTC5x5UnormSrgb = WGPUTextureFormat_ASTC5x5UnormSrgb,\n    ASTC6x5Unorm = WGPUTextureFormat_ASTC6x5Unorm,\n    ASTC6x5UnormSrgb = WGPUTextureFormat_ASTC6x5UnormSrgb,\n    ASTC6x6Unorm = WGPUTextureFormat_ASTC6x6Unorm,\n    ASTC6x6UnormSrgb = WGPUTextureFormat_ASTC6x6UnormSrgb,\n    ASTC8x5Unorm = WGPUTextureFormat_ASTC8x5Unorm,\n    ASTC8x5UnormSrgb = WGPUTextureFormat_ASTC8x5UnormSrgb,\n    ASTC8x6Unorm = WGPUTextureFormat_ASTC8x6Unorm,\n    ASTC8x6UnormSrgb = WGPUTextureFormat_ASTC8x6UnormSrgb,\n    ASTC8x8Unorm = WGPUTextureFormat_ASTC8x8Unorm,\n    ASTC8x8UnormSrgb = WGPUTextureFormat_ASTC8x8UnormSrgb,\n    ASTC10x5Unorm = WGPUTextureFormat_ASTC10x5Unorm,\n    ASTC10x5UnormSrgb = WGPUTextureFormat_ASTC10x5UnormSrgb,\n    ASTC10x6Unorm = WGPUTextureFormat_ASTC10x6Unorm,\n    ASTC10x6UnormSrgb = WGPUTextureFormat_ASTC10x6UnormSrgb,\n    ASTC10x8Unorm = WGPUTextureFormat_ASTC10x8Unorm,\n    ASTC10x8UnormSrgb = WGPUTextureFormat_ASTC10x8UnormSrgb,\n    ASTC10x10Unorm = WGPUTextureFormat_ASTC10x10Unorm,\n    ASTC10x10UnormSrgb = WGPUTextureFormat_ASTC10x10UnormSrgb,\n    ASTC12x10Unorm = WGPUTextureFormat_ASTC12x10Unorm,\n    ASTC12x10UnormSrgb = WGPUTextureFormat_ASTC12x10UnormSrgb,\n    ASTC12x12Unorm = WGPUTextureFormat_ASTC12x12Unorm,\n    ASTC12x12UnormSrgb = WGPUTextureFormat_ASTC12x12UnormSrgb,\n    R16Unorm = WGPUTextureFormat_R16Unorm,\n    RG16Unorm = WGPUTextureFormat_RG16Unorm,\n    RGBA16Unorm = WGPUTextureFormat_RGBA16Unorm,\n    R16Snorm = WGPUTextureFormat_R16Snorm,\n    RG16Snorm = WGPUTextureFormat_RG16Snorm,\n    RGBA16Snorm = WGPUTextureFormat_RGBA16Snorm,\n    R8BG8Biplanar420Unorm = WGPUTextureFormat_R8BG8Biplanar420Unorm,\n    R10X6BG10X6Biplanar420Unorm = WGPUTextureFormat_R10X6BG10X6Biplanar420Unorm,\n    R8BG8A8Triplanar420Unorm = WGPUTextureFormat_R8BG8A8Triplanar420Unorm,\n    R8BG8Biplanar422Unorm = WGPUTextureFormat_R8BG8Biplanar422Unorm,\n    R8BG8Biplanar444Unorm = WGPUTextureFormat_R8BG8Biplanar444Unorm,\n    R10X6BG10X6Biplanar422Unorm = WGPUTextureFormat_R10X6BG10X6Biplanar422Unorm,\n    R10X6BG10X6Biplanar444Unorm = WGPUTextureFormat_R10X6BG10X6Biplanar444Unorm,\n    External = WGPUTextureFormat_External,\n};\nstatic_assert(sizeof(TextureFormat) == sizeof(WGPUTextureFormat), \"sizeof mismatch for TextureFormat\");\nstatic_assert(alignof(TextureFormat) == alignof(WGPUTextureFormat), \"alignof mismatch for TextureFormat\");\n\nenum class TextureSampleType : uint32_t {\n    BindingNotUsed = WGPUTextureSampleType_BindingNotUsed,\n    Float = WGPUTextureSampleType_Float,\n    UnfilterableFloat = WGPUTextureSampleType_UnfilterableFloat,\n    Depth = WGPUTextureSampleType_Depth,\n    Sint = WGPUTextureSampleType_Sint,\n    Uint = WGPUTextureSampleType_Uint,\n};\nstatic_assert(sizeof(TextureSampleType) == sizeof(WGPUTextureSampleType), \"sizeof mismatch for TextureSampleType\");\nstatic_assert(alignof(TextureSampleType) == alignof(WGPUTextureSampleType), \"alignof mismatch for TextureSampleType\");\n\nenum class TextureViewDimension : uint32_t {\n    Undefined = WGPUTextureViewDimension_Undefined,\n    e1D = WGPUTextureViewDimension_1D,\n    e2D = WGPUTextureViewDimension_2D,\n    e2DArray = WGPUTextureViewDimension_2DArray,\n    Cube = WGPUTextureViewDimension_Cube,\n    CubeArray = WGPUTextureViewDimension_CubeArray,\n    e3D = WGPUTextureViewDimension_3D,\n};\nstatic_assert(sizeof(TextureViewDimension) == sizeof(WGPUTextureViewDimension), \"sizeof mismatch for TextureViewDimension\");\nstatic_assert(alignof(TextureViewDimension) == alignof(WGPUTextureViewDimension), \"alignof mismatch for TextureViewDimension\");\n\nenum class VertexFormat : uint32_t {\n    Uint8 = WGPUVertexFormat_Uint8,\n    Uint8x2 = WGPUVertexFormat_Uint8x2,\n    Uint8x4 = WGPUVertexFormat_Uint8x4,\n    Sint8 = WGPUVertexFormat_Sint8,\n    Sint8x2 = WGPUVertexFormat_Sint8x2,\n    Sint8x4 = WGPUVertexFormat_Sint8x4,\n    Unorm8 = WGPUVertexFormat_Unorm8,\n    Unorm8x2 = WGPUVertexFormat_Unorm8x2,\n    Unorm8x4 = WGPUVertexFormat_Unorm8x4,\n    Snorm8 = WGPUVertexFormat_Snorm8,\n    Snorm8x2 = WGPUVertexFormat_Snorm8x2,\n    Snorm8x4 = WGPUVertexFormat_Snorm8x4,\n    Uint16 = WGPUVertexFormat_Uint16,\n    Uint16x2 = WGPUVertexFormat_Uint16x2,\n    Uint16x4 = WGPUVertexFormat_Uint16x4,\n    Sint16 = WGPUVertexFormat_Sint16,\n    Sint16x2 = WGPUVertexFormat_Sint16x2,\n    Sint16x4 = WGPUVertexFormat_Sint16x4,\n    Unorm16 = WGPUVertexFormat_Unorm16,\n    Unorm16x2 = WGPUVertexFormat_Unorm16x2,\n    Unorm16x4 = WGPUVertexFormat_Unorm16x4,\n    Snorm16 = WGPUVertexFormat_Snorm16,\n    Snorm16x2 = WGPUVertexFormat_Snorm16x2,\n    Snorm16x4 = WGPUVertexFormat_Snorm16x4,\n    Float16 = WGPUVertexFormat_Float16,\n    Float16x2 = WGPUVertexFormat_Float16x2,\n    Float16x4 = WGPUVertexFormat_Float16x4,\n    Float32 = WGPUVertexFormat_Float32,\n    Float32x2 = WGPUVertexFormat_Float32x2,\n    Float32x3 = WGPUVertexFormat_Float32x3,\n    Float32x4 = WGPUVertexFormat_Float32x4,\n    Uint32 = WGPUVertexFormat_Uint32,\n    Uint32x2 = WGPUVertexFormat_Uint32x2,\n    Uint32x3 = WGPUVertexFormat_Uint32x3,\n    Uint32x4 = WGPUVertexFormat_Uint32x4,\n    Sint32 = WGPUVertexFormat_Sint32,\n    Sint32x2 = WGPUVertexFormat_Sint32x2,\n    Sint32x3 = WGPUVertexFormat_Sint32x3,\n    Sint32x4 = WGPUVertexFormat_Sint32x4,\n    Unorm10_10_10_2 = WGPUVertexFormat_Unorm10_10_10_2,\n    Unorm8x4BGRA = WGPUVertexFormat_Unorm8x4BGRA,\n};\nstatic_assert(sizeof(VertexFormat) == sizeof(WGPUVertexFormat), \"sizeof mismatch for VertexFormat\");\nstatic_assert(alignof(VertexFormat) == alignof(WGPUVertexFormat), \"alignof mismatch for VertexFormat\");\n\nenum class VertexStepMode : uint32_t {\n    VertexBufferNotUsed = WGPUVertexStepMode_VertexBufferNotUsed,\n    Undefined = WGPUVertexStepMode_Undefined,\n    Vertex = WGPUVertexStepMode_Vertex,\n    Instance = WGPUVertexStepMode_Instance,\n};\nstatic_assert(sizeof(VertexStepMode) == sizeof(WGPUVertexStepMode), \"sizeof mismatch for VertexStepMode\");\nstatic_assert(alignof(VertexStepMode) == alignof(WGPUVertexStepMode), \"alignof mismatch for VertexStepMode\");\n\nenum class WaitStatus : uint32_t {\n    Success = WGPUWaitStatus_Success,\n    TimedOut = WGPUWaitStatus_TimedOut,\n    UnsupportedTimeout = WGPUWaitStatus_UnsupportedTimeout,\n    UnsupportedCount = WGPUWaitStatus_UnsupportedCount,\n    UnsupportedMixedSources = WGPUWaitStatus_UnsupportedMixedSources,\n    Unknown = WGPUWaitStatus_Unknown,\n};\nstatic_assert(sizeof(WaitStatus) == sizeof(WGPUWaitStatus), \"sizeof mismatch for WaitStatus\");\nstatic_assert(alignof(WaitStatus) == alignof(WGPUWaitStatus), \"alignof mismatch for WaitStatus\");\n\n\nenum class BufferUsage : uint64_t {\n    None = WGPUBufferUsage_None,\n    MapRead = WGPUBufferUsage_MapRead,\n    MapWrite = WGPUBufferUsage_MapWrite,\n    CopySrc = WGPUBufferUsage_CopySrc,\n    CopyDst = WGPUBufferUsage_CopyDst,\n    Index = WGPUBufferUsage_Index,\n    Vertex = WGPUBufferUsage_Vertex,\n    Uniform = WGPUBufferUsage_Uniform,\n    Storage = WGPUBufferUsage_Storage,\n    Indirect = WGPUBufferUsage_Indirect,\n    QueryResolve = WGPUBufferUsage_QueryResolve,\n};\nstatic_assert(sizeof(BufferUsage) == sizeof(WGPUBufferUsage), \"sizeof mismatch for BufferUsage\");\nstatic_assert(alignof(BufferUsage) == alignof(WGPUBufferUsage), \"alignof mismatch for BufferUsage\");\n\nenum class ColorWriteMask : uint64_t {\n    None = WGPUColorWriteMask_None,\n    Red = WGPUColorWriteMask_Red,\n    Green = WGPUColorWriteMask_Green,\n    Blue = WGPUColorWriteMask_Blue,\n    Alpha = WGPUColorWriteMask_Alpha,\n    All = WGPUColorWriteMask_All,\n};\nstatic_assert(sizeof(ColorWriteMask) == sizeof(WGPUColorWriteMask), \"sizeof mismatch for ColorWriteMask\");\nstatic_assert(alignof(ColorWriteMask) == alignof(WGPUColorWriteMask), \"alignof mismatch for ColorWriteMask\");\n\nenum class HeapProperty : uint64_t {\n    DeviceLocal = WGPUHeapProperty_DeviceLocal,\n    HostVisible = WGPUHeapProperty_HostVisible,\n    HostCoherent = WGPUHeapProperty_HostCoherent,\n    HostUncached = WGPUHeapProperty_HostUncached,\n    HostCached = WGPUHeapProperty_HostCached,\n};\nstatic_assert(sizeof(HeapProperty) == sizeof(WGPUHeapProperty), \"sizeof mismatch for HeapProperty\");\nstatic_assert(alignof(HeapProperty) == alignof(WGPUHeapProperty), \"alignof mismatch for HeapProperty\");\n\nenum class MapMode : uint64_t {\n    None = WGPUMapMode_None,\n    Read = WGPUMapMode_Read,\n    Write = WGPUMapMode_Write,\n};\nstatic_assert(sizeof(MapMode) == sizeof(WGPUMapMode), \"sizeof mismatch for MapMode\");\nstatic_assert(alignof(MapMode) == alignof(WGPUMapMode), \"alignof mismatch for MapMode\");\n\nenum class ShaderStage : uint64_t {\n    None = WGPUShaderStage_None,\n    Vertex = WGPUShaderStage_Vertex,\n    Fragment = WGPUShaderStage_Fragment,\n    Compute = WGPUShaderStage_Compute,\n};\nstatic_assert(sizeof(ShaderStage) == sizeof(WGPUShaderStage), \"sizeof mismatch for ShaderStage\");\nstatic_assert(alignof(ShaderStage) == alignof(WGPUShaderStage), \"alignof mismatch for ShaderStage\");\n\nenum class TextureUsage : uint64_t {\n    None = WGPUTextureUsage_None,\n    CopySrc = WGPUTextureUsage_CopySrc,\n    CopyDst = WGPUTextureUsage_CopyDst,\n    TextureBinding = WGPUTextureUsage_TextureBinding,\n    StorageBinding = WGPUTextureUsage_StorageBinding,\n    RenderAttachment = WGPUTextureUsage_RenderAttachment,\n    TransientAttachment = WGPUTextureUsage_TransientAttachment,\n    StorageAttachment = WGPUTextureUsage_StorageAttachment,\n};\nstatic_assert(sizeof(TextureUsage) == sizeof(WGPUTextureUsage), \"sizeof mismatch for TextureUsage\");\nstatic_assert(alignof(TextureUsage) == alignof(WGPUTextureUsage), \"alignof mismatch for TextureUsage\");\n\n\n// TODO(crbug.com/42241461): Update these to not be using the C callback types, and instead be\n// defined using C++ types instead. Note that when we remove these, the C++ callback info types\n// should also all be removed as they will no longer be necessary given the C++ templated\n// functions calls and setter utilities.\nusing BufferMapCallback = WGPUBufferMapCallback;\nusing Callback = WGPUCallback;\nusing CompilationInfoCallback = WGPUCompilationInfoCallback;\nusing CreateComputePipelineAsyncCallback = WGPUCreateComputePipelineAsyncCallback;\nusing CreateRenderPipelineAsyncCallback = WGPUCreateRenderPipelineAsyncCallback;\nusing DawnLoadCacheDataFunction = WGPUDawnLoadCacheDataFunction;\nusing DawnStoreCacheDataFunction = WGPUDawnStoreCacheDataFunction;\nusing DeviceLostCallback = WGPUDeviceLostCallback;\nusing DeviceLostCallbackNew = WGPUDeviceLostCallbackNew;\nusing ErrorCallback = WGPUErrorCallback;\nusing LoggingCallback = WGPULoggingCallback;\nusing PopErrorScopeCallback = WGPUPopErrorScopeCallback;\nusing Proc = WGPUProc;\nusing QueueWorkDoneCallback = WGPUQueueWorkDoneCallback;\nusing RequestAdapterCallback = WGPURequestAdapterCallback;\nusing RequestDeviceCallback = WGPURequestDeviceCallback;\n\n// Special class for booleans in order to allow implicit conversions.\nclass Bool {\n  public:\n    constexpr Bool() = default;\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr Bool(bool value) : mValue(static_cast<WGPUBool>(value)) {}\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    Bool(WGPUBool value): mValue(value) {}\n\n    constexpr operator bool() const { return static_cast<bool>(mValue); }\n\n  private:\n    friend struct std::hash<Bool>;\n    // Default to false.\n    WGPUBool mValue = static_cast<WGPUBool>(false);\n};\n\n// Special class for optional booleans in order to allow conversions.\nclass OptionalBool {\n  public:\n    constexpr OptionalBool() = default;\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr OptionalBool(bool value) : mValue(static_cast<WGPUOptionalBool>(value)) {}\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr OptionalBool(std::optional<bool> value) :\n        mValue(value ? static_cast<WGPUOptionalBool>(*value) : WGPUOptionalBool_Undefined) {}\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr OptionalBool(WGPUOptionalBool value): mValue(value) {}\n\n    // Define the values that are equivalent to the enums.\n    static const OptionalBool False;\n    static const OptionalBool True;\n    static const OptionalBool Undefined;\n\n    // Assignment operators.\n    OptionalBool& operator=(const bool& value) {\n        mValue = static_cast<WGPUOptionalBool>(value);\n        return *this;\n    }\n    OptionalBool& operator=(const std::optional<bool>& value) {\n        mValue = value ? static_cast<WGPUOptionalBool>(*value) : WGPUOptionalBool_Undefined;\n        return *this;\n    }\n    OptionalBool& operator=(const WGPUOptionalBool& value) {\n        mValue = value;\n        return *this;\n    }\n\n    // Conversion functions.\n    operator WGPUOptionalBool() const { return mValue; }\n    operator std::optional<bool>() const {\n        if (mValue == WGPUOptionalBool_Undefined) {\n            return std::nullopt;\n        }\n        return static_cast<bool>(mValue);\n    }\n\n    // Comparison functions.\n    friend bool operator==(const OptionalBool& lhs, const OptionalBool& rhs) {\n        return lhs.mValue == rhs.mValue;\n    }\n    friend bool operator!=(const OptionalBool& lhs, const OptionalBool& rhs) {\n        return lhs.mValue != rhs.mValue;\n    }\n\n  private:\n    friend struct std::hash<OptionalBool>;\n    // Default to undefined.\n    WGPUOptionalBool mValue = WGPUOptionalBool_Undefined;\n};\ninline const OptionalBool OptionalBool::False = OptionalBool(WGPUOptionalBool_False);\ninline const OptionalBool OptionalBool::True = OptionalBool(WGPUOptionalBool_True);\ninline const OptionalBool OptionalBool::Undefined = OptionalBool(WGPUOptionalBool_Undefined);\n\n// Helper class to wrap Status which allows implicit conversion to bool.\n// Used while callers switch to checking the Status enum instead of booleans.\n// TODO(crbug.com/42241199): Remove when all callers check the enum.\nstruct ConvertibleStatus {\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr ConvertibleStatus(Status status) : status(status) {}\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit conversion\n    constexpr operator bool() const {\n        return status == Status::Success;\n    }\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit conversion\n    constexpr operator Status() const {\n        return status;\n    }\n    Status status;\n};\n\ntemplate<typename Derived, typename CType>\nclass ObjectBase {\n  public:\n    ObjectBase() = default;\n    ObjectBase(CType handle): mHandle(handle) {\n        if (mHandle) Derived::WGPUAddRef(mHandle);\n    }\n    ~ObjectBase() {\n        if (mHandle) Derived::WGPURelease(mHandle);\n    }\n\n    ObjectBase(ObjectBase const& other)\n        : ObjectBase(other.Get()) {\n    }\n    Derived& operator=(ObjectBase const& other) {\n        if (&other != this) {\n            if (mHandle) Derived::WGPURelease(mHandle);\n            mHandle = other.mHandle;\n            if (mHandle) Derived::WGPUAddRef(mHandle);\n        }\n\n        return static_cast<Derived&>(*this);\n    }\n\n    ObjectBase(ObjectBase&& other) {\n        mHandle = other.mHandle;\n        other.mHandle = 0;\n    }\n    Derived& operator=(ObjectBase&& other) {\n        if (&other != this) {\n            if (mHandle) Derived::WGPURelease(mHandle);\n            mHandle = other.mHandle;\n            other.mHandle = 0;\n        }\n\n        return static_cast<Derived&>(*this);\n    }\n\n    ObjectBase(std::nullptr_t) {}\n    Derived& operator=(std::nullptr_t) {\n        if (mHandle != nullptr) {\n            Derived::WGPURelease(mHandle);\n            mHandle = nullptr;\n        }\n        return static_cast<Derived&>(*this);\n    }\n\n    bool operator==(std::nullptr_t) const {\n        return mHandle == nullptr;\n    }\n    bool operator!=(std::nullptr_t) const {\n        return mHandle != nullptr;\n    }\n\n    explicit operator bool() const {\n        return mHandle != nullptr;\n    }\n    CType Get() const {\n        return mHandle;\n    }\n    CType MoveToCHandle() {\n        CType result = mHandle;\n        mHandle = 0;\n        return result;\n    }\n    static Derived Acquire(CType handle) {\n        Derived result;\n        result.mHandle = handle;\n        return result;\n    }\n\n  protected:\n    CType mHandle = nullptr;\n};\n\n\n\n\n\n\nclass Adapter;\nclass BindGroup;\nclass BindGroupLayout;\nclass Buffer;\nclass CommandBuffer;\nclass CommandEncoder;\nclass ComputePassEncoder;\nclass ComputePipeline;\nclass Device;\nclass ExternalTexture;\nclass Instance;\nclass PipelineLayout;\nclass QuerySet;\nclass Queue;\nclass RenderBundle;\nclass RenderBundleEncoder;\nclass RenderPassEncoder;\nclass RenderPipeline;\nclass Sampler;\nclass ShaderModule;\nclass SharedBufferMemory;\nclass SharedFence;\nclass SharedTextureMemory;\nclass Surface;\nclass Texture;\nclass TextureView;\n\nstruct INTERNAL__HAVE_EMDAWNWEBGPU_HEADER;\nstruct AdapterPropertiesD3D;\nstruct AdapterPropertiesSubgroups;\nstruct AdapterPropertiesVk;\nstruct BindGroupEntry;\nstruct BlendComponent;\nstruct BufferBindingLayout;\nstruct BufferHostMappedPointer;\nstruct BufferMapCallbackInfo;\nstruct Color;\nstruct ColorTargetStateExpandResolveTextureDawn;\nstruct CompilationInfoCallbackInfo;\nstruct ComputePassTimestampWrites;\nstruct CopyTextureForBrowserOptions;\nstruct CreateComputePipelineAsyncCallbackInfo;\nstruct CreateRenderPipelineAsyncCallbackInfo;\nstruct DawnWGSLBlocklist;\nstruct DawnAdapterPropertiesPowerPreference;\nstruct DawnBufferDescriptorErrorInfoFromWireClient;\nstruct DawnEncoderInternalUsageDescriptor;\nstruct DawnExperimentalImmediateDataLimits;\nstruct DawnExperimentalSubgroupLimits;\nstruct DawnRenderPassColorAttachmentRenderToSingleSampled;\nstruct DawnShaderModuleSPIRVOptionsDescriptor;\nstruct DawnTexelCopyBufferRowAlignmentLimits;\nstruct DawnTextureInternalUsageDescriptor;\nstruct DawnTogglesDescriptor;\nstruct DawnWireWGSLControl;\nstruct DeviceLostCallbackInfo;\nstruct DrmFormatProperties;\nstruct Extent2D;\nstruct Extent3D;\nstruct ExternalTextureBindingEntry;\nstruct ExternalTextureBindingLayout;\nstruct FormatCapabilities;\nstruct Future;\nstruct InstanceFeatures;\nstruct Limits;\nstruct MemoryHeapInfo;\nstruct MultisampleState;\nstruct Origin2D;\nstruct Origin3D;\nstruct PipelineLayoutStorageAttachment;\nstruct PopErrorScopeCallbackInfo;\nstruct PrimitiveState;\nstruct QueueWorkDoneCallbackInfo;\nstruct RenderPassDepthStencilAttachment;\nstruct RenderPassDescriptorExpandResolveRect;\nstruct RenderPassMaxDrawCount;\nstruct RenderPassTimestampWrites;\nstruct RequestAdapterCallbackInfo;\nstruct RequestAdapterOptions;\nstruct RequestDeviceCallbackInfo;\nstruct SamplerBindingLayout;\nstruct ShaderModuleCompilationOptions;\nstruct ShaderSourceSPIRV;\nstruct SharedBufferMemoryBeginAccessDescriptor;\nstruct SharedBufferMemoryEndAccessState;\nstruct SharedBufferMemoryProperties;\nstruct SharedFenceDXGISharedHandleDescriptor;\nstruct SharedFenceDXGISharedHandleExportInfo;\nstruct SharedFenceMTLSharedEventDescriptor;\nstruct SharedFenceMTLSharedEventExportInfo;\nstruct SharedFenceExportInfo;\nstruct SharedFenceSyncFDDescriptor;\nstruct SharedFenceSyncFDExportInfo;\nstruct SharedFenceVkSemaphoreOpaqueFDDescriptor;\nstruct SharedFenceVkSemaphoreOpaqueFDExportInfo;\nstruct SharedFenceVkSemaphoreZirconHandleDescriptor;\nstruct SharedFenceVkSemaphoreZirconHandleExportInfo;\nstruct SharedTextureMemoryD3DSwapchainBeginState;\nstruct SharedTextureMemoryDXGISharedHandleDescriptor;\nstruct SharedTextureMemoryEGLImageDescriptor;\nstruct SharedTextureMemoryIOSurfaceDescriptor;\nstruct SharedTextureMemoryAHardwareBufferDescriptor;\nstruct SharedTextureMemoryBeginAccessDescriptor;\nstruct SharedTextureMemoryDmaBufPlane;\nstruct SharedTextureMemoryEndAccessState;\nstruct SharedTextureMemoryOpaqueFDDescriptor;\nstruct SharedTextureMemoryVkDedicatedAllocationDescriptor;\nstruct SharedTextureMemoryVkImageLayoutBeginState;\nstruct SharedTextureMemoryVkImageLayoutEndState;\nstruct SharedTextureMemoryZirconHandleDescriptor;\nstruct StaticSamplerBindingLayout;\nstruct StencilFaceState;\nstruct StorageTextureBindingLayout;\nstruct StringView;\nstruct SupportedFeatures;\nstruct SurfaceCapabilities;\nstruct SurfaceConfiguration;\nstruct SurfaceDescriptorFromWindowsCoreWindow;\nstruct SurfaceDescriptorFromWindowsSwapChainPanel;\nstruct SurfaceSourceXCBWindow;\nstruct SurfaceSourceAndroidNativeWindow;\nstruct SurfaceSourceMetalLayer;\nstruct SurfaceSourceWaylandSurface;\nstruct SurfaceSourceWindowsHWND;\nstruct SurfaceSourceXlibWindow;\nstruct SurfaceTexture;\nstruct TextureBindingLayout;\nstruct TextureBindingViewDimensionDescriptor;\nstruct TextureDataLayout;\nstruct UncapturedErrorCallbackInfo;\nstruct VertexAttribute;\nstruct YCbCrVkDescriptor;\nstruct AHardwareBufferProperties;\nstruct AdapterInfo;\nstruct AdapterPropertiesMemoryHeaps;\nstruct BindGroupDescriptor;\nstruct BindGroupLayoutEntry;\nstruct BlendState;\nstruct BufferDescriptor;\nstruct CommandBufferDescriptor;\nstruct CommandEncoderDescriptor;\nstruct CompilationMessage;\nstruct ComputePassDescriptor;\nstruct ConstantEntry;\nstruct DawnCacheDeviceDescriptor;\nstruct DepthStencilState;\nstruct DrmFormatCapabilities;\nstruct ExternalTextureDescriptor;\nstruct FutureWaitInfo;\nstruct ImageCopyBuffer;\nstruct ImageCopyExternalTexture;\nstruct ImageCopyTexture;\nstruct InstanceDescriptor;\nstruct PipelineLayoutDescriptor;\nstruct PipelineLayoutPixelLocalStorage;\nstruct QuerySetDescriptor;\nstruct QueueDescriptor;\nstruct RenderBundleDescriptor;\nstruct RenderBundleEncoderDescriptor;\nstruct RenderPassColorAttachment;\nstruct RenderPassStorageAttachment;\nstruct RequiredLimits;\nstruct SamplerDescriptor;\nstruct ShaderModuleDescriptor;\nstruct ShaderSourceWGSL;\nstruct SharedBufferMemoryDescriptor;\nstruct SharedFenceDescriptor;\nstruct SharedTextureMemoryAHardwareBufferProperties;\nstruct SharedTextureMemoryDescriptor;\nstruct SharedTextureMemoryDmaBufDescriptor;\nstruct SharedTextureMemoryProperties;\nstruct SupportedLimits;\nstruct SurfaceDescriptor;\nstruct SurfaceSourceCanvasHTMLSelector_Emscripten;\nstruct TextureDescriptor;\nstruct TextureViewDescriptor;\nstruct VertexBufferLayout;\nstruct BindGroupLayoutDescriptor;\nstruct ColorTargetState;\nstruct CompilationInfo;\nstruct ComputeState;\nstruct DeviceDescriptor;\nstruct RenderPassDescriptor;\nstruct RenderPassPixelLocalStorage;\nstruct VertexState;\nstruct ComputePipelineDescriptor;\nstruct FragmentState;\nstruct RenderPipelineDescriptor;\n\n// TODO(42241188): Remove once all clients use StringView versions of the callbacks.\n// To make MSVC happy we need a StringView constructor from the adapter, so we first need to\n// forward declare StringViewAdapter here. Otherwise MSVC complains about an ambiguous conversion.\nnamespace detail {\n    struct StringViewAdapter;\n}  // namespace detail\n\nstruct StringView {\n    char const * data = nullptr;\n    size_t length = WGPU_STRLEN;\n\n    inline constexpr StringView() noexcept = default;\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(const std::string_view& sv) noexcept {\n        this->data = sv.data();\n        this->length = sv.length();\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(const char* s) {\n        this->data = s;\n        this->length = WGPU_STRLEN;  // use strlen\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(WGPUStringView s) {\n        this->data = s.data;\n        this->length = s.length;\n    }\n\n    inline constexpr StringView(const char* data, size_t length) {\n        this->data = data;\n        this->length = length;\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(std::nullptr_t) {\n        this->data = nullptr;\n        this->length = WGPU_STRLEN;\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(std::nullopt_t) {\n        this->data = nullptr;\n        this->length = WGPU_STRLEN;\n    }\n\n    bool IsUndefined() const {\n        return this->data == nullptr && this->length == wgpu::kStrlen;\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit conversion\n    operator std::string_view() const {\n        if (this->length == wgpu::kStrlen) {\n            if (IsUndefined()) {\n                return {};\n            }\n            return {this->data};\n        }\n        return {this->data, this->length};\n    }\n\n    template <typename View,\n              typename = std::enable_if_t<std::is_constructible_v<View, const char*, size_t>>>\n    explicit operator View() const {\n        if (this->length == wgpu::kStrlen) {\n            if (IsUndefined()) {\n                return {};\n            }\n            return {this->data};\n        }\n        return {this->data, this->length};\n    }\n\n\n    StringView(const detail::StringViewAdapter& s);\n};\n\nnamespace detail {\nconstexpr size_t ConstexprMax(size_t a, size_t b) {\n    return a > b ? a : b;\n}\n\ntemplate <typename T>\nstatic T& AsNonConstReference(const T& value) {\n    return const_cast<T&>(value);\n}\n\n// A wrapper around StringView that can be implicitly converted to const char* with temporary\n// storage that adds the \\0 for output strings that are all explicitly-sized.\n// TODO(42241188): Remove once all clients use StringView versions of the callbacks.\nstruct StringViewAdapter {\n    WGPUStringView sv;\n    char* nullTerminated = nullptr;\n\n    StringViewAdapter(WGPUStringView sv) : sv(sv) {}\n    ~StringViewAdapter() { delete[] nullTerminated; }\n    operator ::WGPUStringView() { return sv; }\n    operator StringView() { return {sv.data, sv.length}; }\n    operator const char*() {\n        assert(sv.length != WGPU_STRLEN);\n        assert(nullTerminated == nullptr);\n        nullTerminated = new char[sv.length + 1];\n        for (size_t i = 0; i < sv.length; i++) {\n            nullTerminated[i] = sv.data[i];\n        }\n        nullTerminated[sv.length] = 0;\n        return nullTerminated;\n    }\n};\n}  // namespace detail\n\ninline StringView::StringView(const detail::StringViewAdapter& s): data(s.sv.data), length(s.sv.length) {}\n\nnamespace detail {\n// For callbacks, we support two modes:\n//   1) No userdata where we allow a std::function type that can include argument captures.\n//   2) Explicit typed userdata where we only allow non-capturing lambdas or function pointers.\ntemplate <typename... Args>\nstruct CallbackTypeBase;\ntemplate <typename... Args>\nstruct CallbackTypeBase<std::tuple<Args...>> {\n    using Callback = std::function<void(Args...)>;\n};\ntemplate <typename... Args>\nstruct CallbackTypeBase<std::tuple<Args...>, void> {\n    using Callback = void (Args...);\n};\ntemplate <typename... Args, typename T>\nstruct CallbackTypeBase<std::tuple<Args...>, T> {\n    using Callback = void (Args..., T);\n};\n}  // namespace detail\n\n\ntemplate <typename... T>\nusing BufferMapCallback2 = typename detail::CallbackTypeBase<std::tuple<MapAsyncStatus , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing CompilationInfoCallback2 = typename detail::CallbackTypeBase<std::tuple<CompilationInfoRequestStatus , CompilationInfo const * >, T...>::Callback;\ntemplate <typename... T>\nusing CreateComputePipelineAsyncCallback2 = typename detail::CallbackTypeBase<std::tuple<CreatePipelineAsyncStatus , ComputePipeline , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing CreateRenderPipelineAsyncCallback2 = typename detail::CallbackTypeBase<std::tuple<CreatePipelineAsyncStatus , RenderPipeline , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing PopErrorScopeCallback2 = typename detail::CallbackTypeBase<std::tuple<PopErrorScopeStatus , ErrorType , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing QueueWorkDoneCallback2 = typename detail::CallbackTypeBase<std::tuple<QueueWorkDoneStatus >, T...>::Callback;\ntemplate <typename... T>\nusing RequestAdapterCallback2 = typename detail::CallbackTypeBase<std::tuple<RequestAdapterStatus , Adapter , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing RequestDeviceCallback2 = typename detail::CallbackTypeBase<std::tuple<RequestDeviceStatus , Device , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing DeviceLostCallback2 = typename detail::CallbackTypeBase<std::tuple<const Device&, DeviceLostReason, StringView>, T...>::Callback;\ntemplate <typename... T>\nusing UncapturedErrorCallback = typename detail::CallbackTypeBase<std::tuple<const Device&, ErrorType, StringView>, T...>::Callback;\n\n\n\n\nclass Adapter : public ObjectBase<Adapter, WGPUAdapter> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline Device CreateDevice(DeviceDescriptor const * descriptor = nullptr) const;\n    inline void GetFeatures(SupportedFeatures * features) const;\n    inline ConvertibleStatus GetFormatCapabilities(TextureFormat format, FormatCapabilities * capabilities) const;\n    inline ConvertibleStatus GetInfo(AdapterInfo * info) const;\n    inline Instance GetInstance() const;\n    inline ConvertibleStatus GetLimits(SupportedLimits * limits) const;\n    inline Bool HasFeature(FeatureName feature) const;\n    inline void RequestDevice(DeviceDescriptor const * descriptor, RequestDeviceCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = RequestDeviceCallback2<T>,\n              typename CbChar = void (RequestDeviceStatus status, Device device, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future RequestDevice(DeviceDescriptor const * options, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = RequestDeviceCallback2<>,\n              typename CbChar = std::function<void(RequestDeviceStatus status, Device device, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future RequestDevice(DeviceDescriptor const * options, CallbackMode callbackMode, L callback) const;\n    inline Future RequestDevice(DeviceDescriptor const * options, RequestDeviceCallbackInfo callbackInfo) const;\n\n\n  private:\n    friend ObjectBase<Adapter, WGPUAdapter>;\n    static inline void WGPUAddRef(WGPUAdapter handle);\n    static inline void WGPURelease(WGPUAdapter handle);\n};\n\nclass BindGroup : public ObjectBase<BindGroup, WGPUBindGroup> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<BindGroup, WGPUBindGroup>;\n    static inline void WGPUAddRef(WGPUBindGroup handle);\n    static inline void WGPURelease(WGPUBindGroup handle);\n};\n\nclass BindGroupLayout : public ObjectBase<BindGroupLayout, WGPUBindGroupLayout> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<BindGroupLayout, WGPUBindGroupLayout>;\n    static inline void WGPUAddRef(WGPUBindGroupLayout handle);\n    static inline void WGPURelease(WGPUBindGroupLayout handle);\n};\n\nclass Buffer : public ObjectBase<Buffer, WGPUBuffer> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Destroy() const;\n    inline void const * GetConstMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n    inline BufferMapState GetMapState() const;\n    inline void * GetMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n    inline uint64_t GetSize() const;\n    inline BufferUsage GetUsage() const;\n    inline void MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = BufferMapCallback2<T>,\n              typename CbChar = void (MapAsyncStatus status, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future MapAsync(MapMode mode, size_t offset, size_t size, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = BufferMapCallback2<>,\n              typename CbChar = std::function<void(MapAsyncStatus status, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future MapAsync(MapMode mode, size_t offset, size_t size, CallbackMode callbackMode, L callback) const;\n    inline Future MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallbackInfo callbackInfo) const;\n    inline void SetLabel(StringView label) const;\n    inline void Unmap() const;\n\n\n  private:\n    friend ObjectBase<Buffer, WGPUBuffer>;\n    static inline void WGPUAddRef(WGPUBuffer handle);\n    static inline void WGPURelease(WGPUBuffer handle);\n};\n\nclass CommandBuffer : public ObjectBase<CommandBuffer, WGPUCommandBuffer> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<CommandBuffer, WGPUCommandBuffer>;\n    static inline void WGPUAddRef(WGPUCommandBuffer handle);\n    static inline void WGPURelease(WGPUCommandBuffer handle);\n};\n\nclass CommandEncoder : public ObjectBase<CommandEncoder, WGPUCommandEncoder> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline ComputePassEncoder BeginComputePass(ComputePassDescriptor const * descriptor = nullptr) const;\n    inline RenderPassEncoder BeginRenderPass(RenderPassDescriptor const * descriptor) const;\n    inline void ClearBuffer(Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n    inline void CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const;\n    inline void CopyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n    inline void CopyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) const;\n    inline void CopyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n    inline CommandBuffer Finish(CommandBufferDescriptor const * descriptor = nullptr) const;\n    inline void InjectValidationError(StringView message) const;\n    inline void InsertDebugMarker(StringView markerLabel) const;\n    inline void PopDebugGroup() const;\n    inline void PushDebugGroup(StringView groupLabel) const;\n    inline void ResolveQuerySet(QuerySet const& querySet, uint32_t firstQuery, uint32_t queryCount, Buffer const& destination, uint64_t destinationOffset) const;\n    inline void SetLabel(StringView label) const;\n    inline void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) const;\n    inline void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n\n  private:\n    friend ObjectBase<CommandEncoder, WGPUCommandEncoder>;\n    static inline void WGPUAddRef(WGPUCommandEncoder handle);\n    static inline void WGPURelease(WGPUCommandEncoder handle);\n};\n\nclass ComputePassEncoder : public ObjectBase<ComputePassEncoder, WGPUComputePassEncoder> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void DispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY = 1, uint32_t workgroupCountZ = 1) const;\n    inline void DispatchWorkgroupsIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline void End() const;\n    inline void InsertDebugMarker(StringView markerLabel) const;\n    inline void PopDebugGroup() const;\n    inline void PushDebugGroup(StringView groupLabel) const;\n    inline void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n    inline void SetLabel(StringView label) const;\n    inline void SetPipeline(ComputePipeline const& pipeline) const;\n    inline void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n\n  private:\n    friend ObjectBase<ComputePassEncoder, WGPUComputePassEncoder>;\n    static inline void WGPUAddRef(WGPUComputePassEncoder handle);\n    static inline void WGPURelease(WGPUComputePassEncoder handle);\n};\n\nclass ComputePipeline : public ObjectBase<ComputePipeline, WGPUComputePipeline> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<ComputePipeline, WGPUComputePipeline>;\n    static inline void WGPUAddRef(WGPUComputePipeline handle);\n    static inline void WGPURelease(WGPUComputePipeline handle);\n};\n\nclass Device : public ObjectBase<Device, WGPUDevice> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline BindGroup CreateBindGroup(BindGroupDescriptor const * descriptor) const;\n    inline BindGroupLayout CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const;\n    inline Buffer CreateBuffer(BufferDescriptor const * descriptor) const;\n    inline CommandEncoder CreateCommandEncoder(CommandEncoderDescriptor const * descriptor = nullptr) const;\n    inline ComputePipeline CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const;\n    inline void CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = CreateComputePipelineAsyncCallback2<T>,\n              typename CbChar = void (CreatePipelineAsyncStatus status, ComputePipeline pipeline, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = CreateComputePipelineAsyncCallback2<>,\n              typename CbChar = std::function<void(CreatePipelineAsyncStatus status, ComputePipeline pipeline, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CallbackMode callbackMode, L callback) const;\n    inline Future CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallbackInfo callbackInfo) const;\n    inline Buffer CreateErrorBuffer(BufferDescriptor const * descriptor) const;\n    inline ExternalTexture CreateErrorExternalTexture() const;\n    inline ShaderModule CreateErrorShaderModule(ShaderModuleDescriptor const * descriptor, StringView errorMessage) const;\n    inline Texture CreateErrorTexture(TextureDescriptor const * descriptor) const;\n    inline ExternalTexture CreateExternalTexture(ExternalTextureDescriptor const * externalTextureDescriptor) const;\n    inline PipelineLayout CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const;\n    inline QuerySet CreateQuerySet(QuerySetDescriptor const * descriptor) const;\n    inline RenderBundleEncoder CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const;\n    inline RenderPipeline CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const;\n    inline void CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = CreateRenderPipelineAsyncCallback2<T>,\n              typename CbChar = void (CreatePipelineAsyncStatus status, RenderPipeline pipeline, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = CreateRenderPipelineAsyncCallback2<>,\n              typename CbChar = std::function<void(CreatePipelineAsyncStatus status, RenderPipeline pipeline, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CallbackMode callbackMode, L callback) const;\n    inline Future CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallbackInfo callbackInfo) const;\n    inline Sampler CreateSampler(SamplerDescriptor const * descriptor = nullptr) const;\n    inline ShaderModule CreateShaderModule(ShaderModuleDescriptor const * descriptor) const;\n    inline Texture CreateTexture(TextureDescriptor const * descriptor) const;\n    inline void Destroy() const;\n    inline void ForceLoss(DeviceLostReason type, StringView message) const;\n    inline ConvertibleStatus GetAHardwareBufferProperties(void * handle, AHardwareBufferProperties * properties) const;\n    inline Adapter GetAdapter() const;\n    inline ConvertibleStatus GetAdapterInfo(AdapterInfo * adapterInfo) const;\n    inline void GetFeatures(SupportedFeatures * features) const;\n    inline ConvertibleStatus GetLimits(SupportedLimits * limits) const;\n    inline Future GetLostFuture() const;\n    inline Queue GetQueue() const;\n    inline Bool HasFeature(FeatureName feature) const;\n    inline SharedBufferMemory ImportSharedBufferMemory(SharedBufferMemoryDescriptor const * descriptor) const;\n    inline SharedFence ImportSharedFence(SharedFenceDescriptor const * descriptor) const;\n    inline SharedTextureMemory ImportSharedTextureMemory(SharedTextureMemoryDescriptor const * descriptor) const;\n    inline void InjectError(ErrorType type, StringView message) const;\n    inline void PopErrorScope(ErrorCallback oldCallback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = PopErrorScopeCallback2<T>,\n              typename CbChar = void (PopErrorScopeStatus status, ErrorType type, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future PopErrorScope(CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = PopErrorScopeCallback2<>,\n              typename CbChar = std::function<void(PopErrorScopeStatus status, ErrorType type, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future PopErrorScope(CallbackMode callbackMode, L callback) const;\n    inline Future PopErrorScope(PopErrorScopeCallbackInfo callbackInfo) const;\n    inline void PushErrorScope(ErrorFilter filter) const;\n    inline void SetLabel(StringView label) const;\n    inline void SetLoggingCallback(LoggingCallback callback, void * userdata) const;\n    inline void Tick() const;\n    inline void ValidateTextureDescriptor(TextureDescriptor const * descriptor) const;\n\n\n  private:\n    friend ObjectBase<Device, WGPUDevice>;\n    static inline void WGPUAddRef(WGPUDevice handle);\n    static inline void WGPURelease(WGPUDevice handle);\n};\n\nclass ExternalTexture : public ObjectBase<ExternalTexture, WGPUExternalTexture> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Destroy() const;\n    inline void Expire() const;\n    inline void Refresh() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<ExternalTexture, WGPUExternalTexture>;\n    static inline void WGPUAddRef(WGPUExternalTexture handle);\n    static inline void WGPURelease(WGPUExternalTexture handle);\n};\n\nclass Instance : public ObjectBase<Instance, WGPUInstance> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline Surface CreateSurface(SurfaceDescriptor const * descriptor) const;\n    inline size_t EnumerateWGSLLanguageFeatures(WGSLFeatureName * features) const;\n    inline Bool HasWGSLLanguageFeature(WGSLFeatureName feature) const;\n    inline void ProcessEvents() const;\n    inline void RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = RequestAdapterCallback2<T>,\n              typename CbChar = void (RequestAdapterStatus status, Adapter adapter, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future RequestAdapter(RequestAdapterOptions const * options, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = RequestAdapterCallback2<>,\n              typename CbChar = std::function<void(RequestAdapterStatus status, Adapter adapter, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future RequestAdapter(RequestAdapterOptions const * options, CallbackMode callbackMode, L callback) const;\n    inline Future RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallbackInfo callbackInfo) const;\n    inline WaitStatus WaitAny(size_t futureCount, FutureWaitInfo * futures, uint64_t timeoutNS) const;\n\n    inline WaitStatus WaitAny(Future f, uint64_t timeout) const;\n\n  private:\n    friend ObjectBase<Instance, WGPUInstance>;\n    static inline void WGPUAddRef(WGPUInstance handle);\n    static inline void WGPURelease(WGPUInstance handle);\n};\n\nclass PipelineLayout : public ObjectBase<PipelineLayout, WGPUPipelineLayout> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<PipelineLayout, WGPUPipelineLayout>;\n    static inline void WGPUAddRef(WGPUPipelineLayout handle);\n    static inline void WGPURelease(WGPUPipelineLayout handle);\n};\n\nclass QuerySet : public ObjectBase<QuerySet, WGPUQuerySet> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Destroy() const;\n    inline uint32_t GetCount() const;\n    inline QueryType GetType() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<QuerySet, WGPUQuerySet>;\n    static inline void WGPUAddRef(WGPUQuerySet handle);\n    static inline void WGPURelease(WGPUQuerySet handle);\n};\n\nclass Queue : public ObjectBase<Queue, WGPUQueue> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void CopyExternalTextureForBrowser(ImageCopyExternalTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const;\n    inline void CopyTextureForBrowser(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const;\n    inline void OnSubmittedWorkDone(QueueWorkDoneCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = QueueWorkDoneCallback2<T>,\n              typename CbChar = void (QueueWorkDoneStatus status, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future OnSubmittedWorkDone(CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = QueueWorkDoneCallback2<>,\n              typename CbChar = std::function<void(QueueWorkDoneStatus status)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future OnSubmittedWorkDone(CallbackMode callbackMode, L callback) const;\n    inline Future OnSubmittedWorkDone(QueueWorkDoneCallbackInfo callbackInfo) const;\n    inline void SetLabel(StringView label) const;\n    inline void Submit(size_t commandCount, CommandBuffer const * commands) const;\n    inline void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const;\n    inline void WriteTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) const;\n\n\n  private:\n    friend ObjectBase<Queue, WGPUQueue>;\n    static inline void WGPUAddRef(WGPUQueue handle);\n    static inline void WGPURelease(WGPUQueue handle);\n};\n\nclass RenderBundle : public ObjectBase<RenderBundle, WGPURenderBundle> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<RenderBundle, WGPURenderBundle>;\n    static inline void WGPUAddRef(WGPURenderBundle handle);\n    static inline void WGPURelease(WGPURenderBundle handle);\n};\n\nclass RenderBundleEncoder : public ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n    inline void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n    inline void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline RenderBundle Finish(RenderBundleDescriptor const * descriptor = nullptr) const;\n    inline void InsertDebugMarker(StringView markerLabel) const;\n    inline void PopDebugGroup() const;\n    inline void PushDebugGroup(StringView groupLabel) const;\n    inline void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n    inline void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n    inline void SetLabel(StringView label) const;\n    inline void SetPipeline(RenderPipeline const& pipeline) const;\n    inline void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n\n\n  private:\n    friend ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder>;\n    static inline void WGPUAddRef(WGPURenderBundleEncoder handle);\n    static inline void WGPURelease(WGPURenderBundleEncoder handle);\n};\n\nclass RenderPassEncoder : public ObjectBase<RenderPassEncoder, WGPURenderPassEncoder> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void BeginOcclusionQuery(uint32_t queryIndex) const;\n    inline void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n    inline void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n    inline void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline void End() const;\n    inline void EndOcclusionQuery() const;\n    inline void ExecuteBundles(size_t bundleCount, RenderBundle const * bundles) const;\n    inline void InsertDebugMarker(StringView markerLabel) const;\n    inline void MultiDrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset, uint32_t maxDrawCount, Buffer const& drawCountBuffer, uint64_t drawCountBufferOffset = 0) const;\n    inline void MultiDrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset, uint32_t maxDrawCount, Buffer const& drawCountBuffer, uint64_t drawCountBufferOffset = 0) const;\n    inline void PixelLocalStorageBarrier() const;\n    inline void PopDebugGroup() const;\n    inline void PushDebugGroup(StringView groupLabel) const;\n    inline void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n    inline void SetBlendConstant(Color const * color) const;\n    inline void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n    inline void SetLabel(StringView label) const;\n    inline void SetPipeline(RenderPipeline const& pipeline) const;\n    inline void SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const;\n    inline void SetStencilReference(uint32_t reference) const;\n    inline void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n    inline void SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const;\n    inline void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n\n  private:\n    friend ObjectBase<RenderPassEncoder, WGPURenderPassEncoder>;\n    static inline void WGPUAddRef(WGPURenderPassEncoder handle);\n    static inline void WGPURelease(WGPURenderPassEncoder handle);\n};\n\nclass RenderPipeline : public ObjectBase<RenderPipeline, WGPURenderPipeline> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<RenderPipeline, WGPURenderPipeline>;\n    static inline void WGPUAddRef(WGPURenderPipeline handle);\n    static inline void WGPURelease(WGPURenderPipeline handle);\n};\n\nclass Sampler : public ObjectBase<Sampler, WGPUSampler> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<Sampler, WGPUSampler>;\n    static inline void WGPUAddRef(WGPUSampler handle);\n    static inline void WGPURelease(WGPUSampler handle);\n};\n\nclass ShaderModule : public ObjectBase<ShaderModule, WGPUShaderModule> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void GetCompilationInfo(CompilationInfoCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = CompilationInfoCallback2<T>,\n              typename CbChar = void (CompilationInfoRequestStatus status, CompilationInfo const * compilationInfo, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future GetCompilationInfo(CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = CompilationInfoCallback2<>,\n              typename CbChar = std::function<void(CompilationInfoRequestStatus status, CompilationInfo const * compilationInfo)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future GetCompilationInfo(CallbackMode callbackMode, L callback) const;\n    inline Future GetCompilationInfo(CompilationInfoCallbackInfo callbackInfo) const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<ShaderModule, WGPUShaderModule>;\n    static inline void WGPUAddRef(WGPUShaderModule handle);\n    static inline void WGPURelease(WGPUShaderModule handle);\n};\n\nclass SharedBufferMemory : public ObjectBase<SharedBufferMemory, WGPUSharedBufferMemory> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline ConvertibleStatus BeginAccess(Buffer const& buffer, SharedBufferMemoryBeginAccessDescriptor const * descriptor) const;\n    inline Buffer CreateBuffer(BufferDescriptor const * descriptor = nullptr) const;\n    inline ConvertibleStatus EndAccess(Buffer const& buffer, SharedBufferMemoryEndAccessState * descriptor) const;\n    inline ConvertibleStatus GetProperties(SharedBufferMemoryProperties * properties) const;\n    inline Bool IsDeviceLost() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<SharedBufferMemory, WGPUSharedBufferMemory>;\n    static inline void WGPUAddRef(WGPUSharedBufferMemory handle);\n    static inline void WGPURelease(WGPUSharedBufferMemory handle);\n};\n\nclass SharedFence : public ObjectBase<SharedFence, WGPUSharedFence> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void ExportInfo(SharedFenceExportInfo * info) const;\n\n\n  private:\n    friend ObjectBase<SharedFence, WGPUSharedFence>;\n    static inline void WGPUAddRef(WGPUSharedFence handle);\n    static inline void WGPURelease(WGPUSharedFence handle);\n};\n\nclass SharedTextureMemory : public ObjectBase<SharedTextureMemory, WGPUSharedTextureMemory> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline ConvertibleStatus BeginAccess(Texture const& texture, SharedTextureMemoryBeginAccessDescriptor const * descriptor) const;\n    inline Texture CreateTexture(TextureDescriptor const * descriptor = nullptr) const;\n    inline ConvertibleStatus EndAccess(Texture const& texture, SharedTextureMemoryEndAccessState * descriptor) const;\n    inline ConvertibleStatus GetProperties(SharedTextureMemoryProperties * properties) const;\n    inline Bool IsDeviceLost() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<SharedTextureMemory, WGPUSharedTextureMemory>;\n    static inline void WGPUAddRef(WGPUSharedTextureMemory handle);\n    static inline void WGPURelease(WGPUSharedTextureMemory handle);\n};\n\nclass Surface : public ObjectBase<Surface, WGPUSurface> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Configure(SurfaceConfiguration const * config) const;\n    inline ConvertibleStatus GetCapabilities(Adapter const& adapter, SurfaceCapabilities * capabilities) const;\n    inline void GetCurrentTexture(SurfaceTexture * surfaceTexture) const;\n    inline void Present() const;\n    inline void SetLabel(StringView label) const;\n    inline void Unconfigure() const;\n\n\n  private:\n    friend ObjectBase<Surface, WGPUSurface>;\n    static inline void WGPUAddRef(WGPUSurface handle);\n    static inline void WGPURelease(WGPUSurface handle);\n};\n\nclass Texture : public ObjectBase<Texture, WGPUTexture> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline TextureView CreateErrorView(TextureViewDescriptor const * descriptor = nullptr) const;\n    inline TextureView CreateView(TextureViewDescriptor const * descriptor = nullptr) const;\n    inline void Destroy() const;\n    inline uint32_t GetDepthOrArrayLayers() const;\n    inline TextureDimension GetDimension() const;\n    inline TextureFormat GetFormat() const;\n    inline uint32_t GetHeight() const;\n    inline uint32_t GetMipLevelCount() const;\n    inline uint32_t GetSampleCount() const;\n    inline TextureUsage GetUsage() const;\n    inline uint32_t GetWidth() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<Texture, WGPUTexture>;\n    static inline void WGPUAddRef(WGPUTexture handle);\n    static inline void WGPURelease(WGPUTexture handle);\n};\n\nclass TextureView : public ObjectBase<TextureView, WGPUTextureView> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<TextureView, WGPUTextureView>;\n    static inline void WGPUAddRef(WGPUTextureView handle);\n    static inline void WGPURelease(WGPUTextureView handle);\n};\n\n\n// ChainedStruct\nstatic_assert(sizeof(ChainedStruct) == sizeof(WGPUChainedStruct),\n    \"sizeof mismatch for ChainedStruct\");\nstatic_assert(alignof(ChainedStruct) == alignof(WGPUChainedStruct),\n    \"alignof mismatch for ChainedStruct\");\nstatic_assert(offsetof(ChainedStruct, nextInChain) == offsetof(WGPUChainedStruct, next),\n    \"offsetof mismatch for ChainedStruct::nextInChain\");\nstatic_assert(offsetof(ChainedStruct, sType) == offsetof(WGPUChainedStruct, sType),\n    \"offsetof mismatch for ChainedStruct::sType\");\n\n\nstruct INTERNAL__HAVE_EMDAWNWEBGPU_HEADER {\n    inline operator const WGPUINTERNAL__HAVE_EMDAWNWEBGPU_HEADER&() const noexcept;\n\n    Bool unused = false;\n};\n\n// Can be chained in AdapterInfo\nstruct AdapterPropertiesD3D : ChainedStructOut {\n    inline AdapterPropertiesD3D();\n\n    struct Init;\n    inline AdapterPropertiesD3D(Init&& init);\n    inline operator const WGPUAdapterPropertiesD3D&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t shaderModel;\n};\n\n// Can be chained in AdapterInfo\nstruct AdapterPropertiesSubgroups : ChainedStructOut {\n    inline AdapterPropertiesSubgroups();\n\n    struct Init;\n    inline AdapterPropertiesSubgroups(Init&& init);\n    inline operator const WGPUAdapterPropertiesSubgroups&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t subgroupMinSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t subgroupMaxSize = WGPU_LIMIT_U32_UNDEFINED;\n};\n\n// Can be chained in AdapterInfo\nstruct AdapterPropertiesVk : ChainedStructOut {\n    inline AdapterPropertiesVk();\n\n    struct Init;\n    inline AdapterPropertiesVk(Init&& init);\n    inline operator const WGPUAdapterPropertiesVk&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t driverVersion;\n};\n\nstruct BindGroupEntry {\n    inline operator const WGPUBindGroupEntry&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint32_t binding;\n    Buffer buffer = nullptr;\n    uint64_t offset = 0;\n    uint64_t size = WGPU_WHOLE_SIZE;\n    Sampler sampler = nullptr;\n    TextureView textureView = nullptr;\n};\n\nstruct BlendComponent {\n    inline operator const WGPUBlendComponent&() const noexcept;\n\n    BlendOperation operation = BlendOperation::Add;\n    BlendFactor srcFactor = BlendFactor::One;\n    BlendFactor dstFactor = BlendFactor::Zero;\n};\n\nstruct BufferBindingLayout {\n    inline operator const WGPUBufferBindingLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    BufferBindingType type = BufferBindingType::BindingNotUsed;\n    Bool hasDynamicOffset = false;\n    uint64_t minBindingSize = 0;\n};\n\n// Can be chained in BufferDescriptor\nstruct BufferHostMappedPointer : ChainedStruct {\n    inline BufferHostMappedPointer();\n\n    struct Init;\n    inline BufferHostMappedPointer(Init&& init);\n    inline operator const WGPUBufferHostMappedPointer&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * pointer;\n    Callback disposeCallback;\n    void * userdata;\n};\n\nstruct BufferMapCallbackInfo {\n    inline operator const WGPUBufferMapCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    BufferMapCallback callback;\n    void * userdata;\n};\n\nstruct Color {\n    inline operator const WGPUColor&() const noexcept;\n\n    double r;\n    double g;\n    double b;\n    double a;\n};\n\n// Can be chained in ColorTargetState\nstruct ColorTargetStateExpandResolveTextureDawn : ChainedStruct {\n    inline ColorTargetStateExpandResolveTextureDawn();\n\n    struct Init;\n    inline ColorTargetStateExpandResolveTextureDawn(Init&& init);\n    inline operator const WGPUColorTargetStateExpandResolveTextureDawn&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool enabled = false;\n};\n\nstruct CompilationInfoCallbackInfo {\n    inline operator const WGPUCompilationInfoCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    CompilationInfoCallback callback;\n    void * userdata = nullptr;\n};\n\nstruct ComputePassTimestampWrites {\n    inline operator const WGPUComputePassTimestampWrites&() const noexcept;\n\n    QuerySet querySet;\n    uint32_t beginningOfPassWriteIndex = WGPU_QUERY_SET_INDEX_UNDEFINED;\n    uint32_t endOfPassWriteIndex = WGPU_QUERY_SET_INDEX_UNDEFINED;\n};\n\nstruct CopyTextureForBrowserOptions {\n    inline operator const WGPUCopyTextureForBrowserOptions&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Bool flipY = false;\n    Bool needsColorSpaceConversion = false;\n    AlphaMode srcAlphaMode = AlphaMode::Unpremultiplied;\n    float const * srcTransferFunctionParameters = nullptr;\n    float const * conversionMatrix = nullptr;\n    float const * dstTransferFunctionParameters = nullptr;\n    AlphaMode dstAlphaMode = AlphaMode::Unpremultiplied;\n    Bool internalUsage = false;\n};\n\nstruct CreateComputePipelineAsyncCallbackInfo {\n    inline operator const WGPUCreateComputePipelineAsyncCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    CreateComputePipelineAsyncCallback callback;\n    void * userdata;\n};\n\nstruct CreateRenderPipelineAsyncCallbackInfo {\n    inline operator const WGPUCreateRenderPipelineAsyncCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    CreateRenderPipelineAsyncCallback callback;\n    void * userdata;\n};\n\n// Can be chained in InstanceDescriptor\nstruct DawnWGSLBlocklist : ChainedStruct {\n    inline DawnWGSLBlocklist();\n\n    struct Init;\n    inline DawnWGSLBlocklist(Init&& init);\n    inline operator const WGPUDawnWGSLBlocklist&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(size_t ));\n    alignas(kFirstMemberAlignment) size_t blocklistedFeatureCount = 0;\n    const char* const * blocklistedFeatures;\n};\n\n// Can be chained in AdapterInfo\nstruct DawnAdapterPropertiesPowerPreference : ChainedStructOut {\n    inline DawnAdapterPropertiesPowerPreference();\n\n    struct Init;\n    inline DawnAdapterPropertiesPowerPreference(Init&& init);\n    inline operator const WGPUDawnAdapterPropertiesPowerPreference&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(PowerPreference ));\n    alignas(kFirstMemberAlignment) PowerPreference powerPreference = PowerPreference::Undefined;\n};\n\n// Can be chained in BufferDescriptor\nstruct DawnBufferDescriptorErrorInfoFromWireClient : ChainedStruct {\n    inline DawnBufferDescriptorErrorInfoFromWireClient();\n\n    struct Init;\n    inline DawnBufferDescriptorErrorInfoFromWireClient(Init&& init);\n    inline operator const WGPUDawnBufferDescriptorErrorInfoFromWireClient&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool outOfMemory = false;\n};\n\n// Can be chained in CommandEncoderDescriptor\nstruct DawnEncoderInternalUsageDescriptor : ChainedStruct {\n    inline DawnEncoderInternalUsageDescriptor();\n\n    struct Init;\n    inline DawnEncoderInternalUsageDescriptor(Init&& init);\n    inline operator const WGPUDawnEncoderInternalUsageDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool useInternalUsages = false;\n};\n\n// Can be chained in SupportedLimits\nstruct DawnExperimentalImmediateDataLimits : ChainedStructOut {\n    inline DawnExperimentalImmediateDataLimits();\n\n    struct Init;\n    inline DawnExperimentalImmediateDataLimits(Init&& init);\n    inline operator const WGPUDawnExperimentalImmediateDataLimits&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t maxImmediateDataRangeByteSize = WGPU_LIMIT_U32_UNDEFINED;\n};\n\n// Can be chained in SupportedLimits\nstruct DawnExperimentalSubgroupLimits : ChainedStructOut {\n    inline DawnExperimentalSubgroupLimits();\n\n    struct Init;\n    inline DawnExperimentalSubgroupLimits(Init&& init);\n    inline operator const WGPUDawnExperimentalSubgroupLimits&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t minSubgroupSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxSubgroupSize = WGPU_LIMIT_U32_UNDEFINED;\n};\n\n// Can be chained in RenderPassColorAttachment\nstruct DawnRenderPassColorAttachmentRenderToSingleSampled : ChainedStruct {\n    inline DawnRenderPassColorAttachmentRenderToSingleSampled();\n\n    struct Init;\n    inline DawnRenderPassColorAttachmentRenderToSingleSampled(Init&& init);\n    inline operator const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t implicitSampleCount = 1;\n};\n\n// Can be chained in ShaderModuleDescriptor\nstruct DawnShaderModuleSPIRVOptionsDescriptor : ChainedStruct {\n    inline DawnShaderModuleSPIRVOptionsDescriptor();\n\n    struct Init;\n    inline DawnShaderModuleSPIRVOptionsDescriptor(Init&& init);\n    inline operator const WGPUDawnShaderModuleSPIRVOptionsDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool allowNonUniformDerivatives = false;\n};\n\n// Can be chained in SupportedLimits\nstruct DawnTexelCopyBufferRowAlignmentLimits : ChainedStructOut {\n    inline DawnTexelCopyBufferRowAlignmentLimits();\n\n    struct Init;\n    inline DawnTexelCopyBufferRowAlignmentLimits(Init&& init);\n    inline operator const WGPUDawnTexelCopyBufferRowAlignmentLimits&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t minTexelCopyBufferRowAlignment = WGPU_LIMIT_U32_UNDEFINED;\n};\n\n// Can be chained in TextureDescriptor\nstruct DawnTextureInternalUsageDescriptor : ChainedStruct {\n    inline DawnTextureInternalUsageDescriptor();\n\n    struct Init;\n    inline DawnTextureInternalUsageDescriptor(Init&& init);\n    inline operator const WGPUDawnTextureInternalUsageDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(TextureUsage ));\n    alignas(kFirstMemberAlignment) TextureUsage internalUsage = TextureUsage::None;\n};\n\n// Can be chained in InstanceDescriptor\n// Can be chained in RequestAdapterOptions\n// Can be chained in DeviceDescriptor\nstruct DawnTogglesDescriptor : ChainedStruct {\n    inline DawnTogglesDescriptor();\n\n    struct Init;\n    inline DawnTogglesDescriptor(Init&& init);\n    inline operator const WGPUDawnTogglesDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(size_t ));\n    alignas(kFirstMemberAlignment) size_t enabledToggleCount = 0;\n    const char* const * enabledToggles;\n    size_t disabledToggleCount = 0;\n    const char* const * disabledToggles;\n};\n\n// Can be chained in InstanceDescriptor\nstruct DawnWireWGSLControl : ChainedStruct {\n    inline DawnWireWGSLControl();\n\n    struct Init;\n    inline DawnWireWGSLControl(Init&& init);\n    inline operator const WGPUDawnWireWGSLControl&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool enableExperimental = false;\n    Bool enableUnsafe = false;\n    Bool enableTesting = false;\n};\n\nstruct DeviceLostCallbackInfo {\n    inline operator const WGPUDeviceLostCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode = CallbackMode::WaitAnyOnly;\n    DeviceLostCallbackNew callback = nullptr;\n    void * userdata = nullptr;\n};\n\nstruct DrmFormatProperties {\n    inline operator const WGPUDrmFormatProperties&() const noexcept;\n\n    uint64_t modifier;\n    uint32_t modifierPlaneCount;\n};\n\nstruct Extent2D {\n    inline operator const WGPUExtent2D&() const noexcept;\n\n    uint32_t width;\n    uint32_t height;\n};\n\nstruct Extent3D {\n    inline operator const WGPUExtent3D&() const noexcept;\n\n    uint32_t width;\n    uint32_t height = 1;\n    uint32_t depthOrArrayLayers = 1;\n};\n\n// Can be chained in BindGroupEntry\nstruct ExternalTextureBindingEntry : ChainedStruct {\n    inline ExternalTextureBindingEntry();\n\n    struct Init;\n    inline ExternalTextureBindingEntry(Init&& init);\n    inline operator const WGPUExternalTextureBindingEntry&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(ExternalTexture ));\n    alignas(kFirstMemberAlignment) ExternalTexture externalTexture;\n};\n\n// Can be chained in BindGroupLayoutEntry\nstruct ExternalTextureBindingLayout : ChainedStruct {\n    inline ExternalTextureBindingLayout();\n\n    struct Init;\n    inline ExternalTextureBindingLayout(Init&& init);\n    inline operator const WGPUExternalTextureBindingLayout&() const noexcept;\n\n};\n\nstruct FormatCapabilities {\n    inline operator const WGPUFormatCapabilities&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n};\n\nstruct Future {\n    inline operator const WGPUFuture&() const noexcept;\n\n    uint64_t id;\n};\n\nstruct InstanceFeatures {\n    inline operator const WGPUInstanceFeatures&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Bool timedWaitAnyEnable = false;\n    size_t timedWaitAnyMaxCount = 0;\n};\n\nstruct Limits {\n    inline operator const WGPULimits&() const noexcept;\n\n    uint32_t maxTextureDimension1D = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxTextureDimension2D = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxTextureDimension3D = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxTextureArrayLayers = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxBindGroups = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxBindGroupsPlusVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxBindingsPerBindGroup = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxDynamicUniformBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxDynamicStorageBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxSampledTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxSamplersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxStorageBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxStorageTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxUniformBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint64_t maxUniformBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n    uint64_t maxStorageBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n    uint32_t minUniformBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t minStorageBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n    uint64_t maxBufferSize = WGPU_LIMIT_U64_UNDEFINED;\n    uint32_t maxVertexAttributes = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxVertexBufferArrayStride = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxInterStageShaderComponents = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxInterStageShaderVariables = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxColorAttachments = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxColorAttachmentBytesPerSample = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupStorageSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeInvocationsPerWorkgroup = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupSizeX = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupSizeY = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupSizeZ = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupsPerDimension = WGPU_LIMIT_U32_UNDEFINED;\n};\n\nstruct MemoryHeapInfo {\n    inline operator const WGPUMemoryHeapInfo&() const noexcept;\n\n    HeapProperty properties;\n    uint64_t size;\n};\n\nstruct MultisampleState {\n    inline operator const WGPUMultisampleState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint32_t count = 1;\n    uint32_t mask = 0xFFFFFFFF;\n    Bool alphaToCoverageEnabled = false;\n};\n\nstruct Origin2D {\n    inline operator const WGPUOrigin2D&() const noexcept;\n\n    uint32_t x = 0;\n    uint32_t y = 0;\n};\n\nstruct Origin3D {\n    inline operator const WGPUOrigin3D&() const noexcept;\n\n    uint32_t x = 0;\n    uint32_t y = 0;\n    uint32_t z = 0;\n};\n\nstruct PipelineLayoutStorageAttachment {\n    inline operator const WGPUPipelineLayoutStorageAttachment&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint64_t offset = 0;\n    TextureFormat format;\n};\n\nstruct PopErrorScopeCallbackInfo {\n    inline operator const WGPUPopErrorScopeCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode = CallbackMode::WaitAnyOnly;\n    PopErrorScopeCallback callback;\n    ErrorCallback oldCallback;\n    void * userdata = nullptr;\n};\n\nstruct PrimitiveState {\n    inline operator const WGPUPrimitiveState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    PrimitiveTopology topology = PrimitiveTopology::TriangleList;\n    IndexFormat stripIndexFormat = IndexFormat::Undefined;\n    FrontFace frontFace = FrontFace::CCW;\n    CullMode cullMode = CullMode::None;\n    Bool unclippedDepth = false;\n};\n\nstruct QueueWorkDoneCallbackInfo {\n    inline operator const WGPUQueueWorkDoneCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    QueueWorkDoneCallback callback;\n    void * userdata;\n};\n\nstruct RenderPassDepthStencilAttachment {\n    inline operator const WGPURenderPassDepthStencilAttachment&() const noexcept;\n\n    TextureView view;\n    LoadOp depthLoadOp = LoadOp::Undefined;\n    StoreOp depthStoreOp = StoreOp::Undefined;\n    float depthClearValue = NAN;\n    Bool depthReadOnly = false;\n    LoadOp stencilLoadOp = LoadOp::Undefined;\n    StoreOp stencilStoreOp = StoreOp::Undefined;\n    uint32_t stencilClearValue = 0;\n    Bool stencilReadOnly = false;\n};\n\n// Can be chained in RenderPassDescriptor\nstruct RenderPassDescriptorExpandResolveRect : ChainedStruct {\n    inline RenderPassDescriptorExpandResolveRect();\n\n    struct Init;\n    inline RenderPassDescriptorExpandResolveRect(Init&& init);\n    inline operator const WGPURenderPassDescriptorExpandResolveRect&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t x;\n    uint32_t y;\n    uint32_t width;\n    uint32_t height;\n};\n\n// Can be chained in RenderPassDescriptor\nstruct RenderPassMaxDrawCount : ChainedStruct {\n    inline RenderPassMaxDrawCount();\n\n    struct Init;\n    inline RenderPassMaxDrawCount(Init&& init);\n    inline operator const WGPURenderPassMaxDrawCount&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n    alignas(kFirstMemberAlignment) uint64_t maxDrawCount = 50000000;\n};\n\nstruct RenderPassTimestampWrites {\n    inline operator const WGPURenderPassTimestampWrites&() const noexcept;\n\n    QuerySet querySet;\n    uint32_t beginningOfPassWriteIndex = WGPU_QUERY_SET_INDEX_UNDEFINED;\n    uint32_t endOfPassWriteIndex = WGPU_QUERY_SET_INDEX_UNDEFINED;\n};\n\nstruct RequestAdapterCallbackInfo {\n    inline operator const WGPURequestAdapterCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    RequestAdapterCallback callback;\n    void * userdata;\n};\n\nstruct RequestAdapterOptions {\n    inline operator const WGPURequestAdapterOptions&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Surface compatibleSurface = nullptr;\n    PowerPreference powerPreference = PowerPreference::Undefined;\n    BackendType backendType = BackendType::Undefined;\n    Bool forceFallbackAdapter = false;\n    Bool compatibilityMode = false;\n};\n\nstruct RequestDeviceCallbackInfo {\n    inline operator const WGPURequestDeviceCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    RequestDeviceCallback callback;\n    void * userdata;\n};\n\nstruct SamplerBindingLayout {\n    inline operator const WGPUSamplerBindingLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    SamplerBindingType type = SamplerBindingType::BindingNotUsed;\n};\n\n// Can be chained in ShaderModuleDescriptor\nstruct ShaderModuleCompilationOptions : ChainedStruct {\n    inline ShaderModuleCompilationOptions();\n\n    struct Init;\n    inline ShaderModuleCompilationOptions(Init&& init);\n    inline operator const WGPUShaderModuleCompilationOptions&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool strictMath;\n};\n\n// Can be chained in ShaderModuleDescriptor\nstruct ShaderSourceSPIRV : ChainedStruct {\n    inline ShaderSourceSPIRV();\n\n    struct Init;\n    inline ShaderSourceSPIRV(Init&& init);\n    inline operator const WGPUShaderSourceSPIRV&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t codeSize;\n    uint32_t const * code;\n};\n\nstruct SharedBufferMemoryBeginAccessDescriptor {\n    inline operator const WGPUSharedBufferMemoryBeginAccessDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Bool initialized;\n    size_t fenceCount = 0;\n    SharedFence const * fences;\n    uint64_t const * signaledValues;\n};\n\nstruct SharedBufferMemoryEndAccessState {\n    inline SharedBufferMemoryEndAccessState();\n    inline ~SharedBufferMemoryEndAccessState();\n    SharedBufferMemoryEndAccessState(const SharedBufferMemoryEndAccessState&) = delete;\n    SharedBufferMemoryEndAccessState& operator=(const SharedBufferMemoryEndAccessState&) = delete;\n    inline SharedBufferMemoryEndAccessState(SharedBufferMemoryEndAccessState&&);\n    inline SharedBufferMemoryEndAccessState& operator=(SharedBufferMemoryEndAccessState&&);\n    inline operator const WGPUSharedBufferMemoryEndAccessState&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    Bool const initialized = {};\n    size_t const fenceCount = 0;\n    SharedFence const * const fences = {};\n    uint64_t const * const signaledValues = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(SharedBufferMemoryEndAccessState& value);\n};\n\nstruct SharedBufferMemoryProperties {\n    inline operator const WGPUSharedBufferMemoryProperties&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    BufferUsage usage;\n    uint64_t size;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceDXGISharedHandleDescriptor : ChainedStruct {\n    inline SharedFenceDXGISharedHandleDescriptor();\n\n    struct Init;\n    inline SharedFenceDXGISharedHandleDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceDXGISharedHandleDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * handle;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceDXGISharedHandleExportInfo : ChainedStructOut {\n    inline SharedFenceDXGISharedHandleExportInfo();\n\n    struct Init;\n    inline SharedFenceDXGISharedHandleExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceDXGISharedHandleExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * handle;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceMTLSharedEventDescriptor : ChainedStruct {\n    inline SharedFenceMTLSharedEventDescriptor();\n\n    struct Init;\n    inline SharedFenceMTLSharedEventDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceMTLSharedEventDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * sharedEvent;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceMTLSharedEventExportInfo : ChainedStructOut {\n    inline SharedFenceMTLSharedEventExportInfo();\n\n    struct Init;\n    inline SharedFenceMTLSharedEventExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceMTLSharedEventExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * sharedEvent;\n};\n\nstruct SharedFenceExportInfo {\n    inline operator const WGPUSharedFenceExportInfo&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    SharedFenceType type;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceSyncFDDescriptor : ChainedStruct {\n    inline SharedFenceSyncFDDescriptor();\n\n    struct Init;\n    inline SharedFenceSyncFDDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceSyncFDDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n    alignas(kFirstMemberAlignment) int handle;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceSyncFDExportInfo : ChainedStructOut {\n    inline SharedFenceSyncFDExportInfo();\n\n    struct Init;\n    inline SharedFenceSyncFDExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceSyncFDExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n    alignas(kFirstMemberAlignment) int handle;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceVkSemaphoreOpaqueFDDescriptor : ChainedStruct {\n    inline SharedFenceVkSemaphoreOpaqueFDDescriptor();\n\n    struct Init;\n    inline SharedFenceVkSemaphoreOpaqueFDDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n    alignas(kFirstMemberAlignment) int handle;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceVkSemaphoreOpaqueFDExportInfo : ChainedStructOut {\n    inline SharedFenceVkSemaphoreOpaqueFDExportInfo();\n\n    struct Init;\n    inline SharedFenceVkSemaphoreOpaqueFDExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n    alignas(kFirstMemberAlignment) int handle;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceVkSemaphoreZirconHandleDescriptor : ChainedStruct {\n    inline SharedFenceVkSemaphoreZirconHandleDescriptor();\n\n    struct Init;\n    inline SharedFenceVkSemaphoreZirconHandleDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceVkSemaphoreZirconHandleDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t handle;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceVkSemaphoreZirconHandleExportInfo : ChainedStructOut {\n    inline SharedFenceVkSemaphoreZirconHandleExportInfo();\n\n    struct Init;\n    inline SharedFenceVkSemaphoreZirconHandleExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceVkSemaphoreZirconHandleExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t handle;\n};\n\n// Can be chained in SharedTextureMemoryBeginAccessDescriptor\nstruct SharedTextureMemoryD3DSwapchainBeginState : ChainedStruct {\n    inline SharedTextureMemoryD3DSwapchainBeginState();\n\n    struct Init;\n    inline SharedTextureMemoryD3DSwapchainBeginState(Init&& init);\n    inline operator const WGPUSharedTextureMemoryD3DSwapchainBeginState&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool isSwapchain = false;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryDXGISharedHandleDescriptor : ChainedStruct {\n    inline SharedTextureMemoryDXGISharedHandleDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryDXGISharedHandleDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryDXGISharedHandleDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * handle;\n    Bool useKeyedMutex;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryEGLImageDescriptor : ChainedStruct {\n    inline SharedTextureMemoryEGLImageDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryEGLImageDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryEGLImageDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * image;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryIOSurfaceDescriptor : ChainedStruct {\n    inline SharedTextureMemoryIOSurfaceDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryIOSurfaceDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryIOSurfaceDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * ioSurface;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryAHardwareBufferDescriptor : ChainedStruct {\n    inline SharedTextureMemoryAHardwareBufferDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryAHardwareBufferDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryAHardwareBufferDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * handle;\n    Bool useExternalFormat;\n};\n\nstruct SharedTextureMemoryBeginAccessDescriptor {\n    inline operator const WGPUSharedTextureMemoryBeginAccessDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Bool concurrentRead;\n    Bool initialized;\n    size_t fenceCount;\n    SharedFence const * fences;\n    uint64_t const * signaledValues;\n};\n\nstruct SharedTextureMemoryDmaBufPlane {\n    inline operator const WGPUSharedTextureMemoryDmaBufPlane&() const noexcept;\n\n    int fd;\n    uint64_t offset;\n    uint32_t stride;\n};\n\nstruct SharedTextureMemoryEndAccessState {\n    inline SharedTextureMemoryEndAccessState();\n    inline ~SharedTextureMemoryEndAccessState();\n    SharedTextureMemoryEndAccessState(const SharedTextureMemoryEndAccessState&) = delete;\n    SharedTextureMemoryEndAccessState& operator=(const SharedTextureMemoryEndAccessState&) = delete;\n    inline SharedTextureMemoryEndAccessState(SharedTextureMemoryEndAccessState&&);\n    inline SharedTextureMemoryEndAccessState& operator=(SharedTextureMemoryEndAccessState&&);\n    inline operator const WGPUSharedTextureMemoryEndAccessState&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    Bool const initialized = {};\n    size_t const fenceCount = {};\n    SharedFence const * const fences = {};\n    uint64_t const * const signaledValues = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(SharedTextureMemoryEndAccessState& value);\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryOpaqueFDDescriptor : ChainedStruct {\n    inline SharedTextureMemoryOpaqueFDDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryOpaqueFDDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryOpaqueFDDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void const * ));\n    alignas(kFirstMemberAlignment) void const * vkImageCreateInfo;\n    int memoryFD;\n    uint32_t memoryTypeIndex;\n    uint64_t allocationSize;\n    Bool dedicatedAllocation;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryVkDedicatedAllocationDescriptor : ChainedStruct {\n    inline SharedTextureMemoryVkDedicatedAllocationDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryVkDedicatedAllocationDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool dedicatedAllocation;\n};\n\n// Can be chained in SharedTextureMemoryBeginAccessDescriptor\nstruct SharedTextureMemoryVkImageLayoutBeginState : ChainedStruct {\n    inline SharedTextureMemoryVkImageLayoutBeginState();\n\n    struct Init;\n    inline SharedTextureMemoryVkImageLayoutBeginState(Init&& init);\n    inline operator const WGPUSharedTextureMemoryVkImageLayoutBeginState&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int32_t ));\n    alignas(kFirstMemberAlignment) int32_t oldLayout;\n    int32_t newLayout;\n};\n\n// Can be chained in SharedTextureMemoryEndAccessState\nstruct SharedTextureMemoryVkImageLayoutEndState : ChainedStructOut {\n    inline SharedTextureMemoryVkImageLayoutEndState();\n\n    struct Init;\n    inline SharedTextureMemoryVkImageLayoutEndState(Init&& init);\n    inline operator const WGPUSharedTextureMemoryVkImageLayoutEndState&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int32_t ));\n    alignas(kFirstMemberAlignment) int32_t oldLayout;\n    int32_t newLayout;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryZirconHandleDescriptor : ChainedStruct {\n    inline SharedTextureMemoryZirconHandleDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryZirconHandleDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryZirconHandleDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t memoryFD;\n    uint64_t allocationSize;\n};\n\n// Can be chained in BindGroupLayoutEntry\nstruct StaticSamplerBindingLayout : ChainedStruct {\n    inline StaticSamplerBindingLayout();\n\n    struct Init;\n    inline StaticSamplerBindingLayout(Init&& init);\n    inline operator const WGPUStaticSamplerBindingLayout&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Sampler ));\n    alignas(kFirstMemberAlignment) Sampler sampler;\n    uint32_t sampledTextureBinding = WGPU_LIMIT_U32_UNDEFINED;\n};\n\nstruct StencilFaceState {\n    inline operator const WGPUStencilFaceState&() const noexcept;\n\n    CompareFunction compare = CompareFunction::Always;\n    StencilOperation failOp = StencilOperation::Keep;\n    StencilOperation depthFailOp = StencilOperation::Keep;\n    StencilOperation passOp = StencilOperation::Keep;\n};\n\nstruct StorageTextureBindingLayout {\n    inline operator const WGPUStorageTextureBindingLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StorageTextureAccess access = StorageTextureAccess::BindingNotUsed;\n    TextureFormat format = TextureFormat::Undefined;\n    TextureViewDimension viewDimension = TextureViewDimension::e2D;\n};\n\nstruct SupportedFeatures {\n    inline SupportedFeatures();\n    inline ~SupportedFeatures();\n    SupportedFeatures(const SupportedFeatures&) = delete;\n    SupportedFeatures& operator=(const SupportedFeatures&) = delete;\n    inline SupportedFeatures(SupportedFeatures&&);\n    inline SupportedFeatures& operator=(SupportedFeatures&&);\n    inline operator const WGPUSupportedFeatures&() const noexcept;\n\n    size_t const featureCount = {};\n    FeatureName const * const features = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(SupportedFeatures& value);\n};\n\nstruct SurfaceCapabilities {\n    inline SurfaceCapabilities();\n    inline ~SurfaceCapabilities();\n    SurfaceCapabilities(const SurfaceCapabilities&) = delete;\n    SurfaceCapabilities& operator=(const SurfaceCapabilities&) = delete;\n    inline SurfaceCapabilities(SurfaceCapabilities&&);\n    inline SurfaceCapabilities& operator=(SurfaceCapabilities&&);\n    inline operator const WGPUSurfaceCapabilities&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    TextureUsage const usages = {};\n    size_t const formatCount = {};\n    TextureFormat const * const formats = {};\n    size_t const presentModeCount = {};\n    PresentMode const * const presentModes = {};\n    size_t const alphaModeCount = {};\n    CompositeAlphaMode const * const alphaModes = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(SurfaceCapabilities& value);\n};\n\nstruct SurfaceConfiguration {\n    inline operator const WGPUSurfaceConfiguration&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Device device;\n    TextureFormat format;\n    TextureUsage usage = TextureUsage::RenderAttachment;\n    size_t viewFormatCount = 0;\n    TextureFormat const * viewFormats = nullptr;\n    CompositeAlphaMode alphaMode = CompositeAlphaMode::Auto;\n    uint32_t width;\n    uint32_t height;\n    PresentMode presentMode = PresentMode::Fifo;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceDescriptorFromWindowsCoreWindow : ChainedStruct {\n    inline SurfaceDescriptorFromWindowsCoreWindow();\n\n    struct Init;\n    inline SurfaceDescriptorFromWindowsCoreWindow(Init&& init);\n    inline operator const WGPUSurfaceDescriptorFromWindowsCoreWindow&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * coreWindow;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceDescriptorFromWindowsSwapChainPanel : ChainedStruct {\n    inline SurfaceDescriptorFromWindowsSwapChainPanel();\n\n    struct Init;\n    inline SurfaceDescriptorFromWindowsSwapChainPanel(Init&& init);\n    inline operator const WGPUSurfaceDescriptorFromWindowsSwapChainPanel&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * swapChainPanel;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceXCBWindow : ChainedStruct {\n    inline SurfaceSourceXCBWindow();\n\n    struct Init;\n    inline SurfaceSourceXCBWindow(Init&& init);\n    inline operator const WGPUSurfaceSourceXCBWindow&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * connection;\n    uint32_t window;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceAndroidNativeWindow : ChainedStruct {\n    inline SurfaceSourceAndroidNativeWindow();\n\n    struct Init;\n    inline SurfaceSourceAndroidNativeWindow(Init&& init);\n    inline operator const WGPUSurfaceSourceAndroidNativeWindow&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * window;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceMetalLayer : ChainedStruct {\n    inline SurfaceSourceMetalLayer();\n\n    struct Init;\n    inline SurfaceSourceMetalLayer(Init&& init);\n    inline operator const WGPUSurfaceSourceMetalLayer&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * layer;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceWaylandSurface : ChainedStruct {\n    inline SurfaceSourceWaylandSurface();\n\n    struct Init;\n    inline SurfaceSourceWaylandSurface(Init&& init);\n    inline operator const WGPUSurfaceSourceWaylandSurface&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * display;\n    void * surface;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceWindowsHWND : ChainedStruct {\n    inline SurfaceSourceWindowsHWND();\n\n    struct Init;\n    inline SurfaceSourceWindowsHWND(Init&& init);\n    inline operator const WGPUSurfaceSourceWindowsHWND&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * hinstance;\n    void * hwnd;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceXlibWindow : ChainedStruct {\n    inline SurfaceSourceXlibWindow();\n\n    struct Init;\n    inline SurfaceSourceXlibWindow(Init&& init);\n    inline operator const WGPUSurfaceSourceXlibWindow&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * display;\n    uint64_t window;\n};\n\nstruct SurfaceTexture {\n    inline operator const WGPUSurfaceTexture&() const noexcept;\n\n    Texture texture;\n    Bool suboptimal;\n    SurfaceGetCurrentTextureStatus status;\n};\n\nstruct TextureBindingLayout {\n    inline operator const WGPUTextureBindingLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    TextureSampleType sampleType = TextureSampleType::BindingNotUsed;\n    TextureViewDimension viewDimension = TextureViewDimension::e2D;\n    Bool multisampled = false;\n};\n\n// Can be chained in TextureDescriptor\nstruct TextureBindingViewDimensionDescriptor : ChainedStruct {\n    inline TextureBindingViewDimensionDescriptor();\n\n    struct Init;\n    inline TextureBindingViewDimensionDescriptor(Init&& init);\n    inline operator const WGPUTextureBindingViewDimensionDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(TextureViewDimension ));\n    alignas(kFirstMemberAlignment) TextureViewDimension textureBindingViewDimension = TextureViewDimension::Undefined;\n};\n\nstruct TextureDataLayout {\n    inline operator const WGPUTextureDataLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint64_t offset = 0;\n    uint32_t bytesPerRow = WGPU_COPY_STRIDE_UNDEFINED;\n    uint32_t rowsPerImage = WGPU_COPY_STRIDE_UNDEFINED;\n};\n\nstruct UncapturedErrorCallbackInfo {\n    inline operator const WGPUUncapturedErrorCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ErrorCallback callback = nullptr;\n    void * userdata = nullptr;\n};\n\nstruct VertexAttribute {\n    inline operator const WGPUVertexAttribute&() const noexcept;\n\n    VertexFormat format;\n    uint64_t offset;\n    uint32_t shaderLocation;\n};\n\n// Can be chained in SamplerDescriptor\n// Can be chained in TextureViewDescriptor\nstruct YCbCrVkDescriptor : ChainedStruct {\n    inline YCbCrVkDescriptor();\n\n    struct Init;\n    inline YCbCrVkDescriptor(Init&& init);\n    inline operator const WGPUYCbCrVkDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t vkFormat = 0;\n    uint32_t vkYCbCrModel = 0;\n    uint32_t vkYCbCrRange = 0;\n    uint32_t vkComponentSwizzleRed = 0;\n    uint32_t vkComponentSwizzleGreen = 0;\n    uint32_t vkComponentSwizzleBlue = 0;\n    uint32_t vkComponentSwizzleAlpha = 0;\n    uint32_t vkXChromaOffset = 0;\n    uint32_t vkYChromaOffset = 0;\n    FilterMode vkChromaFilter = FilterMode::Nearest;\n    Bool forceExplicitReconstruction = false;\n    uint64_t externalFormat = 0;\n};\n\nstruct AHardwareBufferProperties {\n    inline operator const WGPUAHardwareBufferProperties&() const noexcept;\n\n    YCbCrVkDescriptor yCbCrInfo = {};\n};\n\nstruct AdapterInfo {\n    inline AdapterInfo();\n    inline ~AdapterInfo();\n    AdapterInfo(const AdapterInfo&) = delete;\n    AdapterInfo& operator=(const AdapterInfo&) = delete;\n    inline AdapterInfo(AdapterInfo&&);\n    inline AdapterInfo& operator=(AdapterInfo&&);\n    inline operator const WGPUAdapterInfo&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    StringView const vendor = {};\n    StringView const architecture = {};\n    StringView const device = {};\n    StringView const description = {};\n    BackendType const backendType = {};\n    AdapterType const adapterType = {};\n    uint32_t const vendorID = {};\n    uint32_t const deviceID = {};\n    Bool const compatibilityMode = false;\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(AdapterInfo& value);\n};\n\n// Can be chained in AdapterInfo\nstruct AdapterPropertiesMemoryHeaps : ChainedStructOut {\n    inline AdapterPropertiesMemoryHeaps();\n\n    struct Init;\n    inline AdapterPropertiesMemoryHeaps(Init&& init);\n    inline ~AdapterPropertiesMemoryHeaps();\n    AdapterPropertiesMemoryHeaps(const AdapterPropertiesMemoryHeaps&) = delete;\n    AdapterPropertiesMemoryHeaps& operator=(const AdapterPropertiesMemoryHeaps&) = delete;\n    inline AdapterPropertiesMemoryHeaps(AdapterPropertiesMemoryHeaps&&);\n    inline AdapterPropertiesMemoryHeaps& operator=(AdapterPropertiesMemoryHeaps&&);\n    inline operator const WGPUAdapterPropertiesMemoryHeaps&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(size_t ));\n    alignas(kFirstMemberAlignment) size_t const heapCount = {};\n    MemoryHeapInfo const * const heapInfo = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(AdapterPropertiesMemoryHeaps& value);\n};\n\nstruct BindGroupDescriptor {\n    inline operator const WGPUBindGroupDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    BindGroupLayout layout;\n    size_t entryCount;\n    BindGroupEntry const * entries;\n};\n\nstruct BindGroupLayoutEntry {\n    inline operator const WGPUBindGroupLayoutEntry&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint32_t binding;\n    ShaderStage visibility;\n    BufferBindingLayout buffer = {};\n    SamplerBindingLayout sampler = {};\n    TextureBindingLayout texture = {};\n    StorageTextureBindingLayout storageTexture = {};\n};\n\nstruct BlendState {\n    inline operator const WGPUBlendState&() const noexcept;\n\n    BlendComponent color = {};\n    BlendComponent alpha = {};\n};\n\nstruct BufferDescriptor {\n    inline operator const WGPUBufferDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    BufferUsage usage;\n    uint64_t size;\n    Bool mappedAtCreation = false;\n};\n\nstruct CommandBufferDescriptor {\n    inline operator const WGPUCommandBufferDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct CommandEncoderDescriptor {\n    inline operator const WGPUCommandEncoderDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct CompilationMessage {\n    inline operator const WGPUCompilationMessage&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView message = {};\n    CompilationMessageType type;\n    uint64_t lineNum;\n    uint64_t linePos;\n    uint64_t offset;\n    uint64_t length;\n    uint64_t utf16LinePos;\n    uint64_t utf16Offset;\n    uint64_t utf16Length;\n};\n\nstruct ComputePassDescriptor {\n    inline operator const WGPUComputePassDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    ComputePassTimestampWrites const * timestampWrites = nullptr;\n};\n\nstruct ConstantEntry {\n    inline operator const WGPUConstantEntry&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView key = {};\n    double value;\n};\n\n// Can be chained in DeviceDescriptor\nstruct DawnCacheDeviceDescriptor : ChainedStruct {\n    inline DawnCacheDeviceDescriptor();\n\n    struct Init;\n    inline DawnCacheDeviceDescriptor(Init&& init);\n    inline operator const WGPUDawnCacheDeviceDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(StringView ));\n    alignas(kFirstMemberAlignment) StringView isolationKey = {};\n    DawnLoadCacheDataFunction loadDataFunction = nullptr;\n    DawnStoreCacheDataFunction storeDataFunction = nullptr;\n    void * functionUserdata = nullptr;\n};\n\nstruct DepthStencilState {\n    inline operator const WGPUDepthStencilState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    TextureFormat format;\n    OptionalBool depthWriteEnabled = OptionalBool::Undefined;\n    CompareFunction depthCompare = CompareFunction::Undefined;\n    StencilFaceState stencilFront = {};\n    StencilFaceState stencilBack = {};\n    uint32_t stencilReadMask = 0xFFFFFFFF;\n    uint32_t stencilWriteMask = 0xFFFFFFFF;\n    int32_t depthBias = 0;\n    float depthBiasSlopeScale = 0.0f;\n    float depthBiasClamp = 0.0f;\n};\n\n// Can be chained in FormatCapabilities\nstruct DrmFormatCapabilities : ChainedStructOut {\n    inline DrmFormatCapabilities();\n\n    struct Init;\n    inline DrmFormatCapabilities(Init&& init);\n    inline ~DrmFormatCapabilities();\n    DrmFormatCapabilities(const DrmFormatCapabilities&) = delete;\n    DrmFormatCapabilities& operator=(const DrmFormatCapabilities&) = delete;\n    inline DrmFormatCapabilities(DrmFormatCapabilities&&);\n    inline DrmFormatCapabilities& operator=(DrmFormatCapabilities&&);\n    inline operator const WGPUDrmFormatCapabilities&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(size_t ));\n    alignas(kFirstMemberAlignment) size_t const propertiesCount = {};\n    DrmFormatProperties const * const properties = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(DrmFormatCapabilities& value);\n};\n\nstruct ExternalTextureDescriptor {\n    inline operator const WGPUExternalTextureDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    TextureView plane0;\n    TextureView plane1 = nullptr;\n    Origin2D cropOrigin = {};\n    Extent2D cropSize = {};\n    Extent2D apparentSize = {};\n    Bool doYuvToRgbConversionOnly = false;\n    float const * yuvToRgbConversionMatrix = nullptr;\n    float const * srcTransferFunctionParameters;\n    float const * dstTransferFunctionParameters;\n    float const * gamutConversionMatrix;\n    Bool mirrored = false;\n    ExternalTextureRotation rotation = ExternalTextureRotation::Rotate0Degrees;\n};\n\nstruct FutureWaitInfo {\n    inline operator const WGPUFutureWaitInfo&() const noexcept;\n\n    Future future = {};\n    Bool completed = false;\n};\n\nstruct ImageCopyBuffer {\n    inline operator const WGPUImageCopyBuffer&() const noexcept;\n\n    TextureDataLayout layout = {};\n    Buffer buffer;\n};\n\nstruct ImageCopyExternalTexture {\n    inline operator const WGPUImageCopyExternalTexture&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ExternalTexture externalTexture;\n    Origin3D origin = {};\n    Extent2D naturalSize = {};\n};\n\nstruct ImageCopyTexture {\n    inline operator const WGPUImageCopyTexture&() const noexcept;\n\n    Texture texture;\n    uint32_t mipLevel = 0;\n    Origin3D origin = {};\n    TextureAspect aspect = TextureAspect::All;\n};\n\nstruct InstanceDescriptor {\n    inline operator const WGPUInstanceDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    InstanceFeatures features = {};\n};\n\nstruct PipelineLayoutDescriptor {\n    inline operator const WGPUPipelineLayoutDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t bindGroupLayoutCount;\n    BindGroupLayout const * bindGroupLayouts = nullptr;\n    uint32_t immediateDataRangeByteSize = 0;\n};\n\n// Can be chained in PipelineLayoutDescriptor\nstruct PipelineLayoutPixelLocalStorage : ChainedStruct {\n    inline PipelineLayoutPixelLocalStorage();\n\n    struct Init;\n    inline PipelineLayoutPixelLocalStorage(Init&& init);\n    inline operator const WGPUPipelineLayoutPixelLocalStorage&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n    alignas(kFirstMemberAlignment) uint64_t totalPixelLocalStorageSize;\n    size_t storageAttachmentCount = 0;\n    PipelineLayoutStorageAttachment const * storageAttachments;\n};\n\nstruct QuerySetDescriptor {\n    inline operator const WGPUQuerySetDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    QueryType type;\n    uint32_t count;\n};\n\nstruct QueueDescriptor {\n    inline operator const WGPUQueueDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct RenderBundleDescriptor {\n    inline operator const WGPURenderBundleDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct RenderBundleEncoderDescriptor {\n    inline operator const WGPURenderBundleEncoderDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t colorFormatCount;\n    TextureFormat const * colorFormats;\n    TextureFormat depthStencilFormat = TextureFormat::Undefined;\n    uint32_t sampleCount = 1;\n    Bool depthReadOnly = false;\n    Bool stencilReadOnly = false;\n};\n\nstruct RenderPassColorAttachment {\n    inline operator const WGPURenderPassColorAttachment&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    TextureView view = nullptr;\n    uint32_t depthSlice = WGPU_DEPTH_SLICE_UNDEFINED;\n    TextureView resolveTarget = nullptr;\n    LoadOp loadOp;\n    StoreOp storeOp;\n    Color clearValue = {};\n};\n\nstruct RenderPassStorageAttachment {\n    inline operator const WGPURenderPassStorageAttachment&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint64_t offset = 0;\n    TextureView storage;\n    LoadOp loadOp;\n    StoreOp storeOp;\n    Color clearValue = {};\n};\n\nstruct RequiredLimits {\n    inline operator const WGPURequiredLimits&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Limits limits = {};\n};\n\nstruct SamplerDescriptor {\n    inline operator const WGPUSamplerDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    AddressMode addressModeU = AddressMode::ClampToEdge;\n    AddressMode addressModeV = AddressMode::ClampToEdge;\n    AddressMode addressModeW = AddressMode::ClampToEdge;\n    FilterMode magFilter = FilterMode::Nearest;\n    FilterMode minFilter = FilterMode::Nearest;\n    MipmapFilterMode mipmapFilter = MipmapFilterMode::Nearest;\n    float lodMinClamp = 0.0f;\n    float lodMaxClamp = 32.0f;\n    CompareFunction compare = CompareFunction::Undefined;\n    uint16_t maxAnisotropy = 1;\n};\n\nstruct ShaderModuleDescriptor {\n    inline operator const WGPUShaderModuleDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\n// Can be chained in ShaderModuleDescriptor\nstruct ShaderSourceWGSL : ChainedStruct {\n    inline ShaderSourceWGSL();\n\n    struct Init;\n    inline ShaderSourceWGSL(Init&& init);\n    inline operator const WGPUShaderSourceWGSL&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(StringView ));\n    alignas(kFirstMemberAlignment) StringView code = {};\n};\n\nstruct SharedBufferMemoryDescriptor {\n    inline operator const WGPUSharedBufferMemoryDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct SharedFenceDescriptor {\n    inline operator const WGPUSharedFenceDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\n// Can be chained in SharedTextureMemoryProperties\nstruct SharedTextureMemoryAHardwareBufferProperties : ChainedStructOut {\n    inline SharedTextureMemoryAHardwareBufferProperties();\n\n    struct Init;\n    inline SharedTextureMemoryAHardwareBufferProperties(Init&& init);\n    inline operator const WGPUSharedTextureMemoryAHardwareBufferProperties&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(YCbCrVkDescriptor ));\n    alignas(kFirstMemberAlignment) YCbCrVkDescriptor yCbCrInfo = {};\n};\n\nstruct SharedTextureMemoryDescriptor {\n    inline operator const WGPUSharedTextureMemoryDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryDmaBufDescriptor : ChainedStruct {\n    inline SharedTextureMemoryDmaBufDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryDmaBufDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryDmaBufDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Extent3D ));\n    alignas(kFirstMemberAlignment) Extent3D size = {};\n    uint32_t drmFormat;\n    uint64_t drmModifier;\n    size_t planeCount;\n    SharedTextureMemoryDmaBufPlane const * planes;\n};\n\nstruct SharedTextureMemoryProperties {\n    inline operator const WGPUSharedTextureMemoryProperties&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    TextureUsage usage;\n    Extent3D size = {};\n    TextureFormat format;\n};\n\nstruct SupportedLimits {\n    inline operator const WGPUSupportedLimits&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    Limits limits = {};\n};\n\nstruct SurfaceDescriptor {\n    inline operator const WGPUSurfaceDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceCanvasHTMLSelector_Emscripten : ChainedStruct {\n    inline SurfaceSourceCanvasHTMLSelector_Emscripten();\n\n    struct Init;\n    inline SurfaceSourceCanvasHTMLSelector_Emscripten(Init&& init);\n    inline operator const WGPUSurfaceSourceCanvasHTMLSelector_Emscripten&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(StringView ));\n    alignas(kFirstMemberAlignment) StringView selector = {};\n};\n\nstruct TextureDescriptor {\n    inline operator const WGPUTextureDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    TextureUsage usage;\n    TextureDimension dimension = TextureDimension::e2D;\n    Extent3D size = {};\n    TextureFormat format;\n    uint32_t mipLevelCount = 1;\n    uint32_t sampleCount = 1;\n    size_t viewFormatCount = 0;\n    TextureFormat const * viewFormats = nullptr;\n};\n\nstruct TextureViewDescriptor {\n    inline operator const WGPUTextureViewDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    TextureFormat format = TextureFormat::Undefined;\n    TextureViewDimension dimension = TextureViewDimension::Undefined;\n    uint32_t baseMipLevel = 0;\n    uint32_t mipLevelCount = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n    uint32_t baseArrayLayer = 0;\n    uint32_t arrayLayerCount = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n    TextureAspect aspect = TextureAspect::All;\n    TextureUsage usage = TextureUsage::None;\n};\n\nstruct VertexBufferLayout {\n    inline operator const WGPUVertexBufferLayout&() const noexcept;\n\n    uint64_t arrayStride;\n    VertexStepMode stepMode;\n    size_t attributeCount;\n    VertexAttribute const * attributes;\n};\n\nstruct BindGroupLayoutDescriptor {\n    inline operator const WGPUBindGroupLayoutDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t entryCount;\n    BindGroupLayoutEntry const * entries;\n};\n\nstruct ColorTargetState {\n    inline operator const WGPUColorTargetState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    TextureFormat format;\n    BlendState const * blend = nullptr;\n    ColorWriteMask writeMask = ColorWriteMask::All;\n};\n\nstruct CompilationInfo {\n    inline operator const WGPUCompilationInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    size_t messageCount;\n    CompilationMessage const * messages;\n};\n\nstruct ComputeState {\n    inline operator const WGPUComputeState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ShaderModule module;\n    StringView entryPoint = {};\n    size_t constantCount = 0;\n    ConstantEntry const * constants;\n};\n\nstruct RenderPassDescriptor {\n    inline operator const WGPURenderPassDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t colorAttachmentCount;\n    RenderPassColorAttachment const * colorAttachments;\n    RenderPassDepthStencilAttachment const * depthStencilAttachment = nullptr;\n    QuerySet occlusionQuerySet = nullptr;\n    RenderPassTimestampWrites const * timestampWrites = nullptr;\n};\n\n// Can be chained in RenderPassDescriptor\nstruct RenderPassPixelLocalStorage : ChainedStruct {\n    inline RenderPassPixelLocalStorage();\n\n    struct Init;\n    inline RenderPassPixelLocalStorage(Init&& init);\n    inline operator const WGPURenderPassPixelLocalStorage&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n    alignas(kFirstMemberAlignment) uint64_t totalPixelLocalStorageSize;\n    size_t storageAttachmentCount = 0;\n    RenderPassStorageAttachment const * storageAttachments;\n};\n\nstruct VertexState {\n    inline operator const WGPUVertexState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ShaderModule module;\n    StringView entryPoint = {};\n    size_t constantCount = 0;\n    ConstantEntry const * constants;\n    size_t bufferCount = 0;\n    VertexBufferLayout const * buffers;\n};\n\nstruct ComputePipelineDescriptor {\n    inline operator const WGPUComputePipelineDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    PipelineLayout layout = nullptr;\n    ComputeState compute = {};\n};\n\nstruct FragmentState {\n    inline operator const WGPUFragmentState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ShaderModule module;\n    StringView entryPoint = {};\n    size_t constantCount = 0;\n    ConstantEntry const * constants;\n    size_t targetCount;\n    ColorTargetState const * targets;\n};\n\nstruct RenderPipelineDescriptor {\n    inline operator const WGPURenderPipelineDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    PipelineLayout layout = nullptr;\n    VertexState vertex = {};\n    PrimitiveState primitive = {};\n    DepthStencilState const * depthStencil = nullptr;\n    MultisampleState multisample = {};\n    FragmentState const * fragment = nullptr;\n};\n\n\nnamespace detail {\nstruct DeviceDescriptor {\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t requiredFeatureCount = 0;\n    FeatureName const * requiredFeatures = nullptr;\n    RequiredLimits const * requiredLimits = nullptr;\n    QueueDescriptor defaultQueue = {};\n    WGPUDeviceLostCallbackInfo2 deviceLostCallbackInfo2 = WGPU_DEVICE_LOST_CALLBACK_INFO_2_INIT;\n    WGPUUncapturedErrorCallbackInfo2 uncapturedErrorCallbackInfo2 = WGPU_UNCAPTURED_ERROR_CALLBACK_INFO_2_INIT;\n};\n}  // namespace detail\nstruct DeviceDescriptor : protected detail::DeviceDescriptor {\n    inline operator const WGPUDeviceDescriptor&() const noexcept;\n\n    using detail::DeviceDescriptor::nextInChain;\n    using detail::DeviceDescriptor::label;\n    using detail::DeviceDescriptor::requiredFeatureCount;\n    using detail::DeviceDescriptor::requiredFeatures;\n    using detail::DeviceDescriptor::requiredLimits;\n    using detail::DeviceDescriptor::defaultQueue;\n\n    inline DeviceDescriptor();\n    struct Init;\n    inline DeviceDescriptor(Init&& init);\n\n    template <typename F, typename T,\n              typename Cb = DeviceLostCallback2<T>,\n              typename CbChar = void (const Device& device, DeviceLostReason reason, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    void SetDeviceLostCallback(CallbackMode callbackMode, F callback, T userdata);\n    template <typename L,\n              typename Cb = DeviceLostCallback2<>,\n              typename CbChar = std::function<void(const Device& device, DeviceLostReason reason, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    void SetDeviceLostCallback(CallbackMode callbackMode, L callback);\n\n    template <typename F, typename T,\n              typename Cb = UncapturedErrorCallback<T>,\n              typename CbChar = void (const Device& device, ErrorType type, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    void SetUncapturedErrorCallback(F callback, T userdata);\n    template <typename L,\n              typename Cb = UncapturedErrorCallback<>,\n              typename CbChar = std::function<void(const Device& device, ErrorType type, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    void SetUncapturedErrorCallback(L callback);\n};\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n// error: 'offsetof' within non-standard-layout type 'wgpu::XXX' is conditionally-supported\n#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n#endif\n\n// INTERNAL__HAVE_EMDAWNWEBGPU_HEADER implementation\n\nINTERNAL__HAVE_EMDAWNWEBGPU_HEADER::operator const WGPUINTERNAL__HAVE_EMDAWNWEBGPU_HEADER&() const noexcept {\n    return *reinterpret_cast<const WGPUINTERNAL__HAVE_EMDAWNWEBGPU_HEADER*>(this);\n}\n\nstatic_assert(sizeof(INTERNAL__HAVE_EMDAWNWEBGPU_HEADER) == sizeof(WGPUINTERNAL__HAVE_EMDAWNWEBGPU_HEADER), \"sizeof mismatch for INTERNAL__HAVE_EMDAWNWEBGPU_HEADER\");\nstatic_assert(alignof(INTERNAL__HAVE_EMDAWNWEBGPU_HEADER) == alignof(WGPUINTERNAL__HAVE_EMDAWNWEBGPU_HEADER), \"alignof mismatch for INTERNAL__HAVE_EMDAWNWEBGPU_HEADER\");\nstatic_assert(offsetof(INTERNAL__HAVE_EMDAWNWEBGPU_HEADER, unused) == offsetof(WGPUINTERNAL__HAVE_EMDAWNWEBGPU_HEADER, unused),\n        \"offsetof mismatch for INTERNAL__HAVE_EMDAWNWEBGPU_HEADER::unused\");\n\n// AdapterPropertiesD3D implementation\nAdapterPropertiesD3D::AdapterPropertiesD3D()\n  : ChainedStructOut { nullptr, SType::AdapterPropertiesD3D } {}\nstruct AdapterPropertiesD3D::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t shaderModel;\n};\nAdapterPropertiesD3D::AdapterPropertiesD3D(AdapterPropertiesD3D::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::AdapterPropertiesD3D }, \n    shaderModel(std::move(init.shaderModel)){}\n\nAdapterPropertiesD3D::operator const WGPUAdapterPropertiesD3D&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterPropertiesD3D*>(this);\n}\n\nstatic_assert(sizeof(AdapterPropertiesD3D) == sizeof(WGPUAdapterPropertiesD3D), \"sizeof mismatch for AdapterPropertiesD3D\");\nstatic_assert(alignof(AdapterPropertiesD3D) == alignof(WGPUAdapterPropertiesD3D), \"alignof mismatch for AdapterPropertiesD3D\");\nstatic_assert(offsetof(AdapterPropertiesD3D, shaderModel) == offsetof(WGPUAdapterPropertiesD3D, shaderModel),\n        \"offsetof mismatch for AdapterPropertiesD3D::shaderModel\");\n\n// AdapterPropertiesSubgroups implementation\nAdapterPropertiesSubgroups::AdapterPropertiesSubgroups()\n  : ChainedStructOut { nullptr, SType::AdapterPropertiesSubgroups } {}\nstruct AdapterPropertiesSubgroups::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t subgroupMinSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t subgroupMaxSize = WGPU_LIMIT_U32_UNDEFINED;\n};\nAdapterPropertiesSubgroups::AdapterPropertiesSubgroups(AdapterPropertiesSubgroups::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::AdapterPropertiesSubgroups }, \n    subgroupMinSize(std::move(init.subgroupMinSize)), \n    subgroupMaxSize(std::move(init.subgroupMaxSize)){}\n\nAdapterPropertiesSubgroups::operator const WGPUAdapterPropertiesSubgroups&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterPropertiesSubgroups*>(this);\n}\n\nstatic_assert(sizeof(AdapterPropertiesSubgroups) == sizeof(WGPUAdapterPropertiesSubgroups), \"sizeof mismatch for AdapterPropertiesSubgroups\");\nstatic_assert(alignof(AdapterPropertiesSubgroups) == alignof(WGPUAdapterPropertiesSubgroups), \"alignof mismatch for AdapterPropertiesSubgroups\");\nstatic_assert(offsetof(AdapterPropertiesSubgroups, subgroupMinSize) == offsetof(WGPUAdapterPropertiesSubgroups, subgroupMinSize),\n        \"offsetof mismatch for AdapterPropertiesSubgroups::subgroupMinSize\");\nstatic_assert(offsetof(AdapterPropertiesSubgroups, subgroupMaxSize) == offsetof(WGPUAdapterPropertiesSubgroups, subgroupMaxSize),\n        \"offsetof mismatch for AdapterPropertiesSubgroups::subgroupMaxSize\");\n\n// AdapterPropertiesVk implementation\nAdapterPropertiesVk::AdapterPropertiesVk()\n  : ChainedStructOut { nullptr, SType::AdapterPropertiesVk } {}\nstruct AdapterPropertiesVk::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t driverVersion;\n};\nAdapterPropertiesVk::AdapterPropertiesVk(AdapterPropertiesVk::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::AdapterPropertiesVk }, \n    driverVersion(std::move(init.driverVersion)){}\n\nAdapterPropertiesVk::operator const WGPUAdapterPropertiesVk&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterPropertiesVk*>(this);\n}\n\nstatic_assert(sizeof(AdapterPropertiesVk) == sizeof(WGPUAdapterPropertiesVk), \"sizeof mismatch for AdapterPropertiesVk\");\nstatic_assert(alignof(AdapterPropertiesVk) == alignof(WGPUAdapterPropertiesVk), \"alignof mismatch for AdapterPropertiesVk\");\nstatic_assert(offsetof(AdapterPropertiesVk, driverVersion) == offsetof(WGPUAdapterPropertiesVk, driverVersion),\n        \"offsetof mismatch for AdapterPropertiesVk::driverVersion\");\n\n// BindGroupEntry implementation\n\nBindGroupEntry::operator const WGPUBindGroupEntry&() const noexcept {\n    return *reinterpret_cast<const WGPUBindGroupEntry*>(this);\n}\n\nstatic_assert(sizeof(BindGroupEntry) == sizeof(WGPUBindGroupEntry), \"sizeof mismatch for BindGroupEntry\");\nstatic_assert(alignof(BindGroupEntry) == alignof(WGPUBindGroupEntry), \"alignof mismatch for BindGroupEntry\");\nstatic_assert(offsetof(BindGroupEntry, nextInChain) == offsetof(WGPUBindGroupEntry, nextInChain),\n        \"offsetof mismatch for BindGroupEntry::nextInChain\");\nstatic_assert(offsetof(BindGroupEntry, binding) == offsetof(WGPUBindGroupEntry, binding),\n        \"offsetof mismatch for BindGroupEntry::binding\");\nstatic_assert(offsetof(BindGroupEntry, buffer) == offsetof(WGPUBindGroupEntry, buffer),\n        \"offsetof mismatch for BindGroupEntry::buffer\");\nstatic_assert(offsetof(BindGroupEntry, offset) == offsetof(WGPUBindGroupEntry, offset),\n        \"offsetof mismatch for BindGroupEntry::offset\");\nstatic_assert(offsetof(BindGroupEntry, size) == offsetof(WGPUBindGroupEntry, size),\n        \"offsetof mismatch for BindGroupEntry::size\");\nstatic_assert(offsetof(BindGroupEntry, sampler) == offsetof(WGPUBindGroupEntry, sampler),\n        \"offsetof mismatch for BindGroupEntry::sampler\");\nstatic_assert(offsetof(BindGroupEntry, textureView) == offsetof(WGPUBindGroupEntry, textureView),\n        \"offsetof mismatch for BindGroupEntry::textureView\");\n\n// BlendComponent implementation\n\nBlendComponent::operator const WGPUBlendComponent&() const noexcept {\n    return *reinterpret_cast<const WGPUBlendComponent*>(this);\n}\n\nstatic_assert(sizeof(BlendComponent) == sizeof(WGPUBlendComponent), \"sizeof mismatch for BlendComponent\");\nstatic_assert(alignof(BlendComponent) == alignof(WGPUBlendComponent), \"alignof mismatch for BlendComponent\");\nstatic_assert(offsetof(BlendComponent, operation) == offsetof(WGPUBlendComponent, operation),\n        \"offsetof mismatch for BlendComponent::operation\");\nstatic_assert(offsetof(BlendComponent, srcFactor) == offsetof(WGPUBlendComponent, srcFactor),\n        \"offsetof mismatch for BlendComponent::srcFactor\");\nstatic_assert(offsetof(BlendComponent, dstFactor) == offsetof(WGPUBlendComponent, dstFactor),\n        \"offsetof mismatch for BlendComponent::dstFactor\");\n\n// BufferBindingLayout implementation\n\nBufferBindingLayout::operator const WGPUBufferBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUBufferBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(BufferBindingLayout) == sizeof(WGPUBufferBindingLayout), \"sizeof mismatch for BufferBindingLayout\");\nstatic_assert(alignof(BufferBindingLayout) == alignof(WGPUBufferBindingLayout), \"alignof mismatch for BufferBindingLayout\");\nstatic_assert(offsetof(BufferBindingLayout, nextInChain) == offsetof(WGPUBufferBindingLayout, nextInChain),\n        \"offsetof mismatch for BufferBindingLayout::nextInChain\");\nstatic_assert(offsetof(BufferBindingLayout, type) == offsetof(WGPUBufferBindingLayout, type),\n        \"offsetof mismatch for BufferBindingLayout::type\");\nstatic_assert(offsetof(BufferBindingLayout, hasDynamicOffset) == offsetof(WGPUBufferBindingLayout, hasDynamicOffset),\n        \"offsetof mismatch for BufferBindingLayout::hasDynamicOffset\");\nstatic_assert(offsetof(BufferBindingLayout, minBindingSize) == offsetof(WGPUBufferBindingLayout, minBindingSize),\n        \"offsetof mismatch for BufferBindingLayout::minBindingSize\");\n\n// BufferHostMappedPointer implementation\nBufferHostMappedPointer::BufferHostMappedPointer()\n  : ChainedStruct { nullptr, SType::BufferHostMappedPointer } {}\nstruct BufferHostMappedPointer::Init {\n    ChainedStruct * const nextInChain;\n    void * pointer;\n    Callback disposeCallback;\n    void * userdata;\n};\nBufferHostMappedPointer::BufferHostMappedPointer(BufferHostMappedPointer::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::BufferHostMappedPointer }, \n    pointer(std::move(init.pointer)), \n    disposeCallback(std::move(init.disposeCallback)), \n    userdata(std::move(init.userdata)){}\n\nBufferHostMappedPointer::operator const WGPUBufferHostMappedPointer&() const noexcept {\n    return *reinterpret_cast<const WGPUBufferHostMappedPointer*>(this);\n}\n\nstatic_assert(sizeof(BufferHostMappedPointer) == sizeof(WGPUBufferHostMappedPointer), \"sizeof mismatch for BufferHostMappedPointer\");\nstatic_assert(alignof(BufferHostMappedPointer) == alignof(WGPUBufferHostMappedPointer), \"alignof mismatch for BufferHostMappedPointer\");\nstatic_assert(offsetof(BufferHostMappedPointer, pointer) == offsetof(WGPUBufferHostMappedPointer, pointer),\n        \"offsetof mismatch for BufferHostMappedPointer::pointer\");\nstatic_assert(offsetof(BufferHostMappedPointer, disposeCallback) == offsetof(WGPUBufferHostMappedPointer, disposeCallback),\n        \"offsetof mismatch for BufferHostMappedPointer::disposeCallback\");\nstatic_assert(offsetof(BufferHostMappedPointer, userdata) == offsetof(WGPUBufferHostMappedPointer, userdata),\n        \"offsetof mismatch for BufferHostMappedPointer::userdata\");\n\n// BufferMapCallbackInfo implementation\n\nBufferMapCallbackInfo::operator const WGPUBufferMapCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUBufferMapCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(BufferMapCallbackInfo) == sizeof(WGPUBufferMapCallbackInfo), \"sizeof mismatch for BufferMapCallbackInfo\");\nstatic_assert(alignof(BufferMapCallbackInfo) == alignof(WGPUBufferMapCallbackInfo), \"alignof mismatch for BufferMapCallbackInfo\");\nstatic_assert(offsetof(BufferMapCallbackInfo, nextInChain) == offsetof(WGPUBufferMapCallbackInfo, nextInChain),\n        \"offsetof mismatch for BufferMapCallbackInfo::nextInChain\");\nstatic_assert(offsetof(BufferMapCallbackInfo, mode) == offsetof(WGPUBufferMapCallbackInfo, mode),\n        \"offsetof mismatch for BufferMapCallbackInfo::mode\");\nstatic_assert(offsetof(BufferMapCallbackInfo, callback) == offsetof(WGPUBufferMapCallbackInfo, callback),\n        \"offsetof mismatch for BufferMapCallbackInfo::callback\");\nstatic_assert(offsetof(BufferMapCallbackInfo, userdata) == offsetof(WGPUBufferMapCallbackInfo, userdata),\n        \"offsetof mismatch for BufferMapCallbackInfo::userdata\");\n\n// Color implementation\n\nColor::operator const WGPUColor&() const noexcept {\n    return *reinterpret_cast<const WGPUColor*>(this);\n}\n\nstatic_assert(sizeof(Color) == sizeof(WGPUColor), \"sizeof mismatch for Color\");\nstatic_assert(alignof(Color) == alignof(WGPUColor), \"alignof mismatch for Color\");\nstatic_assert(offsetof(Color, r) == offsetof(WGPUColor, r),\n        \"offsetof mismatch for Color::r\");\nstatic_assert(offsetof(Color, g) == offsetof(WGPUColor, g),\n        \"offsetof mismatch for Color::g\");\nstatic_assert(offsetof(Color, b) == offsetof(WGPUColor, b),\n        \"offsetof mismatch for Color::b\");\nstatic_assert(offsetof(Color, a) == offsetof(WGPUColor, a),\n        \"offsetof mismatch for Color::a\");\n\n// ColorTargetStateExpandResolveTextureDawn implementation\nColorTargetStateExpandResolveTextureDawn::ColorTargetStateExpandResolveTextureDawn()\n  : ChainedStruct { nullptr, SType::ColorTargetStateExpandResolveTextureDawn } {}\nstruct ColorTargetStateExpandResolveTextureDawn::Init {\n    ChainedStruct * const nextInChain;\n    Bool enabled = false;\n};\nColorTargetStateExpandResolveTextureDawn::ColorTargetStateExpandResolveTextureDawn(ColorTargetStateExpandResolveTextureDawn::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ColorTargetStateExpandResolveTextureDawn }, \n    enabled(std::move(init.enabled)){}\n\nColorTargetStateExpandResolveTextureDawn::operator const WGPUColorTargetStateExpandResolveTextureDawn&() const noexcept {\n    return *reinterpret_cast<const WGPUColorTargetStateExpandResolveTextureDawn*>(this);\n}\n\nstatic_assert(sizeof(ColorTargetStateExpandResolveTextureDawn) == sizeof(WGPUColorTargetStateExpandResolveTextureDawn), \"sizeof mismatch for ColorTargetStateExpandResolveTextureDawn\");\nstatic_assert(alignof(ColorTargetStateExpandResolveTextureDawn) == alignof(WGPUColorTargetStateExpandResolveTextureDawn), \"alignof mismatch for ColorTargetStateExpandResolveTextureDawn\");\nstatic_assert(offsetof(ColorTargetStateExpandResolveTextureDawn, enabled) == offsetof(WGPUColorTargetStateExpandResolveTextureDawn, enabled),\n        \"offsetof mismatch for ColorTargetStateExpandResolveTextureDawn::enabled\");\n\n// CompilationInfoCallbackInfo implementation\n\nCompilationInfoCallbackInfo::operator const WGPUCompilationInfoCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUCompilationInfoCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(CompilationInfoCallbackInfo) == sizeof(WGPUCompilationInfoCallbackInfo), \"sizeof mismatch for CompilationInfoCallbackInfo\");\nstatic_assert(alignof(CompilationInfoCallbackInfo) == alignof(WGPUCompilationInfoCallbackInfo), \"alignof mismatch for CompilationInfoCallbackInfo\");\nstatic_assert(offsetof(CompilationInfoCallbackInfo, nextInChain) == offsetof(WGPUCompilationInfoCallbackInfo, nextInChain),\n        \"offsetof mismatch for CompilationInfoCallbackInfo::nextInChain\");\nstatic_assert(offsetof(CompilationInfoCallbackInfo, mode) == offsetof(WGPUCompilationInfoCallbackInfo, mode),\n        \"offsetof mismatch for CompilationInfoCallbackInfo::mode\");\nstatic_assert(offsetof(CompilationInfoCallbackInfo, callback) == offsetof(WGPUCompilationInfoCallbackInfo, callback),\n        \"offsetof mismatch for CompilationInfoCallbackInfo::callback\");\nstatic_assert(offsetof(CompilationInfoCallbackInfo, userdata) == offsetof(WGPUCompilationInfoCallbackInfo, userdata),\n        \"offsetof mismatch for CompilationInfoCallbackInfo::userdata\");\n\n// ComputePassTimestampWrites implementation\n\nComputePassTimestampWrites::operator const WGPUComputePassTimestampWrites&() const noexcept {\n    return *reinterpret_cast<const WGPUComputePassTimestampWrites*>(this);\n}\n\nstatic_assert(sizeof(ComputePassTimestampWrites) == sizeof(WGPUComputePassTimestampWrites), \"sizeof mismatch for ComputePassTimestampWrites\");\nstatic_assert(alignof(ComputePassTimestampWrites) == alignof(WGPUComputePassTimestampWrites), \"alignof mismatch for ComputePassTimestampWrites\");\nstatic_assert(offsetof(ComputePassTimestampWrites, querySet) == offsetof(WGPUComputePassTimestampWrites, querySet),\n        \"offsetof mismatch for ComputePassTimestampWrites::querySet\");\nstatic_assert(offsetof(ComputePassTimestampWrites, beginningOfPassWriteIndex) == offsetof(WGPUComputePassTimestampWrites, beginningOfPassWriteIndex),\n        \"offsetof mismatch for ComputePassTimestampWrites::beginningOfPassWriteIndex\");\nstatic_assert(offsetof(ComputePassTimestampWrites, endOfPassWriteIndex) == offsetof(WGPUComputePassTimestampWrites, endOfPassWriteIndex),\n        \"offsetof mismatch for ComputePassTimestampWrites::endOfPassWriteIndex\");\n\n// CopyTextureForBrowserOptions implementation\n\nCopyTextureForBrowserOptions::operator const WGPUCopyTextureForBrowserOptions&() const noexcept {\n    return *reinterpret_cast<const WGPUCopyTextureForBrowserOptions*>(this);\n}\n\nstatic_assert(sizeof(CopyTextureForBrowserOptions) == sizeof(WGPUCopyTextureForBrowserOptions), \"sizeof mismatch for CopyTextureForBrowserOptions\");\nstatic_assert(alignof(CopyTextureForBrowserOptions) == alignof(WGPUCopyTextureForBrowserOptions), \"alignof mismatch for CopyTextureForBrowserOptions\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, nextInChain) == offsetof(WGPUCopyTextureForBrowserOptions, nextInChain),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::nextInChain\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, flipY) == offsetof(WGPUCopyTextureForBrowserOptions, flipY),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::flipY\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, needsColorSpaceConversion) == offsetof(WGPUCopyTextureForBrowserOptions, needsColorSpaceConversion),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::needsColorSpaceConversion\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, srcAlphaMode) == offsetof(WGPUCopyTextureForBrowserOptions, srcAlphaMode),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::srcAlphaMode\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, srcTransferFunctionParameters) == offsetof(WGPUCopyTextureForBrowserOptions, srcTransferFunctionParameters),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::srcTransferFunctionParameters\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, conversionMatrix) == offsetof(WGPUCopyTextureForBrowserOptions, conversionMatrix),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::conversionMatrix\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, dstTransferFunctionParameters) == offsetof(WGPUCopyTextureForBrowserOptions, dstTransferFunctionParameters),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::dstTransferFunctionParameters\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, dstAlphaMode) == offsetof(WGPUCopyTextureForBrowserOptions, dstAlphaMode),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::dstAlphaMode\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, internalUsage) == offsetof(WGPUCopyTextureForBrowserOptions, internalUsage),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::internalUsage\");\n\n// CreateComputePipelineAsyncCallbackInfo implementation\n\nCreateComputePipelineAsyncCallbackInfo::operator const WGPUCreateComputePipelineAsyncCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUCreateComputePipelineAsyncCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(CreateComputePipelineAsyncCallbackInfo) == sizeof(WGPUCreateComputePipelineAsyncCallbackInfo), \"sizeof mismatch for CreateComputePipelineAsyncCallbackInfo\");\nstatic_assert(alignof(CreateComputePipelineAsyncCallbackInfo) == alignof(WGPUCreateComputePipelineAsyncCallbackInfo), \"alignof mismatch for CreateComputePipelineAsyncCallbackInfo\");\nstatic_assert(offsetof(CreateComputePipelineAsyncCallbackInfo, nextInChain) == offsetof(WGPUCreateComputePipelineAsyncCallbackInfo, nextInChain),\n        \"offsetof mismatch for CreateComputePipelineAsyncCallbackInfo::nextInChain\");\nstatic_assert(offsetof(CreateComputePipelineAsyncCallbackInfo, mode) == offsetof(WGPUCreateComputePipelineAsyncCallbackInfo, mode),\n        \"offsetof mismatch for CreateComputePipelineAsyncCallbackInfo::mode\");\nstatic_assert(offsetof(CreateComputePipelineAsyncCallbackInfo, callback) == offsetof(WGPUCreateComputePipelineAsyncCallbackInfo, callback),\n        \"offsetof mismatch for CreateComputePipelineAsyncCallbackInfo::callback\");\nstatic_assert(offsetof(CreateComputePipelineAsyncCallbackInfo, userdata) == offsetof(WGPUCreateComputePipelineAsyncCallbackInfo, userdata),\n        \"offsetof mismatch for CreateComputePipelineAsyncCallbackInfo::userdata\");\n\n// CreateRenderPipelineAsyncCallbackInfo implementation\n\nCreateRenderPipelineAsyncCallbackInfo::operator const WGPUCreateRenderPipelineAsyncCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUCreateRenderPipelineAsyncCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(CreateRenderPipelineAsyncCallbackInfo) == sizeof(WGPUCreateRenderPipelineAsyncCallbackInfo), \"sizeof mismatch for CreateRenderPipelineAsyncCallbackInfo\");\nstatic_assert(alignof(CreateRenderPipelineAsyncCallbackInfo) == alignof(WGPUCreateRenderPipelineAsyncCallbackInfo), \"alignof mismatch for CreateRenderPipelineAsyncCallbackInfo\");\nstatic_assert(offsetof(CreateRenderPipelineAsyncCallbackInfo, nextInChain) == offsetof(WGPUCreateRenderPipelineAsyncCallbackInfo, nextInChain),\n        \"offsetof mismatch for CreateRenderPipelineAsyncCallbackInfo::nextInChain\");\nstatic_assert(offsetof(CreateRenderPipelineAsyncCallbackInfo, mode) == offsetof(WGPUCreateRenderPipelineAsyncCallbackInfo, mode),\n        \"offsetof mismatch for CreateRenderPipelineAsyncCallbackInfo::mode\");\nstatic_assert(offsetof(CreateRenderPipelineAsyncCallbackInfo, callback) == offsetof(WGPUCreateRenderPipelineAsyncCallbackInfo, callback),\n        \"offsetof mismatch for CreateRenderPipelineAsyncCallbackInfo::callback\");\nstatic_assert(offsetof(CreateRenderPipelineAsyncCallbackInfo, userdata) == offsetof(WGPUCreateRenderPipelineAsyncCallbackInfo, userdata),\n        \"offsetof mismatch for CreateRenderPipelineAsyncCallbackInfo::userdata\");\n\n// DawnWGSLBlocklist implementation\nDawnWGSLBlocklist::DawnWGSLBlocklist()\n  : ChainedStruct { nullptr, SType::DawnWGSLBlocklist } {}\nstruct DawnWGSLBlocklist::Init {\n    ChainedStruct * const nextInChain;\n    size_t blocklistedFeatureCount = 0;\n    const char* const * blocklistedFeatures;\n};\nDawnWGSLBlocklist::DawnWGSLBlocklist(DawnWGSLBlocklist::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnWGSLBlocklist }, \n    blocklistedFeatureCount(std::move(init.blocklistedFeatureCount)), \n    blocklistedFeatures(std::move(init.blocklistedFeatures)){}\n\nDawnWGSLBlocklist::operator const WGPUDawnWGSLBlocklist&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnWGSLBlocklist*>(this);\n}\n\nstatic_assert(sizeof(DawnWGSLBlocklist) == sizeof(WGPUDawnWGSLBlocklist), \"sizeof mismatch for DawnWGSLBlocklist\");\nstatic_assert(alignof(DawnWGSLBlocklist) == alignof(WGPUDawnWGSLBlocklist), \"alignof mismatch for DawnWGSLBlocklist\");\nstatic_assert(offsetof(DawnWGSLBlocklist, blocklistedFeatureCount) == offsetof(WGPUDawnWGSLBlocklist, blocklistedFeatureCount),\n        \"offsetof mismatch for DawnWGSLBlocklist::blocklistedFeatureCount\");\nstatic_assert(offsetof(DawnWGSLBlocklist, blocklistedFeatures) == offsetof(WGPUDawnWGSLBlocklist, blocklistedFeatures),\n        \"offsetof mismatch for DawnWGSLBlocklist::blocklistedFeatures\");\n\n// DawnAdapterPropertiesPowerPreference implementation\nDawnAdapterPropertiesPowerPreference::DawnAdapterPropertiesPowerPreference()\n  : ChainedStructOut { nullptr, SType::DawnAdapterPropertiesPowerPreference } {}\nstruct DawnAdapterPropertiesPowerPreference::Init {\n    ChainedStructOut *  nextInChain;\n    PowerPreference powerPreference = PowerPreference::Undefined;\n};\nDawnAdapterPropertiesPowerPreference::DawnAdapterPropertiesPowerPreference(DawnAdapterPropertiesPowerPreference::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DawnAdapterPropertiesPowerPreference }, \n    powerPreference(std::move(init.powerPreference)){}\n\nDawnAdapterPropertiesPowerPreference::operator const WGPUDawnAdapterPropertiesPowerPreference&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnAdapterPropertiesPowerPreference*>(this);\n}\n\nstatic_assert(sizeof(DawnAdapterPropertiesPowerPreference) == sizeof(WGPUDawnAdapterPropertiesPowerPreference), \"sizeof mismatch for DawnAdapterPropertiesPowerPreference\");\nstatic_assert(alignof(DawnAdapterPropertiesPowerPreference) == alignof(WGPUDawnAdapterPropertiesPowerPreference), \"alignof mismatch for DawnAdapterPropertiesPowerPreference\");\nstatic_assert(offsetof(DawnAdapterPropertiesPowerPreference, powerPreference) == offsetof(WGPUDawnAdapterPropertiesPowerPreference, powerPreference),\n        \"offsetof mismatch for DawnAdapterPropertiesPowerPreference::powerPreference\");\n\n// DawnBufferDescriptorErrorInfoFromWireClient implementation\nDawnBufferDescriptorErrorInfoFromWireClient::DawnBufferDescriptorErrorInfoFromWireClient()\n  : ChainedStruct { nullptr, SType::DawnBufferDescriptorErrorInfoFromWireClient } {}\nstruct DawnBufferDescriptorErrorInfoFromWireClient::Init {\n    ChainedStruct * const nextInChain;\n    Bool outOfMemory = false;\n};\nDawnBufferDescriptorErrorInfoFromWireClient::DawnBufferDescriptorErrorInfoFromWireClient(DawnBufferDescriptorErrorInfoFromWireClient::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnBufferDescriptorErrorInfoFromWireClient }, \n    outOfMemory(std::move(init.outOfMemory)){}\n\nDawnBufferDescriptorErrorInfoFromWireClient::operator const WGPUDawnBufferDescriptorErrorInfoFromWireClient&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnBufferDescriptorErrorInfoFromWireClient*>(this);\n}\n\nstatic_assert(sizeof(DawnBufferDescriptorErrorInfoFromWireClient) == sizeof(WGPUDawnBufferDescriptorErrorInfoFromWireClient), \"sizeof mismatch for DawnBufferDescriptorErrorInfoFromWireClient\");\nstatic_assert(alignof(DawnBufferDescriptorErrorInfoFromWireClient) == alignof(WGPUDawnBufferDescriptorErrorInfoFromWireClient), \"alignof mismatch for DawnBufferDescriptorErrorInfoFromWireClient\");\nstatic_assert(offsetof(DawnBufferDescriptorErrorInfoFromWireClient, outOfMemory) == offsetof(WGPUDawnBufferDescriptorErrorInfoFromWireClient, outOfMemory),\n        \"offsetof mismatch for DawnBufferDescriptorErrorInfoFromWireClient::outOfMemory\");\n\n// DawnEncoderInternalUsageDescriptor implementation\nDawnEncoderInternalUsageDescriptor::DawnEncoderInternalUsageDescriptor()\n  : ChainedStruct { nullptr, SType::DawnEncoderInternalUsageDescriptor } {}\nstruct DawnEncoderInternalUsageDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    Bool useInternalUsages = false;\n};\nDawnEncoderInternalUsageDescriptor::DawnEncoderInternalUsageDescriptor(DawnEncoderInternalUsageDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnEncoderInternalUsageDescriptor }, \n    useInternalUsages(std::move(init.useInternalUsages)){}\n\nDawnEncoderInternalUsageDescriptor::operator const WGPUDawnEncoderInternalUsageDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnEncoderInternalUsageDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnEncoderInternalUsageDescriptor) == sizeof(WGPUDawnEncoderInternalUsageDescriptor), \"sizeof mismatch for DawnEncoderInternalUsageDescriptor\");\nstatic_assert(alignof(DawnEncoderInternalUsageDescriptor) == alignof(WGPUDawnEncoderInternalUsageDescriptor), \"alignof mismatch for DawnEncoderInternalUsageDescriptor\");\nstatic_assert(offsetof(DawnEncoderInternalUsageDescriptor, useInternalUsages) == offsetof(WGPUDawnEncoderInternalUsageDescriptor, useInternalUsages),\n        \"offsetof mismatch for DawnEncoderInternalUsageDescriptor::useInternalUsages\");\n\n// DawnExperimentalImmediateDataLimits implementation\nDawnExperimentalImmediateDataLimits::DawnExperimentalImmediateDataLimits()\n  : ChainedStructOut { nullptr, SType::DawnExperimentalImmediateDataLimits } {}\nstruct DawnExperimentalImmediateDataLimits::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t maxImmediateDataRangeByteSize = WGPU_LIMIT_U32_UNDEFINED;\n};\nDawnExperimentalImmediateDataLimits::DawnExperimentalImmediateDataLimits(DawnExperimentalImmediateDataLimits::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DawnExperimentalImmediateDataLimits }, \n    maxImmediateDataRangeByteSize(std::move(init.maxImmediateDataRangeByteSize)){}\n\nDawnExperimentalImmediateDataLimits::operator const WGPUDawnExperimentalImmediateDataLimits&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnExperimentalImmediateDataLimits*>(this);\n}\n\nstatic_assert(sizeof(DawnExperimentalImmediateDataLimits) == sizeof(WGPUDawnExperimentalImmediateDataLimits), \"sizeof mismatch for DawnExperimentalImmediateDataLimits\");\nstatic_assert(alignof(DawnExperimentalImmediateDataLimits) == alignof(WGPUDawnExperimentalImmediateDataLimits), \"alignof mismatch for DawnExperimentalImmediateDataLimits\");\nstatic_assert(offsetof(DawnExperimentalImmediateDataLimits, maxImmediateDataRangeByteSize) == offsetof(WGPUDawnExperimentalImmediateDataLimits, maxImmediateDataRangeByteSize),\n        \"offsetof mismatch for DawnExperimentalImmediateDataLimits::maxImmediateDataRangeByteSize\");\n\n// DawnExperimentalSubgroupLimits implementation\nDawnExperimentalSubgroupLimits::DawnExperimentalSubgroupLimits()\n  : ChainedStructOut { nullptr, SType::DawnExperimentalSubgroupLimits } {}\nstruct DawnExperimentalSubgroupLimits::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t minSubgroupSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxSubgroupSize = WGPU_LIMIT_U32_UNDEFINED;\n};\nDawnExperimentalSubgroupLimits::DawnExperimentalSubgroupLimits(DawnExperimentalSubgroupLimits::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DawnExperimentalSubgroupLimits }, \n    minSubgroupSize(std::move(init.minSubgroupSize)), \n    maxSubgroupSize(std::move(init.maxSubgroupSize)){}\n\nDawnExperimentalSubgroupLimits::operator const WGPUDawnExperimentalSubgroupLimits&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnExperimentalSubgroupLimits*>(this);\n}\n\nstatic_assert(sizeof(DawnExperimentalSubgroupLimits) == sizeof(WGPUDawnExperimentalSubgroupLimits), \"sizeof mismatch for DawnExperimentalSubgroupLimits\");\nstatic_assert(alignof(DawnExperimentalSubgroupLimits) == alignof(WGPUDawnExperimentalSubgroupLimits), \"alignof mismatch for DawnExperimentalSubgroupLimits\");\nstatic_assert(offsetof(DawnExperimentalSubgroupLimits, minSubgroupSize) == offsetof(WGPUDawnExperimentalSubgroupLimits, minSubgroupSize),\n        \"offsetof mismatch for DawnExperimentalSubgroupLimits::minSubgroupSize\");\nstatic_assert(offsetof(DawnExperimentalSubgroupLimits, maxSubgroupSize) == offsetof(WGPUDawnExperimentalSubgroupLimits, maxSubgroupSize),\n        \"offsetof mismatch for DawnExperimentalSubgroupLimits::maxSubgroupSize\");\n\n// DawnRenderPassColorAttachmentRenderToSingleSampled implementation\nDawnRenderPassColorAttachmentRenderToSingleSampled::DawnRenderPassColorAttachmentRenderToSingleSampled()\n  : ChainedStruct { nullptr, SType::DawnRenderPassColorAttachmentRenderToSingleSampled } {}\nstruct DawnRenderPassColorAttachmentRenderToSingleSampled::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t implicitSampleCount = 1;\n};\nDawnRenderPassColorAttachmentRenderToSingleSampled::DawnRenderPassColorAttachmentRenderToSingleSampled(DawnRenderPassColorAttachmentRenderToSingleSampled::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnRenderPassColorAttachmentRenderToSingleSampled }, \n    implicitSampleCount(std::move(init.implicitSampleCount)){}\n\nDawnRenderPassColorAttachmentRenderToSingleSampled::operator const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled*>(this);\n}\n\nstatic_assert(sizeof(DawnRenderPassColorAttachmentRenderToSingleSampled) == sizeof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled), \"sizeof mismatch for DawnRenderPassColorAttachmentRenderToSingleSampled\");\nstatic_assert(alignof(DawnRenderPassColorAttachmentRenderToSingleSampled) == alignof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled), \"alignof mismatch for DawnRenderPassColorAttachmentRenderToSingleSampled\");\nstatic_assert(offsetof(DawnRenderPassColorAttachmentRenderToSingleSampled, implicitSampleCount) == offsetof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled, implicitSampleCount),\n        \"offsetof mismatch for DawnRenderPassColorAttachmentRenderToSingleSampled::implicitSampleCount\");\n\n// DawnShaderModuleSPIRVOptionsDescriptor implementation\nDawnShaderModuleSPIRVOptionsDescriptor::DawnShaderModuleSPIRVOptionsDescriptor()\n  : ChainedStruct { nullptr, SType::DawnShaderModuleSPIRVOptionsDescriptor } {}\nstruct DawnShaderModuleSPIRVOptionsDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    Bool allowNonUniformDerivatives = false;\n};\nDawnShaderModuleSPIRVOptionsDescriptor::DawnShaderModuleSPIRVOptionsDescriptor(DawnShaderModuleSPIRVOptionsDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnShaderModuleSPIRVOptionsDescriptor }, \n    allowNonUniformDerivatives(std::move(init.allowNonUniformDerivatives)){}\n\nDawnShaderModuleSPIRVOptionsDescriptor::operator const WGPUDawnShaderModuleSPIRVOptionsDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnShaderModuleSPIRVOptionsDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnShaderModuleSPIRVOptionsDescriptor) == sizeof(WGPUDawnShaderModuleSPIRVOptionsDescriptor), \"sizeof mismatch for DawnShaderModuleSPIRVOptionsDescriptor\");\nstatic_assert(alignof(DawnShaderModuleSPIRVOptionsDescriptor) == alignof(WGPUDawnShaderModuleSPIRVOptionsDescriptor), \"alignof mismatch for DawnShaderModuleSPIRVOptionsDescriptor\");\nstatic_assert(offsetof(DawnShaderModuleSPIRVOptionsDescriptor, allowNonUniformDerivatives) == offsetof(WGPUDawnShaderModuleSPIRVOptionsDescriptor, allowNonUniformDerivatives),\n        \"offsetof mismatch for DawnShaderModuleSPIRVOptionsDescriptor::allowNonUniformDerivatives\");\n\n// DawnTexelCopyBufferRowAlignmentLimits implementation\nDawnTexelCopyBufferRowAlignmentLimits::DawnTexelCopyBufferRowAlignmentLimits()\n  : ChainedStructOut { nullptr, SType::DawnTexelCopyBufferRowAlignmentLimits } {}\nstruct DawnTexelCopyBufferRowAlignmentLimits::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t minTexelCopyBufferRowAlignment = WGPU_LIMIT_U32_UNDEFINED;\n};\nDawnTexelCopyBufferRowAlignmentLimits::DawnTexelCopyBufferRowAlignmentLimits(DawnTexelCopyBufferRowAlignmentLimits::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DawnTexelCopyBufferRowAlignmentLimits }, \n    minTexelCopyBufferRowAlignment(std::move(init.minTexelCopyBufferRowAlignment)){}\n\nDawnTexelCopyBufferRowAlignmentLimits::operator const WGPUDawnTexelCopyBufferRowAlignmentLimits&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnTexelCopyBufferRowAlignmentLimits*>(this);\n}\n\nstatic_assert(sizeof(DawnTexelCopyBufferRowAlignmentLimits) == sizeof(WGPUDawnTexelCopyBufferRowAlignmentLimits), \"sizeof mismatch for DawnTexelCopyBufferRowAlignmentLimits\");\nstatic_assert(alignof(DawnTexelCopyBufferRowAlignmentLimits) == alignof(WGPUDawnTexelCopyBufferRowAlignmentLimits), \"alignof mismatch for DawnTexelCopyBufferRowAlignmentLimits\");\nstatic_assert(offsetof(DawnTexelCopyBufferRowAlignmentLimits, minTexelCopyBufferRowAlignment) == offsetof(WGPUDawnTexelCopyBufferRowAlignmentLimits, minTexelCopyBufferRowAlignment),\n        \"offsetof mismatch for DawnTexelCopyBufferRowAlignmentLimits::minTexelCopyBufferRowAlignment\");\n\n// DawnTextureInternalUsageDescriptor implementation\nDawnTextureInternalUsageDescriptor::DawnTextureInternalUsageDescriptor()\n  : ChainedStruct { nullptr, SType::DawnTextureInternalUsageDescriptor } {}\nstruct DawnTextureInternalUsageDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    TextureUsage internalUsage = TextureUsage::None;\n};\nDawnTextureInternalUsageDescriptor::DawnTextureInternalUsageDescriptor(DawnTextureInternalUsageDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnTextureInternalUsageDescriptor }, \n    internalUsage(std::move(init.internalUsage)){}\n\nDawnTextureInternalUsageDescriptor::operator const WGPUDawnTextureInternalUsageDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnTextureInternalUsageDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnTextureInternalUsageDescriptor) == sizeof(WGPUDawnTextureInternalUsageDescriptor), \"sizeof mismatch for DawnTextureInternalUsageDescriptor\");\nstatic_assert(alignof(DawnTextureInternalUsageDescriptor) == alignof(WGPUDawnTextureInternalUsageDescriptor), \"alignof mismatch for DawnTextureInternalUsageDescriptor\");\nstatic_assert(offsetof(DawnTextureInternalUsageDescriptor, internalUsage) == offsetof(WGPUDawnTextureInternalUsageDescriptor, internalUsage),\n        \"offsetof mismatch for DawnTextureInternalUsageDescriptor::internalUsage\");\n\n// DawnTogglesDescriptor implementation\nDawnTogglesDescriptor::DawnTogglesDescriptor()\n  : ChainedStruct { nullptr, SType::DawnTogglesDescriptor } {}\nstruct DawnTogglesDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    size_t enabledToggleCount = 0;\n    const char* const * enabledToggles;\n    size_t disabledToggleCount = 0;\n    const char* const * disabledToggles;\n};\nDawnTogglesDescriptor::DawnTogglesDescriptor(DawnTogglesDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnTogglesDescriptor }, \n    enabledToggleCount(std::move(init.enabledToggleCount)), \n    enabledToggles(std::move(init.enabledToggles)), \n    disabledToggleCount(std::move(init.disabledToggleCount)), \n    disabledToggles(std::move(init.disabledToggles)){}\n\nDawnTogglesDescriptor::operator const WGPUDawnTogglesDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnTogglesDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnTogglesDescriptor) == sizeof(WGPUDawnTogglesDescriptor), \"sizeof mismatch for DawnTogglesDescriptor\");\nstatic_assert(alignof(DawnTogglesDescriptor) == alignof(WGPUDawnTogglesDescriptor), \"alignof mismatch for DawnTogglesDescriptor\");\nstatic_assert(offsetof(DawnTogglesDescriptor, enabledToggleCount) == offsetof(WGPUDawnTogglesDescriptor, enabledToggleCount),\n        \"offsetof mismatch for DawnTogglesDescriptor::enabledToggleCount\");\nstatic_assert(offsetof(DawnTogglesDescriptor, enabledToggles) == offsetof(WGPUDawnTogglesDescriptor, enabledToggles),\n        \"offsetof mismatch for DawnTogglesDescriptor::enabledToggles\");\nstatic_assert(offsetof(DawnTogglesDescriptor, disabledToggleCount) == offsetof(WGPUDawnTogglesDescriptor, disabledToggleCount),\n        \"offsetof mismatch for DawnTogglesDescriptor::disabledToggleCount\");\nstatic_assert(offsetof(DawnTogglesDescriptor, disabledToggles) == offsetof(WGPUDawnTogglesDescriptor, disabledToggles),\n        \"offsetof mismatch for DawnTogglesDescriptor::disabledToggles\");\n\n// DawnWireWGSLControl implementation\nDawnWireWGSLControl::DawnWireWGSLControl()\n  : ChainedStruct { nullptr, SType::DawnWireWGSLControl } {}\nstruct DawnWireWGSLControl::Init {\n    ChainedStruct * const nextInChain;\n    Bool enableExperimental = false;\n    Bool enableUnsafe = false;\n    Bool enableTesting = false;\n};\nDawnWireWGSLControl::DawnWireWGSLControl(DawnWireWGSLControl::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnWireWGSLControl }, \n    enableExperimental(std::move(init.enableExperimental)), \n    enableUnsafe(std::move(init.enableUnsafe)), \n    enableTesting(std::move(init.enableTesting)){}\n\nDawnWireWGSLControl::operator const WGPUDawnWireWGSLControl&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnWireWGSLControl*>(this);\n}\n\nstatic_assert(sizeof(DawnWireWGSLControl) == sizeof(WGPUDawnWireWGSLControl), \"sizeof mismatch for DawnWireWGSLControl\");\nstatic_assert(alignof(DawnWireWGSLControl) == alignof(WGPUDawnWireWGSLControl), \"alignof mismatch for DawnWireWGSLControl\");\nstatic_assert(offsetof(DawnWireWGSLControl, enableExperimental) == offsetof(WGPUDawnWireWGSLControl, enableExperimental),\n        \"offsetof mismatch for DawnWireWGSLControl::enableExperimental\");\nstatic_assert(offsetof(DawnWireWGSLControl, enableUnsafe) == offsetof(WGPUDawnWireWGSLControl, enableUnsafe),\n        \"offsetof mismatch for DawnWireWGSLControl::enableUnsafe\");\nstatic_assert(offsetof(DawnWireWGSLControl, enableTesting) == offsetof(WGPUDawnWireWGSLControl, enableTesting),\n        \"offsetof mismatch for DawnWireWGSLControl::enableTesting\");\n\n// DeviceLostCallbackInfo implementation\n\nDeviceLostCallbackInfo::operator const WGPUDeviceLostCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUDeviceLostCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(DeviceLostCallbackInfo) == sizeof(WGPUDeviceLostCallbackInfo), \"sizeof mismatch for DeviceLostCallbackInfo\");\nstatic_assert(alignof(DeviceLostCallbackInfo) == alignof(WGPUDeviceLostCallbackInfo), \"alignof mismatch for DeviceLostCallbackInfo\");\nstatic_assert(offsetof(DeviceLostCallbackInfo, nextInChain) == offsetof(WGPUDeviceLostCallbackInfo, nextInChain),\n        \"offsetof mismatch for DeviceLostCallbackInfo::nextInChain\");\nstatic_assert(offsetof(DeviceLostCallbackInfo, mode) == offsetof(WGPUDeviceLostCallbackInfo, mode),\n        \"offsetof mismatch for DeviceLostCallbackInfo::mode\");\nstatic_assert(offsetof(DeviceLostCallbackInfo, callback) == offsetof(WGPUDeviceLostCallbackInfo, callback),\n        \"offsetof mismatch for DeviceLostCallbackInfo::callback\");\nstatic_assert(offsetof(DeviceLostCallbackInfo, userdata) == offsetof(WGPUDeviceLostCallbackInfo, userdata),\n        \"offsetof mismatch for DeviceLostCallbackInfo::userdata\");\n\n// DrmFormatProperties implementation\n\nDrmFormatProperties::operator const WGPUDrmFormatProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUDrmFormatProperties*>(this);\n}\n\nstatic_assert(sizeof(DrmFormatProperties) == sizeof(WGPUDrmFormatProperties), \"sizeof mismatch for DrmFormatProperties\");\nstatic_assert(alignof(DrmFormatProperties) == alignof(WGPUDrmFormatProperties), \"alignof mismatch for DrmFormatProperties\");\nstatic_assert(offsetof(DrmFormatProperties, modifier) == offsetof(WGPUDrmFormatProperties, modifier),\n        \"offsetof mismatch for DrmFormatProperties::modifier\");\nstatic_assert(offsetof(DrmFormatProperties, modifierPlaneCount) == offsetof(WGPUDrmFormatProperties, modifierPlaneCount),\n        \"offsetof mismatch for DrmFormatProperties::modifierPlaneCount\");\n\n// Extent2D implementation\n\nExtent2D::operator const WGPUExtent2D&() const noexcept {\n    return *reinterpret_cast<const WGPUExtent2D*>(this);\n}\n\nstatic_assert(sizeof(Extent2D) == sizeof(WGPUExtent2D), \"sizeof mismatch for Extent2D\");\nstatic_assert(alignof(Extent2D) == alignof(WGPUExtent2D), \"alignof mismatch for Extent2D\");\nstatic_assert(offsetof(Extent2D, width) == offsetof(WGPUExtent2D, width),\n        \"offsetof mismatch for Extent2D::width\");\nstatic_assert(offsetof(Extent2D, height) == offsetof(WGPUExtent2D, height),\n        \"offsetof mismatch for Extent2D::height\");\n\n// Extent3D implementation\n\nExtent3D::operator const WGPUExtent3D&() const noexcept {\n    return *reinterpret_cast<const WGPUExtent3D*>(this);\n}\n\nstatic_assert(sizeof(Extent3D) == sizeof(WGPUExtent3D), \"sizeof mismatch for Extent3D\");\nstatic_assert(alignof(Extent3D) == alignof(WGPUExtent3D), \"alignof mismatch for Extent3D\");\nstatic_assert(offsetof(Extent3D, width) == offsetof(WGPUExtent3D, width),\n        \"offsetof mismatch for Extent3D::width\");\nstatic_assert(offsetof(Extent3D, height) == offsetof(WGPUExtent3D, height),\n        \"offsetof mismatch for Extent3D::height\");\nstatic_assert(offsetof(Extent3D, depthOrArrayLayers) == offsetof(WGPUExtent3D, depthOrArrayLayers),\n        \"offsetof mismatch for Extent3D::depthOrArrayLayers\");\n\n// ExternalTextureBindingEntry implementation\nExternalTextureBindingEntry::ExternalTextureBindingEntry()\n  : ChainedStruct { nullptr, SType::ExternalTextureBindingEntry } {}\nstruct ExternalTextureBindingEntry::Init {\n    ChainedStruct * const nextInChain;\n    ExternalTexture externalTexture;\n};\nExternalTextureBindingEntry::ExternalTextureBindingEntry(ExternalTextureBindingEntry::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ExternalTextureBindingEntry }, \n    externalTexture(std::move(init.externalTexture)){}\n\nExternalTextureBindingEntry::operator const WGPUExternalTextureBindingEntry&() const noexcept {\n    return *reinterpret_cast<const WGPUExternalTextureBindingEntry*>(this);\n}\n\nstatic_assert(sizeof(ExternalTextureBindingEntry) == sizeof(WGPUExternalTextureBindingEntry), \"sizeof mismatch for ExternalTextureBindingEntry\");\nstatic_assert(alignof(ExternalTextureBindingEntry) == alignof(WGPUExternalTextureBindingEntry), \"alignof mismatch for ExternalTextureBindingEntry\");\nstatic_assert(offsetof(ExternalTextureBindingEntry, externalTexture) == offsetof(WGPUExternalTextureBindingEntry, externalTexture),\n        \"offsetof mismatch for ExternalTextureBindingEntry::externalTexture\");\n\n// ExternalTextureBindingLayout implementation\nExternalTextureBindingLayout::ExternalTextureBindingLayout()\n  : ChainedStruct { nullptr, SType::ExternalTextureBindingLayout } {}\nstruct ExternalTextureBindingLayout::Init {\n    ChainedStruct * const nextInChain;\n};\nExternalTextureBindingLayout::ExternalTextureBindingLayout(ExternalTextureBindingLayout::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ExternalTextureBindingLayout }{}\n\nExternalTextureBindingLayout::operator const WGPUExternalTextureBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUExternalTextureBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(ExternalTextureBindingLayout) == sizeof(WGPUExternalTextureBindingLayout), \"sizeof mismatch for ExternalTextureBindingLayout\");\nstatic_assert(alignof(ExternalTextureBindingLayout) == alignof(WGPUExternalTextureBindingLayout), \"alignof mismatch for ExternalTextureBindingLayout\");\n\n// FormatCapabilities implementation\n\nFormatCapabilities::operator const WGPUFormatCapabilities&() const noexcept {\n    return *reinterpret_cast<const WGPUFormatCapabilities*>(this);\n}\n\nstatic_assert(sizeof(FormatCapabilities) == sizeof(WGPUFormatCapabilities), \"sizeof mismatch for FormatCapabilities\");\nstatic_assert(alignof(FormatCapabilities) == alignof(WGPUFormatCapabilities), \"alignof mismatch for FormatCapabilities\");\nstatic_assert(offsetof(FormatCapabilities, nextInChain) == offsetof(WGPUFormatCapabilities, nextInChain),\n        \"offsetof mismatch for FormatCapabilities::nextInChain\");\n\n// Future implementation\n\nFuture::operator const WGPUFuture&() const noexcept {\n    return *reinterpret_cast<const WGPUFuture*>(this);\n}\n\nstatic_assert(sizeof(Future) == sizeof(WGPUFuture), \"sizeof mismatch for Future\");\nstatic_assert(alignof(Future) == alignof(WGPUFuture), \"alignof mismatch for Future\");\nstatic_assert(offsetof(Future, id) == offsetof(WGPUFuture, id),\n        \"offsetof mismatch for Future::id\");\n\n// InstanceFeatures implementation\n\nInstanceFeatures::operator const WGPUInstanceFeatures&() const noexcept {\n    return *reinterpret_cast<const WGPUInstanceFeatures*>(this);\n}\n\nstatic_assert(sizeof(InstanceFeatures) == sizeof(WGPUInstanceFeatures), \"sizeof mismatch for InstanceFeatures\");\nstatic_assert(alignof(InstanceFeatures) == alignof(WGPUInstanceFeatures), \"alignof mismatch for InstanceFeatures\");\nstatic_assert(offsetof(InstanceFeatures, nextInChain) == offsetof(WGPUInstanceFeatures, nextInChain),\n        \"offsetof mismatch for InstanceFeatures::nextInChain\");\nstatic_assert(offsetof(InstanceFeatures, timedWaitAnyEnable) == offsetof(WGPUInstanceFeatures, timedWaitAnyEnable),\n        \"offsetof mismatch for InstanceFeatures::timedWaitAnyEnable\");\nstatic_assert(offsetof(InstanceFeatures, timedWaitAnyMaxCount) == offsetof(WGPUInstanceFeatures, timedWaitAnyMaxCount),\n        \"offsetof mismatch for InstanceFeatures::timedWaitAnyMaxCount\");\n\n// Limits implementation\n\nLimits::operator const WGPULimits&() const noexcept {\n    return *reinterpret_cast<const WGPULimits*>(this);\n}\n\nstatic_assert(sizeof(Limits) == sizeof(WGPULimits), \"sizeof mismatch for Limits\");\nstatic_assert(alignof(Limits) == alignof(WGPULimits), \"alignof mismatch for Limits\");\nstatic_assert(offsetof(Limits, maxTextureDimension1D) == offsetof(WGPULimits, maxTextureDimension1D),\n        \"offsetof mismatch for Limits::maxTextureDimension1D\");\nstatic_assert(offsetof(Limits, maxTextureDimension2D) == offsetof(WGPULimits, maxTextureDimension2D),\n        \"offsetof mismatch for Limits::maxTextureDimension2D\");\nstatic_assert(offsetof(Limits, maxTextureDimension3D) == offsetof(WGPULimits, maxTextureDimension3D),\n        \"offsetof mismatch for Limits::maxTextureDimension3D\");\nstatic_assert(offsetof(Limits, maxTextureArrayLayers) == offsetof(WGPULimits, maxTextureArrayLayers),\n        \"offsetof mismatch for Limits::maxTextureArrayLayers\");\nstatic_assert(offsetof(Limits, maxBindGroups) == offsetof(WGPULimits, maxBindGroups),\n        \"offsetof mismatch for Limits::maxBindGroups\");\nstatic_assert(offsetof(Limits, maxBindGroupsPlusVertexBuffers) == offsetof(WGPULimits, maxBindGroupsPlusVertexBuffers),\n        \"offsetof mismatch for Limits::maxBindGroupsPlusVertexBuffers\");\nstatic_assert(offsetof(Limits, maxBindingsPerBindGroup) == offsetof(WGPULimits, maxBindingsPerBindGroup),\n        \"offsetof mismatch for Limits::maxBindingsPerBindGroup\");\nstatic_assert(offsetof(Limits, maxDynamicUniformBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicUniformBuffersPerPipelineLayout),\n        \"offsetof mismatch for Limits::maxDynamicUniformBuffersPerPipelineLayout\");\nstatic_assert(offsetof(Limits, maxDynamicStorageBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicStorageBuffersPerPipelineLayout),\n        \"offsetof mismatch for Limits::maxDynamicStorageBuffersPerPipelineLayout\");\nstatic_assert(offsetof(Limits, maxSampledTexturesPerShaderStage) == offsetof(WGPULimits, maxSampledTexturesPerShaderStage),\n        \"offsetof mismatch for Limits::maxSampledTexturesPerShaderStage\");\nstatic_assert(offsetof(Limits, maxSamplersPerShaderStage) == offsetof(WGPULimits, maxSamplersPerShaderStage),\n        \"offsetof mismatch for Limits::maxSamplersPerShaderStage\");\nstatic_assert(offsetof(Limits, maxStorageBuffersPerShaderStage) == offsetof(WGPULimits, maxStorageBuffersPerShaderStage),\n        \"offsetof mismatch for Limits::maxStorageBuffersPerShaderStage\");\nstatic_assert(offsetof(Limits, maxStorageTexturesPerShaderStage) == offsetof(WGPULimits, maxStorageTexturesPerShaderStage),\n        \"offsetof mismatch for Limits::maxStorageTexturesPerShaderStage\");\nstatic_assert(offsetof(Limits, maxUniformBuffersPerShaderStage) == offsetof(WGPULimits, maxUniformBuffersPerShaderStage),\n        \"offsetof mismatch for Limits::maxUniformBuffersPerShaderStage\");\nstatic_assert(offsetof(Limits, maxUniformBufferBindingSize) == offsetof(WGPULimits, maxUniformBufferBindingSize),\n        \"offsetof mismatch for Limits::maxUniformBufferBindingSize\");\nstatic_assert(offsetof(Limits, maxStorageBufferBindingSize) == offsetof(WGPULimits, maxStorageBufferBindingSize),\n        \"offsetof mismatch for Limits::maxStorageBufferBindingSize\");\nstatic_assert(offsetof(Limits, minUniformBufferOffsetAlignment) == offsetof(WGPULimits, minUniformBufferOffsetAlignment),\n        \"offsetof mismatch for Limits::minUniformBufferOffsetAlignment\");\nstatic_assert(offsetof(Limits, minStorageBufferOffsetAlignment) == offsetof(WGPULimits, minStorageBufferOffsetAlignment),\n        \"offsetof mismatch for Limits::minStorageBufferOffsetAlignment\");\nstatic_assert(offsetof(Limits, maxVertexBuffers) == offsetof(WGPULimits, maxVertexBuffers),\n        \"offsetof mismatch for Limits::maxVertexBuffers\");\nstatic_assert(offsetof(Limits, maxBufferSize) == offsetof(WGPULimits, maxBufferSize),\n        \"offsetof mismatch for Limits::maxBufferSize\");\nstatic_assert(offsetof(Limits, maxVertexAttributes) == offsetof(WGPULimits, maxVertexAttributes),\n        \"offsetof mismatch for Limits::maxVertexAttributes\");\nstatic_assert(offsetof(Limits, maxVertexBufferArrayStride) == offsetof(WGPULimits, maxVertexBufferArrayStride),\n        \"offsetof mismatch for Limits::maxVertexBufferArrayStride\");\nstatic_assert(offsetof(Limits, maxInterStageShaderComponents) == offsetof(WGPULimits, maxInterStageShaderComponents),\n        \"offsetof mismatch for Limits::maxInterStageShaderComponents\");\nstatic_assert(offsetof(Limits, maxInterStageShaderVariables) == offsetof(WGPULimits, maxInterStageShaderVariables),\n        \"offsetof mismatch for Limits::maxInterStageShaderVariables\");\nstatic_assert(offsetof(Limits, maxColorAttachments) == offsetof(WGPULimits, maxColorAttachments),\n        \"offsetof mismatch for Limits::maxColorAttachments\");\nstatic_assert(offsetof(Limits, maxColorAttachmentBytesPerSample) == offsetof(WGPULimits, maxColorAttachmentBytesPerSample),\n        \"offsetof mismatch for Limits::maxColorAttachmentBytesPerSample\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupStorageSize) == offsetof(WGPULimits, maxComputeWorkgroupStorageSize),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupStorageSize\");\nstatic_assert(offsetof(Limits, maxComputeInvocationsPerWorkgroup) == offsetof(WGPULimits, maxComputeInvocationsPerWorkgroup),\n        \"offsetof mismatch for Limits::maxComputeInvocationsPerWorkgroup\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupSizeX) == offsetof(WGPULimits, maxComputeWorkgroupSizeX),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupSizeX\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupSizeY) == offsetof(WGPULimits, maxComputeWorkgroupSizeY),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupSizeY\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupSizeZ) == offsetof(WGPULimits, maxComputeWorkgroupSizeZ),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupSizeZ\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupsPerDimension) == offsetof(WGPULimits, maxComputeWorkgroupsPerDimension),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupsPerDimension\");\n\n// MemoryHeapInfo implementation\n\nMemoryHeapInfo::operator const WGPUMemoryHeapInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUMemoryHeapInfo*>(this);\n}\n\nstatic_assert(sizeof(MemoryHeapInfo) == sizeof(WGPUMemoryHeapInfo), \"sizeof mismatch for MemoryHeapInfo\");\nstatic_assert(alignof(MemoryHeapInfo) == alignof(WGPUMemoryHeapInfo), \"alignof mismatch for MemoryHeapInfo\");\nstatic_assert(offsetof(MemoryHeapInfo, properties) == offsetof(WGPUMemoryHeapInfo, properties),\n        \"offsetof mismatch for MemoryHeapInfo::properties\");\nstatic_assert(offsetof(MemoryHeapInfo, size) == offsetof(WGPUMemoryHeapInfo, size),\n        \"offsetof mismatch for MemoryHeapInfo::size\");\n\n// MultisampleState implementation\n\nMultisampleState::operator const WGPUMultisampleState&() const noexcept {\n    return *reinterpret_cast<const WGPUMultisampleState*>(this);\n}\n\nstatic_assert(sizeof(MultisampleState) == sizeof(WGPUMultisampleState), \"sizeof mismatch for MultisampleState\");\nstatic_assert(alignof(MultisampleState) == alignof(WGPUMultisampleState), \"alignof mismatch for MultisampleState\");\nstatic_assert(offsetof(MultisampleState, nextInChain) == offsetof(WGPUMultisampleState, nextInChain),\n        \"offsetof mismatch for MultisampleState::nextInChain\");\nstatic_assert(offsetof(MultisampleState, count) == offsetof(WGPUMultisampleState, count),\n        \"offsetof mismatch for MultisampleState::count\");\nstatic_assert(offsetof(MultisampleState, mask) == offsetof(WGPUMultisampleState, mask),\n        \"offsetof mismatch for MultisampleState::mask\");\nstatic_assert(offsetof(MultisampleState, alphaToCoverageEnabled) == offsetof(WGPUMultisampleState, alphaToCoverageEnabled),\n        \"offsetof mismatch for MultisampleState::alphaToCoverageEnabled\");\n\n// Origin2D implementation\n\nOrigin2D::operator const WGPUOrigin2D&() const noexcept {\n    return *reinterpret_cast<const WGPUOrigin2D*>(this);\n}\n\nstatic_assert(sizeof(Origin2D) == sizeof(WGPUOrigin2D), \"sizeof mismatch for Origin2D\");\nstatic_assert(alignof(Origin2D) == alignof(WGPUOrigin2D), \"alignof mismatch for Origin2D\");\nstatic_assert(offsetof(Origin2D, x) == offsetof(WGPUOrigin2D, x),\n        \"offsetof mismatch for Origin2D::x\");\nstatic_assert(offsetof(Origin2D, y) == offsetof(WGPUOrigin2D, y),\n        \"offsetof mismatch for Origin2D::y\");\n\n// Origin3D implementation\n\nOrigin3D::operator const WGPUOrigin3D&() const noexcept {\n    return *reinterpret_cast<const WGPUOrigin3D*>(this);\n}\n\nstatic_assert(sizeof(Origin3D) == sizeof(WGPUOrigin3D), \"sizeof mismatch for Origin3D\");\nstatic_assert(alignof(Origin3D) == alignof(WGPUOrigin3D), \"alignof mismatch for Origin3D\");\nstatic_assert(offsetof(Origin3D, x) == offsetof(WGPUOrigin3D, x),\n        \"offsetof mismatch for Origin3D::x\");\nstatic_assert(offsetof(Origin3D, y) == offsetof(WGPUOrigin3D, y),\n        \"offsetof mismatch for Origin3D::y\");\nstatic_assert(offsetof(Origin3D, z) == offsetof(WGPUOrigin3D, z),\n        \"offsetof mismatch for Origin3D::z\");\n\n// PipelineLayoutStorageAttachment implementation\n\nPipelineLayoutStorageAttachment::operator const WGPUPipelineLayoutStorageAttachment&() const noexcept {\n    return *reinterpret_cast<const WGPUPipelineLayoutStorageAttachment*>(this);\n}\n\nstatic_assert(sizeof(PipelineLayoutStorageAttachment) == sizeof(WGPUPipelineLayoutStorageAttachment), \"sizeof mismatch for PipelineLayoutStorageAttachment\");\nstatic_assert(alignof(PipelineLayoutStorageAttachment) == alignof(WGPUPipelineLayoutStorageAttachment), \"alignof mismatch for PipelineLayoutStorageAttachment\");\nstatic_assert(offsetof(PipelineLayoutStorageAttachment, nextInChain) == offsetof(WGPUPipelineLayoutStorageAttachment, nextInChain),\n        \"offsetof mismatch for PipelineLayoutStorageAttachment::nextInChain\");\nstatic_assert(offsetof(PipelineLayoutStorageAttachment, offset) == offsetof(WGPUPipelineLayoutStorageAttachment, offset),\n        \"offsetof mismatch for PipelineLayoutStorageAttachment::offset\");\nstatic_assert(offsetof(PipelineLayoutStorageAttachment, format) == offsetof(WGPUPipelineLayoutStorageAttachment, format),\n        \"offsetof mismatch for PipelineLayoutStorageAttachment::format\");\n\n// PopErrorScopeCallbackInfo implementation\n\nPopErrorScopeCallbackInfo::operator const WGPUPopErrorScopeCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUPopErrorScopeCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(PopErrorScopeCallbackInfo) == sizeof(WGPUPopErrorScopeCallbackInfo), \"sizeof mismatch for PopErrorScopeCallbackInfo\");\nstatic_assert(alignof(PopErrorScopeCallbackInfo) == alignof(WGPUPopErrorScopeCallbackInfo), \"alignof mismatch for PopErrorScopeCallbackInfo\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, nextInChain) == offsetof(WGPUPopErrorScopeCallbackInfo, nextInChain),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::nextInChain\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, mode) == offsetof(WGPUPopErrorScopeCallbackInfo, mode),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::mode\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, callback) == offsetof(WGPUPopErrorScopeCallbackInfo, callback),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::callback\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, oldCallback) == offsetof(WGPUPopErrorScopeCallbackInfo, oldCallback),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::oldCallback\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, userdata) == offsetof(WGPUPopErrorScopeCallbackInfo, userdata),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::userdata\");\n\n// PrimitiveState implementation\n\nPrimitiveState::operator const WGPUPrimitiveState&() const noexcept {\n    return *reinterpret_cast<const WGPUPrimitiveState*>(this);\n}\n\nstatic_assert(sizeof(PrimitiveState) == sizeof(WGPUPrimitiveState), \"sizeof mismatch for PrimitiveState\");\nstatic_assert(alignof(PrimitiveState) == alignof(WGPUPrimitiveState), \"alignof mismatch for PrimitiveState\");\nstatic_assert(offsetof(PrimitiveState, nextInChain) == offsetof(WGPUPrimitiveState, nextInChain),\n        \"offsetof mismatch for PrimitiveState::nextInChain\");\nstatic_assert(offsetof(PrimitiveState, topology) == offsetof(WGPUPrimitiveState, topology),\n        \"offsetof mismatch for PrimitiveState::topology\");\nstatic_assert(offsetof(PrimitiveState, stripIndexFormat) == offsetof(WGPUPrimitiveState, stripIndexFormat),\n        \"offsetof mismatch for PrimitiveState::stripIndexFormat\");\nstatic_assert(offsetof(PrimitiveState, frontFace) == offsetof(WGPUPrimitiveState, frontFace),\n        \"offsetof mismatch for PrimitiveState::frontFace\");\nstatic_assert(offsetof(PrimitiveState, cullMode) == offsetof(WGPUPrimitiveState, cullMode),\n        \"offsetof mismatch for PrimitiveState::cullMode\");\nstatic_assert(offsetof(PrimitiveState, unclippedDepth) == offsetof(WGPUPrimitiveState, unclippedDepth),\n        \"offsetof mismatch for PrimitiveState::unclippedDepth\");\n\n// QueueWorkDoneCallbackInfo implementation\n\nQueueWorkDoneCallbackInfo::operator const WGPUQueueWorkDoneCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUQueueWorkDoneCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(QueueWorkDoneCallbackInfo) == sizeof(WGPUQueueWorkDoneCallbackInfo), \"sizeof mismatch for QueueWorkDoneCallbackInfo\");\nstatic_assert(alignof(QueueWorkDoneCallbackInfo) == alignof(WGPUQueueWorkDoneCallbackInfo), \"alignof mismatch for QueueWorkDoneCallbackInfo\");\nstatic_assert(offsetof(QueueWorkDoneCallbackInfo, nextInChain) == offsetof(WGPUQueueWorkDoneCallbackInfo, nextInChain),\n        \"offsetof mismatch for QueueWorkDoneCallbackInfo::nextInChain\");\nstatic_assert(offsetof(QueueWorkDoneCallbackInfo, mode) == offsetof(WGPUQueueWorkDoneCallbackInfo, mode),\n        \"offsetof mismatch for QueueWorkDoneCallbackInfo::mode\");\nstatic_assert(offsetof(QueueWorkDoneCallbackInfo, callback) == offsetof(WGPUQueueWorkDoneCallbackInfo, callback),\n        \"offsetof mismatch for QueueWorkDoneCallbackInfo::callback\");\nstatic_assert(offsetof(QueueWorkDoneCallbackInfo, userdata) == offsetof(WGPUQueueWorkDoneCallbackInfo, userdata),\n        \"offsetof mismatch for QueueWorkDoneCallbackInfo::userdata\");\n\n// RenderPassDepthStencilAttachment implementation\n\nRenderPassDepthStencilAttachment::operator const WGPURenderPassDepthStencilAttachment&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassDepthStencilAttachment*>(this);\n}\n\nstatic_assert(sizeof(RenderPassDepthStencilAttachment) == sizeof(WGPURenderPassDepthStencilAttachment), \"sizeof mismatch for RenderPassDepthStencilAttachment\");\nstatic_assert(alignof(RenderPassDepthStencilAttachment) == alignof(WGPURenderPassDepthStencilAttachment), \"alignof mismatch for RenderPassDepthStencilAttachment\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, view) == offsetof(WGPURenderPassDepthStencilAttachment, view),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::view\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, depthLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthLoadOp),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::depthLoadOp\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, depthStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthStoreOp),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::depthStoreOp\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, depthClearValue) == offsetof(WGPURenderPassDepthStencilAttachment, depthClearValue),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::depthClearValue\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, depthReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, depthReadOnly),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::depthReadOnly\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, stencilLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilLoadOp),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilLoadOp\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, stencilStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilStoreOp),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilStoreOp\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, stencilClearValue) == offsetof(WGPURenderPassDepthStencilAttachment, stencilClearValue),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilClearValue\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, stencilReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, stencilReadOnly),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilReadOnly\");\n\n// RenderPassDescriptorExpandResolveRect implementation\nRenderPassDescriptorExpandResolveRect::RenderPassDescriptorExpandResolveRect()\n  : ChainedStruct { nullptr, SType::RenderPassDescriptorExpandResolveRect } {}\nstruct RenderPassDescriptorExpandResolveRect::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t x;\n    uint32_t y;\n    uint32_t width;\n    uint32_t height;\n};\nRenderPassDescriptorExpandResolveRect::RenderPassDescriptorExpandResolveRect(RenderPassDescriptorExpandResolveRect::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::RenderPassDescriptorExpandResolveRect }, \n    x(std::move(init.x)), \n    y(std::move(init.y)), \n    width(std::move(init.width)), \n    height(std::move(init.height)){}\n\nRenderPassDescriptorExpandResolveRect::operator const WGPURenderPassDescriptorExpandResolveRect&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassDescriptorExpandResolveRect*>(this);\n}\n\nstatic_assert(sizeof(RenderPassDescriptorExpandResolveRect) == sizeof(WGPURenderPassDescriptorExpandResolveRect), \"sizeof mismatch for RenderPassDescriptorExpandResolveRect\");\nstatic_assert(alignof(RenderPassDescriptorExpandResolveRect) == alignof(WGPURenderPassDescriptorExpandResolveRect), \"alignof mismatch for RenderPassDescriptorExpandResolveRect\");\nstatic_assert(offsetof(RenderPassDescriptorExpandResolveRect, x) == offsetof(WGPURenderPassDescriptorExpandResolveRect, x),\n        \"offsetof mismatch for RenderPassDescriptorExpandResolveRect::x\");\nstatic_assert(offsetof(RenderPassDescriptorExpandResolveRect, y) == offsetof(WGPURenderPassDescriptorExpandResolveRect, y),\n        \"offsetof mismatch for RenderPassDescriptorExpandResolveRect::y\");\nstatic_assert(offsetof(RenderPassDescriptorExpandResolveRect, width) == offsetof(WGPURenderPassDescriptorExpandResolveRect, width),\n        \"offsetof mismatch for RenderPassDescriptorExpandResolveRect::width\");\nstatic_assert(offsetof(RenderPassDescriptorExpandResolveRect, height) == offsetof(WGPURenderPassDescriptorExpandResolveRect, height),\n        \"offsetof mismatch for RenderPassDescriptorExpandResolveRect::height\");\n\n// RenderPassMaxDrawCount implementation\nRenderPassMaxDrawCount::RenderPassMaxDrawCount()\n  : ChainedStruct { nullptr, SType::RenderPassMaxDrawCount } {}\nstruct RenderPassMaxDrawCount::Init {\n    ChainedStruct * const nextInChain;\n    uint64_t maxDrawCount = 50000000;\n};\nRenderPassMaxDrawCount::RenderPassMaxDrawCount(RenderPassMaxDrawCount::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::RenderPassMaxDrawCount }, \n    maxDrawCount(std::move(init.maxDrawCount)){}\n\nRenderPassMaxDrawCount::operator const WGPURenderPassMaxDrawCount&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassMaxDrawCount*>(this);\n}\n\nstatic_assert(sizeof(RenderPassMaxDrawCount) == sizeof(WGPURenderPassMaxDrawCount), \"sizeof mismatch for RenderPassMaxDrawCount\");\nstatic_assert(alignof(RenderPassMaxDrawCount) == alignof(WGPURenderPassMaxDrawCount), \"alignof mismatch for RenderPassMaxDrawCount\");\nstatic_assert(offsetof(RenderPassMaxDrawCount, maxDrawCount) == offsetof(WGPURenderPassMaxDrawCount, maxDrawCount),\n        \"offsetof mismatch for RenderPassMaxDrawCount::maxDrawCount\");\n\n// RenderPassTimestampWrites implementation\n\nRenderPassTimestampWrites::operator const WGPURenderPassTimestampWrites&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassTimestampWrites*>(this);\n}\n\nstatic_assert(sizeof(RenderPassTimestampWrites) == sizeof(WGPURenderPassTimestampWrites), \"sizeof mismatch for RenderPassTimestampWrites\");\nstatic_assert(alignof(RenderPassTimestampWrites) == alignof(WGPURenderPassTimestampWrites), \"alignof mismatch for RenderPassTimestampWrites\");\nstatic_assert(offsetof(RenderPassTimestampWrites, querySet) == offsetof(WGPURenderPassTimestampWrites, querySet),\n        \"offsetof mismatch for RenderPassTimestampWrites::querySet\");\nstatic_assert(offsetof(RenderPassTimestampWrites, beginningOfPassWriteIndex) == offsetof(WGPURenderPassTimestampWrites, beginningOfPassWriteIndex),\n        \"offsetof mismatch for RenderPassTimestampWrites::beginningOfPassWriteIndex\");\nstatic_assert(offsetof(RenderPassTimestampWrites, endOfPassWriteIndex) == offsetof(WGPURenderPassTimestampWrites, endOfPassWriteIndex),\n        \"offsetof mismatch for RenderPassTimestampWrites::endOfPassWriteIndex\");\n\n// RequestAdapterCallbackInfo implementation\n\nRequestAdapterCallbackInfo::operator const WGPURequestAdapterCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPURequestAdapterCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(RequestAdapterCallbackInfo) == sizeof(WGPURequestAdapterCallbackInfo), \"sizeof mismatch for RequestAdapterCallbackInfo\");\nstatic_assert(alignof(RequestAdapterCallbackInfo) == alignof(WGPURequestAdapterCallbackInfo), \"alignof mismatch for RequestAdapterCallbackInfo\");\nstatic_assert(offsetof(RequestAdapterCallbackInfo, nextInChain) == offsetof(WGPURequestAdapterCallbackInfo, nextInChain),\n        \"offsetof mismatch for RequestAdapterCallbackInfo::nextInChain\");\nstatic_assert(offsetof(RequestAdapterCallbackInfo, mode) == offsetof(WGPURequestAdapterCallbackInfo, mode),\n        \"offsetof mismatch for RequestAdapterCallbackInfo::mode\");\nstatic_assert(offsetof(RequestAdapterCallbackInfo, callback) == offsetof(WGPURequestAdapterCallbackInfo, callback),\n        \"offsetof mismatch for RequestAdapterCallbackInfo::callback\");\nstatic_assert(offsetof(RequestAdapterCallbackInfo, userdata) == offsetof(WGPURequestAdapterCallbackInfo, userdata),\n        \"offsetof mismatch for RequestAdapterCallbackInfo::userdata\");\n\n// RequestAdapterOptions implementation\n\nRequestAdapterOptions::operator const WGPURequestAdapterOptions&() const noexcept {\n    return *reinterpret_cast<const WGPURequestAdapterOptions*>(this);\n}\n\nstatic_assert(sizeof(RequestAdapterOptions) == sizeof(WGPURequestAdapterOptions), \"sizeof mismatch for RequestAdapterOptions\");\nstatic_assert(alignof(RequestAdapterOptions) == alignof(WGPURequestAdapterOptions), \"alignof mismatch for RequestAdapterOptions\");\nstatic_assert(offsetof(RequestAdapterOptions, nextInChain) == offsetof(WGPURequestAdapterOptions, nextInChain),\n        \"offsetof mismatch for RequestAdapterOptions::nextInChain\");\nstatic_assert(offsetof(RequestAdapterOptions, compatibleSurface) == offsetof(WGPURequestAdapterOptions, compatibleSurface),\n        \"offsetof mismatch for RequestAdapterOptions::compatibleSurface\");\nstatic_assert(offsetof(RequestAdapterOptions, powerPreference) == offsetof(WGPURequestAdapterOptions, powerPreference),\n        \"offsetof mismatch for RequestAdapterOptions::powerPreference\");\nstatic_assert(offsetof(RequestAdapterOptions, backendType) == offsetof(WGPURequestAdapterOptions, backendType),\n        \"offsetof mismatch for RequestAdapterOptions::backendType\");\nstatic_assert(offsetof(RequestAdapterOptions, forceFallbackAdapter) == offsetof(WGPURequestAdapterOptions, forceFallbackAdapter),\n        \"offsetof mismatch for RequestAdapterOptions::forceFallbackAdapter\");\nstatic_assert(offsetof(RequestAdapterOptions, compatibilityMode) == offsetof(WGPURequestAdapterOptions, compatibilityMode),\n        \"offsetof mismatch for RequestAdapterOptions::compatibilityMode\");\n\n// RequestDeviceCallbackInfo implementation\n\nRequestDeviceCallbackInfo::operator const WGPURequestDeviceCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPURequestDeviceCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(RequestDeviceCallbackInfo) == sizeof(WGPURequestDeviceCallbackInfo), \"sizeof mismatch for RequestDeviceCallbackInfo\");\nstatic_assert(alignof(RequestDeviceCallbackInfo) == alignof(WGPURequestDeviceCallbackInfo), \"alignof mismatch for RequestDeviceCallbackInfo\");\nstatic_assert(offsetof(RequestDeviceCallbackInfo, nextInChain) == offsetof(WGPURequestDeviceCallbackInfo, nextInChain),\n        \"offsetof mismatch for RequestDeviceCallbackInfo::nextInChain\");\nstatic_assert(offsetof(RequestDeviceCallbackInfo, mode) == offsetof(WGPURequestDeviceCallbackInfo, mode),\n        \"offsetof mismatch for RequestDeviceCallbackInfo::mode\");\nstatic_assert(offsetof(RequestDeviceCallbackInfo, callback) == offsetof(WGPURequestDeviceCallbackInfo, callback),\n        \"offsetof mismatch for RequestDeviceCallbackInfo::callback\");\nstatic_assert(offsetof(RequestDeviceCallbackInfo, userdata) == offsetof(WGPURequestDeviceCallbackInfo, userdata),\n        \"offsetof mismatch for RequestDeviceCallbackInfo::userdata\");\n\n// SamplerBindingLayout implementation\n\nSamplerBindingLayout::operator const WGPUSamplerBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUSamplerBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(SamplerBindingLayout) == sizeof(WGPUSamplerBindingLayout), \"sizeof mismatch for SamplerBindingLayout\");\nstatic_assert(alignof(SamplerBindingLayout) == alignof(WGPUSamplerBindingLayout), \"alignof mismatch for SamplerBindingLayout\");\nstatic_assert(offsetof(SamplerBindingLayout, nextInChain) == offsetof(WGPUSamplerBindingLayout, nextInChain),\n        \"offsetof mismatch for SamplerBindingLayout::nextInChain\");\nstatic_assert(offsetof(SamplerBindingLayout, type) == offsetof(WGPUSamplerBindingLayout, type),\n        \"offsetof mismatch for SamplerBindingLayout::type\");\n\n// ShaderModuleCompilationOptions implementation\nShaderModuleCompilationOptions::ShaderModuleCompilationOptions()\n  : ChainedStruct { nullptr, SType::ShaderModuleCompilationOptions } {}\nstruct ShaderModuleCompilationOptions::Init {\n    ChainedStruct * const nextInChain;\n    Bool strictMath;\n};\nShaderModuleCompilationOptions::ShaderModuleCompilationOptions(ShaderModuleCompilationOptions::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ShaderModuleCompilationOptions }, \n    strictMath(std::move(init.strictMath)){}\n\nShaderModuleCompilationOptions::operator const WGPUShaderModuleCompilationOptions&() const noexcept {\n    return *reinterpret_cast<const WGPUShaderModuleCompilationOptions*>(this);\n}\n\nstatic_assert(sizeof(ShaderModuleCompilationOptions) == sizeof(WGPUShaderModuleCompilationOptions), \"sizeof mismatch for ShaderModuleCompilationOptions\");\nstatic_assert(alignof(ShaderModuleCompilationOptions) == alignof(WGPUShaderModuleCompilationOptions), \"alignof mismatch for ShaderModuleCompilationOptions\");\nstatic_assert(offsetof(ShaderModuleCompilationOptions, strictMath) == offsetof(WGPUShaderModuleCompilationOptions, strictMath),\n        \"offsetof mismatch for ShaderModuleCompilationOptions::strictMath\");\n\n// ShaderSourceSPIRV implementation\nShaderSourceSPIRV::ShaderSourceSPIRV()\n  : ChainedStruct { nullptr, SType::ShaderSourceSPIRV } {}\nstruct ShaderSourceSPIRV::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t codeSize;\n    uint32_t const * code;\n};\nShaderSourceSPIRV::ShaderSourceSPIRV(ShaderSourceSPIRV::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ShaderSourceSPIRV }, \n    codeSize(std::move(init.codeSize)), \n    code(std::move(init.code)){}\n\nShaderSourceSPIRV::operator const WGPUShaderSourceSPIRV&() const noexcept {\n    return *reinterpret_cast<const WGPUShaderSourceSPIRV*>(this);\n}\n\nstatic_assert(sizeof(ShaderSourceSPIRV) == sizeof(WGPUShaderSourceSPIRV), \"sizeof mismatch for ShaderSourceSPIRV\");\nstatic_assert(alignof(ShaderSourceSPIRV) == alignof(WGPUShaderSourceSPIRV), \"alignof mismatch for ShaderSourceSPIRV\");\nstatic_assert(offsetof(ShaderSourceSPIRV, codeSize) == offsetof(WGPUShaderSourceSPIRV, codeSize),\n        \"offsetof mismatch for ShaderSourceSPIRV::codeSize\");\nstatic_assert(offsetof(ShaderSourceSPIRV, code) == offsetof(WGPUShaderSourceSPIRV, code),\n        \"offsetof mismatch for ShaderSourceSPIRV::code\");\n\n// SharedBufferMemoryBeginAccessDescriptor implementation\n\nSharedBufferMemoryBeginAccessDescriptor::operator const WGPUSharedBufferMemoryBeginAccessDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedBufferMemoryBeginAccessDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedBufferMemoryBeginAccessDescriptor) == sizeof(WGPUSharedBufferMemoryBeginAccessDescriptor), \"sizeof mismatch for SharedBufferMemoryBeginAccessDescriptor\");\nstatic_assert(alignof(SharedBufferMemoryBeginAccessDescriptor) == alignof(WGPUSharedBufferMemoryBeginAccessDescriptor), \"alignof mismatch for SharedBufferMemoryBeginAccessDescriptor\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, nextInChain) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, nextInChain),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, initialized) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, initialized),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::initialized\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, fenceCount) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, fenceCount),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::fenceCount\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, fences) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, fences),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::fences\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, signaledValues) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, signaledValues),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::signaledValues\");\n\n// SharedBufferMemoryEndAccessState implementation\nSharedBufferMemoryEndAccessState::SharedBufferMemoryEndAccessState() = default;\nSharedBufferMemoryEndAccessState::~SharedBufferMemoryEndAccessState() {\n    FreeMembers();\n}\n\nSharedBufferMemoryEndAccessState::SharedBufferMemoryEndAccessState(SharedBufferMemoryEndAccessState&& rhs)\n    : initialized(rhs.initialized),\n            fenceCount(rhs.fenceCount),\n            fences(rhs.fences),\n            signaledValues(rhs.signaledValues){\n    Reset(rhs);\n}\n\nSharedBufferMemoryEndAccessState& SharedBufferMemoryEndAccessState::operator=(SharedBufferMemoryEndAccessState&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->initialized) = std::move(rhs.initialized);\n    detail::AsNonConstReference(this->fenceCount) = std::move(rhs.fenceCount);\n    detail::AsNonConstReference(this->fences) = std::move(rhs.fences);\n    detail::AsNonConstReference(this->signaledValues) = std::move(rhs.signaledValues);\n    Reset(rhs);\n    return *this;\n}\n\nvoid SharedBufferMemoryEndAccessState::FreeMembers() {\n    bool needsFreeing = false;    if (this->fences != nullptr) { needsFreeing = true; }    if (this->signaledValues != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuSharedBufferMemoryEndAccessStateFreeMembers(\n            *reinterpret_cast<WGPUSharedBufferMemoryEndAccessState*>(this));\n    }\n}\n\n// static\nvoid SharedBufferMemoryEndAccessState::Reset(SharedBufferMemoryEndAccessState& value) {\n    SharedBufferMemoryEndAccessState defaultValue{};\n    detail::AsNonConstReference(value.initialized) = defaultValue.initialized;\n    detail::AsNonConstReference(value.fenceCount) = defaultValue.fenceCount;\n    detail::AsNonConstReference(value.fences) = defaultValue.fences;\n    detail::AsNonConstReference(value.signaledValues) = defaultValue.signaledValues;\n}\n\nSharedBufferMemoryEndAccessState::operator const WGPUSharedBufferMemoryEndAccessState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedBufferMemoryEndAccessState*>(this);\n}\n\nstatic_assert(sizeof(SharedBufferMemoryEndAccessState) == sizeof(WGPUSharedBufferMemoryEndAccessState), \"sizeof mismatch for SharedBufferMemoryEndAccessState\");\nstatic_assert(alignof(SharedBufferMemoryEndAccessState) == alignof(WGPUSharedBufferMemoryEndAccessState), \"alignof mismatch for SharedBufferMemoryEndAccessState\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, nextInChain) == offsetof(WGPUSharedBufferMemoryEndAccessState, nextInChain),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::nextInChain\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, initialized) == offsetof(WGPUSharedBufferMemoryEndAccessState, initialized),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::initialized\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, fenceCount) == offsetof(WGPUSharedBufferMemoryEndAccessState, fenceCount),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::fenceCount\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, fences) == offsetof(WGPUSharedBufferMemoryEndAccessState, fences),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::fences\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, signaledValues) == offsetof(WGPUSharedBufferMemoryEndAccessState, signaledValues),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::signaledValues\");\n\n// SharedBufferMemoryProperties implementation\n\nSharedBufferMemoryProperties::operator const WGPUSharedBufferMemoryProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedBufferMemoryProperties*>(this);\n}\n\nstatic_assert(sizeof(SharedBufferMemoryProperties) == sizeof(WGPUSharedBufferMemoryProperties), \"sizeof mismatch for SharedBufferMemoryProperties\");\nstatic_assert(alignof(SharedBufferMemoryProperties) == alignof(WGPUSharedBufferMemoryProperties), \"alignof mismatch for SharedBufferMemoryProperties\");\nstatic_assert(offsetof(SharedBufferMemoryProperties, nextInChain) == offsetof(WGPUSharedBufferMemoryProperties, nextInChain),\n        \"offsetof mismatch for SharedBufferMemoryProperties::nextInChain\");\nstatic_assert(offsetof(SharedBufferMemoryProperties, usage) == offsetof(WGPUSharedBufferMemoryProperties, usage),\n        \"offsetof mismatch for SharedBufferMemoryProperties::usage\");\nstatic_assert(offsetof(SharedBufferMemoryProperties, size) == offsetof(WGPUSharedBufferMemoryProperties, size),\n        \"offsetof mismatch for SharedBufferMemoryProperties::size\");\n\n// SharedFenceDXGISharedHandleDescriptor implementation\nSharedFenceDXGISharedHandleDescriptor::SharedFenceDXGISharedHandleDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceDXGISharedHandleDescriptor } {}\nstruct SharedFenceDXGISharedHandleDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * handle;\n};\nSharedFenceDXGISharedHandleDescriptor::SharedFenceDXGISharedHandleDescriptor(SharedFenceDXGISharedHandleDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceDXGISharedHandleDescriptor }, \n    handle(std::move(init.handle)){}\n\nSharedFenceDXGISharedHandleDescriptor::operator const WGPUSharedFenceDXGISharedHandleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceDXGISharedHandleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceDXGISharedHandleDescriptor) == sizeof(WGPUSharedFenceDXGISharedHandleDescriptor), \"sizeof mismatch for SharedFenceDXGISharedHandleDescriptor\");\nstatic_assert(alignof(SharedFenceDXGISharedHandleDescriptor) == alignof(WGPUSharedFenceDXGISharedHandleDescriptor), \"alignof mismatch for SharedFenceDXGISharedHandleDescriptor\");\nstatic_assert(offsetof(SharedFenceDXGISharedHandleDescriptor, handle) == offsetof(WGPUSharedFenceDXGISharedHandleDescriptor, handle),\n        \"offsetof mismatch for SharedFenceDXGISharedHandleDescriptor::handle\");\n\n// SharedFenceDXGISharedHandleExportInfo implementation\nSharedFenceDXGISharedHandleExportInfo::SharedFenceDXGISharedHandleExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceDXGISharedHandleExportInfo } {}\nstruct SharedFenceDXGISharedHandleExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    void * handle;\n};\nSharedFenceDXGISharedHandleExportInfo::SharedFenceDXGISharedHandleExportInfo(SharedFenceDXGISharedHandleExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceDXGISharedHandleExportInfo }, \n    handle(std::move(init.handle)){}\n\nSharedFenceDXGISharedHandleExportInfo::operator const WGPUSharedFenceDXGISharedHandleExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceDXGISharedHandleExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceDXGISharedHandleExportInfo) == sizeof(WGPUSharedFenceDXGISharedHandleExportInfo), \"sizeof mismatch for SharedFenceDXGISharedHandleExportInfo\");\nstatic_assert(alignof(SharedFenceDXGISharedHandleExportInfo) == alignof(WGPUSharedFenceDXGISharedHandleExportInfo), \"alignof mismatch for SharedFenceDXGISharedHandleExportInfo\");\nstatic_assert(offsetof(SharedFenceDXGISharedHandleExportInfo, handle) == offsetof(WGPUSharedFenceDXGISharedHandleExportInfo, handle),\n        \"offsetof mismatch for SharedFenceDXGISharedHandleExportInfo::handle\");\n\n// SharedFenceMTLSharedEventDescriptor implementation\nSharedFenceMTLSharedEventDescriptor::SharedFenceMTLSharedEventDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceMTLSharedEventDescriptor } {}\nstruct SharedFenceMTLSharedEventDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * sharedEvent;\n};\nSharedFenceMTLSharedEventDescriptor::SharedFenceMTLSharedEventDescriptor(SharedFenceMTLSharedEventDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceMTLSharedEventDescriptor }, \n    sharedEvent(std::move(init.sharedEvent)){}\n\nSharedFenceMTLSharedEventDescriptor::operator const WGPUSharedFenceMTLSharedEventDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceMTLSharedEventDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceMTLSharedEventDescriptor) == sizeof(WGPUSharedFenceMTLSharedEventDescriptor), \"sizeof mismatch for SharedFenceMTLSharedEventDescriptor\");\nstatic_assert(alignof(SharedFenceMTLSharedEventDescriptor) == alignof(WGPUSharedFenceMTLSharedEventDescriptor), \"alignof mismatch for SharedFenceMTLSharedEventDescriptor\");\nstatic_assert(offsetof(SharedFenceMTLSharedEventDescriptor, sharedEvent) == offsetof(WGPUSharedFenceMTLSharedEventDescriptor, sharedEvent),\n        \"offsetof mismatch for SharedFenceMTLSharedEventDescriptor::sharedEvent\");\n\n// SharedFenceMTLSharedEventExportInfo implementation\nSharedFenceMTLSharedEventExportInfo::SharedFenceMTLSharedEventExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceMTLSharedEventExportInfo } {}\nstruct SharedFenceMTLSharedEventExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    void * sharedEvent;\n};\nSharedFenceMTLSharedEventExportInfo::SharedFenceMTLSharedEventExportInfo(SharedFenceMTLSharedEventExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceMTLSharedEventExportInfo }, \n    sharedEvent(std::move(init.sharedEvent)){}\n\nSharedFenceMTLSharedEventExportInfo::operator const WGPUSharedFenceMTLSharedEventExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceMTLSharedEventExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceMTLSharedEventExportInfo) == sizeof(WGPUSharedFenceMTLSharedEventExportInfo), \"sizeof mismatch for SharedFenceMTLSharedEventExportInfo\");\nstatic_assert(alignof(SharedFenceMTLSharedEventExportInfo) == alignof(WGPUSharedFenceMTLSharedEventExportInfo), \"alignof mismatch for SharedFenceMTLSharedEventExportInfo\");\nstatic_assert(offsetof(SharedFenceMTLSharedEventExportInfo, sharedEvent) == offsetof(WGPUSharedFenceMTLSharedEventExportInfo, sharedEvent),\n        \"offsetof mismatch for SharedFenceMTLSharedEventExportInfo::sharedEvent\");\n\n// SharedFenceExportInfo implementation\n\nSharedFenceExportInfo::operator const WGPUSharedFenceExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceExportInfo) == sizeof(WGPUSharedFenceExportInfo), \"sizeof mismatch for SharedFenceExportInfo\");\nstatic_assert(alignof(SharedFenceExportInfo) == alignof(WGPUSharedFenceExportInfo), \"alignof mismatch for SharedFenceExportInfo\");\nstatic_assert(offsetof(SharedFenceExportInfo, nextInChain) == offsetof(WGPUSharedFenceExportInfo, nextInChain),\n        \"offsetof mismatch for SharedFenceExportInfo::nextInChain\");\nstatic_assert(offsetof(SharedFenceExportInfo, type) == offsetof(WGPUSharedFenceExportInfo, type),\n        \"offsetof mismatch for SharedFenceExportInfo::type\");\n\n// SharedFenceSyncFDDescriptor implementation\nSharedFenceSyncFDDescriptor::SharedFenceSyncFDDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceSyncFDDescriptor } {}\nstruct SharedFenceSyncFDDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    int handle;\n};\nSharedFenceSyncFDDescriptor::SharedFenceSyncFDDescriptor(SharedFenceSyncFDDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceSyncFDDescriptor }, \n    handle(std::move(init.handle)){}\n\nSharedFenceSyncFDDescriptor::operator const WGPUSharedFenceSyncFDDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceSyncFDDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceSyncFDDescriptor) == sizeof(WGPUSharedFenceSyncFDDescriptor), \"sizeof mismatch for SharedFenceSyncFDDescriptor\");\nstatic_assert(alignof(SharedFenceSyncFDDescriptor) == alignof(WGPUSharedFenceSyncFDDescriptor), \"alignof mismatch for SharedFenceSyncFDDescriptor\");\nstatic_assert(offsetof(SharedFenceSyncFDDescriptor, handle) == offsetof(WGPUSharedFenceSyncFDDescriptor, handle),\n        \"offsetof mismatch for SharedFenceSyncFDDescriptor::handle\");\n\n// SharedFenceSyncFDExportInfo implementation\nSharedFenceSyncFDExportInfo::SharedFenceSyncFDExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceSyncFDExportInfo } {}\nstruct SharedFenceSyncFDExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    int handle;\n};\nSharedFenceSyncFDExportInfo::SharedFenceSyncFDExportInfo(SharedFenceSyncFDExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceSyncFDExportInfo }, \n    handle(std::move(init.handle)){}\n\nSharedFenceSyncFDExportInfo::operator const WGPUSharedFenceSyncFDExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceSyncFDExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceSyncFDExportInfo) == sizeof(WGPUSharedFenceSyncFDExportInfo), \"sizeof mismatch for SharedFenceSyncFDExportInfo\");\nstatic_assert(alignof(SharedFenceSyncFDExportInfo) == alignof(WGPUSharedFenceSyncFDExportInfo), \"alignof mismatch for SharedFenceSyncFDExportInfo\");\nstatic_assert(offsetof(SharedFenceSyncFDExportInfo, handle) == offsetof(WGPUSharedFenceSyncFDExportInfo, handle),\n        \"offsetof mismatch for SharedFenceSyncFDExportInfo::handle\");\n\n// SharedFenceVkSemaphoreOpaqueFDDescriptor implementation\nSharedFenceVkSemaphoreOpaqueFDDescriptor::SharedFenceVkSemaphoreOpaqueFDDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceVkSemaphoreOpaqueFDDescriptor } {}\nstruct SharedFenceVkSemaphoreOpaqueFDDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    int handle;\n};\nSharedFenceVkSemaphoreOpaqueFDDescriptor::SharedFenceVkSemaphoreOpaqueFDDescriptor(SharedFenceVkSemaphoreOpaqueFDDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceVkSemaphoreOpaqueFDDescriptor }, \n    handle(std::move(init.handle)){}\n\nSharedFenceVkSemaphoreOpaqueFDDescriptor::operator const WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceVkSemaphoreOpaqueFDDescriptor) == sizeof(WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor), \"sizeof mismatch for SharedFenceVkSemaphoreOpaqueFDDescriptor\");\nstatic_assert(alignof(SharedFenceVkSemaphoreOpaqueFDDescriptor) == alignof(WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor), \"alignof mismatch for SharedFenceVkSemaphoreOpaqueFDDescriptor\");\nstatic_assert(offsetof(SharedFenceVkSemaphoreOpaqueFDDescriptor, handle) == offsetof(WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor, handle),\n        \"offsetof mismatch for SharedFenceVkSemaphoreOpaqueFDDescriptor::handle\");\n\n// SharedFenceVkSemaphoreOpaqueFDExportInfo implementation\nSharedFenceVkSemaphoreOpaqueFDExportInfo::SharedFenceVkSemaphoreOpaqueFDExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceVkSemaphoreOpaqueFDExportInfo } {}\nstruct SharedFenceVkSemaphoreOpaqueFDExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    int handle;\n};\nSharedFenceVkSemaphoreOpaqueFDExportInfo::SharedFenceVkSemaphoreOpaqueFDExportInfo(SharedFenceVkSemaphoreOpaqueFDExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceVkSemaphoreOpaqueFDExportInfo }, \n    handle(std::move(init.handle)){}\n\nSharedFenceVkSemaphoreOpaqueFDExportInfo::operator const WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceVkSemaphoreOpaqueFDExportInfo) == sizeof(WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo), \"sizeof mismatch for SharedFenceVkSemaphoreOpaqueFDExportInfo\");\nstatic_assert(alignof(SharedFenceVkSemaphoreOpaqueFDExportInfo) == alignof(WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo), \"alignof mismatch for SharedFenceVkSemaphoreOpaqueFDExportInfo\");\nstatic_assert(offsetof(SharedFenceVkSemaphoreOpaqueFDExportInfo, handle) == offsetof(WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo, handle),\n        \"offsetof mismatch for SharedFenceVkSemaphoreOpaqueFDExportInfo::handle\");\n\n// SharedFenceVkSemaphoreZirconHandleDescriptor implementation\nSharedFenceVkSemaphoreZirconHandleDescriptor::SharedFenceVkSemaphoreZirconHandleDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceVkSemaphoreZirconHandleDescriptor } {}\nstruct SharedFenceVkSemaphoreZirconHandleDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t handle;\n};\nSharedFenceVkSemaphoreZirconHandleDescriptor::SharedFenceVkSemaphoreZirconHandleDescriptor(SharedFenceVkSemaphoreZirconHandleDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceVkSemaphoreZirconHandleDescriptor }, \n    handle(std::move(init.handle)){}\n\nSharedFenceVkSemaphoreZirconHandleDescriptor::operator const WGPUSharedFenceVkSemaphoreZirconHandleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceVkSemaphoreZirconHandleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceVkSemaphoreZirconHandleDescriptor) == sizeof(WGPUSharedFenceVkSemaphoreZirconHandleDescriptor), \"sizeof mismatch for SharedFenceVkSemaphoreZirconHandleDescriptor\");\nstatic_assert(alignof(SharedFenceVkSemaphoreZirconHandleDescriptor) == alignof(WGPUSharedFenceVkSemaphoreZirconHandleDescriptor), \"alignof mismatch for SharedFenceVkSemaphoreZirconHandleDescriptor\");\nstatic_assert(offsetof(SharedFenceVkSemaphoreZirconHandleDescriptor, handle) == offsetof(WGPUSharedFenceVkSemaphoreZirconHandleDescriptor, handle),\n        \"offsetof mismatch for SharedFenceVkSemaphoreZirconHandleDescriptor::handle\");\n\n// SharedFenceVkSemaphoreZirconHandleExportInfo implementation\nSharedFenceVkSemaphoreZirconHandleExportInfo::SharedFenceVkSemaphoreZirconHandleExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceVkSemaphoreZirconHandleExportInfo } {}\nstruct SharedFenceVkSemaphoreZirconHandleExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t handle;\n};\nSharedFenceVkSemaphoreZirconHandleExportInfo::SharedFenceVkSemaphoreZirconHandleExportInfo(SharedFenceVkSemaphoreZirconHandleExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceVkSemaphoreZirconHandleExportInfo }, \n    handle(std::move(init.handle)){}\n\nSharedFenceVkSemaphoreZirconHandleExportInfo::operator const WGPUSharedFenceVkSemaphoreZirconHandleExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceVkSemaphoreZirconHandleExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceVkSemaphoreZirconHandleExportInfo) == sizeof(WGPUSharedFenceVkSemaphoreZirconHandleExportInfo), \"sizeof mismatch for SharedFenceVkSemaphoreZirconHandleExportInfo\");\nstatic_assert(alignof(SharedFenceVkSemaphoreZirconHandleExportInfo) == alignof(WGPUSharedFenceVkSemaphoreZirconHandleExportInfo), \"alignof mismatch for SharedFenceVkSemaphoreZirconHandleExportInfo\");\nstatic_assert(offsetof(SharedFenceVkSemaphoreZirconHandleExportInfo, handle) == offsetof(WGPUSharedFenceVkSemaphoreZirconHandleExportInfo, handle),\n        \"offsetof mismatch for SharedFenceVkSemaphoreZirconHandleExportInfo::handle\");\n\n// SharedTextureMemoryD3DSwapchainBeginState implementation\nSharedTextureMemoryD3DSwapchainBeginState::SharedTextureMemoryD3DSwapchainBeginState()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryD3DSwapchainBeginState } {}\nstruct SharedTextureMemoryD3DSwapchainBeginState::Init {\n    ChainedStruct * const nextInChain;\n    Bool isSwapchain = false;\n};\nSharedTextureMemoryD3DSwapchainBeginState::SharedTextureMemoryD3DSwapchainBeginState(SharedTextureMemoryD3DSwapchainBeginState::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryD3DSwapchainBeginState }, \n    isSwapchain(std::move(init.isSwapchain)){}\n\nSharedTextureMemoryD3DSwapchainBeginState::operator const WGPUSharedTextureMemoryD3DSwapchainBeginState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryD3DSwapchainBeginState*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryD3DSwapchainBeginState) == sizeof(WGPUSharedTextureMemoryD3DSwapchainBeginState), \"sizeof mismatch for SharedTextureMemoryD3DSwapchainBeginState\");\nstatic_assert(alignof(SharedTextureMemoryD3DSwapchainBeginState) == alignof(WGPUSharedTextureMemoryD3DSwapchainBeginState), \"alignof mismatch for SharedTextureMemoryD3DSwapchainBeginState\");\nstatic_assert(offsetof(SharedTextureMemoryD3DSwapchainBeginState, isSwapchain) == offsetof(WGPUSharedTextureMemoryD3DSwapchainBeginState, isSwapchain),\n        \"offsetof mismatch for SharedTextureMemoryD3DSwapchainBeginState::isSwapchain\");\n\n// SharedTextureMemoryDXGISharedHandleDescriptor implementation\nSharedTextureMemoryDXGISharedHandleDescriptor::SharedTextureMemoryDXGISharedHandleDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryDXGISharedHandleDescriptor } {}\nstruct SharedTextureMemoryDXGISharedHandleDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * handle;\n    Bool useKeyedMutex;\n};\nSharedTextureMemoryDXGISharedHandleDescriptor::SharedTextureMemoryDXGISharedHandleDescriptor(SharedTextureMemoryDXGISharedHandleDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryDXGISharedHandleDescriptor }, \n    handle(std::move(init.handle)), \n    useKeyedMutex(std::move(init.useKeyedMutex)){}\n\nSharedTextureMemoryDXGISharedHandleDescriptor::operator const WGPUSharedTextureMemoryDXGISharedHandleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryDXGISharedHandleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryDXGISharedHandleDescriptor) == sizeof(WGPUSharedTextureMemoryDXGISharedHandleDescriptor), \"sizeof mismatch for SharedTextureMemoryDXGISharedHandleDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryDXGISharedHandleDescriptor) == alignof(WGPUSharedTextureMemoryDXGISharedHandleDescriptor), \"alignof mismatch for SharedTextureMemoryDXGISharedHandleDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryDXGISharedHandleDescriptor, handle) == offsetof(WGPUSharedTextureMemoryDXGISharedHandleDescriptor, handle),\n        \"offsetof mismatch for SharedTextureMemoryDXGISharedHandleDescriptor::handle\");\nstatic_assert(offsetof(SharedTextureMemoryDXGISharedHandleDescriptor, useKeyedMutex) == offsetof(WGPUSharedTextureMemoryDXGISharedHandleDescriptor, useKeyedMutex),\n        \"offsetof mismatch for SharedTextureMemoryDXGISharedHandleDescriptor::useKeyedMutex\");\n\n// SharedTextureMemoryEGLImageDescriptor implementation\nSharedTextureMemoryEGLImageDescriptor::SharedTextureMemoryEGLImageDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryEGLImageDescriptor } {}\nstruct SharedTextureMemoryEGLImageDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * image;\n};\nSharedTextureMemoryEGLImageDescriptor::SharedTextureMemoryEGLImageDescriptor(SharedTextureMemoryEGLImageDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryEGLImageDescriptor }, \n    image(std::move(init.image)){}\n\nSharedTextureMemoryEGLImageDescriptor::operator const WGPUSharedTextureMemoryEGLImageDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryEGLImageDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryEGLImageDescriptor) == sizeof(WGPUSharedTextureMemoryEGLImageDescriptor), \"sizeof mismatch for SharedTextureMemoryEGLImageDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryEGLImageDescriptor) == alignof(WGPUSharedTextureMemoryEGLImageDescriptor), \"alignof mismatch for SharedTextureMemoryEGLImageDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryEGLImageDescriptor, image) == offsetof(WGPUSharedTextureMemoryEGLImageDescriptor, image),\n        \"offsetof mismatch for SharedTextureMemoryEGLImageDescriptor::image\");\n\n// SharedTextureMemoryIOSurfaceDescriptor implementation\nSharedTextureMemoryIOSurfaceDescriptor::SharedTextureMemoryIOSurfaceDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryIOSurfaceDescriptor } {}\nstruct SharedTextureMemoryIOSurfaceDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * ioSurface;\n};\nSharedTextureMemoryIOSurfaceDescriptor::SharedTextureMemoryIOSurfaceDescriptor(SharedTextureMemoryIOSurfaceDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryIOSurfaceDescriptor }, \n    ioSurface(std::move(init.ioSurface)){}\n\nSharedTextureMemoryIOSurfaceDescriptor::operator const WGPUSharedTextureMemoryIOSurfaceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryIOSurfaceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryIOSurfaceDescriptor) == sizeof(WGPUSharedTextureMemoryIOSurfaceDescriptor), \"sizeof mismatch for SharedTextureMemoryIOSurfaceDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryIOSurfaceDescriptor) == alignof(WGPUSharedTextureMemoryIOSurfaceDescriptor), \"alignof mismatch for SharedTextureMemoryIOSurfaceDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryIOSurfaceDescriptor, ioSurface) == offsetof(WGPUSharedTextureMemoryIOSurfaceDescriptor, ioSurface),\n        \"offsetof mismatch for SharedTextureMemoryIOSurfaceDescriptor::ioSurface\");\n\n// SharedTextureMemoryAHardwareBufferDescriptor implementation\nSharedTextureMemoryAHardwareBufferDescriptor::SharedTextureMemoryAHardwareBufferDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryAHardwareBufferDescriptor } {}\nstruct SharedTextureMemoryAHardwareBufferDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * handle;\n    Bool useExternalFormat;\n};\nSharedTextureMemoryAHardwareBufferDescriptor::SharedTextureMemoryAHardwareBufferDescriptor(SharedTextureMemoryAHardwareBufferDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryAHardwareBufferDescriptor }, \n    handle(std::move(init.handle)), \n    useExternalFormat(std::move(init.useExternalFormat)){}\n\nSharedTextureMemoryAHardwareBufferDescriptor::operator const WGPUSharedTextureMemoryAHardwareBufferDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryAHardwareBufferDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryAHardwareBufferDescriptor) == sizeof(WGPUSharedTextureMemoryAHardwareBufferDescriptor), \"sizeof mismatch for SharedTextureMemoryAHardwareBufferDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryAHardwareBufferDescriptor) == alignof(WGPUSharedTextureMemoryAHardwareBufferDescriptor), \"alignof mismatch for SharedTextureMemoryAHardwareBufferDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryAHardwareBufferDescriptor, handle) == offsetof(WGPUSharedTextureMemoryAHardwareBufferDescriptor, handle),\n        \"offsetof mismatch for SharedTextureMemoryAHardwareBufferDescriptor::handle\");\nstatic_assert(offsetof(SharedTextureMemoryAHardwareBufferDescriptor, useExternalFormat) == offsetof(WGPUSharedTextureMemoryAHardwareBufferDescriptor, useExternalFormat),\n        \"offsetof mismatch for SharedTextureMemoryAHardwareBufferDescriptor::useExternalFormat\");\n\n// SharedTextureMemoryBeginAccessDescriptor implementation\n\nSharedTextureMemoryBeginAccessDescriptor::operator const WGPUSharedTextureMemoryBeginAccessDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryBeginAccessDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryBeginAccessDescriptor) == sizeof(WGPUSharedTextureMemoryBeginAccessDescriptor), \"sizeof mismatch for SharedTextureMemoryBeginAccessDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryBeginAccessDescriptor) == alignof(WGPUSharedTextureMemoryBeginAccessDescriptor), \"alignof mismatch for SharedTextureMemoryBeginAccessDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, nextInChain) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, nextInChain),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, concurrentRead) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, concurrentRead),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::concurrentRead\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, initialized) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, initialized),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::initialized\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, fenceCount) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, fenceCount),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::fenceCount\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, fences) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, fences),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::fences\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, signaledValues) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, signaledValues),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::signaledValues\");\n\n// SharedTextureMemoryDmaBufPlane implementation\n\nSharedTextureMemoryDmaBufPlane::operator const WGPUSharedTextureMemoryDmaBufPlane&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryDmaBufPlane*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryDmaBufPlane) == sizeof(WGPUSharedTextureMemoryDmaBufPlane), \"sizeof mismatch for SharedTextureMemoryDmaBufPlane\");\nstatic_assert(alignof(SharedTextureMemoryDmaBufPlane) == alignof(WGPUSharedTextureMemoryDmaBufPlane), \"alignof mismatch for SharedTextureMemoryDmaBufPlane\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufPlane, fd) == offsetof(WGPUSharedTextureMemoryDmaBufPlane, fd),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufPlane::fd\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufPlane, offset) == offsetof(WGPUSharedTextureMemoryDmaBufPlane, offset),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufPlane::offset\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufPlane, stride) == offsetof(WGPUSharedTextureMemoryDmaBufPlane, stride),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufPlane::stride\");\n\n// SharedTextureMemoryEndAccessState implementation\nSharedTextureMemoryEndAccessState::SharedTextureMemoryEndAccessState() = default;\nSharedTextureMemoryEndAccessState::~SharedTextureMemoryEndAccessState() {\n    FreeMembers();\n}\n\nSharedTextureMemoryEndAccessState::SharedTextureMemoryEndAccessState(SharedTextureMemoryEndAccessState&& rhs)\n    : initialized(rhs.initialized),\n            fenceCount(rhs.fenceCount),\n            fences(rhs.fences),\n            signaledValues(rhs.signaledValues){\n    Reset(rhs);\n}\n\nSharedTextureMemoryEndAccessState& SharedTextureMemoryEndAccessState::operator=(SharedTextureMemoryEndAccessState&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->initialized) = std::move(rhs.initialized);\n    detail::AsNonConstReference(this->fenceCount) = std::move(rhs.fenceCount);\n    detail::AsNonConstReference(this->fences) = std::move(rhs.fences);\n    detail::AsNonConstReference(this->signaledValues) = std::move(rhs.signaledValues);\n    Reset(rhs);\n    return *this;\n}\n\nvoid SharedTextureMemoryEndAccessState::FreeMembers() {\n    bool needsFreeing = false;    if (this->fences != nullptr) { needsFreeing = true; }    if (this->signaledValues != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuSharedTextureMemoryEndAccessStateFreeMembers(\n            *reinterpret_cast<WGPUSharedTextureMemoryEndAccessState*>(this));\n    }\n}\n\n// static\nvoid SharedTextureMemoryEndAccessState::Reset(SharedTextureMemoryEndAccessState& value) {\n    SharedTextureMemoryEndAccessState defaultValue{};\n    detail::AsNonConstReference(value.initialized) = defaultValue.initialized;\n    detail::AsNonConstReference(value.fenceCount) = defaultValue.fenceCount;\n    detail::AsNonConstReference(value.fences) = defaultValue.fences;\n    detail::AsNonConstReference(value.signaledValues) = defaultValue.signaledValues;\n}\n\nSharedTextureMemoryEndAccessState::operator const WGPUSharedTextureMemoryEndAccessState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryEndAccessState*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryEndAccessState) == sizeof(WGPUSharedTextureMemoryEndAccessState), \"sizeof mismatch for SharedTextureMemoryEndAccessState\");\nstatic_assert(alignof(SharedTextureMemoryEndAccessState) == alignof(WGPUSharedTextureMemoryEndAccessState), \"alignof mismatch for SharedTextureMemoryEndAccessState\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, nextInChain) == offsetof(WGPUSharedTextureMemoryEndAccessState, nextInChain),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::nextInChain\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, initialized) == offsetof(WGPUSharedTextureMemoryEndAccessState, initialized),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::initialized\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, fenceCount) == offsetof(WGPUSharedTextureMemoryEndAccessState, fenceCount),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::fenceCount\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, fences) == offsetof(WGPUSharedTextureMemoryEndAccessState, fences),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::fences\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, signaledValues) == offsetof(WGPUSharedTextureMemoryEndAccessState, signaledValues),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::signaledValues\");\n\n// SharedTextureMemoryOpaqueFDDescriptor implementation\nSharedTextureMemoryOpaqueFDDescriptor::SharedTextureMemoryOpaqueFDDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryOpaqueFDDescriptor } {}\nstruct SharedTextureMemoryOpaqueFDDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void const * vkImageCreateInfo;\n    int memoryFD;\n    uint32_t memoryTypeIndex;\n    uint64_t allocationSize;\n    Bool dedicatedAllocation;\n};\nSharedTextureMemoryOpaqueFDDescriptor::SharedTextureMemoryOpaqueFDDescriptor(SharedTextureMemoryOpaqueFDDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryOpaqueFDDescriptor }, \n    vkImageCreateInfo(std::move(init.vkImageCreateInfo)), \n    memoryFD(std::move(init.memoryFD)), \n    memoryTypeIndex(std::move(init.memoryTypeIndex)), \n    allocationSize(std::move(init.allocationSize)), \n    dedicatedAllocation(std::move(init.dedicatedAllocation)){}\n\nSharedTextureMemoryOpaqueFDDescriptor::operator const WGPUSharedTextureMemoryOpaqueFDDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryOpaqueFDDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryOpaqueFDDescriptor) == sizeof(WGPUSharedTextureMemoryOpaqueFDDescriptor), \"sizeof mismatch for SharedTextureMemoryOpaqueFDDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryOpaqueFDDescriptor) == alignof(WGPUSharedTextureMemoryOpaqueFDDescriptor), \"alignof mismatch for SharedTextureMemoryOpaqueFDDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, vkImageCreateInfo) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, vkImageCreateInfo),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::vkImageCreateInfo\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, memoryFD) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, memoryFD),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::memoryFD\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, memoryTypeIndex) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, memoryTypeIndex),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::memoryTypeIndex\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, allocationSize) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, allocationSize),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::allocationSize\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, dedicatedAllocation) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, dedicatedAllocation),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::dedicatedAllocation\");\n\n// SharedTextureMemoryVkDedicatedAllocationDescriptor implementation\nSharedTextureMemoryVkDedicatedAllocationDescriptor::SharedTextureMemoryVkDedicatedAllocationDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryVkDedicatedAllocationDescriptor } {}\nstruct SharedTextureMemoryVkDedicatedAllocationDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    Bool dedicatedAllocation;\n};\nSharedTextureMemoryVkDedicatedAllocationDescriptor::SharedTextureMemoryVkDedicatedAllocationDescriptor(SharedTextureMemoryVkDedicatedAllocationDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryVkDedicatedAllocationDescriptor }, \n    dedicatedAllocation(std::move(init.dedicatedAllocation)){}\n\nSharedTextureMemoryVkDedicatedAllocationDescriptor::operator const WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryVkDedicatedAllocationDescriptor) == sizeof(WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor), \"sizeof mismatch for SharedTextureMemoryVkDedicatedAllocationDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryVkDedicatedAllocationDescriptor) == alignof(WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor), \"alignof mismatch for SharedTextureMemoryVkDedicatedAllocationDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryVkDedicatedAllocationDescriptor, dedicatedAllocation) == offsetof(WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor, dedicatedAllocation),\n        \"offsetof mismatch for SharedTextureMemoryVkDedicatedAllocationDescriptor::dedicatedAllocation\");\n\n// SharedTextureMemoryVkImageLayoutBeginState implementation\nSharedTextureMemoryVkImageLayoutBeginState::SharedTextureMemoryVkImageLayoutBeginState()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryVkImageLayoutBeginState } {}\nstruct SharedTextureMemoryVkImageLayoutBeginState::Init {\n    ChainedStruct * const nextInChain;\n    int32_t oldLayout;\n    int32_t newLayout;\n};\nSharedTextureMemoryVkImageLayoutBeginState::SharedTextureMemoryVkImageLayoutBeginState(SharedTextureMemoryVkImageLayoutBeginState::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryVkImageLayoutBeginState }, \n    oldLayout(std::move(init.oldLayout)), \n    newLayout(std::move(init.newLayout)){}\n\nSharedTextureMemoryVkImageLayoutBeginState::operator const WGPUSharedTextureMemoryVkImageLayoutBeginState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryVkImageLayoutBeginState*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryVkImageLayoutBeginState) == sizeof(WGPUSharedTextureMemoryVkImageLayoutBeginState), \"sizeof mismatch for SharedTextureMemoryVkImageLayoutBeginState\");\nstatic_assert(alignof(SharedTextureMemoryVkImageLayoutBeginState) == alignof(WGPUSharedTextureMemoryVkImageLayoutBeginState), \"alignof mismatch for SharedTextureMemoryVkImageLayoutBeginState\");\nstatic_assert(offsetof(SharedTextureMemoryVkImageLayoutBeginState, oldLayout) == offsetof(WGPUSharedTextureMemoryVkImageLayoutBeginState, oldLayout),\n        \"offsetof mismatch for SharedTextureMemoryVkImageLayoutBeginState::oldLayout\");\nstatic_assert(offsetof(SharedTextureMemoryVkImageLayoutBeginState, newLayout) == offsetof(WGPUSharedTextureMemoryVkImageLayoutBeginState, newLayout),\n        \"offsetof mismatch for SharedTextureMemoryVkImageLayoutBeginState::newLayout\");\n\n// SharedTextureMemoryVkImageLayoutEndState implementation\nSharedTextureMemoryVkImageLayoutEndState::SharedTextureMemoryVkImageLayoutEndState()\n  : ChainedStructOut { nullptr, SType::SharedTextureMemoryVkImageLayoutEndState } {}\nstruct SharedTextureMemoryVkImageLayoutEndState::Init {\n    ChainedStructOut *  nextInChain;\n    int32_t oldLayout;\n    int32_t newLayout;\n};\nSharedTextureMemoryVkImageLayoutEndState::SharedTextureMemoryVkImageLayoutEndState(SharedTextureMemoryVkImageLayoutEndState::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedTextureMemoryVkImageLayoutEndState }, \n    oldLayout(std::move(init.oldLayout)), \n    newLayout(std::move(init.newLayout)){}\n\nSharedTextureMemoryVkImageLayoutEndState::operator const WGPUSharedTextureMemoryVkImageLayoutEndState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryVkImageLayoutEndState*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryVkImageLayoutEndState) == sizeof(WGPUSharedTextureMemoryVkImageLayoutEndState), \"sizeof mismatch for SharedTextureMemoryVkImageLayoutEndState\");\nstatic_assert(alignof(SharedTextureMemoryVkImageLayoutEndState) == alignof(WGPUSharedTextureMemoryVkImageLayoutEndState), \"alignof mismatch for SharedTextureMemoryVkImageLayoutEndState\");\nstatic_assert(offsetof(SharedTextureMemoryVkImageLayoutEndState, oldLayout) == offsetof(WGPUSharedTextureMemoryVkImageLayoutEndState, oldLayout),\n        \"offsetof mismatch for SharedTextureMemoryVkImageLayoutEndState::oldLayout\");\nstatic_assert(offsetof(SharedTextureMemoryVkImageLayoutEndState, newLayout) == offsetof(WGPUSharedTextureMemoryVkImageLayoutEndState, newLayout),\n        \"offsetof mismatch for SharedTextureMemoryVkImageLayoutEndState::newLayout\");\n\n// SharedTextureMemoryZirconHandleDescriptor implementation\nSharedTextureMemoryZirconHandleDescriptor::SharedTextureMemoryZirconHandleDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryZirconHandleDescriptor } {}\nstruct SharedTextureMemoryZirconHandleDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t memoryFD;\n    uint64_t allocationSize;\n};\nSharedTextureMemoryZirconHandleDescriptor::SharedTextureMemoryZirconHandleDescriptor(SharedTextureMemoryZirconHandleDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryZirconHandleDescriptor }, \n    memoryFD(std::move(init.memoryFD)), \n    allocationSize(std::move(init.allocationSize)){}\n\nSharedTextureMemoryZirconHandleDescriptor::operator const WGPUSharedTextureMemoryZirconHandleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryZirconHandleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryZirconHandleDescriptor) == sizeof(WGPUSharedTextureMemoryZirconHandleDescriptor), \"sizeof mismatch for SharedTextureMemoryZirconHandleDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryZirconHandleDescriptor) == alignof(WGPUSharedTextureMemoryZirconHandleDescriptor), \"alignof mismatch for SharedTextureMemoryZirconHandleDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryZirconHandleDescriptor, memoryFD) == offsetof(WGPUSharedTextureMemoryZirconHandleDescriptor, memoryFD),\n        \"offsetof mismatch for SharedTextureMemoryZirconHandleDescriptor::memoryFD\");\nstatic_assert(offsetof(SharedTextureMemoryZirconHandleDescriptor, allocationSize) == offsetof(WGPUSharedTextureMemoryZirconHandleDescriptor, allocationSize),\n        \"offsetof mismatch for SharedTextureMemoryZirconHandleDescriptor::allocationSize\");\n\n// StaticSamplerBindingLayout implementation\nStaticSamplerBindingLayout::StaticSamplerBindingLayout()\n  : ChainedStruct { nullptr, SType::StaticSamplerBindingLayout } {}\nstruct StaticSamplerBindingLayout::Init {\n    ChainedStruct * const nextInChain;\n    Sampler sampler;\n    uint32_t sampledTextureBinding = WGPU_LIMIT_U32_UNDEFINED;\n};\nStaticSamplerBindingLayout::StaticSamplerBindingLayout(StaticSamplerBindingLayout::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::StaticSamplerBindingLayout }, \n    sampler(std::move(init.sampler)), \n    sampledTextureBinding(std::move(init.sampledTextureBinding)){}\n\nStaticSamplerBindingLayout::operator const WGPUStaticSamplerBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUStaticSamplerBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(StaticSamplerBindingLayout) == sizeof(WGPUStaticSamplerBindingLayout), \"sizeof mismatch for StaticSamplerBindingLayout\");\nstatic_assert(alignof(StaticSamplerBindingLayout) == alignof(WGPUStaticSamplerBindingLayout), \"alignof mismatch for StaticSamplerBindingLayout\");\nstatic_assert(offsetof(StaticSamplerBindingLayout, sampler) == offsetof(WGPUStaticSamplerBindingLayout, sampler),\n        \"offsetof mismatch for StaticSamplerBindingLayout::sampler\");\nstatic_assert(offsetof(StaticSamplerBindingLayout, sampledTextureBinding) == offsetof(WGPUStaticSamplerBindingLayout, sampledTextureBinding),\n        \"offsetof mismatch for StaticSamplerBindingLayout::sampledTextureBinding\");\n\n// StencilFaceState implementation\n\nStencilFaceState::operator const WGPUStencilFaceState&() const noexcept {\n    return *reinterpret_cast<const WGPUStencilFaceState*>(this);\n}\n\nstatic_assert(sizeof(StencilFaceState) == sizeof(WGPUStencilFaceState), \"sizeof mismatch for StencilFaceState\");\nstatic_assert(alignof(StencilFaceState) == alignof(WGPUStencilFaceState), \"alignof mismatch for StencilFaceState\");\nstatic_assert(offsetof(StencilFaceState, compare) == offsetof(WGPUStencilFaceState, compare),\n        \"offsetof mismatch for StencilFaceState::compare\");\nstatic_assert(offsetof(StencilFaceState, failOp) == offsetof(WGPUStencilFaceState, failOp),\n        \"offsetof mismatch for StencilFaceState::failOp\");\nstatic_assert(offsetof(StencilFaceState, depthFailOp) == offsetof(WGPUStencilFaceState, depthFailOp),\n        \"offsetof mismatch for StencilFaceState::depthFailOp\");\nstatic_assert(offsetof(StencilFaceState, passOp) == offsetof(WGPUStencilFaceState, passOp),\n        \"offsetof mismatch for StencilFaceState::passOp\");\n\n// StorageTextureBindingLayout implementation\n\nStorageTextureBindingLayout::operator const WGPUStorageTextureBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUStorageTextureBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(StorageTextureBindingLayout) == sizeof(WGPUStorageTextureBindingLayout), \"sizeof mismatch for StorageTextureBindingLayout\");\nstatic_assert(alignof(StorageTextureBindingLayout) == alignof(WGPUStorageTextureBindingLayout), \"alignof mismatch for StorageTextureBindingLayout\");\nstatic_assert(offsetof(StorageTextureBindingLayout, nextInChain) == offsetof(WGPUStorageTextureBindingLayout, nextInChain),\n        \"offsetof mismatch for StorageTextureBindingLayout::nextInChain\");\nstatic_assert(offsetof(StorageTextureBindingLayout, access) == offsetof(WGPUStorageTextureBindingLayout, access),\n        \"offsetof mismatch for StorageTextureBindingLayout::access\");\nstatic_assert(offsetof(StorageTextureBindingLayout, format) == offsetof(WGPUStorageTextureBindingLayout, format),\n        \"offsetof mismatch for StorageTextureBindingLayout::format\");\nstatic_assert(offsetof(StorageTextureBindingLayout, viewDimension) == offsetof(WGPUStorageTextureBindingLayout, viewDimension),\n        \"offsetof mismatch for StorageTextureBindingLayout::viewDimension\");\n\n// SupportedFeatures implementation\nSupportedFeatures::SupportedFeatures() = default;\nSupportedFeatures::~SupportedFeatures() {\n    FreeMembers();\n}\n\nSupportedFeatures::SupportedFeatures(SupportedFeatures&& rhs)\n    : featureCount(rhs.featureCount),\n            features(rhs.features){\n    Reset(rhs);\n}\n\nSupportedFeatures& SupportedFeatures::operator=(SupportedFeatures&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->featureCount) = std::move(rhs.featureCount);\n    detail::AsNonConstReference(this->features) = std::move(rhs.features);\n    Reset(rhs);\n    return *this;\n}\n\nvoid SupportedFeatures::FreeMembers() {\n    bool needsFreeing = false;    if (this->features != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuSupportedFeaturesFreeMembers(\n            *reinterpret_cast<WGPUSupportedFeatures*>(this));\n    }\n}\n\n// static\nvoid SupportedFeatures::Reset(SupportedFeatures& value) {\n    SupportedFeatures defaultValue{};\n    detail::AsNonConstReference(value.featureCount) = defaultValue.featureCount;\n    detail::AsNonConstReference(value.features) = defaultValue.features;\n}\n\nSupportedFeatures::operator const WGPUSupportedFeatures&() const noexcept {\n    return *reinterpret_cast<const WGPUSupportedFeatures*>(this);\n}\n\nstatic_assert(sizeof(SupportedFeatures) == sizeof(WGPUSupportedFeatures), \"sizeof mismatch for SupportedFeatures\");\nstatic_assert(alignof(SupportedFeatures) == alignof(WGPUSupportedFeatures), \"alignof mismatch for SupportedFeatures\");\nstatic_assert(offsetof(SupportedFeatures, featureCount) == offsetof(WGPUSupportedFeatures, featureCount),\n        \"offsetof mismatch for SupportedFeatures::featureCount\");\nstatic_assert(offsetof(SupportedFeatures, features) == offsetof(WGPUSupportedFeatures, features),\n        \"offsetof mismatch for SupportedFeatures::features\");\n\n// SurfaceCapabilities implementation\nSurfaceCapabilities::SurfaceCapabilities() = default;\nSurfaceCapabilities::~SurfaceCapabilities() {\n    FreeMembers();\n}\n\nSurfaceCapabilities::SurfaceCapabilities(SurfaceCapabilities&& rhs)\n    : usages(rhs.usages),\n            formatCount(rhs.formatCount),\n            formats(rhs.formats),\n            presentModeCount(rhs.presentModeCount),\n            presentModes(rhs.presentModes),\n            alphaModeCount(rhs.alphaModeCount),\n            alphaModes(rhs.alphaModes){\n    Reset(rhs);\n}\n\nSurfaceCapabilities& SurfaceCapabilities::operator=(SurfaceCapabilities&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->usages) = std::move(rhs.usages);\n    detail::AsNonConstReference(this->formatCount) = std::move(rhs.formatCount);\n    detail::AsNonConstReference(this->formats) = std::move(rhs.formats);\n    detail::AsNonConstReference(this->presentModeCount) = std::move(rhs.presentModeCount);\n    detail::AsNonConstReference(this->presentModes) = std::move(rhs.presentModes);\n    detail::AsNonConstReference(this->alphaModeCount) = std::move(rhs.alphaModeCount);\n    detail::AsNonConstReference(this->alphaModes) = std::move(rhs.alphaModes);\n    Reset(rhs);\n    return *this;\n}\n\nvoid SurfaceCapabilities::FreeMembers() {\n    bool needsFreeing = false;    if (this->formats != nullptr) { needsFreeing = true; }    if (this->presentModes != nullptr) { needsFreeing = true; }    if (this->alphaModes != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuSurfaceCapabilitiesFreeMembers(\n            *reinterpret_cast<WGPUSurfaceCapabilities*>(this));\n    }\n}\n\n// static\nvoid SurfaceCapabilities::Reset(SurfaceCapabilities& value) {\n    SurfaceCapabilities defaultValue{};\n    detail::AsNonConstReference(value.usages) = defaultValue.usages;\n    detail::AsNonConstReference(value.formatCount) = defaultValue.formatCount;\n    detail::AsNonConstReference(value.formats) = defaultValue.formats;\n    detail::AsNonConstReference(value.presentModeCount) = defaultValue.presentModeCount;\n    detail::AsNonConstReference(value.presentModes) = defaultValue.presentModes;\n    detail::AsNonConstReference(value.alphaModeCount) = defaultValue.alphaModeCount;\n    detail::AsNonConstReference(value.alphaModes) = defaultValue.alphaModes;\n}\n\nSurfaceCapabilities::operator const WGPUSurfaceCapabilities&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceCapabilities*>(this);\n}\n\nstatic_assert(sizeof(SurfaceCapabilities) == sizeof(WGPUSurfaceCapabilities), \"sizeof mismatch for SurfaceCapabilities\");\nstatic_assert(alignof(SurfaceCapabilities) == alignof(WGPUSurfaceCapabilities), \"alignof mismatch for SurfaceCapabilities\");\nstatic_assert(offsetof(SurfaceCapabilities, nextInChain) == offsetof(WGPUSurfaceCapabilities, nextInChain),\n        \"offsetof mismatch for SurfaceCapabilities::nextInChain\");\nstatic_assert(offsetof(SurfaceCapabilities, usages) == offsetof(WGPUSurfaceCapabilities, usages),\n        \"offsetof mismatch for SurfaceCapabilities::usages\");\nstatic_assert(offsetof(SurfaceCapabilities, formatCount) == offsetof(WGPUSurfaceCapabilities, formatCount),\n        \"offsetof mismatch for SurfaceCapabilities::formatCount\");\nstatic_assert(offsetof(SurfaceCapabilities, formats) == offsetof(WGPUSurfaceCapabilities, formats),\n        \"offsetof mismatch for SurfaceCapabilities::formats\");\nstatic_assert(offsetof(SurfaceCapabilities, presentModeCount) == offsetof(WGPUSurfaceCapabilities, presentModeCount),\n        \"offsetof mismatch for SurfaceCapabilities::presentModeCount\");\nstatic_assert(offsetof(SurfaceCapabilities, presentModes) == offsetof(WGPUSurfaceCapabilities, presentModes),\n        \"offsetof mismatch for SurfaceCapabilities::presentModes\");\nstatic_assert(offsetof(SurfaceCapabilities, alphaModeCount) == offsetof(WGPUSurfaceCapabilities, alphaModeCount),\n        \"offsetof mismatch for SurfaceCapabilities::alphaModeCount\");\nstatic_assert(offsetof(SurfaceCapabilities, alphaModes) == offsetof(WGPUSurfaceCapabilities, alphaModes),\n        \"offsetof mismatch for SurfaceCapabilities::alphaModes\");\n\n// SurfaceConfiguration implementation\n\nSurfaceConfiguration::operator const WGPUSurfaceConfiguration&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceConfiguration*>(this);\n}\n\nstatic_assert(sizeof(SurfaceConfiguration) == sizeof(WGPUSurfaceConfiguration), \"sizeof mismatch for SurfaceConfiguration\");\nstatic_assert(alignof(SurfaceConfiguration) == alignof(WGPUSurfaceConfiguration), \"alignof mismatch for SurfaceConfiguration\");\nstatic_assert(offsetof(SurfaceConfiguration, nextInChain) == offsetof(WGPUSurfaceConfiguration, nextInChain),\n        \"offsetof mismatch for SurfaceConfiguration::nextInChain\");\nstatic_assert(offsetof(SurfaceConfiguration, device) == offsetof(WGPUSurfaceConfiguration, device),\n        \"offsetof mismatch for SurfaceConfiguration::device\");\nstatic_assert(offsetof(SurfaceConfiguration, format) == offsetof(WGPUSurfaceConfiguration, format),\n        \"offsetof mismatch for SurfaceConfiguration::format\");\nstatic_assert(offsetof(SurfaceConfiguration, usage) == offsetof(WGPUSurfaceConfiguration, usage),\n        \"offsetof mismatch for SurfaceConfiguration::usage\");\nstatic_assert(offsetof(SurfaceConfiguration, viewFormatCount) == offsetof(WGPUSurfaceConfiguration, viewFormatCount),\n        \"offsetof mismatch for SurfaceConfiguration::viewFormatCount\");\nstatic_assert(offsetof(SurfaceConfiguration, viewFormats) == offsetof(WGPUSurfaceConfiguration, viewFormats),\n        \"offsetof mismatch for SurfaceConfiguration::viewFormats\");\nstatic_assert(offsetof(SurfaceConfiguration, alphaMode) == offsetof(WGPUSurfaceConfiguration, alphaMode),\n        \"offsetof mismatch for SurfaceConfiguration::alphaMode\");\nstatic_assert(offsetof(SurfaceConfiguration, width) == offsetof(WGPUSurfaceConfiguration, width),\n        \"offsetof mismatch for SurfaceConfiguration::width\");\nstatic_assert(offsetof(SurfaceConfiguration, height) == offsetof(WGPUSurfaceConfiguration, height),\n        \"offsetof mismatch for SurfaceConfiguration::height\");\nstatic_assert(offsetof(SurfaceConfiguration, presentMode) == offsetof(WGPUSurfaceConfiguration, presentMode),\n        \"offsetof mismatch for SurfaceConfiguration::presentMode\");\n\n// SurfaceDescriptorFromWindowsCoreWindow implementation\nSurfaceDescriptorFromWindowsCoreWindow::SurfaceDescriptorFromWindowsCoreWindow()\n  : ChainedStruct { nullptr, SType::SurfaceDescriptorFromWindowsCoreWindow } {}\nstruct SurfaceDescriptorFromWindowsCoreWindow::Init {\n    ChainedStruct * const nextInChain;\n    void * coreWindow;\n};\nSurfaceDescriptorFromWindowsCoreWindow::SurfaceDescriptorFromWindowsCoreWindow(SurfaceDescriptorFromWindowsCoreWindow::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceDescriptorFromWindowsCoreWindow }, \n    coreWindow(std::move(init.coreWindow)){}\n\nSurfaceDescriptorFromWindowsCoreWindow::operator const WGPUSurfaceDescriptorFromWindowsCoreWindow&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsCoreWindow*>(this);\n}\n\nstatic_assert(sizeof(SurfaceDescriptorFromWindowsCoreWindow) == sizeof(WGPUSurfaceDescriptorFromWindowsCoreWindow), \"sizeof mismatch for SurfaceDescriptorFromWindowsCoreWindow\");\nstatic_assert(alignof(SurfaceDescriptorFromWindowsCoreWindow) == alignof(WGPUSurfaceDescriptorFromWindowsCoreWindow), \"alignof mismatch for SurfaceDescriptorFromWindowsCoreWindow\");\nstatic_assert(offsetof(SurfaceDescriptorFromWindowsCoreWindow, coreWindow) == offsetof(WGPUSurfaceDescriptorFromWindowsCoreWindow, coreWindow),\n        \"offsetof mismatch for SurfaceDescriptorFromWindowsCoreWindow::coreWindow\");\n\n// SurfaceDescriptorFromWindowsSwapChainPanel implementation\nSurfaceDescriptorFromWindowsSwapChainPanel::SurfaceDescriptorFromWindowsSwapChainPanel()\n  : ChainedStruct { nullptr, SType::SurfaceDescriptorFromWindowsSwapChainPanel } {}\nstruct SurfaceDescriptorFromWindowsSwapChainPanel::Init {\n    ChainedStruct * const nextInChain;\n    void * swapChainPanel;\n};\nSurfaceDescriptorFromWindowsSwapChainPanel::SurfaceDescriptorFromWindowsSwapChainPanel(SurfaceDescriptorFromWindowsSwapChainPanel::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceDescriptorFromWindowsSwapChainPanel }, \n    swapChainPanel(std::move(init.swapChainPanel)){}\n\nSurfaceDescriptorFromWindowsSwapChainPanel::operator const WGPUSurfaceDescriptorFromWindowsSwapChainPanel&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsSwapChainPanel*>(this);\n}\n\nstatic_assert(sizeof(SurfaceDescriptorFromWindowsSwapChainPanel) == sizeof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel), \"sizeof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel\");\nstatic_assert(alignof(SurfaceDescriptorFromWindowsSwapChainPanel) == alignof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel), \"alignof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel\");\nstatic_assert(offsetof(SurfaceDescriptorFromWindowsSwapChainPanel, swapChainPanel) == offsetof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel, swapChainPanel),\n        \"offsetof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel::swapChainPanel\");\n\n// SurfaceSourceXCBWindow implementation\nSurfaceSourceXCBWindow::SurfaceSourceXCBWindow()\n  : ChainedStruct { nullptr, SType::SurfaceSourceXCBWindow } {}\nstruct SurfaceSourceXCBWindow::Init {\n    ChainedStruct * const nextInChain;\n    void * connection;\n    uint32_t window;\n};\nSurfaceSourceXCBWindow::SurfaceSourceXCBWindow(SurfaceSourceXCBWindow::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceXCBWindow }, \n    connection(std::move(init.connection)), \n    window(std::move(init.window)){}\n\nSurfaceSourceXCBWindow::operator const WGPUSurfaceSourceXCBWindow&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceXCBWindow*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceXCBWindow) == sizeof(WGPUSurfaceSourceXCBWindow), \"sizeof mismatch for SurfaceSourceXCBWindow\");\nstatic_assert(alignof(SurfaceSourceXCBWindow) == alignof(WGPUSurfaceSourceXCBWindow), \"alignof mismatch for SurfaceSourceXCBWindow\");\nstatic_assert(offsetof(SurfaceSourceXCBWindow, connection) == offsetof(WGPUSurfaceSourceXCBWindow, connection),\n        \"offsetof mismatch for SurfaceSourceXCBWindow::connection\");\nstatic_assert(offsetof(SurfaceSourceXCBWindow, window) == offsetof(WGPUSurfaceSourceXCBWindow, window),\n        \"offsetof mismatch for SurfaceSourceXCBWindow::window\");\n\n// SurfaceSourceAndroidNativeWindow implementation\nSurfaceSourceAndroidNativeWindow::SurfaceSourceAndroidNativeWindow()\n  : ChainedStruct { nullptr, SType::SurfaceSourceAndroidNativeWindow } {}\nstruct SurfaceSourceAndroidNativeWindow::Init {\n    ChainedStruct * const nextInChain;\n    void * window;\n};\nSurfaceSourceAndroidNativeWindow::SurfaceSourceAndroidNativeWindow(SurfaceSourceAndroidNativeWindow::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceAndroidNativeWindow }, \n    window(std::move(init.window)){}\n\nSurfaceSourceAndroidNativeWindow::operator const WGPUSurfaceSourceAndroidNativeWindow&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceAndroidNativeWindow*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceAndroidNativeWindow) == sizeof(WGPUSurfaceSourceAndroidNativeWindow), \"sizeof mismatch for SurfaceSourceAndroidNativeWindow\");\nstatic_assert(alignof(SurfaceSourceAndroidNativeWindow) == alignof(WGPUSurfaceSourceAndroidNativeWindow), \"alignof mismatch for SurfaceSourceAndroidNativeWindow\");\nstatic_assert(offsetof(SurfaceSourceAndroidNativeWindow, window) == offsetof(WGPUSurfaceSourceAndroidNativeWindow, window),\n        \"offsetof mismatch for SurfaceSourceAndroidNativeWindow::window\");\n\n// SurfaceSourceMetalLayer implementation\nSurfaceSourceMetalLayer::SurfaceSourceMetalLayer()\n  : ChainedStruct { nullptr, SType::SurfaceSourceMetalLayer } {}\nstruct SurfaceSourceMetalLayer::Init {\n    ChainedStruct * const nextInChain;\n    void * layer;\n};\nSurfaceSourceMetalLayer::SurfaceSourceMetalLayer(SurfaceSourceMetalLayer::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceMetalLayer }, \n    layer(std::move(init.layer)){}\n\nSurfaceSourceMetalLayer::operator const WGPUSurfaceSourceMetalLayer&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceMetalLayer*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceMetalLayer) == sizeof(WGPUSurfaceSourceMetalLayer), \"sizeof mismatch for SurfaceSourceMetalLayer\");\nstatic_assert(alignof(SurfaceSourceMetalLayer) == alignof(WGPUSurfaceSourceMetalLayer), \"alignof mismatch for SurfaceSourceMetalLayer\");\nstatic_assert(offsetof(SurfaceSourceMetalLayer, layer) == offsetof(WGPUSurfaceSourceMetalLayer, layer),\n        \"offsetof mismatch for SurfaceSourceMetalLayer::layer\");\n\n// SurfaceSourceWaylandSurface implementation\nSurfaceSourceWaylandSurface::SurfaceSourceWaylandSurface()\n  : ChainedStruct { nullptr, SType::SurfaceSourceWaylandSurface } {}\nstruct SurfaceSourceWaylandSurface::Init {\n    ChainedStruct * const nextInChain;\n    void * display;\n    void * surface;\n};\nSurfaceSourceWaylandSurface::SurfaceSourceWaylandSurface(SurfaceSourceWaylandSurface::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceWaylandSurface }, \n    display(std::move(init.display)), \n    surface(std::move(init.surface)){}\n\nSurfaceSourceWaylandSurface::operator const WGPUSurfaceSourceWaylandSurface&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceWaylandSurface*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceWaylandSurface) == sizeof(WGPUSurfaceSourceWaylandSurface), \"sizeof mismatch for SurfaceSourceWaylandSurface\");\nstatic_assert(alignof(SurfaceSourceWaylandSurface) == alignof(WGPUSurfaceSourceWaylandSurface), \"alignof mismatch for SurfaceSourceWaylandSurface\");\nstatic_assert(offsetof(SurfaceSourceWaylandSurface, display) == offsetof(WGPUSurfaceSourceWaylandSurface, display),\n        \"offsetof mismatch for SurfaceSourceWaylandSurface::display\");\nstatic_assert(offsetof(SurfaceSourceWaylandSurface, surface) == offsetof(WGPUSurfaceSourceWaylandSurface, surface),\n        \"offsetof mismatch for SurfaceSourceWaylandSurface::surface\");\n\n// SurfaceSourceWindowsHWND implementation\nSurfaceSourceWindowsHWND::SurfaceSourceWindowsHWND()\n  : ChainedStruct { nullptr, SType::SurfaceSourceWindowsHWND } {}\nstruct SurfaceSourceWindowsHWND::Init {\n    ChainedStruct * const nextInChain;\n    void * hinstance;\n    void * hwnd;\n};\nSurfaceSourceWindowsHWND::SurfaceSourceWindowsHWND(SurfaceSourceWindowsHWND::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceWindowsHWND }, \n    hinstance(std::move(init.hinstance)), \n    hwnd(std::move(init.hwnd)){}\n\nSurfaceSourceWindowsHWND::operator const WGPUSurfaceSourceWindowsHWND&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceWindowsHWND*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceWindowsHWND) == sizeof(WGPUSurfaceSourceWindowsHWND), \"sizeof mismatch for SurfaceSourceWindowsHWND\");\nstatic_assert(alignof(SurfaceSourceWindowsHWND) == alignof(WGPUSurfaceSourceWindowsHWND), \"alignof mismatch for SurfaceSourceWindowsHWND\");\nstatic_assert(offsetof(SurfaceSourceWindowsHWND, hinstance) == offsetof(WGPUSurfaceSourceWindowsHWND, hinstance),\n        \"offsetof mismatch for SurfaceSourceWindowsHWND::hinstance\");\nstatic_assert(offsetof(SurfaceSourceWindowsHWND, hwnd) == offsetof(WGPUSurfaceSourceWindowsHWND, hwnd),\n        \"offsetof mismatch for SurfaceSourceWindowsHWND::hwnd\");\n\n// SurfaceSourceXlibWindow implementation\nSurfaceSourceXlibWindow::SurfaceSourceXlibWindow()\n  : ChainedStruct { nullptr, SType::SurfaceSourceXlibWindow } {}\nstruct SurfaceSourceXlibWindow::Init {\n    ChainedStruct * const nextInChain;\n    void * display;\n    uint64_t window;\n};\nSurfaceSourceXlibWindow::SurfaceSourceXlibWindow(SurfaceSourceXlibWindow::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceXlibWindow }, \n    display(std::move(init.display)), \n    window(std::move(init.window)){}\n\nSurfaceSourceXlibWindow::operator const WGPUSurfaceSourceXlibWindow&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceXlibWindow*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceXlibWindow) == sizeof(WGPUSurfaceSourceXlibWindow), \"sizeof mismatch for SurfaceSourceXlibWindow\");\nstatic_assert(alignof(SurfaceSourceXlibWindow) == alignof(WGPUSurfaceSourceXlibWindow), \"alignof mismatch for SurfaceSourceXlibWindow\");\nstatic_assert(offsetof(SurfaceSourceXlibWindow, display) == offsetof(WGPUSurfaceSourceXlibWindow, display),\n        \"offsetof mismatch for SurfaceSourceXlibWindow::display\");\nstatic_assert(offsetof(SurfaceSourceXlibWindow, window) == offsetof(WGPUSurfaceSourceXlibWindow, window),\n        \"offsetof mismatch for SurfaceSourceXlibWindow::window\");\n\n// SurfaceTexture implementation\n\nSurfaceTexture::operator const WGPUSurfaceTexture&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceTexture*>(this);\n}\n\nstatic_assert(sizeof(SurfaceTexture) == sizeof(WGPUSurfaceTexture), \"sizeof mismatch for SurfaceTexture\");\nstatic_assert(alignof(SurfaceTexture) == alignof(WGPUSurfaceTexture), \"alignof mismatch for SurfaceTexture\");\nstatic_assert(offsetof(SurfaceTexture, texture) == offsetof(WGPUSurfaceTexture, texture),\n        \"offsetof mismatch for SurfaceTexture::texture\");\nstatic_assert(offsetof(SurfaceTexture, suboptimal) == offsetof(WGPUSurfaceTexture, suboptimal),\n        \"offsetof mismatch for SurfaceTexture::suboptimal\");\nstatic_assert(offsetof(SurfaceTexture, status) == offsetof(WGPUSurfaceTexture, status),\n        \"offsetof mismatch for SurfaceTexture::status\");\n\n// TextureBindingLayout implementation\n\nTextureBindingLayout::operator const WGPUTextureBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(TextureBindingLayout) == sizeof(WGPUTextureBindingLayout), \"sizeof mismatch for TextureBindingLayout\");\nstatic_assert(alignof(TextureBindingLayout) == alignof(WGPUTextureBindingLayout), \"alignof mismatch for TextureBindingLayout\");\nstatic_assert(offsetof(TextureBindingLayout, nextInChain) == offsetof(WGPUTextureBindingLayout, nextInChain),\n        \"offsetof mismatch for TextureBindingLayout::nextInChain\");\nstatic_assert(offsetof(TextureBindingLayout, sampleType) == offsetof(WGPUTextureBindingLayout, sampleType),\n        \"offsetof mismatch for TextureBindingLayout::sampleType\");\nstatic_assert(offsetof(TextureBindingLayout, viewDimension) == offsetof(WGPUTextureBindingLayout, viewDimension),\n        \"offsetof mismatch for TextureBindingLayout::viewDimension\");\nstatic_assert(offsetof(TextureBindingLayout, multisampled) == offsetof(WGPUTextureBindingLayout, multisampled),\n        \"offsetof mismatch for TextureBindingLayout::multisampled\");\n\n// TextureBindingViewDimensionDescriptor implementation\nTextureBindingViewDimensionDescriptor::TextureBindingViewDimensionDescriptor()\n  : ChainedStruct { nullptr, SType::TextureBindingViewDimensionDescriptor } {}\nstruct TextureBindingViewDimensionDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    TextureViewDimension textureBindingViewDimension = TextureViewDimension::Undefined;\n};\nTextureBindingViewDimensionDescriptor::TextureBindingViewDimensionDescriptor(TextureBindingViewDimensionDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::TextureBindingViewDimensionDescriptor }, \n    textureBindingViewDimension(std::move(init.textureBindingViewDimension)){}\n\nTextureBindingViewDimensionDescriptor::operator const WGPUTextureBindingViewDimensionDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureBindingViewDimensionDescriptor*>(this);\n}\n\nstatic_assert(sizeof(TextureBindingViewDimensionDescriptor) == sizeof(WGPUTextureBindingViewDimensionDescriptor), \"sizeof mismatch for TextureBindingViewDimensionDescriptor\");\nstatic_assert(alignof(TextureBindingViewDimensionDescriptor) == alignof(WGPUTextureBindingViewDimensionDescriptor), \"alignof mismatch for TextureBindingViewDimensionDescriptor\");\nstatic_assert(offsetof(TextureBindingViewDimensionDescriptor, textureBindingViewDimension) == offsetof(WGPUTextureBindingViewDimensionDescriptor, textureBindingViewDimension),\n        \"offsetof mismatch for TextureBindingViewDimensionDescriptor::textureBindingViewDimension\");\n\n// TextureDataLayout implementation\n\nTextureDataLayout::operator const WGPUTextureDataLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureDataLayout*>(this);\n}\n\nstatic_assert(sizeof(TextureDataLayout) == sizeof(WGPUTextureDataLayout), \"sizeof mismatch for TextureDataLayout\");\nstatic_assert(alignof(TextureDataLayout) == alignof(WGPUTextureDataLayout), \"alignof mismatch for TextureDataLayout\");\nstatic_assert(offsetof(TextureDataLayout, nextInChain) == offsetof(WGPUTextureDataLayout, nextInChain),\n        \"offsetof mismatch for TextureDataLayout::nextInChain\");\nstatic_assert(offsetof(TextureDataLayout, offset) == offsetof(WGPUTextureDataLayout, offset),\n        \"offsetof mismatch for TextureDataLayout::offset\");\nstatic_assert(offsetof(TextureDataLayout, bytesPerRow) == offsetof(WGPUTextureDataLayout, bytesPerRow),\n        \"offsetof mismatch for TextureDataLayout::bytesPerRow\");\nstatic_assert(offsetof(TextureDataLayout, rowsPerImage) == offsetof(WGPUTextureDataLayout, rowsPerImage),\n        \"offsetof mismatch for TextureDataLayout::rowsPerImage\");\n\n// UncapturedErrorCallbackInfo implementation\n\nUncapturedErrorCallbackInfo::operator const WGPUUncapturedErrorCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUUncapturedErrorCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(UncapturedErrorCallbackInfo) == sizeof(WGPUUncapturedErrorCallbackInfo), \"sizeof mismatch for UncapturedErrorCallbackInfo\");\nstatic_assert(alignof(UncapturedErrorCallbackInfo) == alignof(WGPUUncapturedErrorCallbackInfo), \"alignof mismatch for UncapturedErrorCallbackInfo\");\nstatic_assert(offsetof(UncapturedErrorCallbackInfo, nextInChain) == offsetof(WGPUUncapturedErrorCallbackInfo, nextInChain),\n        \"offsetof mismatch for UncapturedErrorCallbackInfo::nextInChain\");\nstatic_assert(offsetof(UncapturedErrorCallbackInfo, callback) == offsetof(WGPUUncapturedErrorCallbackInfo, callback),\n        \"offsetof mismatch for UncapturedErrorCallbackInfo::callback\");\nstatic_assert(offsetof(UncapturedErrorCallbackInfo, userdata) == offsetof(WGPUUncapturedErrorCallbackInfo, userdata),\n        \"offsetof mismatch for UncapturedErrorCallbackInfo::userdata\");\n\n// VertexAttribute implementation\n\nVertexAttribute::operator const WGPUVertexAttribute&() const noexcept {\n    return *reinterpret_cast<const WGPUVertexAttribute*>(this);\n}\n\nstatic_assert(sizeof(VertexAttribute) == sizeof(WGPUVertexAttribute), \"sizeof mismatch for VertexAttribute\");\nstatic_assert(alignof(VertexAttribute) == alignof(WGPUVertexAttribute), \"alignof mismatch for VertexAttribute\");\nstatic_assert(offsetof(VertexAttribute, format) == offsetof(WGPUVertexAttribute, format),\n        \"offsetof mismatch for VertexAttribute::format\");\nstatic_assert(offsetof(VertexAttribute, offset) == offsetof(WGPUVertexAttribute, offset),\n        \"offsetof mismatch for VertexAttribute::offset\");\nstatic_assert(offsetof(VertexAttribute, shaderLocation) == offsetof(WGPUVertexAttribute, shaderLocation),\n        \"offsetof mismatch for VertexAttribute::shaderLocation\");\n\n// YCbCrVkDescriptor implementation\nYCbCrVkDescriptor::YCbCrVkDescriptor()\n  : ChainedStruct { nullptr, SType::YCbCrVkDescriptor } {}\nstruct YCbCrVkDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t vkFormat = 0;\n    uint32_t vkYCbCrModel = 0;\n    uint32_t vkYCbCrRange = 0;\n    uint32_t vkComponentSwizzleRed = 0;\n    uint32_t vkComponentSwizzleGreen = 0;\n    uint32_t vkComponentSwizzleBlue = 0;\n    uint32_t vkComponentSwizzleAlpha = 0;\n    uint32_t vkXChromaOffset = 0;\n    uint32_t vkYChromaOffset = 0;\n    FilterMode vkChromaFilter = FilterMode::Nearest;\n    Bool forceExplicitReconstruction = false;\n    uint64_t externalFormat = 0;\n};\nYCbCrVkDescriptor::YCbCrVkDescriptor(YCbCrVkDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::YCbCrVkDescriptor }, \n    vkFormat(std::move(init.vkFormat)), \n    vkYCbCrModel(std::move(init.vkYCbCrModel)), \n    vkYCbCrRange(std::move(init.vkYCbCrRange)), \n    vkComponentSwizzleRed(std::move(init.vkComponentSwizzleRed)), \n    vkComponentSwizzleGreen(std::move(init.vkComponentSwizzleGreen)), \n    vkComponentSwizzleBlue(std::move(init.vkComponentSwizzleBlue)), \n    vkComponentSwizzleAlpha(std::move(init.vkComponentSwizzleAlpha)), \n    vkXChromaOffset(std::move(init.vkXChromaOffset)), \n    vkYChromaOffset(std::move(init.vkYChromaOffset)), \n    vkChromaFilter(std::move(init.vkChromaFilter)), \n    forceExplicitReconstruction(std::move(init.forceExplicitReconstruction)), \n    externalFormat(std::move(init.externalFormat)){}\n\nYCbCrVkDescriptor::operator const WGPUYCbCrVkDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUYCbCrVkDescriptor*>(this);\n}\n\nstatic_assert(sizeof(YCbCrVkDescriptor) == sizeof(WGPUYCbCrVkDescriptor), \"sizeof mismatch for YCbCrVkDescriptor\");\nstatic_assert(alignof(YCbCrVkDescriptor) == alignof(WGPUYCbCrVkDescriptor), \"alignof mismatch for YCbCrVkDescriptor\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkFormat) == offsetof(WGPUYCbCrVkDescriptor, vkFormat),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkFormat\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkYCbCrModel) == offsetof(WGPUYCbCrVkDescriptor, vkYCbCrModel),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkYCbCrModel\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkYCbCrRange) == offsetof(WGPUYCbCrVkDescriptor, vkYCbCrRange),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkYCbCrRange\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkComponentSwizzleRed) == offsetof(WGPUYCbCrVkDescriptor, vkComponentSwizzleRed),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkComponentSwizzleRed\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkComponentSwizzleGreen) == offsetof(WGPUYCbCrVkDescriptor, vkComponentSwizzleGreen),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkComponentSwizzleGreen\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkComponentSwizzleBlue) == offsetof(WGPUYCbCrVkDescriptor, vkComponentSwizzleBlue),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkComponentSwizzleBlue\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkComponentSwizzleAlpha) == offsetof(WGPUYCbCrVkDescriptor, vkComponentSwizzleAlpha),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkComponentSwizzleAlpha\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkXChromaOffset) == offsetof(WGPUYCbCrVkDescriptor, vkXChromaOffset),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkXChromaOffset\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkYChromaOffset) == offsetof(WGPUYCbCrVkDescriptor, vkYChromaOffset),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkYChromaOffset\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkChromaFilter) == offsetof(WGPUYCbCrVkDescriptor, vkChromaFilter),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkChromaFilter\");\nstatic_assert(offsetof(YCbCrVkDescriptor, forceExplicitReconstruction) == offsetof(WGPUYCbCrVkDescriptor, forceExplicitReconstruction),\n        \"offsetof mismatch for YCbCrVkDescriptor::forceExplicitReconstruction\");\nstatic_assert(offsetof(YCbCrVkDescriptor, externalFormat) == offsetof(WGPUYCbCrVkDescriptor, externalFormat),\n        \"offsetof mismatch for YCbCrVkDescriptor::externalFormat\");\n\n// AHardwareBufferProperties implementation\n\nAHardwareBufferProperties::operator const WGPUAHardwareBufferProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUAHardwareBufferProperties*>(this);\n}\n\nstatic_assert(sizeof(AHardwareBufferProperties) == sizeof(WGPUAHardwareBufferProperties), \"sizeof mismatch for AHardwareBufferProperties\");\nstatic_assert(alignof(AHardwareBufferProperties) == alignof(WGPUAHardwareBufferProperties), \"alignof mismatch for AHardwareBufferProperties\");\nstatic_assert(offsetof(AHardwareBufferProperties, yCbCrInfo) == offsetof(WGPUAHardwareBufferProperties, yCbCrInfo),\n        \"offsetof mismatch for AHardwareBufferProperties::yCbCrInfo\");\n\n// AdapterInfo implementation\nAdapterInfo::AdapterInfo() = default;\nAdapterInfo::~AdapterInfo() {\n    FreeMembers();\n}\n\nAdapterInfo::AdapterInfo(AdapterInfo&& rhs)\n    : vendor(rhs.vendor),\n            architecture(rhs.architecture),\n            device(rhs.device),\n            description(rhs.description),\n            backendType(rhs.backendType),\n            adapterType(rhs.adapterType),\n            vendorID(rhs.vendorID),\n            deviceID(rhs.deviceID),\n            compatibilityMode(rhs.compatibilityMode){\n    Reset(rhs);\n}\n\nAdapterInfo& AdapterInfo::operator=(AdapterInfo&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->vendor) = std::move(rhs.vendor);\n    detail::AsNonConstReference(this->architecture) = std::move(rhs.architecture);\n    detail::AsNonConstReference(this->device) = std::move(rhs.device);\n    detail::AsNonConstReference(this->description) = std::move(rhs.description);\n    detail::AsNonConstReference(this->backendType) = std::move(rhs.backendType);\n    detail::AsNonConstReference(this->adapterType) = std::move(rhs.adapterType);\n    detail::AsNonConstReference(this->vendorID) = std::move(rhs.vendorID);\n    detail::AsNonConstReference(this->deviceID) = std::move(rhs.deviceID);\n    detail::AsNonConstReference(this->compatibilityMode) = std::move(rhs.compatibilityMode);\n    Reset(rhs);\n    return *this;\n}\n\nvoid AdapterInfo::FreeMembers() {\n    bool needsFreeing = false;    if (this->vendor.data != nullptr) { needsFreeing = true; }    if (this->architecture.data != nullptr) { needsFreeing = true; }    if (this->device.data != nullptr) { needsFreeing = true; }    if (this->description.data != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuAdapterInfoFreeMembers(\n            *reinterpret_cast<WGPUAdapterInfo*>(this));\n    }\n}\n\n// static\nvoid AdapterInfo::Reset(AdapterInfo& value) {\n    AdapterInfo defaultValue{};\n    detail::AsNonConstReference(value.vendor) = defaultValue.vendor;\n    detail::AsNonConstReference(value.architecture) = defaultValue.architecture;\n    detail::AsNonConstReference(value.device) = defaultValue.device;\n    detail::AsNonConstReference(value.description) = defaultValue.description;\n    detail::AsNonConstReference(value.backendType) = defaultValue.backendType;\n    detail::AsNonConstReference(value.adapterType) = defaultValue.adapterType;\n    detail::AsNonConstReference(value.vendorID) = defaultValue.vendorID;\n    detail::AsNonConstReference(value.deviceID) = defaultValue.deviceID;\n    detail::AsNonConstReference(value.compatibilityMode) = defaultValue.compatibilityMode;\n}\n\nAdapterInfo::operator const WGPUAdapterInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterInfo*>(this);\n}\n\nstatic_assert(sizeof(AdapterInfo) == sizeof(WGPUAdapterInfo), \"sizeof mismatch for AdapterInfo\");\nstatic_assert(alignof(AdapterInfo) == alignof(WGPUAdapterInfo), \"alignof mismatch for AdapterInfo\");\nstatic_assert(offsetof(AdapterInfo, nextInChain) == offsetof(WGPUAdapterInfo, nextInChain),\n        \"offsetof mismatch for AdapterInfo::nextInChain\");\nstatic_assert(offsetof(AdapterInfo, vendor) == offsetof(WGPUAdapterInfo, vendor),\n        \"offsetof mismatch for AdapterInfo::vendor\");\nstatic_assert(offsetof(AdapterInfo, architecture) == offsetof(WGPUAdapterInfo, architecture),\n        \"offsetof mismatch for AdapterInfo::architecture\");\nstatic_assert(offsetof(AdapterInfo, device) == offsetof(WGPUAdapterInfo, device),\n        \"offsetof mismatch for AdapterInfo::device\");\nstatic_assert(offsetof(AdapterInfo, description) == offsetof(WGPUAdapterInfo, description),\n        \"offsetof mismatch for AdapterInfo::description\");\nstatic_assert(offsetof(AdapterInfo, backendType) == offsetof(WGPUAdapterInfo, backendType),\n        \"offsetof mismatch for AdapterInfo::backendType\");\nstatic_assert(offsetof(AdapterInfo, adapterType) == offsetof(WGPUAdapterInfo, adapterType),\n        \"offsetof mismatch for AdapterInfo::adapterType\");\nstatic_assert(offsetof(AdapterInfo, vendorID) == offsetof(WGPUAdapterInfo, vendorID),\n        \"offsetof mismatch for AdapterInfo::vendorID\");\nstatic_assert(offsetof(AdapterInfo, deviceID) == offsetof(WGPUAdapterInfo, deviceID),\n        \"offsetof mismatch for AdapterInfo::deviceID\");\nstatic_assert(offsetof(AdapterInfo, compatibilityMode) == offsetof(WGPUAdapterInfo, compatibilityMode),\n        \"offsetof mismatch for AdapterInfo::compatibilityMode\");\n\n// AdapterPropertiesMemoryHeaps implementation\nAdapterPropertiesMemoryHeaps::AdapterPropertiesMemoryHeaps()\n  : ChainedStructOut { nullptr, SType::AdapterPropertiesMemoryHeaps } {}\nstruct AdapterPropertiesMemoryHeaps::Init {\n    ChainedStructOut *  nextInChain;\n    size_t const heapCount = {};\n    MemoryHeapInfo const * const heapInfo = {};\n};\nAdapterPropertiesMemoryHeaps::AdapterPropertiesMemoryHeaps(AdapterPropertiesMemoryHeaps::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::AdapterPropertiesMemoryHeaps }, \n    heapCount(std::move(init.heapCount)), \n    heapInfo(std::move(init.heapInfo)){}\nAdapterPropertiesMemoryHeaps::~AdapterPropertiesMemoryHeaps() {\n    FreeMembers();\n}\n\nAdapterPropertiesMemoryHeaps::AdapterPropertiesMemoryHeaps(AdapterPropertiesMemoryHeaps&& rhs)\n    : heapCount(rhs.heapCount),\n            heapInfo(rhs.heapInfo){\n    Reset(rhs);\n}\n\nAdapterPropertiesMemoryHeaps& AdapterPropertiesMemoryHeaps::operator=(AdapterPropertiesMemoryHeaps&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->heapCount) = std::move(rhs.heapCount);\n    detail::AsNonConstReference(this->heapInfo) = std::move(rhs.heapInfo);\n    Reset(rhs);\n    return *this;\n}\n\nvoid AdapterPropertiesMemoryHeaps::FreeMembers() {\n    bool needsFreeing = false;    if (this->heapInfo != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuAdapterPropertiesMemoryHeapsFreeMembers(\n            *reinterpret_cast<WGPUAdapterPropertiesMemoryHeaps*>(this));\n    }\n}\n\n// static\nvoid AdapterPropertiesMemoryHeaps::Reset(AdapterPropertiesMemoryHeaps& value) {\n    AdapterPropertiesMemoryHeaps defaultValue{};\n    detail::AsNonConstReference(value.heapCount) = defaultValue.heapCount;\n    detail::AsNonConstReference(value.heapInfo) = defaultValue.heapInfo;\n}\n\nAdapterPropertiesMemoryHeaps::operator const WGPUAdapterPropertiesMemoryHeaps&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterPropertiesMemoryHeaps*>(this);\n}\n\nstatic_assert(sizeof(AdapterPropertiesMemoryHeaps) == sizeof(WGPUAdapterPropertiesMemoryHeaps), \"sizeof mismatch for AdapterPropertiesMemoryHeaps\");\nstatic_assert(alignof(AdapterPropertiesMemoryHeaps) == alignof(WGPUAdapterPropertiesMemoryHeaps), \"alignof mismatch for AdapterPropertiesMemoryHeaps\");\nstatic_assert(offsetof(AdapterPropertiesMemoryHeaps, heapCount) == offsetof(WGPUAdapterPropertiesMemoryHeaps, heapCount),\n        \"offsetof mismatch for AdapterPropertiesMemoryHeaps::heapCount\");\nstatic_assert(offsetof(AdapterPropertiesMemoryHeaps, heapInfo) == offsetof(WGPUAdapterPropertiesMemoryHeaps, heapInfo),\n        \"offsetof mismatch for AdapterPropertiesMemoryHeaps::heapInfo\");\n\n// BindGroupDescriptor implementation\n\nBindGroupDescriptor::operator const WGPUBindGroupDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUBindGroupDescriptor*>(this);\n}\n\nstatic_assert(sizeof(BindGroupDescriptor) == sizeof(WGPUBindGroupDescriptor), \"sizeof mismatch for BindGroupDescriptor\");\nstatic_assert(alignof(BindGroupDescriptor) == alignof(WGPUBindGroupDescriptor), \"alignof mismatch for BindGroupDescriptor\");\nstatic_assert(offsetof(BindGroupDescriptor, nextInChain) == offsetof(WGPUBindGroupDescriptor, nextInChain),\n        \"offsetof mismatch for BindGroupDescriptor::nextInChain\");\nstatic_assert(offsetof(BindGroupDescriptor, label) == offsetof(WGPUBindGroupDescriptor, label),\n        \"offsetof mismatch for BindGroupDescriptor::label\");\nstatic_assert(offsetof(BindGroupDescriptor, layout) == offsetof(WGPUBindGroupDescriptor, layout),\n        \"offsetof mismatch for BindGroupDescriptor::layout\");\nstatic_assert(offsetof(BindGroupDescriptor, entryCount) == offsetof(WGPUBindGroupDescriptor, entryCount),\n        \"offsetof mismatch for BindGroupDescriptor::entryCount\");\nstatic_assert(offsetof(BindGroupDescriptor, entries) == offsetof(WGPUBindGroupDescriptor, entries),\n        \"offsetof mismatch for BindGroupDescriptor::entries\");\n\n// BindGroupLayoutEntry implementation\n\nBindGroupLayoutEntry::operator const WGPUBindGroupLayoutEntry&() const noexcept {\n    return *reinterpret_cast<const WGPUBindGroupLayoutEntry*>(this);\n}\n\nstatic_assert(sizeof(BindGroupLayoutEntry) == sizeof(WGPUBindGroupLayoutEntry), \"sizeof mismatch for BindGroupLayoutEntry\");\nstatic_assert(alignof(BindGroupLayoutEntry) == alignof(WGPUBindGroupLayoutEntry), \"alignof mismatch for BindGroupLayoutEntry\");\nstatic_assert(offsetof(BindGroupLayoutEntry, nextInChain) == offsetof(WGPUBindGroupLayoutEntry, nextInChain),\n        \"offsetof mismatch for BindGroupLayoutEntry::nextInChain\");\nstatic_assert(offsetof(BindGroupLayoutEntry, binding) == offsetof(WGPUBindGroupLayoutEntry, binding),\n        \"offsetof mismatch for BindGroupLayoutEntry::binding\");\nstatic_assert(offsetof(BindGroupLayoutEntry, visibility) == offsetof(WGPUBindGroupLayoutEntry, visibility),\n        \"offsetof mismatch for BindGroupLayoutEntry::visibility\");\nstatic_assert(offsetof(BindGroupLayoutEntry, buffer) == offsetof(WGPUBindGroupLayoutEntry, buffer),\n        \"offsetof mismatch for BindGroupLayoutEntry::buffer\");\nstatic_assert(offsetof(BindGroupLayoutEntry, sampler) == offsetof(WGPUBindGroupLayoutEntry, sampler),\n        \"offsetof mismatch for BindGroupLayoutEntry::sampler\");\nstatic_assert(offsetof(BindGroupLayoutEntry, texture) == offsetof(WGPUBindGroupLayoutEntry, texture),\n        \"offsetof mismatch for BindGroupLayoutEntry::texture\");\nstatic_assert(offsetof(BindGroupLayoutEntry, storageTexture) == offsetof(WGPUBindGroupLayoutEntry, storageTexture),\n        \"offsetof mismatch for BindGroupLayoutEntry::storageTexture\");\n\n// BlendState implementation\n\nBlendState::operator const WGPUBlendState&() const noexcept {\n    return *reinterpret_cast<const WGPUBlendState*>(this);\n}\n\nstatic_assert(sizeof(BlendState) == sizeof(WGPUBlendState), \"sizeof mismatch for BlendState\");\nstatic_assert(alignof(BlendState) == alignof(WGPUBlendState), \"alignof mismatch for BlendState\");\nstatic_assert(offsetof(BlendState, color) == offsetof(WGPUBlendState, color),\n        \"offsetof mismatch for BlendState::color\");\nstatic_assert(offsetof(BlendState, alpha) == offsetof(WGPUBlendState, alpha),\n        \"offsetof mismatch for BlendState::alpha\");\n\n// BufferDescriptor implementation\n\nBufferDescriptor::operator const WGPUBufferDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUBufferDescriptor*>(this);\n}\n\nstatic_assert(sizeof(BufferDescriptor) == sizeof(WGPUBufferDescriptor), \"sizeof mismatch for BufferDescriptor\");\nstatic_assert(alignof(BufferDescriptor) == alignof(WGPUBufferDescriptor), \"alignof mismatch for BufferDescriptor\");\nstatic_assert(offsetof(BufferDescriptor, nextInChain) == offsetof(WGPUBufferDescriptor, nextInChain),\n        \"offsetof mismatch for BufferDescriptor::nextInChain\");\nstatic_assert(offsetof(BufferDescriptor, label) == offsetof(WGPUBufferDescriptor, label),\n        \"offsetof mismatch for BufferDescriptor::label\");\nstatic_assert(offsetof(BufferDescriptor, usage) == offsetof(WGPUBufferDescriptor, usage),\n        \"offsetof mismatch for BufferDescriptor::usage\");\nstatic_assert(offsetof(BufferDescriptor, size) == offsetof(WGPUBufferDescriptor, size),\n        \"offsetof mismatch for BufferDescriptor::size\");\nstatic_assert(offsetof(BufferDescriptor, mappedAtCreation) == offsetof(WGPUBufferDescriptor, mappedAtCreation),\n        \"offsetof mismatch for BufferDescriptor::mappedAtCreation\");\n\n// CommandBufferDescriptor implementation\n\nCommandBufferDescriptor::operator const WGPUCommandBufferDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUCommandBufferDescriptor*>(this);\n}\n\nstatic_assert(sizeof(CommandBufferDescriptor) == sizeof(WGPUCommandBufferDescriptor), \"sizeof mismatch for CommandBufferDescriptor\");\nstatic_assert(alignof(CommandBufferDescriptor) == alignof(WGPUCommandBufferDescriptor), \"alignof mismatch for CommandBufferDescriptor\");\nstatic_assert(offsetof(CommandBufferDescriptor, nextInChain) == offsetof(WGPUCommandBufferDescriptor, nextInChain),\n        \"offsetof mismatch for CommandBufferDescriptor::nextInChain\");\nstatic_assert(offsetof(CommandBufferDescriptor, label) == offsetof(WGPUCommandBufferDescriptor, label),\n        \"offsetof mismatch for CommandBufferDescriptor::label\");\n\n// CommandEncoderDescriptor implementation\n\nCommandEncoderDescriptor::operator const WGPUCommandEncoderDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUCommandEncoderDescriptor*>(this);\n}\n\nstatic_assert(sizeof(CommandEncoderDescriptor) == sizeof(WGPUCommandEncoderDescriptor), \"sizeof mismatch for CommandEncoderDescriptor\");\nstatic_assert(alignof(CommandEncoderDescriptor) == alignof(WGPUCommandEncoderDescriptor), \"alignof mismatch for CommandEncoderDescriptor\");\nstatic_assert(offsetof(CommandEncoderDescriptor, nextInChain) == offsetof(WGPUCommandEncoderDescriptor, nextInChain),\n        \"offsetof mismatch for CommandEncoderDescriptor::nextInChain\");\nstatic_assert(offsetof(CommandEncoderDescriptor, label) == offsetof(WGPUCommandEncoderDescriptor, label),\n        \"offsetof mismatch for CommandEncoderDescriptor::label\");\n\n// CompilationMessage implementation\n\nCompilationMessage::operator const WGPUCompilationMessage&() const noexcept {\n    return *reinterpret_cast<const WGPUCompilationMessage*>(this);\n}\n\nstatic_assert(sizeof(CompilationMessage) == sizeof(WGPUCompilationMessage), \"sizeof mismatch for CompilationMessage\");\nstatic_assert(alignof(CompilationMessage) == alignof(WGPUCompilationMessage), \"alignof mismatch for CompilationMessage\");\nstatic_assert(offsetof(CompilationMessage, nextInChain) == offsetof(WGPUCompilationMessage, nextInChain),\n        \"offsetof mismatch for CompilationMessage::nextInChain\");\nstatic_assert(offsetof(CompilationMessage, message) == offsetof(WGPUCompilationMessage, message),\n        \"offsetof mismatch for CompilationMessage::message\");\nstatic_assert(offsetof(CompilationMessage, type) == offsetof(WGPUCompilationMessage, type),\n        \"offsetof mismatch for CompilationMessage::type\");\nstatic_assert(offsetof(CompilationMessage, lineNum) == offsetof(WGPUCompilationMessage, lineNum),\n        \"offsetof mismatch for CompilationMessage::lineNum\");\nstatic_assert(offsetof(CompilationMessage, linePos) == offsetof(WGPUCompilationMessage, linePos),\n        \"offsetof mismatch for CompilationMessage::linePos\");\nstatic_assert(offsetof(CompilationMessage, offset) == offsetof(WGPUCompilationMessage, offset),\n        \"offsetof mismatch for CompilationMessage::offset\");\nstatic_assert(offsetof(CompilationMessage, length) == offsetof(WGPUCompilationMessage, length),\n        \"offsetof mismatch for CompilationMessage::length\");\nstatic_assert(offsetof(CompilationMessage, utf16LinePos) == offsetof(WGPUCompilationMessage, utf16LinePos),\n        \"offsetof mismatch for CompilationMessage::utf16LinePos\");\nstatic_assert(offsetof(CompilationMessage, utf16Offset) == offsetof(WGPUCompilationMessage, utf16Offset),\n        \"offsetof mismatch for CompilationMessage::utf16Offset\");\nstatic_assert(offsetof(CompilationMessage, utf16Length) == offsetof(WGPUCompilationMessage, utf16Length),\n        \"offsetof mismatch for CompilationMessage::utf16Length\");\n\n// ComputePassDescriptor implementation\n\nComputePassDescriptor::operator const WGPUComputePassDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUComputePassDescriptor*>(this);\n}\n\nstatic_assert(sizeof(ComputePassDescriptor) == sizeof(WGPUComputePassDescriptor), \"sizeof mismatch for ComputePassDescriptor\");\nstatic_assert(alignof(ComputePassDescriptor) == alignof(WGPUComputePassDescriptor), \"alignof mismatch for ComputePassDescriptor\");\nstatic_assert(offsetof(ComputePassDescriptor, nextInChain) == offsetof(WGPUComputePassDescriptor, nextInChain),\n        \"offsetof mismatch for ComputePassDescriptor::nextInChain\");\nstatic_assert(offsetof(ComputePassDescriptor, label) == offsetof(WGPUComputePassDescriptor, label),\n        \"offsetof mismatch for ComputePassDescriptor::label\");\nstatic_assert(offsetof(ComputePassDescriptor, timestampWrites) == offsetof(WGPUComputePassDescriptor, timestampWrites),\n        \"offsetof mismatch for ComputePassDescriptor::timestampWrites\");\n\n// ConstantEntry implementation\n\nConstantEntry::operator const WGPUConstantEntry&() const noexcept {\n    return *reinterpret_cast<const WGPUConstantEntry*>(this);\n}\n\nstatic_assert(sizeof(ConstantEntry) == sizeof(WGPUConstantEntry), \"sizeof mismatch for ConstantEntry\");\nstatic_assert(alignof(ConstantEntry) == alignof(WGPUConstantEntry), \"alignof mismatch for ConstantEntry\");\nstatic_assert(offsetof(ConstantEntry, nextInChain) == offsetof(WGPUConstantEntry, nextInChain),\n        \"offsetof mismatch for ConstantEntry::nextInChain\");\nstatic_assert(offsetof(ConstantEntry, key) == offsetof(WGPUConstantEntry, key),\n        \"offsetof mismatch for ConstantEntry::key\");\nstatic_assert(offsetof(ConstantEntry, value) == offsetof(WGPUConstantEntry, value),\n        \"offsetof mismatch for ConstantEntry::value\");\n\n// DawnCacheDeviceDescriptor implementation\nDawnCacheDeviceDescriptor::DawnCacheDeviceDescriptor()\n  : ChainedStruct { nullptr, SType::DawnCacheDeviceDescriptor } {}\nstruct DawnCacheDeviceDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    StringView isolationKey = {};\n    DawnLoadCacheDataFunction loadDataFunction = nullptr;\n    DawnStoreCacheDataFunction storeDataFunction = nullptr;\n    void * functionUserdata = nullptr;\n};\nDawnCacheDeviceDescriptor::DawnCacheDeviceDescriptor(DawnCacheDeviceDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnCacheDeviceDescriptor }, \n    isolationKey(std::move(init.isolationKey)), \n    loadDataFunction(std::move(init.loadDataFunction)), \n    storeDataFunction(std::move(init.storeDataFunction)), \n    functionUserdata(std::move(init.functionUserdata)){}\n\nDawnCacheDeviceDescriptor::operator const WGPUDawnCacheDeviceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnCacheDeviceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnCacheDeviceDescriptor) == sizeof(WGPUDawnCacheDeviceDescriptor), \"sizeof mismatch for DawnCacheDeviceDescriptor\");\nstatic_assert(alignof(DawnCacheDeviceDescriptor) == alignof(WGPUDawnCacheDeviceDescriptor), \"alignof mismatch for DawnCacheDeviceDescriptor\");\nstatic_assert(offsetof(DawnCacheDeviceDescriptor, isolationKey) == offsetof(WGPUDawnCacheDeviceDescriptor, isolationKey),\n        \"offsetof mismatch for DawnCacheDeviceDescriptor::isolationKey\");\nstatic_assert(offsetof(DawnCacheDeviceDescriptor, loadDataFunction) == offsetof(WGPUDawnCacheDeviceDescriptor, loadDataFunction),\n        \"offsetof mismatch for DawnCacheDeviceDescriptor::loadDataFunction\");\nstatic_assert(offsetof(DawnCacheDeviceDescriptor, storeDataFunction) == offsetof(WGPUDawnCacheDeviceDescriptor, storeDataFunction),\n        \"offsetof mismatch for DawnCacheDeviceDescriptor::storeDataFunction\");\nstatic_assert(offsetof(DawnCacheDeviceDescriptor, functionUserdata) == offsetof(WGPUDawnCacheDeviceDescriptor, functionUserdata),\n        \"offsetof mismatch for DawnCacheDeviceDescriptor::functionUserdata\");\n\n// DepthStencilState implementation\n\nDepthStencilState::operator const WGPUDepthStencilState&() const noexcept {\n    return *reinterpret_cast<const WGPUDepthStencilState*>(this);\n}\n\nstatic_assert(sizeof(DepthStencilState) == sizeof(WGPUDepthStencilState), \"sizeof mismatch for DepthStencilState\");\nstatic_assert(alignof(DepthStencilState) == alignof(WGPUDepthStencilState), \"alignof mismatch for DepthStencilState\");\nstatic_assert(offsetof(DepthStencilState, nextInChain) == offsetof(WGPUDepthStencilState, nextInChain),\n        \"offsetof mismatch for DepthStencilState::nextInChain\");\nstatic_assert(offsetof(DepthStencilState, format) == offsetof(WGPUDepthStencilState, format),\n        \"offsetof mismatch for DepthStencilState::format\");\nstatic_assert(offsetof(DepthStencilState, depthWriteEnabled) == offsetof(WGPUDepthStencilState, depthWriteEnabled),\n        \"offsetof mismatch for DepthStencilState::depthWriteEnabled\");\nstatic_assert(offsetof(DepthStencilState, depthCompare) == offsetof(WGPUDepthStencilState, depthCompare),\n        \"offsetof mismatch for DepthStencilState::depthCompare\");\nstatic_assert(offsetof(DepthStencilState, stencilFront) == offsetof(WGPUDepthStencilState, stencilFront),\n        \"offsetof mismatch for DepthStencilState::stencilFront\");\nstatic_assert(offsetof(DepthStencilState, stencilBack) == offsetof(WGPUDepthStencilState, stencilBack),\n        \"offsetof mismatch for DepthStencilState::stencilBack\");\nstatic_assert(offsetof(DepthStencilState, stencilReadMask) == offsetof(WGPUDepthStencilState, stencilReadMask),\n        \"offsetof mismatch for DepthStencilState::stencilReadMask\");\nstatic_assert(offsetof(DepthStencilState, stencilWriteMask) == offsetof(WGPUDepthStencilState, stencilWriteMask),\n        \"offsetof mismatch for DepthStencilState::stencilWriteMask\");\nstatic_assert(offsetof(DepthStencilState, depthBias) == offsetof(WGPUDepthStencilState, depthBias),\n        \"offsetof mismatch for DepthStencilState::depthBias\");\nstatic_assert(offsetof(DepthStencilState, depthBiasSlopeScale) == offsetof(WGPUDepthStencilState, depthBiasSlopeScale),\n        \"offsetof mismatch for DepthStencilState::depthBiasSlopeScale\");\nstatic_assert(offsetof(DepthStencilState, depthBiasClamp) == offsetof(WGPUDepthStencilState, depthBiasClamp),\n        \"offsetof mismatch for DepthStencilState::depthBiasClamp\");\n\n// DrmFormatCapabilities implementation\nDrmFormatCapabilities::DrmFormatCapabilities()\n  : ChainedStructOut { nullptr, SType::DrmFormatCapabilities } {}\nstruct DrmFormatCapabilities::Init {\n    ChainedStructOut *  nextInChain;\n    size_t const propertiesCount = {};\n    DrmFormatProperties const * const properties = {};\n};\nDrmFormatCapabilities::DrmFormatCapabilities(DrmFormatCapabilities::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DrmFormatCapabilities }, \n    propertiesCount(std::move(init.propertiesCount)), \n    properties(std::move(init.properties)){}\nDrmFormatCapabilities::~DrmFormatCapabilities() {\n    FreeMembers();\n}\n\nDrmFormatCapabilities::DrmFormatCapabilities(DrmFormatCapabilities&& rhs)\n    : propertiesCount(rhs.propertiesCount),\n            properties(rhs.properties){\n    Reset(rhs);\n}\n\nDrmFormatCapabilities& DrmFormatCapabilities::operator=(DrmFormatCapabilities&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->propertiesCount) = std::move(rhs.propertiesCount);\n    detail::AsNonConstReference(this->properties) = std::move(rhs.properties);\n    Reset(rhs);\n    return *this;\n}\n\nvoid DrmFormatCapabilities::FreeMembers() {\n    bool needsFreeing = false;    if (this->properties != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuDrmFormatCapabilitiesFreeMembers(\n            *reinterpret_cast<WGPUDrmFormatCapabilities*>(this));\n    }\n}\n\n// static\nvoid DrmFormatCapabilities::Reset(DrmFormatCapabilities& value) {\n    DrmFormatCapabilities defaultValue{};\n    detail::AsNonConstReference(value.propertiesCount) = defaultValue.propertiesCount;\n    detail::AsNonConstReference(value.properties) = defaultValue.properties;\n}\n\nDrmFormatCapabilities::operator const WGPUDrmFormatCapabilities&() const noexcept {\n    return *reinterpret_cast<const WGPUDrmFormatCapabilities*>(this);\n}\n\nstatic_assert(sizeof(DrmFormatCapabilities) == sizeof(WGPUDrmFormatCapabilities), \"sizeof mismatch for DrmFormatCapabilities\");\nstatic_assert(alignof(DrmFormatCapabilities) == alignof(WGPUDrmFormatCapabilities), \"alignof mismatch for DrmFormatCapabilities\");\nstatic_assert(offsetof(DrmFormatCapabilities, propertiesCount) == offsetof(WGPUDrmFormatCapabilities, propertiesCount),\n        \"offsetof mismatch for DrmFormatCapabilities::propertiesCount\");\nstatic_assert(offsetof(DrmFormatCapabilities, properties) == offsetof(WGPUDrmFormatCapabilities, properties),\n        \"offsetof mismatch for DrmFormatCapabilities::properties\");\n\n// ExternalTextureDescriptor implementation\n\nExternalTextureDescriptor::operator const WGPUExternalTextureDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUExternalTextureDescriptor*>(this);\n}\n\nstatic_assert(sizeof(ExternalTextureDescriptor) == sizeof(WGPUExternalTextureDescriptor), \"sizeof mismatch for ExternalTextureDescriptor\");\nstatic_assert(alignof(ExternalTextureDescriptor) == alignof(WGPUExternalTextureDescriptor), \"alignof mismatch for ExternalTextureDescriptor\");\nstatic_assert(offsetof(ExternalTextureDescriptor, nextInChain) == offsetof(WGPUExternalTextureDescriptor, nextInChain),\n        \"offsetof mismatch for ExternalTextureDescriptor::nextInChain\");\nstatic_assert(offsetof(ExternalTextureDescriptor, label) == offsetof(WGPUExternalTextureDescriptor, label),\n        \"offsetof mismatch for ExternalTextureDescriptor::label\");\nstatic_assert(offsetof(ExternalTextureDescriptor, plane0) == offsetof(WGPUExternalTextureDescriptor, plane0),\n        \"offsetof mismatch for ExternalTextureDescriptor::plane0\");\nstatic_assert(offsetof(ExternalTextureDescriptor, plane1) == offsetof(WGPUExternalTextureDescriptor, plane1),\n        \"offsetof mismatch for ExternalTextureDescriptor::plane1\");\nstatic_assert(offsetof(ExternalTextureDescriptor, cropOrigin) == offsetof(WGPUExternalTextureDescriptor, cropOrigin),\n        \"offsetof mismatch for ExternalTextureDescriptor::cropOrigin\");\nstatic_assert(offsetof(ExternalTextureDescriptor, cropSize) == offsetof(WGPUExternalTextureDescriptor, cropSize),\n        \"offsetof mismatch for ExternalTextureDescriptor::cropSize\");\nstatic_assert(offsetof(ExternalTextureDescriptor, apparentSize) == offsetof(WGPUExternalTextureDescriptor, apparentSize),\n        \"offsetof mismatch for ExternalTextureDescriptor::apparentSize\");\nstatic_assert(offsetof(ExternalTextureDescriptor, doYuvToRgbConversionOnly) == offsetof(WGPUExternalTextureDescriptor, doYuvToRgbConversionOnly),\n        \"offsetof mismatch for ExternalTextureDescriptor::doYuvToRgbConversionOnly\");\nstatic_assert(offsetof(ExternalTextureDescriptor, yuvToRgbConversionMatrix) == offsetof(WGPUExternalTextureDescriptor, yuvToRgbConversionMatrix),\n        \"offsetof mismatch for ExternalTextureDescriptor::yuvToRgbConversionMatrix\");\nstatic_assert(offsetof(ExternalTextureDescriptor, srcTransferFunctionParameters) == offsetof(WGPUExternalTextureDescriptor, srcTransferFunctionParameters),\n        \"offsetof mismatch for ExternalTextureDescriptor::srcTransferFunctionParameters\");\nstatic_assert(offsetof(ExternalTextureDescriptor, dstTransferFunctionParameters) == offsetof(WGPUExternalTextureDescriptor, dstTransferFunctionParameters),\n        \"offsetof mismatch for ExternalTextureDescriptor::dstTransferFunctionParameters\");\nstatic_assert(offsetof(ExternalTextureDescriptor, gamutConversionMatrix) == offsetof(WGPUExternalTextureDescriptor, gamutConversionMatrix),\n        \"offsetof mismatch for ExternalTextureDescriptor::gamutConversionMatrix\");\nstatic_assert(offsetof(ExternalTextureDescriptor, mirrored) == offsetof(WGPUExternalTextureDescriptor, mirrored),\n        \"offsetof mismatch for ExternalTextureDescriptor::mirrored\");\nstatic_assert(offsetof(ExternalTextureDescriptor, rotation) == offsetof(WGPUExternalTextureDescriptor, rotation),\n        \"offsetof mismatch for ExternalTextureDescriptor::rotation\");\n\n// FutureWaitInfo implementation\n\nFutureWaitInfo::operator const WGPUFutureWaitInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUFutureWaitInfo*>(this);\n}\n\nstatic_assert(sizeof(FutureWaitInfo) == sizeof(WGPUFutureWaitInfo), \"sizeof mismatch for FutureWaitInfo\");\nstatic_assert(alignof(FutureWaitInfo) == alignof(WGPUFutureWaitInfo), \"alignof mismatch for FutureWaitInfo\");\nstatic_assert(offsetof(FutureWaitInfo, future) == offsetof(WGPUFutureWaitInfo, future),\n        \"offsetof mismatch for FutureWaitInfo::future\");\nstatic_assert(offsetof(FutureWaitInfo, completed) == offsetof(WGPUFutureWaitInfo, completed),\n        \"offsetof mismatch for FutureWaitInfo::completed\");\n\n// ImageCopyBuffer implementation\n\nImageCopyBuffer::operator const WGPUImageCopyBuffer&() const noexcept {\n    return *reinterpret_cast<const WGPUImageCopyBuffer*>(this);\n}\n\nstatic_assert(sizeof(ImageCopyBuffer) == sizeof(WGPUImageCopyBuffer), \"sizeof mismatch for ImageCopyBuffer\");\nstatic_assert(alignof(ImageCopyBuffer) == alignof(WGPUImageCopyBuffer), \"alignof mismatch for ImageCopyBuffer\");\nstatic_assert(offsetof(ImageCopyBuffer, layout) == offsetof(WGPUImageCopyBuffer, layout),\n        \"offsetof mismatch for ImageCopyBuffer::layout\");\nstatic_assert(offsetof(ImageCopyBuffer, buffer) == offsetof(WGPUImageCopyBuffer, buffer),\n        \"offsetof mismatch for ImageCopyBuffer::buffer\");\n\n// ImageCopyExternalTexture implementation\n\nImageCopyExternalTexture::operator const WGPUImageCopyExternalTexture&() const noexcept {\n    return *reinterpret_cast<const WGPUImageCopyExternalTexture*>(this);\n}\n\nstatic_assert(sizeof(ImageCopyExternalTexture) == sizeof(WGPUImageCopyExternalTexture), \"sizeof mismatch for ImageCopyExternalTexture\");\nstatic_assert(alignof(ImageCopyExternalTexture) == alignof(WGPUImageCopyExternalTexture), \"alignof mismatch for ImageCopyExternalTexture\");\nstatic_assert(offsetof(ImageCopyExternalTexture, nextInChain) == offsetof(WGPUImageCopyExternalTexture, nextInChain),\n        \"offsetof mismatch for ImageCopyExternalTexture::nextInChain\");\nstatic_assert(offsetof(ImageCopyExternalTexture, externalTexture) == offsetof(WGPUImageCopyExternalTexture, externalTexture),\n        \"offsetof mismatch for ImageCopyExternalTexture::externalTexture\");\nstatic_assert(offsetof(ImageCopyExternalTexture, origin) == offsetof(WGPUImageCopyExternalTexture, origin),\n        \"offsetof mismatch for ImageCopyExternalTexture::origin\");\nstatic_assert(offsetof(ImageCopyExternalTexture, naturalSize) == offsetof(WGPUImageCopyExternalTexture, naturalSize),\n        \"offsetof mismatch for ImageCopyExternalTexture::naturalSize\");\n\n// ImageCopyTexture implementation\n\nImageCopyTexture::operator const WGPUImageCopyTexture&() const noexcept {\n    return *reinterpret_cast<const WGPUImageCopyTexture*>(this);\n}\n\nstatic_assert(sizeof(ImageCopyTexture) == sizeof(WGPUImageCopyTexture), \"sizeof mismatch for ImageCopyTexture\");\nstatic_assert(alignof(ImageCopyTexture) == alignof(WGPUImageCopyTexture), \"alignof mismatch for ImageCopyTexture\");\nstatic_assert(offsetof(ImageCopyTexture, texture) == offsetof(WGPUImageCopyTexture, texture),\n        \"offsetof mismatch for ImageCopyTexture::texture\");\nstatic_assert(offsetof(ImageCopyTexture, mipLevel) == offsetof(WGPUImageCopyTexture, mipLevel),\n        \"offsetof mismatch for ImageCopyTexture::mipLevel\");\nstatic_assert(offsetof(ImageCopyTexture, origin) == offsetof(WGPUImageCopyTexture, origin),\n        \"offsetof mismatch for ImageCopyTexture::origin\");\nstatic_assert(offsetof(ImageCopyTexture, aspect) == offsetof(WGPUImageCopyTexture, aspect),\n        \"offsetof mismatch for ImageCopyTexture::aspect\");\n\n// InstanceDescriptor implementation\n\nInstanceDescriptor::operator const WGPUInstanceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUInstanceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(InstanceDescriptor) == sizeof(WGPUInstanceDescriptor), \"sizeof mismatch for InstanceDescriptor\");\nstatic_assert(alignof(InstanceDescriptor) == alignof(WGPUInstanceDescriptor), \"alignof mismatch for InstanceDescriptor\");\nstatic_assert(offsetof(InstanceDescriptor, nextInChain) == offsetof(WGPUInstanceDescriptor, nextInChain),\n        \"offsetof mismatch for InstanceDescriptor::nextInChain\");\nstatic_assert(offsetof(InstanceDescriptor, features) == offsetof(WGPUInstanceDescriptor, features),\n        \"offsetof mismatch for InstanceDescriptor::features\");\n\n// PipelineLayoutDescriptor implementation\n\nPipelineLayoutDescriptor::operator const WGPUPipelineLayoutDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUPipelineLayoutDescriptor*>(this);\n}\n\nstatic_assert(sizeof(PipelineLayoutDescriptor) == sizeof(WGPUPipelineLayoutDescriptor), \"sizeof mismatch for PipelineLayoutDescriptor\");\nstatic_assert(alignof(PipelineLayoutDescriptor) == alignof(WGPUPipelineLayoutDescriptor), \"alignof mismatch for PipelineLayoutDescriptor\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, nextInChain) == offsetof(WGPUPipelineLayoutDescriptor, nextInChain),\n        \"offsetof mismatch for PipelineLayoutDescriptor::nextInChain\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, label) == offsetof(WGPUPipelineLayoutDescriptor, label),\n        \"offsetof mismatch for PipelineLayoutDescriptor::label\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayoutCount) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayoutCount),\n        \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayoutCount\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayouts) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayouts),\n        \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayouts\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, immediateDataRangeByteSize) == offsetof(WGPUPipelineLayoutDescriptor, immediateDataRangeByteSize),\n        \"offsetof mismatch for PipelineLayoutDescriptor::immediateDataRangeByteSize\");\n\n// PipelineLayoutPixelLocalStorage implementation\nPipelineLayoutPixelLocalStorage::PipelineLayoutPixelLocalStorage()\n  : ChainedStruct { nullptr, SType::PipelineLayoutPixelLocalStorage } {}\nstruct PipelineLayoutPixelLocalStorage::Init {\n    ChainedStruct * const nextInChain;\n    uint64_t totalPixelLocalStorageSize;\n    size_t storageAttachmentCount = 0;\n    PipelineLayoutStorageAttachment const * storageAttachments;\n};\nPipelineLayoutPixelLocalStorage::PipelineLayoutPixelLocalStorage(PipelineLayoutPixelLocalStorage::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::PipelineLayoutPixelLocalStorage }, \n    totalPixelLocalStorageSize(std::move(init.totalPixelLocalStorageSize)), \n    storageAttachmentCount(std::move(init.storageAttachmentCount)), \n    storageAttachments(std::move(init.storageAttachments)){}\n\nPipelineLayoutPixelLocalStorage::operator const WGPUPipelineLayoutPixelLocalStorage&() const noexcept {\n    return *reinterpret_cast<const WGPUPipelineLayoutPixelLocalStorage*>(this);\n}\n\nstatic_assert(sizeof(PipelineLayoutPixelLocalStorage) == sizeof(WGPUPipelineLayoutPixelLocalStorage), \"sizeof mismatch for PipelineLayoutPixelLocalStorage\");\nstatic_assert(alignof(PipelineLayoutPixelLocalStorage) == alignof(WGPUPipelineLayoutPixelLocalStorage), \"alignof mismatch for PipelineLayoutPixelLocalStorage\");\nstatic_assert(offsetof(PipelineLayoutPixelLocalStorage, totalPixelLocalStorageSize) == offsetof(WGPUPipelineLayoutPixelLocalStorage, totalPixelLocalStorageSize),\n        \"offsetof mismatch for PipelineLayoutPixelLocalStorage::totalPixelLocalStorageSize\");\nstatic_assert(offsetof(PipelineLayoutPixelLocalStorage, storageAttachmentCount) == offsetof(WGPUPipelineLayoutPixelLocalStorage, storageAttachmentCount),\n        \"offsetof mismatch for PipelineLayoutPixelLocalStorage::storageAttachmentCount\");\nstatic_assert(offsetof(PipelineLayoutPixelLocalStorage, storageAttachments) == offsetof(WGPUPipelineLayoutPixelLocalStorage, storageAttachments),\n        \"offsetof mismatch for PipelineLayoutPixelLocalStorage::storageAttachments\");\n\n// QuerySetDescriptor implementation\n\nQuerySetDescriptor::operator const WGPUQuerySetDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUQuerySetDescriptor*>(this);\n}\n\nstatic_assert(sizeof(QuerySetDescriptor) == sizeof(WGPUQuerySetDescriptor), \"sizeof mismatch for QuerySetDescriptor\");\nstatic_assert(alignof(QuerySetDescriptor) == alignof(WGPUQuerySetDescriptor), \"alignof mismatch for QuerySetDescriptor\");\nstatic_assert(offsetof(QuerySetDescriptor, nextInChain) == offsetof(WGPUQuerySetDescriptor, nextInChain),\n        \"offsetof mismatch for QuerySetDescriptor::nextInChain\");\nstatic_assert(offsetof(QuerySetDescriptor, label) == offsetof(WGPUQuerySetDescriptor, label),\n        \"offsetof mismatch for QuerySetDescriptor::label\");\nstatic_assert(offsetof(QuerySetDescriptor, type) == offsetof(WGPUQuerySetDescriptor, type),\n        \"offsetof mismatch for QuerySetDescriptor::type\");\nstatic_assert(offsetof(QuerySetDescriptor, count) == offsetof(WGPUQuerySetDescriptor, count),\n        \"offsetof mismatch for QuerySetDescriptor::count\");\n\n// QueueDescriptor implementation\n\nQueueDescriptor::operator const WGPUQueueDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUQueueDescriptor*>(this);\n}\n\nstatic_assert(sizeof(QueueDescriptor) == sizeof(WGPUQueueDescriptor), \"sizeof mismatch for QueueDescriptor\");\nstatic_assert(alignof(QueueDescriptor) == alignof(WGPUQueueDescriptor), \"alignof mismatch for QueueDescriptor\");\nstatic_assert(offsetof(QueueDescriptor, nextInChain) == offsetof(WGPUQueueDescriptor, nextInChain),\n        \"offsetof mismatch for QueueDescriptor::nextInChain\");\nstatic_assert(offsetof(QueueDescriptor, label) == offsetof(WGPUQueueDescriptor, label),\n        \"offsetof mismatch for QueueDescriptor::label\");\n\n// RenderBundleDescriptor implementation\n\nRenderBundleDescriptor::operator const WGPURenderBundleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPURenderBundleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(RenderBundleDescriptor) == sizeof(WGPURenderBundleDescriptor), \"sizeof mismatch for RenderBundleDescriptor\");\nstatic_assert(alignof(RenderBundleDescriptor) == alignof(WGPURenderBundleDescriptor), \"alignof mismatch for RenderBundleDescriptor\");\nstatic_assert(offsetof(RenderBundleDescriptor, nextInChain) == offsetof(WGPURenderBundleDescriptor, nextInChain),\n        \"offsetof mismatch for RenderBundleDescriptor::nextInChain\");\nstatic_assert(offsetof(RenderBundleDescriptor, label) == offsetof(WGPURenderBundleDescriptor, label),\n        \"offsetof mismatch for RenderBundleDescriptor::label\");\n\n// RenderBundleEncoderDescriptor implementation\n\nRenderBundleEncoderDescriptor::operator const WGPURenderBundleEncoderDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPURenderBundleEncoderDescriptor*>(this);\n}\n\nstatic_assert(sizeof(RenderBundleEncoderDescriptor) == sizeof(WGPURenderBundleEncoderDescriptor), \"sizeof mismatch for RenderBundleEncoderDescriptor\");\nstatic_assert(alignof(RenderBundleEncoderDescriptor) == alignof(WGPURenderBundleEncoderDescriptor), \"alignof mismatch for RenderBundleEncoderDescriptor\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, nextInChain) == offsetof(WGPURenderBundleEncoderDescriptor, nextInChain),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::nextInChain\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, label) == offsetof(WGPURenderBundleEncoderDescriptor, label),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::label\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, colorFormatCount) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormatCount),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormatCount\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, colorFormats) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormats),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormats\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, depthStencilFormat) == offsetof(WGPURenderBundleEncoderDescriptor, depthStencilFormat),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::depthStencilFormat\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, sampleCount) == offsetof(WGPURenderBundleEncoderDescriptor, sampleCount),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::sampleCount\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, depthReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, depthReadOnly),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::depthReadOnly\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, stencilReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, stencilReadOnly),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::stencilReadOnly\");\n\n// RenderPassColorAttachment implementation\n\nRenderPassColorAttachment::operator const WGPURenderPassColorAttachment&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassColorAttachment*>(this);\n}\n\nstatic_assert(sizeof(RenderPassColorAttachment) == sizeof(WGPURenderPassColorAttachment), \"sizeof mismatch for RenderPassColorAttachment\");\nstatic_assert(alignof(RenderPassColorAttachment) == alignof(WGPURenderPassColorAttachment), \"alignof mismatch for RenderPassColorAttachment\");\nstatic_assert(offsetof(RenderPassColorAttachment, nextInChain) == offsetof(WGPURenderPassColorAttachment, nextInChain),\n        \"offsetof mismatch for RenderPassColorAttachment::nextInChain\");\nstatic_assert(offsetof(RenderPassColorAttachment, view) == offsetof(WGPURenderPassColorAttachment, view),\n        \"offsetof mismatch for RenderPassColorAttachment::view\");\nstatic_assert(offsetof(RenderPassColorAttachment, depthSlice) == offsetof(WGPURenderPassColorAttachment, depthSlice),\n        \"offsetof mismatch for RenderPassColorAttachment::depthSlice\");\nstatic_assert(offsetof(RenderPassColorAttachment, resolveTarget) == offsetof(WGPURenderPassColorAttachment, resolveTarget),\n        \"offsetof mismatch for RenderPassColorAttachment::resolveTarget\");\nstatic_assert(offsetof(RenderPassColorAttachment, loadOp) == offsetof(WGPURenderPassColorAttachment, loadOp),\n        \"offsetof mismatch for RenderPassColorAttachment::loadOp\");\nstatic_assert(offsetof(RenderPassColorAttachment, storeOp) == offsetof(WGPURenderPassColorAttachment, storeOp),\n        \"offsetof mismatch for RenderPassColorAttachment::storeOp\");\nstatic_assert(offsetof(RenderPassColorAttachment, clearValue) == offsetof(WGPURenderPassColorAttachment, clearValue),\n        \"offsetof mismatch for RenderPassColorAttachment::clearValue\");\n\n// RenderPassStorageAttachment implementation\n\nRenderPassStorageAttachment::operator const WGPURenderPassStorageAttachment&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassStorageAttachment*>(this);\n}\n\nstatic_assert(sizeof(RenderPassStorageAttachment) == sizeof(WGPURenderPassStorageAttachment), \"sizeof mismatch for RenderPassStorageAttachment\");\nstatic_assert(alignof(RenderPassStorageAttachment) == alignof(WGPURenderPassStorageAttachment), \"alignof mismatch for RenderPassStorageAttachment\");\nstatic_assert(offsetof(RenderPassStorageAttachment, nextInChain) == offsetof(WGPURenderPassStorageAttachment, nextInChain),\n        \"offsetof mismatch for RenderPassStorageAttachment::nextInChain\");\nstatic_assert(offsetof(RenderPassStorageAttachment, offset) == offsetof(WGPURenderPassStorageAttachment, offset),\n        \"offsetof mismatch for RenderPassStorageAttachment::offset\");\nstatic_assert(offsetof(RenderPassStorageAttachment, storage) == offsetof(WGPURenderPassStorageAttachment, storage),\n        \"offsetof mismatch for RenderPassStorageAttachment::storage\");\nstatic_assert(offsetof(RenderPassStorageAttachment, loadOp) == offsetof(WGPURenderPassStorageAttachment, loadOp),\n        \"offsetof mismatch for RenderPassStorageAttachment::loadOp\");\nstatic_assert(offsetof(RenderPassStorageAttachment, storeOp) == offsetof(WGPURenderPassStorageAttachment, storeOp),\n        \"offsetof mismatch for RenderPassStorageAttachment::storeOp\");\nstatic_assert(offsetof(RenderPassStorageAttachment, clearValue) == offsetof(WGPURenderPassStorageAttachment, clearValue),\n        \"offsetof mismatch for RenderPassStorageAttachment::clearValue\");\n\n// RequiredLimits implementation\n\nRequiredLimits::operator const WGPURequiredLimits&() const noexcept {\n    return *reinterpret_cast<const WGPURequiredLimits*>(this);\n}\n\nstatic_assert(sizeof(RequiredLimits) == sizeof(WGPURequiredLimits), \"sizeof mismatch for RequiredLimits\");\nstatic_assert(alignof(RequiredLimits) == alignof(WGPURequiredLimits), \"alignof mismatch for RequiredLimits\");\nstatic_assert(offsetof(RequiredLimits, nextInChain) == offsetof(WGPURequiredLimits, nextInChain),\n        \"offsetof mismatch for RequiredLimits::nextInChain\");\nstatic_assert(offsetof(RequiredLimits, limits) == offsetof(WGPURequiredLimits, limits),\n        \"offsetof mismatch for RequiredLimits::limits\");\n\n// SamplerDescriptor implementation\n\nSamplerDescriptor::operator const WGPUSamplerDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSamplerDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SamplerDescriptor) == sizeof(WGPUSamplerDescriptor), \"sizeof mismatch for SamplerDescriptor\");\nstatic_assert(alignof(SamplerDescriptor) == alignof(WGPUSamplerDescriptor), \"alignof mismatch for SamplerDescriptor\");\nstatic_assert(offsetof(SamplerDescriptor, nextInChain) == offsetof(WGPUSamplerDescriptor, nextInChain),\n        \"offsetof mismatch for SamplerDescriptor::nextInChain\");\nstatic_assert(offsetof(SamplerDescriptor, label) == offsetof(WGPUSamplerDescriptor, label),\n        \"offsetof mismatch for SamplerDescriptor::label\");\nstatic_assert(offsetof(SamplerDescriptor, addressModeU) == offsetof(WGPUSamplerDescriptor, addressModeU),\n        \"offsetof mismatch for SamplerDescriptor::addressModeU\");\nstatic_assert(offsetof(SamplerDescriptor, addressModeV) == offsetof(WGPUSamplerDescriptor, addressModeV),\n        \"offsetof mismatch for SamplerDescriptor::addressModeV\");\nstatic_assert(offsetof(SamplerDescriptor, addressModeW) == offsetof(WGPUSamplerDescriptor, addressModeW),\n        \"offsetof mismatch for SamplerDescriptor::addressModeW\");\nstatic_assert(offsetof(SamplerDescriptor, magFilter) == offsetof(WGPUSamplerDescriptor, magFilter),\n        \"offsetof mismatch for SamplerDescriptor::magFilter\");\nstatic_assert(offsetof(SamplerDescriptor, minFilter) == offsetof(WGPUSamplerDescriptor, minFilter),\n        \"offsetof mismatch for SamplerDescriptor::minFilter\");\nstatic_assert(offsetof(SamplerDescriptor, mipmapFilter) == offsetof(WGPUSamplerDescriptor, mipmapFilter),\n        \"offsetof mismatch for SamplerDescriptor::mipmapFilter\");\nstatic_assert(offsetof(SamplerDescriptor, lodMinClamp) == offsetof(WGPUSamplerDescriptor, lodMinClamp),\n        \"offsetof mismatch for SamplerDescriptor::lodMinClamp\");\nstatic_assert(offsetof(SamplerDescriptor, lodMaxClamp) == offsetof(WGPUSamplerDescriptor, lodMaxClamp),\n        \"offsetof mismatch for SamplerDescriptor::lodMaxClamp\");\nstatic_assert(offsetof(SamplerDescriptor, compare) == offsetof(WGPUSamplerDescriptor, compare),\n        \"offsetof mismatch for SamplerDescriptor::compare\");\nstatic_assert(offsetof(SamplerDescriptor, maxAnisotropy) == offsetof(WGPUSamplerDescriptor, maxAnisotropy),\n        \"offsetof mismatch for SamplerDescriptor::maxAnisotropy\");\n\n// ShaderModuleDescriptor implementation\n\nShaderModuleDescriptor::operator const WGPUShaderModuleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUShaderModuleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(ShaderModuleDescriptor) == sizeof(WGPUShaderModuleDescriptor), \"sizeof mismatch for ShaderModuleDescriptor\");\nstatic_assert(alignof(ShaderModuleDescriptor) == alignof(WGPUShaderModuleDescriptor), \"alignof mismatch for ShaderModuleDescriptor\");\nstatic_assert(offsetof(ShaderModuleDescriptor, nextInChain) == offsetof(WGPUShaderModuleDescriptor, nextInChain),\n        \"offsetof mismatch for ShaderModuleDescriptor::nextInChain\");\nstatic_assert(offsetof(ShaderModuleDescriptor, label) == offsetof(WGPUShaderModuleDescriptor, label),\n        \"offsetof mismatch for ShaderModuleDescriptor::label\");\n\n// ShaderSourceWGSL implementation\nShaderSourceWGSL::ShaderSourceWGSL()\n  : ChainedStruct { nullptr, SType::ShaderSourceWGSL } {}\nstruct ShaderSourceWGSL::Init {\n    ChainedStruct * const nextInChain;\n    StringView code = {};\n};\nShaderSourceWGSL::ShaderSourceWGSL(ShaderSourceWGSL::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ShaderSourceWGSL }, \n    code(std::move(init.code)){}\n\nShaderSourceWGSL::operator const WGPUShaderSourceWGSL&() const noexcept {\n    return *reinterpret_cast<const WGPUShaderSourceWGSL*>(this);\n}\n\nstatic_assert(sizeof(ShaderSourceWGSL) == sizeof(WGPUShaderSourceWGSL), \"sizeof mismatch for ShaderSourceWGSL\");\nstatic_assert(alignof(ShaderSourceWGSL) == alignof(WGPUShaderSourceWGSL), \"alignof mismatch for ShaderSourceWGSL\");\nstatic_assert(offsetof(ShaderSourceWGSL, code) == offsetof(WGPUShaderSourceWGSL, code),\n        \"offsetof mismatch for ShaderSourceWGSL::code\");\n\n// SharedBufferMemoryDescriptor implementation\n\nSharedBufferMemoryDescriptor::operator const WGPUSharedBufferMemoryDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedBufferMemoryDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedBufferMemoryDescriptor) == sizeof(WGPUSharedBufferMemoryDescriptor), \"sizeof mismatch for SharedBufferMemoryDescriptor\");\nstatic_assert(alignof(SharedBufferMemoryDescriptor) == alignof(WGPUSharedBufferMemoryDescriptor), \"alignof mismatch for SharedBufferMemoryDescriptor\");\nstatic_assert(offsetof(SharedBufferMemoryDescriptor, nextInChain) == offsetof(WGPUSharedBufferMemoryDescriptor, nextInChain),\n        \"offsetof mismatch for SharedBufferMemoryDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedBufferMemoryDescriptor, label) == offsetof(WGPUSharedBufferMemoryDescriptor, label),\n        \"offsetof mismatch for SharedBufferMemoryDescriptor::label\");\n\n// SharedFenceDescriptor implementation\n\nSharedFenceDescriptor::operator const WGPUSharedFenceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceDescriptor) == sizeof(WGPUSharedFenceDescriptor), \"sizeof mismatch for SharedFenceDescriptor\");\nstatic_assert(alignof(SharedFenceDescriptor) == alignof(WGPUSharedFenceDescriptor), \"alignof mismatch for SharedFenceDescriptor\");\nstatic_assert(offsetof(SharedFenceDescriptor, nextInChain) == offsetof(WGPUSharedFenceDescriptor, nextInChain),\n        \"offsetof mismatch for SharedFenceDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedFenceDescriptor, label) == offsetof(WGPUSharedFenceDescriptor, label),\n        \"offsetof mismatch for SharedFenceDescriptor::label\");\n\n// SharedTextureMemoryAHardwareBufferProperties implementation\nSharedTextureMemoryAHardwareBufferProperties::SharedTextureMemoryAHardwareBufferProperties()\n  : ChainedStructOut { nullptr, SType::SharedTextureMemoryAHardwareBufferProperties } {}\nstruct SharedTextureMemoryAHardwareBufferProperties::Init {\n    ChainedStructOut *  nextInChain;\n    YCbCrVkDescriptor yCbCrInfo = {};\n};\nSharedTextureMemoryAHardwareBufferProperties::SharedTextureMemoryAHardwareBufferProperties(SharedTextureMemoryAHardwareBufferProperties::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedTextureMemoryAHardwareBufferProperties }, \n    yCbCrInfo(std::move(init.yCbCrInfo)){}\n\nSharedTextureMemoryAHardwareBufferProperties::operator const WGPUSharedTextureMemoryAHardwareBufferProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryAHardwareBufferProperties*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryAHardwareBufferProperties) == sizeof(WGPUSharedTextureMemoryAHardwareBufferProperties), \"sizeof mismatch for SharedTextureMemoryAHardwareBufferProperties\");\nstatic_assert(alignof(SharedTextureMemoryAHardwareBufferProperties) == alignof(WGPUSharedTextureMemoryAHardwareBufferProperties), \"alignof mismatch for SharedTextureMemoryAHardwareBufferProperties\");\nstatic_assert(offsetof(SharedTextureMemoryAHardwareBufferProperties, yCbCrInfo) == offsetof(WGPUSharedTextureMemoryAHardwareBufferProperties, yCbCrInfo),\n        \"offsetof mismatch for SharedTextureMemoryAHardwareBufferProperties::yCbCrInfo\");\n\n// SharedTextureMemoryDescriptor implementation\n\nSharedTextureMemoryDescriptor::operator const WGPUSharedTextureMemoryDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryDescriptor) == sizeof(WGPUSharedTextureMemoryDescriptor), \"sizeof mismatch for SharedTextureMemoryDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryDescriptor) == alignof(WGPUSharedTextureMemoryDescriptor), \"alignof mismatch for SharedTextureMemoryDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryDescriptor, nextInChain) == offsetof(WGPUSharedTextureMemoryDescriptor, nextInChain),\n        \"offsetof mismatch for SharedTextureMemoryDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedTextureMemoryDescriptor, label) == offsetof(WGPUSharedTextureMemoryDescriptor, label),\n        \"offsetof mismatch for SharedTextureMemoryDescriptor::label\");\n\n// SharedTextureMemoryDmaBufDescriptor implementation\nSharedTextureMemoryDmaBufDescriptor::SharedTextureMemoryDmaBufDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryDmaBufDescriptor } {}\nstruct SharedTextureMemoryDmaBufDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    Extent3D size = {};\n    uint32_t drmFormat;\n    uint64_t drmModifier;\n    size_t planeCount;\n    SharedTextureMemoryDmaBufPlane const * planes;\n};\nSharedTextureMemoryDmaBufDescriptor::SharedTextureMemoryDmaBufDescriptor(SharedTextureMemoryDmaBufDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryDmaBufDescriptor }, \n    size(std::move(init.size)), \n    drmFormat(std::move(init.drmFormat)), \n    drmModifier(std::move(init.drmModifier)), \n    planeCount(std::move(init.planeCount)), \n    planes(std::move(init.planes)){}\n\nSharedTextureMemoryDmaBufDescriptor::operator const WGPUSharedTextureMemoryDmaBufDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryDmaBufDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryDmaBufDescriptor) == sizeof(WGPUSharedTextureMemoryDmaBufDescriptor), \"sizeof mismatch for SharedTextureMemoryDmaBufDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryDmaBufDescriptor) == alignof(WGPUSharedTextureMemoryDmaBufDescriptor), \"alignof mismatch for SharedTextureMemoryDmaBufDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, size) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, size),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::size\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, drmFormat) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, drmFormat),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::drmFormat\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, drmModifier) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, drmModifier),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::drmModifier\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, planeCount) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, planeCount),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::planeCount\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, planes) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, planes),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::planes\");\n\n// SharedTextureMemoryProperties implementation\n\nSharedTextureMemoryProperties::operator const WGPUSharedTextureMemoryProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryProperties*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryProperties) == sizeof(WGPUSharedTextureMemoryProperties), \"sizeof mismatch for SharedTextureMemoryProperties\");\nstatic_assert(alignof(SharedTextureMemoryProperties) == alignof(WGPUSharedTextureMemoryProperties), \"alignof mismatch for SharedTextureMemoryProperties\");\nstatic_assert(offsetof(SharedTextureMemoryProperties, nextInChain) == offsetof(WGPUSharedTextureMemoryProperties, nextInChain),\n        \"offsetof mismatch for SharedTextureMemoryProperties::nextInChain\");\nstatic_assert(offsetof(SharedTextureMemoryProperties, usage) == offsetof(WGPUSharedTextureMemoryProperties, usage),\n        \"offsetof mismatch for SharedTextureMemoryProperties::usage\");\nstatic_assert(offsetof(SharedTextureMemoryProperties, size) == offsetof(WGPUSharedTextureMemoryProperties, size),\n        \"offsetof mismatch for SharedTextureMemoryProperties::size\");\nstatic_assert(offsetof(SharedTextureMemoryProperties, format) == offsetof(WGPUSharedTextureMemoryProperties, format),\n        \"offsetof mismatch for SharedTextureMemoryProperties::format\");\n\n// SupportedLimits implementation\n\nSupportedLimits::operator const WGPUSupportedLimits&() const noexcept {\n    return *reinterpret_cast<const WGPUSupportedLimits*>(this);\n}\n\nstatic_assert(sizeof(SupportedLimits) == sizeof(WGPUSupportedLimits), \"sizeof mismatch for SupportedLimits\");\nstatic_assert(alignof(SupportedLimits) == alignof(WGPUSupportedLimits), \"alignof mismatch for SupportedLimits\");\nstatic_assert(offsetof(SupportedLimits, nextInChain) == offsetof(WGPUSupportedLimits, nextInChain),\n        \"offsetof mismatch for SupportedLimits::nextInChain\");\nstatic_assert(offsetof(SupportedLimits, limits) == offsetof(WGPUSupportedLimits, limits),\n        \"offsetof mismatch for SupportedLimits::limits\");\n\n// SurfaceDescriptor implementation\n\nSurfaceDescriptor::operator const WGPUSurfaceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SurfaceDescriptor) == sizeof(WGPUSurfaceDescriptor), \"sizeof mismatch for SurfaceDescriptor\");\nstatic_assert(alignof(SurfaceDescriptor) == alignof(WGPUSurfaceDescriptor), \"alignof mismatch for SurfaceDescriptor\");\nstatic_assert(offsetof(SurfaceDescriptor, nextInChain) == offsetof(WGPUSurfaceDescriptor, nextInChain),\n        \"offsetof mismatch for SurfaceDescriptor::nextInChain\");\nstatic_assert(offsetof(SurfaceDescriptor, label) == offsetof(WGPUSurfaceDescriptor, label),\n        \"offsetof mismatch for SurfaceDescriptor::label\");\n\n// SurfaceSourceCanvasHTMLSelector_Emscripten implementation\nSurfaceSourceCanvasHTMLSelector_Emscripten::SurfaceSourceCanvasHTMLSelector_Emscripten()\n  : ChainedStruct { nullptr, SType::SurfaceSourceCanvasHTMLSelector_Emscripten } {}\nstruct SurfaceSourceCanvasHTMLSelector_Emscripten::Init {\n    ChainedStruct * const nextInChain;\n    StringView selector = {};\n};\nSurfaceSourceCanvasHTMLSelector_Emscripten::SurfaceSourceCanvasHTMLSelector_Emscripten(SurfaceSourceCanvasHTMLSelector_Emscripten::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceCanvasHTMLSelector_Emscripten }, \n    selector(std::move(init.selector)){}\n\nSurfaceSourceCanvasHTMLSelector_Emscripten::operator const WGPUSurfaceSourceCanvasHTMLSelector_Emscripten&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceCanvasHTMLSelector_Emscripten*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceCanvasHTMLSelector_Emscripten) == sizeof(WGPUSurfaceSourceCanvasHTMLSelector_Emscripten), \"sizeof mismatch for SurfaceSourceCanvasHTMLSelector_Emscripten\");\nstatic_assert(alignof(SurfaceSourceCanvasHTMLSelector_Emscripten) == alignof(WGPUSurfaceSourceCanvasHTMLSelector_Emscripten), \"alignof mismatch for SurfaceSourceCanvasHTMLSelector_Emscripten\");\nstatic_assert(offsetof(SurfaceSourceCanvasHTMLSelector_Emscripten, selector) == offsetof(WGPUSurfaceSourceCanvasHTMLSelector_Emscripten, selector),\n        \"offsetof mismatch for SurfaceSourceCanvasHTMLSelector_Emscripten::selector\");\n\n// TextureDescriptor implementation\n\nTextureDescriptor::operator const WGPUTextureDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureDescriptor*>(this);\n}\n\nstatic_assert(sizeof(TextureDescriptor) == sizeof(WGPUTextureDescriptor), \"sizeof mismatch for TextureDescriptor\");\nstatic_assert(alignof(TextureDescriptor) == alignof(WGPUTextureDescriptor), \"alignof mismatch for TextureDescriptor\");\nstatic_assert(offsetof(TextureDescriptor, nextInChain) == offsetof(WGPUTextureDescriptor, nextInChain),\n        \"offsetof mismatch for TextureDescriptor::nextInChain\");\nstatic_assert(offsetof(TextureDescriptor, label) == offsetof(WGPUTextureDescriptor, label),\n        \"offsetof mismatch for TextureDescriptor::label\");\nstatic_assert(offsetof(TextureDescriptor, usage) == offsetof(WGPUTextureDescriptor, usage),\n        \"offsetof mismatch for TextureDescriptor::usage\");\nstatic_assert(offsetof(TextureDescriptor, dimension) == offsetof(WGPUTextureDescriptor, dimension),\n        \"offsetof mismatch for TextureDescriptor::dimension\");\nstatic_assert(offsetof(TextureDescriptor, size) == offsetof(WGPUTextureDescriptor, size),\n        \"offsetof mismatch for TextureDescriptor::size\");\nstatic_assert(offsetof(TextureDescriptor, format) == offsetof(WGPUTextureDescriptor, format),\n        \"offsetof mismatch for TextureDescriptor::format\");\nstatic_assert(offsetof(TextureDescriptor, mipLevelCount) == offsetof(WGPUTextureDescriptor, mipLevelCount),\n        \"offsetof mismatch for TextureDescriptor::mipLevelCount\");\nstatic_assert(offsetof(TextureDescriptor, sampleCount) == offsetof(WGPUTextureDescriptor, sampleCount),\n        \"offsetof mismatch for TextureDescriptor::sampleCount\");\nstatic_assert(offsetof(TextureDescriptor, viewFormatCount) == offsetof(WGPUTextureDescriptor, viewFormatCount),\n        \"offsetof mismatch for TextureDescriptor::viewFormatCount\");\nstatic_assert(offsetof(TextureDescriptor, viewFormats) == offsetof(WGPUTextureDescriptor, viewFormats),\n        \"offsetof mismatch for TextureDescriptor::viewFormats\");\n\n// TextureViewDescriptor implementation\n\nTextureViewDescriptor::operator const WGPUTextureViewDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureViewDescriptor*>(this);\n}\n\nstatic_assert(sizeof(TextureViewDescriptor) == sizeof(WGPUTextureViewDescriptor), \"sizeof mismatch for TextureViewDescriptor\");\nstatic_assert(alignof(TextureViewDescriptor) == alignof(WGPUTextureViewDescriptor), \"alignof mismatch for TextureViewDescriptor\");\nstatic_assert(offsetof(TextureViewDescriptor, nextInChain) == offsetof(WGPUTextureViewDescriptor, nextInChain),\n        \"offsetof mismatch for TextureViewDescriptor::nextInChain\");\nstatic_assert(offsetof(TextureViewDescriptor, label) == offsetof(WGPUTextureViewDescriptor, label),\n        \"offsetof mismatch for TextureViewDescriptor::label\");\nstatic_assert(offsetof(TextureViewDescriptor, format) == offsetof(WGPUTextureViewDescriptor, format),\n        \"offsetof mismatch for TextureViewDescriptor::format\");\nstatic_assert(offsetof(TextureViewDescriptor, dimension) == offsetof(WGPUTextureViewDescriptor, dimension),\n        \"offsetof mismatch for TextureViewDescriptor::dimension\");\nstatic_assert(offsetof(TextureViewDescriptor, baseMipLevel) == offsetof(WGPUTextureViewDescriptor, baseMipLevel),\n        \"offsetof mismatch for TextureViewDescriptor::baseMipLevel\");\nstatic_assert(offsetof(TextureViewDescriptor, mipLevelCount) == offsetof(WGPUTextureViewDescriptor, mipLevelCount),\n        \"offsetof mismatch for TextureViewDescriptor::mipLevelCount\");\nstatic_assert(offsetof(TextureViewDescriptor, baseArrayLayer) == offsetof(WGPUTextureViewDescriptor, baseArrayLayer),\n        \"offsetof mismatch for TextureViewDescriptor::baseArrayLayer\");\nstatic_assert(offsetof(TextureViewDescriptor, arrayLayerCount) == offsetof(WGPUTextureViewDescriptor, arrayLayerCount),\n        \"offsetof mismatch for TextureViewDescriptor::arrayLayerCount\");\nstatic_assert(offsetof(TextureViewDescriptor, aspect) == offsetof(WGPUTextureViewDescriptor, aspect),\n        \"offsetof mismatch for TextureViewDescriptor::aspect\");\nstatic_assert(offsetof(TextureViewDescriptor, usage) == offsetof(WGPUTextureViewDescriptor, usage),\n        \"offsetof mismatch for TextureViewDescriptor::usage\");\n\n// VertexBufferLayout implementation\n\nVertexBufferLayout::operator const WGPUVertexBufferLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUVertexBufferLayout*>(this);\n}\n\nstatic_assert(sizeof(VertexBufferLayout) == sizeof(WGPUVertexBufferLayout), \"sizeof mismatch for VertexBufferLayout\");\nstatic_assert(alignof(VertexBufferLayout) == alignof(WGPUVertexBufferLayout), \"alignof mismatch for VertexBufferLayout\");\nstatic_assert(offsetof(VertexBufferLayout, arrayStride) == offsetof(WGPUVertexBufferLayout, arrayStride),\n        \"offsetof mismatch for VertexBufferLayout::arrayStride\");\nstatic_assert(offsetof(VertexBufferLayout, stepMode) == offsetof(WGPUVertexBufferLayout, stepMode),\n        \"offsetof mismatch for VertexBufferLayout::stepMode\");\nstatic_assert(offsetof(VertexBufferLayout, attributeCount) == offsetof(WGPUVertexBufferLayout, attributeCount),\n        \"offsetof mismatch for VertexBufferLayout::attributeCount\");\nstatic_assert(offsetof(VertexBufferLayout, attributes) == offsetof(WGPUVertexBufferLayout, attributes),\n        \"offsetof mismatch for VertexBufferLayout::attributes\");\n\n// BindGroupLayoutDescriptor implementation\n\nBindGroupLayoutDescriptor::operator const WGPUBindGroupLayoutDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUBindGroupLayoutDescriptor*>(this);\n}\n\nstatic_assert(sizeof(BindGroupLayoutDescriptor) == sizeof(WGPUBindGroupLayoutDescriptor), \"sizeof mismatch for BindGroupLayoutDescriptor\");\nstatic_assert(alignof(BindGroupLayoutDescriptor) == alignof(WGPUBindGroupLayoutDescriptor), \"alignof mismatch for BindGroupLayoutDescriptor\");\nstatic_assert(offsetof(BindGroupLayoutDescriptor, nextInChain) == offsetof(WGPUBindGroupLayoutDescriptor, nextInChain),\n        \"offsetof mismatch for BindGroupLayoutDescriptor::nextInChain\");\nstatic_assert(offsetof(BindGroupLayoutDescriptor, label) == offsetof(WGPUBindGroupLayoutDescriptor, label),\n        \"offsetof mismatch for BindGroupLayoutDescriptor::label\");\nstatic_assert(offsetof(BindGroupLayoutDescriptor, entryCount) == offsetof(WGPUBindGroupLayoutDescriptor, entryCount),\n        \"offsetof mismatch for BindGroupLayoutDescriptor::entryCount\");\nstatic_assert(offsetof(BindGroupLayoutDescriptor, entries) == offsetof(WGPUBindGroupLayoutDescriptor, entries),\n        \"offsetof mismatch for BindGroupLayoutDescriptor::entries\");\n\n// ColorTargetState implementation\n\nColorTargetState::operator const WGPUColorTargetState&() const noexcept {\n    return *reinterpret_cast<const WGPUColorTargetState*>(this);\n}\n\nstatic_assert(sizeof(ColorTargetState) == sizeof(WGPUColorTargetState), \"sizeof mismatch for ColorTargetState\");\nstatic_assert(alignof(ColorTargetState) == alignof(WGPUColorTargetState), \"alignof mismatch for ColorTargetState\");\nstatic_assert(offsetof(ColorTargetState, nextInChain) == offsetof(WGPUColorTargetState, nextInChain),\n        \"offsetof mismatch for ColorTargetState::nextInChain\");\nstatic_assert(offsetof(ColorTargetState, format) == offsetof(WGPUColorTargetState, format),\n        \"offsetof mismatch for ColorTargetState::format\");\nstatic_assert(offsetof(ColorTargetState, blend) == offsetof(WGPUColorTargetState, blend),\n        \"offsetof mismatch for ColorTargetState::blend\");\nstatic_assert(offsetof(ColorTargetState, writeMask) == offsetof(WGPUColorTargetState, writeMask),\n        \"offsetof mismatch for ColorTargetState::writeMask\");\n\n// CompilationInfo implementation\n\nCompilationInfo::operator const WGPUCompilationInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUCompilationInfo*>(this);\n}\n\nstatic_assert(sizeof(CompilationInfo) == sizeof(WGPUCompilationInfo), \"sizeof mismatch for CompilationInfo\");\nstatic_assert(alignof(CompilationInfo) == alignof(WGPUCompilationInfo), \"alignof mismatch for CompilationInfo\");\nstatic_assert(offsetof(CompilationInfo, nextInChain) == offsetof(WGPUCompilationInfo, nextInChain),\n        \"offsetof mismatch for CompilationInfo::nextInChain\");\nstatic_assert(offsetof(CompilationInfo, messageCount) == offsetof(WGPUCompilationInfo, messageCount),\n        \"offsetof mismatch for CompilationInfo::messageCount\");\nstatic_assert(offsetof(CompilationInfo, messages) == offsetof(WGPUCompilationInfo, messages),\n        \"offsetof mismatch for CompilationInfo::messages\");\n\n// ComputeState implementation\n\nComputeState::operator const WGPUComputeState&() const noexcept {\n    return *reinterpret_cast<const WGPUComputeState*>(this);\n}\n\nstatic_assert(sizeof(ComputeState) == sizeof(WGPUComputeState), \"sizeof mismatch for ComputeState\");\nstatic_assert(alignof(ComputeState) == alignof(WGPUComputeState), \"alignof mismatch for ComputeState\");\nstatic_assert(offsetof(ComputeState, nextInChain) == offsetof(WGPUComputeState, nextInChain),\n        \"offsetof mismatch for ComputeState::nextInChain\");\nstatic_assert(offsetof(ComputeState, module) == offsetof(WGPUComputeState, module),\n        \"offsetof mismatch for ComputeState::module\");\nstatic_assert(offsetof(ComputeState, entryPoint) == offsetof(WGPUComputeState, entryPoint),\n        \"offsetof mismatch for ComputeState::entryPoint\");\nstatic_assert(offsetof(ComputeState, constantCount) == offsetof(WGPUComputeState, constantCount),\n        \"offsetof mismatch for ComputeState::constantCount\");\nstatic_assert(offsetof(ComputeState, constants) == offsetof(WGPUComputeState, constants),\n        \"offsetof mismatch for ComputeState::constants\");\n\n// RenderPassDescriptor implementation\n\nRenderPassDescriptor::operator const WGPURenderPassDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassDescriptor*>(this);\n}\n\nstatic_assert(sizeof(RenderPassDescriptor) == sizeof(WGPURenderPassDescriptor), \"sizeof mismatch for RenderPassDescriptor\");\nstatic_assert(alignof(RenderPassDescriptor) == alignof(WGPURenderPassDescriptor), \"alignof mismatch for RenderPassDescriptor\");\nstatic_assert(offsetof(RenderPassDescriptor, nextInChain) == offsetof(WGPURenderPassDescriptor, nextInChain),\n        \"offsetof mismatch for RenderPassDescriptor::nextInChain\");\nstatic_assert(offsetof(RenderPassDescriptor, label) == offsetof(WGPURenderPassDescriptor, label),\n        \"offsetof mismatch for RenderPassDescriptor::label\");\nstatic_assert(offsetof(RenderPassDescriptor, colorAttachmentCount) == offsetof(WGPURenderPassDescriptor, colorAttachmentCount),\n        \"offsetof mismatch for RenderPassDescriptor::colorAttachmentCount\");\nstatic_assert(offsetof(RenderPassDescriptor, colorAttachments) == offsetof(WGPURenderPassDescriptor, colorAttachments),\n        \"offsetof mismatch for RenderPassDescriptor::colorAttachments\");\nstatic_assert(offsetof(RenderPassDescriptor, depthStencilAttachment) == offsetof(WGPURenderPassDescriptor, depthStencilAttachment),\n        \"offsetof mismatch for RenderPassDescriptor::depthStencilAttachment\");\nstatic_assert(offsetof(RenderPassDescriptor, occlusionQuerySet) == offsetof(WGPURenderPassDescriptor, occlusionQuerySet),\n        \"offsetof mismatch for RenderPassDescriptor::occlusionQuerySet\");\nstatic_assert(offsetof(RenderPassDescriptor, timestampWrites) == offsetof(WGPURenderPassDescriptor, timestampWrites),\n        \"offsetof mismatch for RenderPassDescriptor::timestampWrites\");\n\n// RenderPassPixelLocalStorage implementation\nRenderPassPixelLocalStorage::RenderPassPixelLocalStorage()\n  : ChainedStruct { nullptr, SType::RenderPassPixelLocalStorage } {}\nstruct RenderPassPixelLocalStorage::Init {\n    ChainedStruct * const nextInChain;\n    uint64_t totalPixelLocalStorageSize;\n    size_t storageAttachmentCount = 0;\n    RenderPassStorageAttachment const * storageAttachments;\n};\nRenderPassPixelLocalStorage::RenderPassPixelLocalStorage(RenderPassPixelLocalStorage::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::RenderPassPixelLocalStorage }, \n    totalPixelLocalStorageSize(std::move(init.totalPixelLocalStorageSize)), \n    storageAttachmentCount(std::move(init.storageAttachmentCount)), \n    storageAttachments(std::move(init.storageAttachments)){}\n\nRenderPassPixelLocalStorage::operator const WGPURenderPassPixelLocalStorage&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassPixelLocalStorage*>(this);\n}\n\nstatic_assert(sizeof(RenderPassPixelLocalStorage) == sizeof(WGPURenderPassPixelLocalStorage), \"sizeof mismatch for RenderPassPixelLocalStorage\");\nstatic_assert(alignof(RenderPassPixelLocalStorage) == alignof(WGPURenderPassPixelLocalStorage), \"alignof mismatch for RenderPassPixelLocalStorage\");\nstatic_assert(offsetof(RenderPassPixelLocalStorage, totalPixelLocalStorageSize) == offsetof(WGPURenderPassPixelLocalStorage, totalPixelLocalStorageSize),\n        \"offsetof mismatch for RenderPassPixelLocalStorage::totalPixelLocalStorageSize\");\nstatic_assert(offsetof(RenderPassPixelLocalStorage, storageAttachmentCount) == offsetof(WGPURenderPassPixelLocalStorage, storageAttachmentCount),\n        \"offsetof mismatch for RenderPassPixelLocalStorage::storageAttachmentCount\");\nstatic_assert(offsetof(RenderPassPixelLocalStorage, storageAttachments) == offsetof(WGPURenderPassPixelLocalStorage, storageAttachments),\n        \"offsetof mismatch for RenderPassPixelLocalStorage::storageAttachments\");\n\n// VertexState implementation\n\nVertexState::operator const WGPUVertexState&() const noexcept {\n    return *reinterpret_cast<const WGPUVertexState*>(this);\n}\n\nstatic_assert(sizeof(VertexState) == sizeof(WGPUVertexState), \"sizeof mismatch for VertexState\");\nstatic_assert(alignof(VertexState) == alignof(WGPUVertexState), \"alignof mismatch for VertexState\");\nstatic_assert(offsetof(VertexState, nextInChain) == offsetof(WGPUVertexState, nextInChain),\n        \"offsetof mismatch for VertexState::nextInChain\");\nstatic_assert(offsetof(VertexState, module) == offsetof(WGPUVertexState, module),\n        \"offsetof mismatch for VertexState::module\");\nstatic_assert(offsetof(VertexState, entryPoint) == offsetof(WGPUVertexState, entryPoint),\n        \"offsetof mismatch for VertexState::entryPoint\");\nstatic_assert(offsetof(VertexState, constantCount) == offsetof(WGPUVertexState, constantCount),\n        \"offsetof mismatch for VertexState::constantCount\");\nstatic_assert(offsetof(VertexState, constants) == offsetof(WGPUVertexState, constants),\n        \"offsetof mismatch for VertexState::constants\");\nstatic_assert(offsetof(VertexState, bufferCount) == offsetof(WGPUVertexState, bufferCount),\n        \"offsetof mismatch for VertexState::bufferCount\");\nstatic_assert(offsetof(VertexState, buffers) == offsetof(WGPUVertexState, buffers),\n        \"offsetof mismatch for VertexState::buffers\");\n\n// ComputePipelineDescriptor implementation\n\nComputePipelineDescriptor::operator const WGPUComputePipelineDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUComputePipelineDescriptor*>(this);\n}\n\nstatic_assert(sizeof(ComputePipelineDescriptor) == sizeof(WGPUComputePipelineDescriptor), \"sizeof mismatch for ComputePipelineDescriptor\");\nstatic_assert(alignof(ComputePipelineDescriptor) == alignof(WGPUComputePipelineDescriptor), \"alignof mismatch for ComputePipelineDescriptor\");\nstatic_assert(offsetof(ComputePipelineDescriptor, nextInChain) == offsetof(WGPUComputePipelineDescriptor, nextInChain),\n        \"offsetof mismatch for ComputePipelineDescriptor::nextInChain\");\nstatic_assert(offsetof(ComputePipelineDescriptor, label) == offsetof(WGPUComputePipelineDescriptor, label),\n        \"offsetof mismatch for ComputePipelineDescriptor::label\");\nstatic_assert(offsetof(ComputePipelineDescriptor, layout) == offsetof(WGPUComputePipelineDescriptor, layout),\n        \"offsetof mismatch for ComputePipelineDescriptor::layout\");\nstatic_assert(offsetof(ComputePipelineDescriptor, compute) == offsetof(WGPUComputePipelineDescriptor, compute),\n        \"offsetof mismatch for ComputePipelineDescriptor::compute\");\n\n// FragmentState implementation\n\nFragmentState::operator const WGPUFragmentState&() const noexcept {\n    return *reinterpret_cast<const WGPUFragmentState*>(this);\n}\n\nstatic_assert(sizeof(FragmentState) == sizeof(WGPUFragmentState), \"sizeof mismatch for FragmentState\");\nstatic_assert(alignof(FragmentState) == alignof(WGPUFragmentState), \"alignof mismatch for FragmentState\");\nstatic_assert(offsetof(FragmentState, nextInChain) == offsetof(WGPUFragmentState, nextInChain),\n        \"offsetof mismatch for FragmentState::nextInChain\");\nstatic_assert(offsetof(FragmentState, module) == offsetof(WGPUFragmentState, module),\n        \"offsetof mismatch for FragmentState::module\");\nstatic_assert(offsetof(FragmentState, entryPoint) == offsetof(WGPUFragmentState, entryPoint),\n        \"offsetof mismatch for FragmentState::entryPoint\");\nstatic_assert(offsetof(FragmentState, constantCount) == offsetof(WGPUFragmentState, constantCount),\n        \"offsetof mismatch for FragmentState::constantCount\");\nstatic_assert(offsetof(FragmentState, constants) == offsetof(WGPUFragmentState, constants),\n        \"offsetof mismatch for FragmentState::constants\");\nstatic_assert(offsetof(FragmentState, targetCount) == offsetof(WGPUFragmentState, targetCount),\n        \"offsetof mismatch for FragmentState::targetCount\");\nstatic_assert(offsetof(FragmentState, targets) == offsetof(WGPUFragmentState, targets),\n        \"offsetof mismatch for FragmentState::targets\");\n\n// RenderPipelineDescriptor implementation\n\nRenderPipelineDescriptor::operator const WGPURenderPipelineDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPipelineDescriptor*>(this);\n}\n\nstatic_assert(sizeof(RenderPipelineDescriptor) == sizeof(WGPURenderPipelineDescriptor), \"sizeof mismatch for RenderPipelineDescriptor\");\nstatic_assert(alignof(RenderPipelineDescriptor) == alignof(WGPURenderPipelineDescriptor), \"alignof mismatch for RenderPipelineDescriptor\");\nstatic_assert(offsetof(RenderPipelineDescriptor, nextInChain) == offsetof(WGPURenderPipelineDescriptor, nextInChain),\n        \"offsetof mismatch for RenderPipelineDescriptor::nextInChain\");\nstatic_assert(offsetof(RenderPipelineDescriptor, label) == offsetof(WGPURenderPipelineDescriptor, label),\n        \"offsetof mismatch for RenderPipelineDescriptor::label\");\nstatic_assert(offsetof(RenderPipelineDescriptor, layout) == offsetof(WGPURenderPipelineDescriptor, layout),\n        \"offsetof mismatch for RenderPipelineDescriptor::layout\");\nstatic_assert(offsetof(RenderPipelineDescriptor, vertex) == offsetof(WGPURenderPipelineDescriptor, vertex),\n        \"offsetof mismatch for RenderPipelineDescriptor::vertex\");\nstatic_assert(offsetof(RenderPipelineDescriptor, primitive) == offsetof(WGPURenderPipelineDescriptor, primitive),\n        \"offsetof mismatch for RenderPipelineDescriptor::primitive\");\nstatic_assert(offsetof(RenderPipelineDescriptor, depthStencil) == offsetof(WGPURenderPipelineDescriptor, depthStencil),\n        \"offsetof mismatch for RenderPipelineDescriptor::depthStencil\");\nstatic_assert(offsetof(RenderPipelineDescriptor, multisample) == offsetof(WGPURenderPipelineDescriptor, multisample),\n        \"offsetof mismatch for RenderPipelineDescriptor::multisample\");\nstatic_assert(offsetof(RenderPipelineDescriptor, fragment) == offsetof(WGPURenderPipelineDescriptor, fragment),\n        \"offsetof mismatch for RenderPipelineDescriptor::fragment\");\n\n// DeviceDescriptor implementation\n\nDeviceDescriptor::operator const WGPUDeviceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDeviceDescriptor*>(this);\n}\n\nDeviceDescriptor::DeviceDescriptor() : detail::DeviceDescriptor {} {\n    static_assert(offsetof(DeviceDescriptor, nextInChain) == offsetof(WGPUDeviceDescriptor, nextInChain),\n                \"offsetof mismatch for DeviceDescriptor::nextInChain\");\n    static_assert(offsetof(DeviceDescriptor, label) == offsetof(WGPUDeviceDescriptor, label),\n            \"offsetof mismatch for DeviceDescriptor::label\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeatureCount) == offsetof(WGPUDeviceDescriptor, requiredFeatureCount),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeatureCount\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeatures) == offsetof(WGPUDeviceDescriptor, requiredFeatures),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeatures\");\n    static_assert(offsetof(DeviceDescriptor, requiredLimits) == offsetof(WGPUDeviceDescriptor, requiredLimits),\n            \"offsetof mismatch for DeviceDescriptor::requiredLimits\");\n    static_assert(offsetof(DeviceDescriptor, defaultQueue) == offsetof(WGPUDeviceDescriptor, defaultQueue),\n            \"offsetof mismatch for DeviceDescriptor::defaultQueue\");\n    static_assert(offsetof(DeviceDescriptor, deviceLostCallbackInfo2) == offsetof(WGPUDeviceDescriptor, deviceLostCallbackInfo2),\n            \"offsetof mismatch for DeviceDescriptor::deviceLostCallbackInfo2\");\n    static_assert(offsetof(DeviceDescriptor, uncapturedErrorCallbackInfo2) == offsetof(WGPUDeviceDescriptor, uncapturedErrorCallbackInfo2),\n            \"offsetof mismatch for DeviceDescriptor::uncapturedErrorCallbackInfo2\");\n}\n\nstruct DeviceDescriptor::Init {\n    ChainedStruct const * nextInChain;\n    StringView label = {};\n    size_t requiredFeatureCount = 0;\n    FeatureName const * requiredFeatures = nullptr;\n    RequiredLimits const * requiredLimits = nullptr;\n    QueueDescriptor defaultQueue = {};\n};\n\nDeviceDescriptor::DeviceDescriptor(DeviceDescriptor::Init&& init) : detail::DeviceDescriptor {\n    init.nextInChain, \n    std::move(init.label), \n    std::move(init.requiredFeatureCount), \n    std::move(init.requiredFeatures), \n    std::move(init.requiredLimits), \n    std::move(init.defaultQueue)} {}\n\nstatic_assert(sizeof(DeviceDescriptor) == sizeof(WGPUDeviceDescriptor), \"sizeof mismatch for DeviceDescriptor\");\nstatic_assert(alignof(DeviceDescriptor) == alignof(WGPUDeviceDescriptor), \"alignof mismatch for DeviceDescriptor\");\n\ntemplate <typename F, typename T, typename Cb, typename CbChar, typename>\nvoid DeviceDescriptor::SetDeviceLostCallback(CallbackMode callbackMode, F callback, T userdata) {\n    assert(deviceLostCallbackInfo2.callback == nullptr);\n\n    deviceLostCallbackInfo2.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        deviceLostCallbackInfo2.callback = [](WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<DeviceLostReason>(reason), message, static_cast<T>(userdata_param));\n            apiDevice.MoveToCHandle();\n        };\n    } else {\n        deviceLostCallbackInfo2.callback = [](WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<DeviceLostReason>(reason), detail::StringViewAdapter(message), static_cast<T>(userdata_param));\n            apiDevice.MoveToCHandle();\n        };\n    }\n    deviceLostCallbackInfo2.userdata1 = reinterpret_cast<void*>(+callback);\n    deviceLostCallbackInfo2.userdata2 = reinterpret_cast<void*>(userdata);\n}\n\ntemplate <typename L, typename Cb, typename CbChar, typename>\nvoid DeviceDescriptor::SetDeviceLostCallback(CallbackMode callbackMode, L callback) {\n    assert(deviceLostCallbackInfo2.callback == nullptr);\n    using F = DeviceLostCallback2<void>;\n\n    deviceLostCallbackInfo2.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        deviceLostCallbackInfo2.callback = [](WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<DeviceLostReason>(reason), message);\n            apiDevice.MoveToCHandle();\n        };\n        deviceLostCallbackInfo2.userdata1 = reinterpret_cast<void*>(+callback);\n        deviceLostCallbackInfo2.userdata2 = nullptr;\n    } else {\n        auto* lambda = new L(std::move(callback));\n        deviceLostCallbackInfo2.callback = [](WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*the_lambda)(apiDevice, static_cast<DeviceLostReason>(reason), detail::StringViewAdapter(message));\n            apiDevice.MoveToCHandle();\n        };\n        deviceLostCallbackInfo2.userdata1 = reinterpret_cast<void*>(lambda);\n        deviceLostCallbackInfo2.userdata2 = nullptr;\n    }\n}\n\ntemplate <typename F, typename T, typename Cb, typename CbChar, typename>\nvoid DeviceDescriptor::SetUncapturedErrorCallback(F callback, T userdata) {\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        uncapturedErrorCallbackInfo2.callback = [](WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<ErrorType>(type), message, static_cast<T>(userdata_param));\n            apiDevice.MoveToCHandle();\n        };\n    } else {\n        uncapturedErrorCallbackInfo2.callback = [](WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<ErrorType>(type), detail::StringViewAdapter(message), static_cast<T>(userdata_param));\n            apiDevice.MoveToCHandle();\n        };\n    }\n    uncapturedErrorCallbackInfo2.userdata1 = reinterpret_cast<void*>(+callback);\n    uncapturedErrorCallbackInfo2.userdata2 = reinterpret_cast<void*>(userdata);\n}\n\ntemplate <typename L, typename Cb, typename CbChar, typename>\nvoid DeviceDescriptor::SetUncapturedErrorCallback(L callback) {\n    using F = UncapturedErrorCallback<void>;\n    using FChar = void (const Device& device, ErrorType type, const char* message);\n    static_assert(std::is_convertible_v<L, F*> || std::is_convertible_v<L, FChar*>, \"Uncaptured error callback cannot be a binding lambda\");\n\n    if constexpr (std::is_convertible_v<L, F*>) {\n        uncapturedErrorCallbackInfo2.callback = [](WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<ErrorType>(type), message);\n            apiDevice.MoveToCHandle();\n        };\n    } else {\n        uncapturedErrorCallbackInfo2.callback = [](WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<FChar*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<ErrorType>(type), detail::StringViewAdapter(message));\n            apiDevice.MoveToCHandle();\n        };\n    }\n    uncapturedErrorCallbackInfo2.userdata1 = reinterpret_cast<void*>(+callback);\n    uncapturedErrorCallbackInfo2.userdata2 = nullptr;\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n// Adapter implementation\n\nDevice Adapter::CreateDevice(DeviceDescriptor const * descriptor) const {\n    auto result = wgpuAdapterCreateDevice(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(descriptor));\n    return Device::Acquire(result);\n}\nvoid Adapter::GetFeatures(SupportedFeatures * features) const {\n    *features = SupportedFeatures();\n    wgpuAdapterGetFeatures(Get(), reinterpret_cast<WGPUSupportedFeatures * >(features));\n}\nConvertibleStatus Adapter::GetFormatCapabilities(TextureFormat format, FormatCapabilities * capabilities) const {\n    auto result = wgpuAdapterGetFormatCapabilities(Get(), static_cast<WGPUTextureFormat>(format), reinterpret_cast<WGPUFormatCapabilities * >(capabilities));\n    return static_cast<Status>(result);\n}\nConvertibleStatus Adapter::GetInfo(AdapterInfo * info) const {\n    *info = AdapterInfo();\n    auto result = wgpuAdapterGetInfo(Get(), reinterpret_cast<WGPUAdapterInfo * >(info));\n    return static_cast<Status>(result);\n}\nInstance Adapter::GetInstance() const {\n    auto result = wgpuAdapterGetInstance(Get());\n    return Instance::Acquire(result);\n}\nConvertibleStatus Adapter::GetLimits(SupportedLimits * limits) const {\n    auto result = wgpuAdapterGetLimits(Get(), reinterpret_cast<WGPUSupportedLimits * >(limits));\n    return static_cast<Status>(result);\n}\nBool Adapter::HasFeature(FeatureName feature) const {\n    auto result = wgpuAdapterHasFeature(Get(), static_cast<WGPUFeatureName>(feature));\n    return result;\n}\nvoid Adapter::RequestDevice(DeviceDescriptor const * descriptor, RequestDeviceCallback callback, void * userdata) const {\n    wgpuAdapterRequestDevice(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(descriptor), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Adapter::RequestDevice(DeviceDescriptor const * options, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPURequestDeviceCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<RequestDeviceStatus>(status), Device::Acquire(device), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<RequestDeviceStatus>(status), Device::Acquire(device), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuAdapterRequestDevice2(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(options), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Adapter::RequestDevice(DeviceDescriptor const * options, CallbackMode callbackMode, L callback) const {\n    using F = RequestDeviceCallback2<void>;\n\n    WGPURequestDeviceCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<RequestDeviceStatus>(status), Device::Acquire(device), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuAdapterRequestDevice2(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(options), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<RequestDeviceStatus>(status), Device::Acquire(device), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuAdapterRequestDevice2(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(options), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Adapter::RequestDevice(DeviceDescriptor const * options, RequestDeviceCallbackInfo callbackInfo) const {\n    auto result = wgpuAdapterRequestDeviceF(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(options), *reinterpret_cast<WGPURequestDeviceCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\n\n\nvoid Adapter::WGPUAddRef(WGPUAdapter handle) {\n    if (handle != nullptr) {\n        wgpuAdapterAddRef(handle);\n    }\n}\nvoid Adapter::WGPURelease(WGPUAdapter handle) {\n    if (handle != nullptr) {\n        wgpuAdapterRelease(handle);\n    }\n}\nstatic_assert(sizeof(Adapter) == sizeof(WGPUAdapter), \"sizeof mismatch for Adapter\");\nstatic_assert(alignof(Adapter) == alignof(WGPUAdapter), \"alignof mismatch for Adapter\");\n\n// BindGroup implementation\n\nvoid BindGroup::SetLabel(StringView label) const {\n    wgpuBindGroupSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid BindGroup::WGPUAddRef(WGPUBindGroup handle) {\n    if (handle != nullptr) {\n        wgpuBindGroupAddRef(handle);\n    }\n}\nvoid BindGroup::WGPURelease(WGPUBindGroup handle) {\n    if (handle != nullptr) {\n        wgpuBindGroupRelease(handle);\n    }\n}\nstatic_assert(sizeof(BindGroup) == sizeof(WGPUBindGroup), \"sizeof mismatch for BindGroup\");\nstatic_assert(alignof(BindGroup) == alignof(WGPUBindGroup), \"alignof mismatch for BindGroup\");\n\n// BindGroupLayout implementation\n\nvoid BindGroupLayout::SetLabel(StringView label) const {\n    wgpuBindGroupLayoutSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid BindGroupLayout::WGPUAddRef(WGPUBindGroupLayout handle) {\n    if (handle != nullptr) {\n        wgpuBindGroupLayoutAddRef(handle);\n    }\n}\nvoid BindGroupLayout::WGPURelease(WGPUBindGroupLayout handle) {\n    if (handle != nullptr) {\n        wgpuBindGroupLayoutRelease(handle);\n    }\n}\nstatic_assert(sizeof(BindGroupLayout) == sizeof(WGPUBindGroupLayout), \"sizeof mismatch for BindGroupLayout\");\nstatic_assert(alignof(BindGroupLayout) == alignof(WGPUBindGroupLayout), \"alignof mismatch for BindGroupLayout\");\n\n// Buffer implementation\n\nvoid Buffer::Destroy() const {\n    wgpuBufferDestroy(Get());\n}\nvoid const * Buffer::GetConstMappedRange(size_t offset, size_t size) const {\n    auto result = wgpuBufferGetConstMappedRange(Get(), offset, size);\n    return result;\n}\nBufferMapState Buffer::GetMapState() const {\n    auto result = wgpuBufferGetMapState(Get());\n    return static_cast<BufferMapState>(result);\n}\nvoid * Buffer::GetMappedRange(size_t offset, size_t size) const {\n    auto result = wgpuBufferGetMappedRange(Get(), offset, size);\n    return result;\n}\nuint64_t Buffer::GetSize() const {\n    auto result = wgpuBufferGetSize(Get());\n    return result;\n}\nBufferUsage Buffer::GetUsage() const {\n    auto result = wgpuBufferGetUsage(Get());\n    return static_cast<BufferUsage>(result);\n}\nvoid Buffer::MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) const {\n    wgpuBufferMapAsync(Get(), static_cast<WGPUMapMode>(mode), offset, size, callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Buffer::MapAsync(MapMode mode, size_t offset, size_t size, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUBufferMapCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUMapAsyncStatus status, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<MapAsyncStatus>(status), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUMapAsyncStatus status, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<MapAsyncStatus>(status), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuBufferMapAsync2(Get(), static_cast<WGPUMapMode>(mode), offset, size, callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Buffer::MapAsync(MapMode mode, size_t offset, size_t size, CallbackMode callbackMode, L callback) const {\n    using F = BufferMapCallback2<void>;\n\n    WGPUBufferMapCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUMapAsyncStatus status, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<MapAsyncStatus>(status), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuBufferMapAsync2(Get(), static_cast<WGPUMapMode>(mode), offset, size, callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUMapAsyncStatus status, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<MapAsyncStatus>(status), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuBufferMapAsync2(Get(), static_cast<WGPUMapMode>(mode), offset, size, callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Buffer::MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallbackInfo callbackInfo) const {\n    auto result = wgpuBufferMapAsyncF(Get(), static_cast<WGPUMapMode>(mode), offset, size, *reinterpret_cast<WGPUBufferMapCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nvoid Buffer::SetLabel(StringView label) const {\n    wgpuBufferSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid Buffer::Unmap() const {\n    wgpuBufferUnmap(Get());\n}\n\n\nvoid Buffer::WGPUAddRef(WGPUBuffer handle) {\n    if (handle != nullptr) {\n        wgpuBufferAddRef(handle);\n    }\n}\nvoid Buffer::WGPURelease(WGPUBuffer handle) {\n    if (handle != nullptr) {\n        wgpuBufferRelease(handle);\n    }\n}\nstatic_assert(sizeof(Buffer) == sizeof(WGPUBuffer), \"sizeof mismatch for Buffer\");\nstatic_assert(alignof(Buffer) == alignof(WGPUBuffer), \"alignof mismatch for Buffer\");\n\n// CommandBuffer implementation\n\nvoid CommandBuffer::SetLabel(StringView label) const {\n    wgpuCommandBufferSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid CommandBuffer::WGPUAddRef(WGPUCommandBuffer handle) {\n    if (handle != nullptr) {\n        wgpuCommandBufferAddRef(handle);\n    }\n}\nvoid CommandBuffer::WGPURelease(WGPUCommandBuffer handle) {\n    if (handle != nullptr) {\n        wgpuCommandBufferRelease(handle);\n    }\n}\nstatic_assert(sizeof(CommandBuffer) == sizeof(WGPUCommandBuffer), \"sizeof mismatch for CommandBuffer\");\nstatic_assert(alignof(CommandBuffer) == alignof(WGPUCommandBuffer), \"alignof mismatch for CommandBuffer\");\n\n// CommandEncoder implementation\n\nComputePassEncoder CommandEncoder::BeginComputePass(ComputePassDescriptor const * descriptor) const {\n    auto result = wgpuCommandEncoderBeginComputePass(Get(), reinterpret_cast<WGPUComputePassDescriptor const * >(descriptor));\n    return ComputePassEncoder::Acquire(result);\n}\nRenderPassEncoder CommandEncoder::BeginRenderPass(RenderPassDescriptor const * descriptor) const {\n    auto result = wgpuCommandEncoderBeginRenderPass(Get(), reinterpret_cast<WGPURenderPassDescriptor const * >(descriptor));\n    return RenderPassEncoder::Acquire(result);\n}\nvoid CommandEncoder::ClearBuffer(Buffer const& buffer, uint64_t offset, uint64_t size) const {\n    wgpuCommandEncoderClearBuffer(Get(), buffer.Get(), offset, size);\n}\nvoid CommandEncoder::CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const {\n    wgpuCommandEncoderCopyBufferToBuffer(Get(), source.Get(), sourceOffset, destination.Get(), destinationOffset, size);\n}\nvoid CommandEncoder::CopyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const {\n    wgpuCommandEncoderCopyBufferToTexture(Get(), reinterpret_cast<WGPUImageCopyBuffer const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize));\n}\nvoid CommandEncoder::CopyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) const {\n    wgpuCommandEncoderCopyTextureToBuffer(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(source), reinterpret_cast<WGPUImageCopyBuffer const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize));\n}\nvoid CommandEncoder::CopyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const {\n    wgpuCommandEncoderCopyTextureToTexture(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize));\n}\nCommandBuffer CommandEncoder::Finish(CommandBufferDescriptor const * descriptor) const {\n    auto result = wgpuCommandEncoderFinish(Get(), reinterpret_cast<WGPUCommandBufferDescriptor const * >(descriptor));\n    return CommandBuffer::Acquire(result);\n}\nvoid CommandEncoder::InjectValidationError(StringView message) const {\n    wgpuCommandEncoderInjectValidationError(Get(), *reinterpret_cast<WGPUStringView const*>(&message));\n}\nvoid CommandEncoder::InsertDebugMarker(StringView markerLabel) const {\n    wgpuCommandEncoderInsertDebugMarker(Get(), *reinterpret_cast<WGPUStringView const*>(&markerLabel));\n}\nvoid CommandEncoder::PopDebugGroup() const {\n    wgpuCommandEncoderPopDebugGroup(Get());\n}\nvoid CommandEncoder::PushDebugGroup(StringView groupLabel) const {\n    wgpuCommandEncoderPushDebugGroup(Get(), *reinterpret_cast<WGPUStringView const*>(&groupLabel));\n}\nvoid CommandEncoder::ResolveQuerySet(QuerySet const& querySet, uint32_t firstQuery, uint32_t queryCount, Buffer const& destination, uint64_t destinationOffset) const {\n    wgpuCommandEncoderResolveQuerySet(Get(), querySet.Get(), firstQuery, queryCount, destination.Get(), destinationOffset);\n}\nvoid CommandEncoder::SetLabel(StringView label) const {\n    wgpuCommandEncoderSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid CommandEncoder::WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) const {\n    wgpuCommandEncoderWriteBuffer(Get(), buffer.Get(), bufferOffset, reinterpret_cast<uint8_t const * >(data), size);\n}\nvoid CommandEncoder::WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const {\n    wgpuCommandEncoderWriteTimestamp(Get(), querySet.Get(), queryIndex);\n}\n\n\nvoid CommandEncoder::WGPUAddRef(WGPUCommandEncoder handle) {\n    if (handle != nullptr) {\n        wgpuCommandEncoderAddRef(handle);\n    }\n}\nvoid CommandEncoder::WGPURelease(WGPUCommandEncoder handle) {\n    if (handle != nullptr) {\n        wgpuCommandEncoderRelease(handle);\n    }\n}\nstatic_assert(sizeof(CommandEncoder) == sizeof(WGPUCommandEncoder), \"sizeof mismatch for CommandEncoder\");\nstatic_assert(alignof(CommandEncoder) == alignof(WGPUCommandEncoder), \"alignof mismatch for CommandEncoder\");\n\n// ComputePassEncoder implementation\n\nvoid ComputePassEncoder::DispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) const {\n    wgpuComputePassEncoderDispatchWorkgroups(Get(), workgroupCountX, workgroupCountY, workgroupCountZ);\n}\nvoid ComputePassEncoder::DispatchWorkgroupsIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuComputePassEncoderDispatchWorkgroupsIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nvoid ComputePassEncoder::End() const {\n    wgpuComputePassEncoderEnd(Get());\n}\nvoid ComputePassEncoder::InsertDebugMarker(StringView markerLabel) const {\n    wgpuComputePassEncoderInsertDebugMarker(Get(), *reinterpret_cast<WGPUStringView const*>(&markerLabel));\n}\nvoid ComputePassEncoder::PopDebugGroup() const {\n    wgpuComputePassEncoderPopDebugGroup(Get());\n}\nvoid ComputePassEncoder::PushDebugGroup(StringView groupLabel) const {\n    wgpuComputePassEncoderPushDebugGroup(Get(), *reinterpret_cast<WGPUStringView const*>(&groupLabel));\n}\nvoid ComputePassEncoder::SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) const {\n    wgpuComputePassEncoderSetBindGroup(Get(), groupIndex, group.Get(), dynamicOffsetCount, reinterpret_cast<uint32_t const * >(dynamicOffsets));\n}\nvoid ComputePassEncoder::SetLabel(StringView label) const {\n    wgpuComputePassEncoderSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid ComputePassEncoder::SetPipeline(ComputePipeline const& pipeline) const {\n    wgpuComputePassEncoderSetPipeline(Get(), pipeline.Get());\n}\nvoid ComputePassEncoder::WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const {\n    wgpuComputePassEncoderWriteTimestamp(Get(), querySet.Get(), queryIndex);\n}\n\n\nvoid ComputePassEncoder::WGPUAddRef(WGPUComputePassEncoder handle) {\n    if (handle != nullptr) {\n        wgpuComputePassEncoderAddRef(handle);\n    }\n}\nvoid ComputePassEncoder::WGPURelease(WGPUComputePassEncoder handle) {\n    if (handle != nullptr) {\n        wgpuComputePassEncoderRelease(handle);\n    }\n}\nstatic_assert(sizeof(ComputePassEncoder) == sizeof(WGPUComputePassEncoder), \"sizeof mismatch for ComputePassEncoder\");\nstatic_assert(alignof(ComputePassEncoder) == alignof(WGPUComputePassEncoder), \"alignof mismatch for ComputePassEncoder\");\n\n// ComputePipeline implementation\n\nBindGroupLayout ComputePipeline::GetBindGroupLayout(uint32_t groupIndex) const {\n    auto result = wgpuComputePipelineGetBindGroupLayout(Get(), groupIndex);\n    return BindGroupLayout::Acquire(result);\n}\nvoid ComputePipeline::SetLabel(StringView label) const {\n    wgpuComputePipelineSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid ComputePipeline::WGPUAddRef(WGPUComputePipeline handle) {\n    if (handle != nullptr) {\n        wgpuComputePipelineAddRef(handle);\n    }\n}\nvoid ComputePipeline::WGPURelease(WGPUComputePipeline handle) {\n    if (handle != nullptr) {\n        wgpuComputePipelineRelease(handle);\n    }\n}\nstatic_assert(sizeof(ComputePipeline) == sizeof(WGPUComputePipeline), \"sizeof mismatch for ComputePipeline\");\nstatic_assert(alignof(ComputePipeline) == alignof(WGPUComputePipeline), \"alignof mismatch for ComputePipeline\");\n\n// Device implementation\n\nBindGroup Device::CreateBindGroup(BindGroupDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateBindGroup(Get(), reinterpret_cast<WGPUBindGroupDescriptor const * >(descriptor));\n    return BindGroup::Acquire(result);\n}\nBindGroupLayout Device::CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateBindGroupLayout(Get(), reinterpret_cast<WGPUBindGroupLayoutDescriptor const * >(descriptor));\n    return BindGroupLayout::Acquire(result);\n}\nBuffer Device::CreateBuffer(BufferDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateBuffer(Get(), reinterpret_cast<WGPUBufferDescriptor const * >(descriptor));\n    return Buffer::Acquire(result);\n}\nCommandEncoder Device::CreateCommandEncoder(CommandEncoderDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateCommandEncoder(Get(), reinterpret_cast<WGPUCommandEncoderDescriptor const * >(descriptor));\n    return CommandEncoder::Acquire(result);\n}\nComputePipeline Device::CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateComputePipeline(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor));\n    return ComputePipeline::Acquire(result);\n}\nvoid Device::CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) const {\n    wgpuDeviceCreateComputePipelineAsync(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUCreateComputePipelineAsyncCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), ComputePipeline::Acquire(pipeline), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), ComputePipeline::Acquire(pipeline), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDeviceCreateComputePipelineAsync2(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CallbackMode callbackMode, L callback) const {\n    using F = CreateComputePipelineAsyncCallback2<void>;\n\n    WGPUCreateComputePipelineAsyncCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), ComputePipeline::Acquire(pipeline), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDeviceCreateComputePipelineAsync2(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<CreatePipelineAsyncStatus>(status), ComputePipeline::Acquire(pipeline), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDeviceCreateComputePipelineAsync2(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Device::CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallbackInfo callbackInfo) const {\n    auto result = wgpuDeviceCreateComputePipelineAsyncF(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), *reinterpret_cast<WGPUCreateComputePipelineAsyncCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nBuffer Device::CreateErrorBuffer(BufferDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateErrorBuffer(Get(), reinterpret_cast<WGPUBufferDescriptor const * >(descriptor));\n    return Buffer::Acquire(result);\n}\nExternalTexture Device::CreateErrorExternalTexture() const {\n    auto result = wgpuDeviceCreateErrorExternalTexture(Get());\n    return ExternalTexture::Acquire(result);\n}\nShaderModule Device::CreateErrorShaderModule(ShaderModuleDescriptor const * descriptor, StringView errorMessage) const {\n    auto result = wgpuDeviceCreateErrorShaderModule(Get(), reinterpret_cast<WGPUShaderModuleDescriptor const * >(descriptor), *reinterpret_cast<WGPUStringView const*>(&errorMessage));\n    return ShaderModule::Acquire(result);\n}\nTexture Device::CreateErrorTexture(TextureDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateErrorTexture(Get(), reinterpret_cast<WGPUTextureDescriptor const * >(descriptor));\n    return Texture::Acquire(result);\n}\nExternalTexture Device::CreateExternalTexture(ExternalTextureDescriptor const * externalTextureDescriptor) const {\n    auto result = wgpuDeviceCreateExternalTexture(Get(), reinterpret_cast<WGPUExternalTextureDescriptor const * >(externalTextureDescriptor));\n    return ExternalTexture::Acquire(result);\n}\nPipelineLayout Device::CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreatePipelineLayout(Get(), reinterpret_cast<WGPUPipelineLayoutDescriptor const * >(descriptor));\n    return PipelineLayout::Acquire(result);\n}\nQuerySet Device::CreateQuerySet(QuerySetDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateQuerySet(Get(), reinterpret_cast<WGPUQuerySetDescriptor const * >(descriptor));\n    return QuerySet::Acquire(result);\n}\nRenderBundleEncoder Device::CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateRenderBundleEncoder(Get(), reinterpret_cast<WGPURenderBundleEncoderDescriptor const * >(descriptor));\n    return RenderBundleEncoder::Acquire(result);\n}\nRenderPipeline Device::CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateRenderPipeline(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor));\n    return RenderPipeline::Acquire(result);\n}\nvoid Device::CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) const {\n    wgpuDeviceCreateRenderPipelineAsync(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUCreateRenderPipelineAsyncCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), RenderPipeline::Acquire(pipeline), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), RenderPipeline::Acquire(pipeline), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDeviceCreateRenderPipelineAsync2(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CallbackMode callbackMode, L callback) const {\n    using F = CreateRenderPipelineAsyncCallback2<void>;\n\n    WGPUCreateRenderPipelineAsyncCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), RenderPipeline::Acquire(pipeline), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDeviceCreateRenderPipelineAsync2(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<CreatePipelineAsyncStatus>(status), RenderPipeline::Acquire(pipeline), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDeviceCreateRenderPipelineAsync2(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Device::CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallbackInfo callbackInfo) const {\n    auto result = wgpuDeviceCreateRenderPipelineAsyncF(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), *reinterpret_cast<WGPUCreateRenderPipelineAsyncCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nSampler Device::CreateSampler(SamplerDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateSampler(Get(), reinterpret_cast<WGPUSamplerDescriptor const * >(descriptor));\n    return Sampler::Acquire(result);\n}\nShaderModule Device::CreateShaderModule(ShaderModuleDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateShaderModule(Get(), reinterpret_cast<WGPUShaderModuleDescriptor const * >(descriptor));\n    return ShaderModule::Acquire(result);\n}\nTexture Device::CreateTexture(TextureDescriptor const * descriptor) const {\n    auto result = wgpuDeviceCreateTexture(Get(), reinterpret_cast<WGPUTextureDescriptor const * >(descriptor));\n    return Texture::Acquire(result);\n}\nvoid Device::Destroy() const {\n    wgpuDeviceDestroy(Get());\n}\nvoid Device::ForceLoss(DeviceLostReason type, StringView message) const {\n    wgpuDeviceForceLoss(Get(), static_cast<WGPUDeviceLostReason>(type), *reinterpret_cast<WGPUStringView const*>(&message));\n}\nConvertibleStatus Device::GetAHardwareBufferProperties(void * handle, AHardwareBufferProperties * properties) const {\n    auto result = wgpuDeviceGetAHardwareBufferProperties(Get(), handle, reinterpret_cast<WGPUAHardwareBufferProperties * >(properties));\n    return static_cast<Status>(result);\n}\nAdapter Device::GetAdapter() const {\n    auto result = wgpuDeviceGetAdapter(Get());\n    return Adapter::Acquire(result);\n}\nConvertibleStatus Device::GetAdapterInfo(AdapterInfo * adapterInfo) const {\n    *adapterInfo = AdapterInfo();\n    auto result = wgpuDeviceGetAdapterInfo(Get(), reinterpret_cast<WGPUAdapterInfo * >(adapterInfo));\n    return static_cast<Status>(result);\n}\nvoid Device::GetFeatures(SupportedFeatures * features) const {\n    *features = SupportedFeatures();\n    wgpuDeviceGetFeatures(Get(), reinterpret_cast<WGPUSupportedFeatures * >(features));\n}\nConvertibleStatus Device::GetLimits(SupportedLimits * limits) const {\n    auto result = wgpuDeviceGetLimits(Get(), reinterpret_cast<WGPUSupportedLimits * >(limits));\n    return static_cast<Status>(result);\n}\nFuture Device::GetLostFuture() const {\n    auto result = wgpuDeviceGetLostFuture(Get());\n    return Future {\n            result.id\n        };\n}\nQueue Device::GetQueue() const {\n    auto result = wgpuDeviceGetQueue(Get());\n    return Queue::Acquire(result);\n}\nBool Device::HasFeature(FeatureName feature) const {\n    auto result = wgpuDeviceHasFeature(Get(), static_cast<WGPUFeatureName>(feature));\n    return result;\n}\nSharedBufferMemory Device::ImportSharedBufferMemory(SharedBufferMemoryDescriptor const * descriptor) const {\n    auto result = wgpuDeviceImportSharedBufferMemory(Get(), reinterpret_cast<WGPUSharedBufferMemoryDescriptor const * >(descriptor));\n    return SharedBufferMemory::Acquire(result);\n}\nSharedFence Device::ImportSharedFence(SharedFenceDescriptor const * descriptor) const {\n    auto result = wgpuDeviceImportSharedFence(Get(), reinterpret_cast<WGPUSharedFenceDescriptor const * >(descriptor));\n    return SharedFence::Acquire(result);\n}\nSharedTextureMemory Device::ImportSharedTextureMemory(SharedTextureMemoryDescriptor const * descriptor) const {\n    auto result = wgpuDeviceImportSharedTextureMemory(Get(), reinterpret_cast<WGPUSharedTextureMemoryDescriptor const * >(descriptor));\n    return SharedTextureMemory::Acquire(result);\n}\nvoid Device::InjectError(ErrorType type, StringView message) const {\n    wgpuDeviceInjectError(Get(), static_cast<WGPUErrorType>(type), *reinterpret_cast<WGPUStringView const*>(&message));\n}\nvoid Device::PopErrorScope(ErrorCallback oldCallback, void * userdata) const {\n    wgpuDevicePopErrorScope(Get(), oldCallback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::PopErrorScope(CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUPopErrorScopeCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<PopErrorScopeStatus>(status), static_cast<ErrorType>(type), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<PopErrorScopeStatus>(status), static_cast<ErrorType>(type), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDevicePopErrorScope2(Get(), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::PopErrorScope(CallbackMode callbackMode, L callback) const {\n    using F = PopErrorScopeCallback2<void>;\n\n    WGPUPopErrorScopeCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<PopErrorScopeStatus>(status), static_cast<ErrorType>(type), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDevicePopErrorScope2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<PopErrorScopeStatus>(status), static_cast<ErrorType>(type), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDevicePopErrorScope2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Device::PopErrorScope(PopErrorScopeCallbackInfo callbackInfo) const {\n    auto result = wgpuDevicePopErrorScopeF(Get(), *reinterpret_cast<WGPUPopErrorScopeCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nvoid Device::PushErrorScope(ErrorFilter filter) const {\n    wgpuDevicePushErrorScope(Get(), static_cast<WGPUErrorFilter>(filter));\n}\nvoid Device::SetLabel(StringView label) const {\n    wgpuDeviceSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid Device::SetLoggingCallback(LoggingCallback callback, void * userdata) const {\n    wgpuDeviceSetLoggingCallback(Get(), callback, userdata);\n}\nvoid Device::Tick() const {\n    wgpuDeviceTick(Get());\n}\nvoid Device::ValidateTextureDescriptor(TextureDescriptor const * descriptor) const {\n    wgpuDeviceValidateTextureDescriptor(Get(), reinterpret_cast<WGPUTextureDescriptor const * >(descriptor));\n}\n\n\nvoid Device::WGPUAddRef(WGPUDevice handle) {\n    if (handle != nullptr) {\n        wgpuDeviceAddRef(handle);\n    }\n}\nvoid Device::WGPURelease(WGPUDevice handle) {\n    if (handle != nullptr) {\n        wgpuDeviceRelease(handle);\n    }\n}\nstatic_assert(sizeof(Device) == sizeof(WGPUDevice), \"sizeof mismatch for Device\");\nstatic_assert(alignof(Device) == alignof(WGPUDevice), \"alignof mismatch for Device\");\n\n// ExternalTexture implementation\n\nvoid ExternalTexture::Destroy() const {\n    wgpuExternalTextureDestroy(Get());\n}\nvoid ExternalTexture::Expire() const {\n    wgpuExternalTextureExpire(Get());\n}\nvoid ExternalTexture::Refresh() const {\n    wgpuExternalTextureRefresh(Get());\n}\nvoid ExternalTexture::SetLabel(StringView label) const {\n    wgpuExternalTextureSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid ExternalTexture::WGPUAddRef(WGPUExternalTexture handle) {\n    if (handle != nullptr) {\n        wgpuExternalTextureAddRef(handle);\n    }\n}\nvoid ExternalTexture::WGPURelease(WGPUExternalTexture handle) {\n    if (handle != nullptr) {\n        wgpuExternalTextureRelease(handle);\n    }\n}\nstatic_assert(sizeof(ExternalTexture) == sizeof(WGPUExternalTexture), \"sizeof mismatch for ExternalTexture\");\nstatic_assert(alignof(ExternalTexture) == alignof(WGPUExternalTexture), \"alignof mismatch for ExternalTexture\");\n\n// Instance implementation\n\nSurface Instance::CreateSurface(SurfaceDescriptor const * descriptor) const {\n    auto result = wgpuInstanceCreateSurface(Get(), reinterpret_cast<WGPUSurfaceDescriptor const * >(descriptor));\n    return Surface::Acquire(result);\n}\nsize_t Instance::EnumerateWGSLLanguageFeatures(WGSLFeatureName * features) const {\n    auto result = wgpuInstanceEnumerateWGSLLanguageFeatures(Get(), reinterpret_cast<WGPUWGSLFeatureName * >(features));\n    return result;\n}\nBool Instance::HasWGSLLanguageFeature(WGSLFeatureName feature) const {\n    auto result = wgpuInstanceHasWGSLLanguageFeature(Get(), static_cast<WGPUWGSLFeatureName>(feature));\n    return result;\n}\nvoid Instance::ProcessEvents() const {\n    wgpuInstanceProcessEvents(Get());\n}\nvoid Instance::RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallback callback, void * userdata) const {\n    wgpuInstanceRequestAdapter(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Instance::RequestAdapter(RequestAdapterOptions const * options, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPURequestAdapterCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<RequestAdapterStatus>(status), Adapter::Acquire(adapter), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<RequestAdapterStatus>(status), Adapter::Acquire(adapter), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuInstanceRequestAdapter2(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Instance::RequestAdapter(RequestAdapterOptions const * options, CallbackMode callbackMode, L callback) const {\n    using F = RequestAdapterCallback2<void>;\n\n    WGPURequestAdapterCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<RequestAdapterStatus>(status), Adapter::Acquire(adapter), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuInstanceRequestAdapter2(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<RequestAdapterStatus>(status), Adapter::Acquire(adapter), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuInstanceRequestAdapter2(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Instance::RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallbackInfo callbackInfo) const {\n    auto result = wgpuInstanceRequestAdapterF(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), *reinterpret_cast<WGPURequestAdapterCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nWaitStatus Instance::WaitAny(size_t futureCount, FutureWaitInfo * futures, uint64_t timeoutNS) const {\n    auto result = wgpuInstanceWaitAny(Get(), futureCount, reinterpret_cast<WGPUFutureWaitInfo * >(futures), timeoutNS);\n    return static_cast<WaitStatus>(result);\n}\n\nWaitStatus Instance::WaitAny(Future f, uint64_t timeout) const {\n    FutureWaitInfo waitInfo { f };\n    return WaitAny(1, &waitInfo, timeout);\n}\n\nvoid Instance::WGPUAddRef(WGPUInstance handle) {\n    if (handle != nullptr) {\n        wgpuInstanceAddRef(handle);\n    }\n}\nvoid Instance::WGPURelease(WGPUInstance handle) {\n    if (handle != nullptr) {\n        wgpuInstanceRelease(handle);\n    }\n}\nstatic_assert(sizeof(Instance) == sizeof(WGPUInstance), \"sizeof mismatch for Instance\");\nstatic_assert(alignof(Instance) == alignof(WGPUInstance), \"alignof mismatch for Instance\");\n\n// PipelineLayout implementation\n\nvoid PipelineLayout::SetLabel(StringView label) const {\n    wgpuPipelineLayoutSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid PipelineLayout::WGPUAddRef(WGPUPipelineLayout handle) {\n    if (handle != nullptr) {\n        wgpuPipelineLayoutAddRef(handle);\n    }\n}\nvoid PipelineLayout::WGPURelease(WGPUPipelineLayout handle) {\n    if (handle != nullptr) {\n        wgpuPipelineLayoutRelease(handle);\n    }\n}\nstatic_assert(sizeof(PipelineLayout) == sizeof(WGPUPipelineLayout), \"sizeof mismatch for PipelineLayout\");\nstatic_assert(alignof(PipelineLayout) == alignof(WGPUPipelineLayout), \"alignof mismatch for PipelineLayout\");\n\n// QuerySet implementation\n\nvoid QuerySet::Destroy() const {\n    wgpuQuerySetDestroy(Get());\n}\nuint32_t QuerySet::GetCount() const {\n    auto result = wgpuQuerySetGetCount(Get());\n    return result;\n}\nQueryType QuerySet::GetType() const {\n    auto result = wgpuQuerySetGetType(Get());\n    return static_cast<QueryType>(result);\n}\nvoid QuerySet::SetLabel(StringView label) const {\n    wgpuQuerySetSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid QuerySet::WGPUAddRef(WGPUQuerySet handle) {\n    if (handle != nullptr) {\n        wgpuQuerySetAddRef(handle);\n    }\n}\nvoid QuerySet::WGPURelease(WGPUQuerySet handle) {\n    if (handle != nullptr) {\n        wgpuQuerySetRelease(handle);\n    }\n}\nstatic_assert(sizeof(QuerySet) == sizeof(WGPUQuerySet), \"sizeof mismatch for QuerySet\");\nstatic_assert(alignof(QuerySet) == alignof(WGPUQuerySet), \"alignof mismatch for QuerySet\");\n\n// Queue implementation\n\nvoid Queue::CopyExternalTextureForBrowser(ImageCopyExternalTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const {\n    wgpuQueueCopyExternalTextureForBrowser(Get(), reinterpret_cast<WGPUImageCopyExternalTexture const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize), reinterpret_cast<WGPUCopyTextureForBrowserOptions const * >(options));\n}\nvoid Queue::CopyTextureForBrowser(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const {\n    wgpuQueueCopyTextureForBrowser(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize), reinterpret_cast<WGPUCopyTextureForBrowserOptions const * >(options));\n}\nvoid Queue::OnSubmittedWorkDone(QueueWorkDoneCallback callback, void * userdata) const {\n    wgpuQueueOnSubmittedWorkDone(Get(), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Queue::OnSubmittedWorkDone(CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUQueueWorkDoneCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUQueueWorkDoneStatus status, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<QueueWorkDoneStatus>(status), static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUQueueWorkDoneStatus status, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<QueueWorkDoneStatus>(status), static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuQueueOnSubmittedWorkDone2(Get(), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Queue::OnSubmittedWorkDone(CallbackMode callbackMode, L callback) const {\n    using F = QueueWorkDoneCallback2<void>;\n\n    WGPUQueueWorkDoneCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUQueueWorkDoneStatus status, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<QueueWorkDoneStatus>(status));\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuQueueOnSubmittedWorkDone2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUQueueWorkDoneStatus status, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<QueueWorkDoneStatus>(status));\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuQueueOnSubmittedWorkDone2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Queue::OnSubmittedWorkDone(QueueWorkDoneCallbackInfo callbackInfo) const {\n    auto result = wgpuQueueOnSubmittedWorkDoneF(Get(), *reinterpret_cast<WGPUQueueWorkDoneCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nvoid Queue::SetLabel(StringView label) const {\n    wgpuQueueSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid Queue::Submit(size_t commandCount, CommandBuffer const * commands) const {\n    wgpuQueueSubmit(Get(), commandCount, reinterpret_cast<WGPUCommandBuffer const * >(commands));\n}\nvoid Queue::WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const {\n    wgpuQueueWriteBuffer(Get(), buffer.Get(), bufferOffset, reinterpret_cast<void const * >(data), size);\n}\nvoid Queue::WriteTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) const {\n    wgpuQueueWriteTexture(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<void const * >(data), dataSize, reinterpret_cast<WGPUTextureDataLayout const * >(dataLayout), reinterpret_cast<WGPUExtent3D const * >(writeSize));\n}\n\n\nvoid Queue::WGPUAddRef(WGPUQueue handle) {\n    if (handle != nullptr) {\n        wgpuQueueAddRef(handle);\n    }\n}\nvoid Queue::WGPURelease(WGPUQueue handle) {\n    if (handle != nullptr) {\n        wgpuQueueRelease(handle);\n    }\n}\nstatic_assert(sizeof(Queue) == sizeof(WGPUQueue), \"sizeof mismatch for Queue\");\nstatic_assert(alignof(Queue) == alignof(WGPUQueue), \"alignof mismatch for Queue\");\n\n// RenderBundle implementation\n\nvoid RenderBundle::SetLabel(StringView label) const {\n    wgpuRenderBundleSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid RenderBundle::WGPUAddRef(WGPURenderBundle handle) {\n    if (handle != nullptr) {\n        wgpuRenderBundleAddRef(handle);\n    }\n}\nvoid RenderBundle::WGPURelease(WGPURenderBundle handle) {\n    if (handle != nullptr) {\n        wgpuRenderBundleRelease(handle);\n    }\n}\nstatic_assert(sizeof(RenderBundle) == sizeof(WGPURenderBundle), \"sizeof mismatch for RenderBundle\");\nstatic_assert(alignof(RenderBundle) == alignof(WGPURenderBundle), \"alignof mismatch for RenderBundle\");\n\n// RenderBundleEncoder implementation\n\nvoid RenderBundleEncoder::Draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const {\n    wgpuRenderBundleEncoderDraw(Get(), vertexCount, instanceCount, firstVertex, firstInstance);\n}\nvoid RenderBundleEncoder::DrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) const {\n    wgpuRenderBundleEncoderDrawIndexed(Get(), indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n}\nvoid RenderBundleEncoder::DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuRenderBundleEncoderDrawIndexedIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nvoid RenderBundleEncoder::DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuRenderBundleEncoderDrawIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nRenderBundle RenderBundleEncoder::Finish(RenderBundleDescriptor const * descriptor) const {\n    auto result = wgpuRenderBundleEncoderFinish(Get(), reinterpret_cast<WGPURenderBundleDescriptor const * >(descriptor));\n    return RenderBundle::Acquire(result);\n}\nvoid RenderBundleEncoder::InsertDebugMarker(StringView markerLabel) const {\n    wgpuRenderBundleEncoderInsertDebugMarker(Get(), *reinterpret_cast<WGPUStringView const*>(&markerLabel));\n}\nvoid RenderBundleEncoder::PopDebugGroup() const {\n    wgpuRenderBundleEncoderPopDebugGroup(Get());\n}\nvoid RenderBundleEncoder::PushDebugGroup(StringView groupLabel) const {\n    wgpuRenderBundleEncoderPushDebugGroup(Get(), *reinterpret_cast<WGPUStringView const*>(&groupLabel));\n}\nvoid RenderBundleEncoder::SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) const {\n    wgpuRenderBundleEncoderSetBindGroup(Get(), groupIndex, group.Get(), dynamicOffsetCount, reinterpret_cast<uint32_t const * >(dynamicOffsets));\n}\nvoid RenderBundleEncoder::SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset, uint64_t size) const {\n    wgpuRenderBundleEncoderSetIndexBuffer(Get(), buffer.Get(), static_cast<WGPUIndexFormat>(format), offset, size);\n}\nvoid RenderBundleEncoder::SetLabel(StringView label) const {\n    wgpuRenderBundleEncoderSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid RenderBundleEncoder::SetPipeline(RenderPipeline const& pipeline) const {\n    wgpuRenderBundleEncoderSetPipeline(Get(), pipeline.Get());\n}\nvoid RenderBundleEncoder::SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset, uint64_t size) const {\n    wgpuRenderBundleEncoderSetVertexBuffer(Get(), slot, buffer.Get(), offset, size);\n}\n\n\nvoid RenderBundleEncoder::WGPUAddRef(WGPURenderBundleEncoder handle) {\n    if (handle != nullptr) {\n        wgpuRenderBundleEncoderAddRef(handle);\n    }\n}\nvoid RenderBundleEncoder::WGPURelease(WGPURenderBundleEncoder handle) {\n    if (handle != nullptr) {\n        wgpuRenderBundleEncoderRelease(handle);\n    }\n}\nstatic_assert(sizeof(RenderBundleEncoder) == sizeof(WGPURenderBundleEncoder), \"sizeof mismatch for RenderBundleEncoder\");\nstatic_assert(alignof(RenderBundleEncoder) == alignof(WGPURenderBundleEncoder), \"alignof mismatch for RenderBundleEncoder\");\n\n// RenderPassEncoder implementation\n\nvoid RenderPassEncoder::BeginOcclusionQuery(uint32_t queryIndex) const {\n    wgpuRenderPassEncoderBeginOcclusionQuery(Get(), queryIndex);\n}\nvoid RenderPassEncoder::Draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const {\n    wgpuRenderPassEncoderDraw(Get(), vertexCount, instanceCount, firstVertex, firstInstance);\n}\nvoid RenderPassEncoder::DrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) const {\n    wgpuRenderPassEncoderDrawIndexed(Get(), indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n}\nvoid RenderPassEncoder::DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuRenderPassEncoderDrawIndexedIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nvoid RenderPassEncoder::DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuRenderPassEncoderDrawIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nvoid RenderPassEncoder::End() const {\n    wgpuRenderPassEncoderEnd(Get());\n}\nvoid RenderPassEncoder::EndOcclusionQuery() const {\n    wgpuRenderPassEncoderEndOcclusionQuery(Get());\n}\nvoid RenderPassEncoder::ExecuteBundles(size_t bundleCount, RenderBundle const * bundles) const {\n    wgpuRenderPassEncoderExecuteBundles(Get(), bundleCount, reinterpret_cast<WGPURenderBundle const * >(bundles));\n}\nvoid RenderPassEncoder::InsertDebugMarker(StringView markerLabel) const {\n    wgpuRenderPassEncoderInsertDebugMarker(Get(), *reinterpret_cast<WGPUStringView const*>(&markerLabel));\n}\nvoid RenderPassEncoder::MultiDrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset, uint32_t maxDrawCount, Buffer const& drawCountBuffer, uint64_t drawCountBufferOffset) const {\n    wgpuRenderPassEncoderMultiDrawIndexedIndirect(Get(), indirectBuffer.Get(), indirectOffset, maxDrawCount, drawCountBuffer.Get(), drawCountBufferOffset);\n}\nvoid RenderPassEncoder::MultiDrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset, uint32_t maxDrawCount, Buffer const& drawCountBuffer, uint64_t drawCountBufferOffset) const {\n    wgpuRenderPassEncoderMultiDrawIndirect(Get(), indirectBuffer.Get(), indirectOffset, maxDrawCount, drawCountBuffer.Get(), drawCountBufferOffset);\n}\nvoid RenderPassEncoder::PixelLocalStorageBarrier() const {\n    wgpuRenderPassEncoderPixelLocalStorageBarrier(Get());\n}\nvoid RenderPassEncoder::PopDebugGroup() const {\n    wgpuRenderPassEncoderPopDebugGroup(Get());\n}\nvoid RenderPassEncoder::PushDebugGroup(StringView groupLabel) const {\n    wgpuRenderPassEncoderPushDebugGroup(Get(), *reinterpret_cast<WGPUStringView const*>(&groupLabel));\n}\nvoid RenderPassEncoder::SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) const {\n    wgpuRenderPassEncoderSetBindGroup(Get(), groupIndex, group.Get(), dynamicOffsetCount, reinterpret_cast<uint32_t const * >(dynamicOffsets));\n}\nvoid RenderPassEncoder::SetBlendConstant(Color const * color) const {\n    wgpuRenderPassEncoderSetBlendConstant(Get(), reinterpret_cast<WGPUColor const * >(color));\n}\nvoid RenderPassEncoder::SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset, uint64_t size) const {\n    wgpuRenderPassEncoderSetIndexBuffer(Get(), buffer.Get(), static_cast<WGPUIndexFormat>(format), offset, size);\n}\nvoid RenderPassEncoder::SetLabel(StringView label) const {\n    wgpuRenderPassEncoderSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid RenderPassEncoder::SetPipeline(RenderPipeline const& pipeline) const {\n    wgpuRenderPassEncoderSetPipeline(Get(), pipeline.Get());\n}\nvoid RenderPassEncoder::SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const {\n    wgpuRenderPassEncoderSetScissorRect(Get(), x, y, width, height);\n}\nvoid RenderPassEncoder::SetStencilReference(uint32_t reference) const {\n    wgpuRenderPassEncoderSetStencilReference(Get(), reference);\n}\nvoid RenderPassEncoder::SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset, uint64_t size) const {\n    wgpuRenderPassEncoderSetVertexBuffer(Get(), slot, buffer.Get(), offset, size);\n}\nvoid RenderPassEncoder::SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const {\n    wgpuRenderPassEncoderSetViewport(Get(), x, y, width, height, minDepth, maxDepth);\n}\nvoid RenderPassEncoder::WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const {\n    wgpuRenderPassEncoderWriteTimestamp(Get(), querySet.Get(), queryIndex);\n}\n\n\nvoid RenderPassEncoder::WGPUAddRef(WGPURenderPassEncoder handle) {\n    if (handle != nullptr) {\n        wgpuRenderPassEncoderAddRef(handle);\n    }\n}\nvoid RenderPassEncoder::WGPURelease(WGPURenderPassEncoder handle) {\n    if (handle != nullptr) {\n        wgpuRenderPassEncoderRelease(handle);\n    }\n}\nstatic_assert(sizeof(RenderPassEncoder) == sizeof(WGPURenderPassEncoder), \"sizeof mismatch for RenderPassEncoder\");\nstatic_assert(alignof(RenderPassEncoder) == alignof(WGPURenderPassEncoder), \"alignof mismatch for RenderPassEncoder\");\n\n// RenderPipeline implementation\n\nBindGroupLayout RenderPipeline::GetBindGroupLayout(uint32_t groupIndex) const {\n    auto result = wgpuRenderPipelineGetBindGroupLayout(Get(), groupIndex);\n    return BindGroupLayout::Acquire(result);\n}\nvoid RenderPipeline::SetLabel(StringView label) const {\n    wgpuRenderPipelineSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid RenderPipeline::WGPUAddRef(WGPURenderPipeline handle) {\n    if (handle != nullptr) {\n        wgpuRenderPipelineAddRef(handle);\n    }\n}\nvoid RenderPipeline::WGPURelease(WGPURenderPipeline handle) {\n    if (handle != nullptr) {\n        wgpuRenderPipelineRelease(handle);\n    }\n}\nstatic_assert(sizeof(RenderPipeline) == sizeof(WGPURenderPipeline), \"sizeof mismatch for RenderPipeline\");\nstatic_assert(alignof(RenderPipeline) == alignof(WGPURenderPipeline), \"alignof mismatch for RenderPipeline\");\n\n// Sampler implementation\n\nvoid Sampler::SetLabel(StringView label) const {\n    wgpuSamplerSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid Sampler::WGPUAddRef(WGPUSampler handle) {\n    if (handle != nullptr) {\n        wgpuSamplerAddRef(handle);\n    }\n}\nvoid Sampler::WGPURelease(WGPUSampler handle) {\n    if (handle != nullptr) {\n        wgpuSamplerRelease(handle);\n    }\n}\nstatic_assert(sizeof(Sampler) == sizeof(WGPUSampler), \"sizeof mismatch for Sampler\");\nstatic_assert(alignof(Sampler) == alignof(WGPUSampler), \"alignof mismatch for Sampler\");\n\n// ShaderModule implementation\n\nvoid ShaderModule::GetCompilationInfo(CompilationInfoCallback callback, void * userdata) const {\n    wgpuShaderModuleGetCompilationInfo(Get(), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture ShaderModule::GetCompilationInfo(CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUCompilationInfoCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * compilationInfo, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<CompilationInfoRequestStatus>(status), reinterpret_cast<CompilationInfo const*>(compilationInfo), static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * compilationInfo, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<CompilationInfoRequestStatus>(status), reinterpret_cast<CompilationInfo const*>(compilationInfo), static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuShaderModuleGetCompilationInfo2(Get(), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture ShaderModule::GetCompilationInfo(CallbackMode callbackMode, L callback) const {\n    using F = CompilationInfoCallback2<void>;\n\n    WGPUCompilationInfoCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * compilationInfo, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<CompilationInfoRequestStatus>(status), reinterpret_cast<CompilationInfo const*>(compilationInfo));\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuShaderModuleGetCompilationInfo2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * compilationInfo, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<CompilationInfoRequestStatus>(status), reinterpret_cast<CompilationInfo const*>(compilationInfo));\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuShaderModuleGetCompilationInfo2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture ShaderModule::GetCompilationInfo(CompilationInfoCallbackInfo callbackInfo) const {\n    auto result = wgpuShaderModuleGetCompilationInfoF(Get(), *reinterpret_cast<WGPUCompilationInfoCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nvoid ShaderModule::SetLabel(StringView label) const {\n    wgpuShaderModuleSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid ShaderModule::WGPUAddRef(WGPUShaderModule handle) {\n    if (handle != nullptr) {\n        wgpuShaderModuleAddRef(handle);\n    }\n}\nvoid ShaderModule::WGPURelease(WGPUShaderModule handle) {\n    if (handle != nullptr) {\n        wgpuShaderModuleRelease(handle);\n    }\n}\nstatic_assert(sizeof(ShaderModule) == sizeof(WGPUShaderModule), \"sizeof mismatch for ShaderModule\");\nstatic_assert(alignof(ShaderModule) == alignof(WGPUShaderModule), \"alignof mismatch for ShaderModule\");\n\n// SharedBufferMemory implementation\n\nConvertibleStatus SharedBufferMemory::BeginAccess(Buffer const& buffer, SharedBufferMemoryBeginAccessDescriptor const * descriptor) const {\n    auto result = wgpuSharedBufferMemoryBeginAccess(Get(), buffer.Get(), reinterpret_cast<WGPUSharedBufferMemoryBeginAccessDescriptor const * >(descriptor));\n    return static_cast<Status>(result);\n}\nBuffer SharedBufferMemory::CreateBuffer(BufferDescriptor const * descriptor) const {\n    auto result = wgpuSharedBufferMemoryCreateBuffer(Get(), reinterpret_cast<WGPUBufferDescriptor const * >(descriptor));\n    return Buffer::Acquire(result);\n}\nConvertibleStatus SharedBufferMemory::EndAccess(Buffer const& buffer, SharedBufferMemoryEndAccessState * descriptor) const {\n    *descriptor = SharedBufferMemoryEndAccessState();\n    auto result = wgpuSharedBufferMemoryEndAccess(Get(), buffer.Get(), reinterpret_cast<WGPUSharedBufferMemoryEndAccessState * >(descriptor));\n    return static_cast<Status>(result);\n}\nConvertibleStatus SharedBufferMemory::GetProperties(SharedBufferMemoryProperties * properties) const {\n    auto result = wgpuSharedBufferMemoryGetProperties(Get(), reinterpret_cast<WGPUSharedBufferMemoryProperties * >(properties));\n    return static_cast<Status>(result);\n}\nBool SharedBufferMemory::IsDeviceLost() const {\n    auto result = wgpuSharedBufferMemoryIsDeviceLost(Get());\n    return result;\n}\nvoid SharedBufferMemory::SetLabel(StringView label) const {\n    wgpuSharedBufferMemorySetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid SharedBufferMemory::WGPUAddRef(WGPUSharedBufferMemory handle) {\n    if (handle != nullptr) {\n        wgpuSharedBufferMemoryAddRef(handle);\n    }\n}\nvoid SharedBufferMemory::WGPURelease(WGPUSharedBufferMemory handle) {\n    if (handle != nullptr) {\n        wgpuSharedBufferMemoryRelease(handle);\n    }\n}\nstatic_assert(sizeof(SharedBufferMemory) == sizeof(WGPUSharedBufferMemory), \"sizeof mismatch for SharedBufferMemory\");\nstatic_assert(alignof(SharedBufferMemory) == alignof(WGPUSharedBufferMemory), \"alignof mismatch for SharedBufferMemory\");\n\n// SharedFence implementation\n\nvoid SharedFence::ExportInfo(SharedFenceExportInfo * info) const {\n    wgpuSharedFenceExportInfo(Get(), reinterpret_cast<WGPUSharedFenceExportInfo * >(info));\n}\n\n\nvoid SharedFence::WGPUAddRef(WGPUSharedFence handle) {\n    if (handle != nullptr) {\n        wgpuSharedFenceAddRef(handle);\n    }\n}\nvoid SharedFence::WGPURelease(WGPUSharedFence handle) {\n    if (handle != nullptr) {\n        wgpuSharedFenceRelease(handle);\n    }\n}\nstatic_assert(sizeof(SharedFence) == sizeof(WGPUSharedFence), \"sizeof mismatch for SharedFence\");\nstatic_assert(alignof(SharedFence) == alignof(WGPUSharedFence), \"alignof mismatch for SharedFence\");\n\n// SharedTextureMemory implementation\n\nConvertibleStatus SharedTextureMemory::BeginAccess(Texture const& texture, SharedTextureMemoryBeginAccessDescriptor const * descriptor) const {\n    auto result = wgpuSharedTextureMemoryBeginAccess(Get(), texture.Get(), reinterpret_cast<WGPUSharedTextureMemoryBeginAccessDescriptor const * >(descriptor));\n    return static_cast<Status>(result);\n}\nTexture SharedTextureMemory::CreateTexture(TextureDescriptor const * descriptor) const {\n    auto result = wgpuSharedTextureMemoryCreateTexture(Get(), reinterpret_cast<WGPUTextureDescriptor const * >(descriptor));\n    return Texture::Acquire(result);\n}\nConvertibleStatus SharedTextureMemory::EndAccess(Texture const& texture, SharedTextureMemoryEndAccessState * descriptor) const {\n    *descriptor = SharedTextureMemoryEndAccessState();\n    auto result = wgpuSharedTextureMemoryEndAccess(Get(), texture.Get(), reinterpret_cast<WGPUSharedTextureMemoryEndAccessState * >(descriptor));\n    return static_cast<Status>(result);\n}\nConvertibleStatus SharedTextureMemory::GetProperties(SharedTextureMemoryProperties * properties) const {\n    auto result = wgpuSharedTextureMemoryGetProperties(Get(), reinterpret_cast<WGPUSharedTextureMemoryProperties * >(properties));\n    return static_cast<Status>(result);\n}\nBool SharedTextureMemory::IsDeviceLost() const {\n    auto result = wgpuSharedTextureMemoryIsDeviceLost(Get());\n    return result;\n}\nvoid SharedTextureMemory::SetLabel(StringView label) const {\n    wgpuSharedTextureMemorySetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid SharedTextureMemory::WGPUAddRef(WGPUSharedTextureMemory handle) {\n    if (handle != nullptr) {\n        wgpuSharedTextureMemoryAddRef(handle);\n    }\n}\nvoid SharedTextureMemory::WGPURelease(WGPUSharedTextureMemory handle) {\n    if (handle != nullptr) {\n        wgpuSharedTextureMemoryRelease(handle);\n    }\n}\nstatic_assert(sizeof(SharedTextureMemory) == sizeof(WGPUSharedTextureMemory), \"sizeof mismatch for SharedTextureMemory\");\nstatic_assert(alignof(SharedTextureMemory) == alignof(WGPUSharedTextureMemory), \"alignof mismatch for SharedTextureMemory\");\n\n// Surface implementation\n\nvoid Surface::Configure(SurfaceConfiguration const * config) const {\n    wgpuSurfaceConfigure(Get(), reinterpret_cast<WGPUSurfaceConfiguration const * >(config));\n}\nConvertibleStatus Surface::GetCapabilities(Adapter const& adapter, SurfaceCapabilities * capabilities) const {\n    *capabilities = SurfaceCapabilities();\n    auto result = wgpuSurfaceGetCapabilities(Get(), adapter.Get(), reinterpret_cast<WGPUSurfaceCapabilities * >(capabilities));\n    return static_cast<Status>(result);\n}\nvoid Surface::GetCurrentTexture(SurfaceTexture * surfaceTexture) const {\n    wgpuSurfaceGetCurrentTexture(Get(), reinterpret_cast<WGPUSurfaceTexture * >(surfaceTexture));\n}\nvoid Surface::Present() const {\n    wgpuSurfacePresent(Get());\n}\nvoid Surface::SetLabel(StringView label) const {\n    wgpuSurfaceSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid Surface::Unconfigure() const {\n    wgpuSurfaceUnconfigure(Get());\n}\n\n\nvoid Surface::WGPUAddRef(WGPUSurface handle) {\n    if (handle != nullptr) {\n        wgpuSurfaceAddRef(handle);\n    }\n}\nvoid Surface::WGPURelease(WGPUSurface handle) {\n    if (handle != nullptr) {\n        wgpuSurfaceRelease(handle);\n    }\n}\nstatic_assert(sizeof(Surface) == sizeof(WGPUSurface), \"sizeof mismatch for Surface\");\nstatic_assert(alignof(Surface) == alignof(WGPUSurface), \"alignof mismatch for Surface\");\n\n// Texture implementation\n\nTextureView Texture::CreateErrorView(TextureViewDescriptor const * descriptor) const {\n    auto result = wgpuTextureCreateErrorView(Get(), reinterpret_cast<WGPUTextureViewDescriptor const * >(descriptor));\n    return TextureView::Acquire(result);\n}\nTextureView Texture::CreateView(TextureViewDescriptor const * descriptor) const {\n    auto result = wgpuTextureCreateView(Get(), reinterpret_cast<WGPUTextureViewDescriptor const * >(descriptor));\n    return TextureView::Acquire(result);\n}\nvoid Texture::Destroy() const {\n    wgpuTextureDestroy(Get());\n}\nuint32_t Texture::GetDepthOrArrayLayers() const {\n    auto result = wgpuTextureGetDepthOrArrayLayers(Get());\n    return result;\n}\nTextureDimension Texture::GetDimension() const {\n    auto result = wgpuTextureGetDimension(Get());\n    return static_cast<TextureDimension>(result);\n}\nTextureFormat Texture::GetFormat() const {\n    auto result = wgpuTextureGetFormat(Get());\n    return static_cast<TextureFormat>(result);\n}\nuint32_t Texture::GetHeight() const {\n    auto result = wgpuTextureGetHeight(Get());\n    return result;\n}\nuint32_t Texture::GetMipLevelCount() const {\n    auto result = wgpuTextureGetMipLevelCount(Get());\n    return result;\n}\nuint32_t Texture::GetSampleCount() const {\n    auto result = wgpuTextureGetSampleCount(Get());\n    return result;\n}\nTextureUsage Texture::GetUsage() const {\n    auto result = wgpuTextureGetUsage(Get());\n    return static_cast<TextureUsage>(result);\n}\nuint32_t Texture::GetWidth() const {\n    auto result = wgpuTextureGetWidth(Get());\n    return result;\n}\nvoid Texture::SetLabel(StringView label) const {\n    wgpuTextureSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid Texture::WGPUAddRef(WGPUTexture handle) {\n    if (handle != nullptr) {\n        wgpuTextureAddRef(handle);\n    }\n}\nvoid Texture::WGPURelease(WGPUTexture handle) {\n    if (handle != nullptr) {\n        wgpuTextureRelease(handle);\n    }\n}\nstatic_assert(sizeof(Texture) == sizeof(WGPUTexture), \"sizeof mismatch for Texture\");\nstatic_assert(alignof(Texture) == alignof(WGPUTexture), \"alignof mismatch for Texture\");\n\n// TextureView implementation\n\nvoid TextureView::SetLabel(StringView label) const {\n    wgpuTextureViewSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid TextureView::WGPUAddRef(WGPUTextureView handle) {\n    if (handle != nullptr) {\n        wgpuTextureViewAddRef(handle);\n    }\n}\nvoid TextureView::WGPURelease(WGPUTextureView handle) {\n    if (handle != nullptr) {\n        wgpuTextureViewRelease(handle);\n    }\n}\nstatic_assert(sizeof(TextureView) == sizeof(WGPUTextureView), \"sizeof mismatch for TextureView\");\nstatic_assert(alignof(TextureView) == alignof(WGPUTextureView), \"alignof mismatch for TextureView\");\n\n\n\n// ProgrammableStageDescriptor is deprecated.\n// Use ComputeState instead.\nusing ProgrammableStageDescriptor = ComputeState;\n// RenderPassDescriptorMaxDrawCount is deprecated.\n// Use RenderPassMaxDrawCount instead.\nusing RenderPassDescriptorMaxDrawCount = RenderPassMaxDrawCount;\n// ShaderModuleSPIRVDescriptor is deprecated.\n// Use ShaderSourceSPIRV instead.\nusing ShaderModuleSPIRVDescriptor = ShaderSourceSPIRV;\n// ShaderModuleWGSLDescriptor is deprecated.\n// Use ShaderSourceWGSL instead.\nusing ShaderModuleWGSLDescriptor = ShaderSourceWGSL;\n// SurfaceDescriptorFromAndroidNativeWindow is deprecated.\n// Use SurfaceSourceAndroidNativeWindow instead.\nusing SurfaceDescriptorFromAndroidNativeWindow = SurfaceSourceAndroidNativeWindow;\n// SurfaceDescriptorFromCanvasHTMLSelector is deprecated.\n// Use SurfaceSourceCanvasHTMLSelector_Emscripten instead.\nusing SurfaceDescriptorFromCanvasHTMLSelector = SurfaceSourceCanvasHTMLSelector_Emscripten;\n// SurfaceDescriptorFromMetalLayer is deprecated.\n// Use SurfaceSourceMetalLayer instead.\nusing SurfaceDescriptorFromMetalLayer = SurfaceSourceMetalLayer;\n// SurfaceDescriptorFromWaylandSurface is deprecated.\n// Use SurfaceSourceWaylandSurface instead.\nusing SurfaceDescriptorFromWaylandSurface = SurfaceSourceWaylandSurface;\n// SurfaceDescriptorFromWindowsHWND is deprecated.\n// Use SurfaceSourceWindowsHWND instead.\nusing SurfaceDescriptorFromWindowsHWND = SurfaceSourceWindowsHWND;\n// SurfaceDescriptorFromXcbWindow is deprecated.\n// Use SurfaceSourceXCBWindow instead.\nusing SurfaceDescriptorFromXcbWindow = SurfaceSourceXCBWindow;\n// SurfaceDescriptorFromXlibWindow is deprecated.\n// Use SurfaceSourceXlibWindow instead.\nusing SurfaceDescriptorFromXlibWindow = SurfaceSourceXlibWindow;\n\n// Free Functions\nstatic inline Instance CreateInstance(InstanceDescriptor const * descriptor = nullptr) {\n    auto result = wgpuCreateInstance(reinterpret_cast<WGPUInstanceDescriptor const * >(descriptor));\n    return Instance::Acquire(result);\n}\nstatic inline Status GetInstanceFeatures(InstanceFeatures * features) {\n    auto result = wgpuGetInstanceFeatures(reinterpret_cast<WGPUInstanceFeatures * >(features));\n    return static_cast<Status>(result);\n}\nstatic inline Proc GetProcAddress(StringView procName) {\n    auto result = wgpuGetProcAddress(*reinterpret_cast<WGPUStringView const*>(&procName));\n    return reinterpret_cast<Proc>(result);\n}\n\n}  // namespace wgpu\n\nnamespace wgpu {\ntemplate<>\nstruct IsWGPUBitmask<wgpu::BufferUsage> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::ColorWriteMask> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::HeapProperty> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::MapMode> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::ShaderStage> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::TextureUsage> {\n    static constexpr bool enable = true;\n};\n\n} // namespace wgpu\n\nnamespace std {\n// Custom boolean class needs corresponding hash function so that it appears as a transparent bool.\ntemplate <>\nstruct hash<wgpu::Bool> {\n  public:\n    size_t operator()(const wgpu::Bool &v) const {\n        return hash<bool>()(v);\n    }\n};\ntemplate <>\nstruct hash<wgpu::OptionalBool> {\n  public:\n    size_t operator()(const wgpu::OptionalBool &v) const {\n        return hash<WGPUOptionalBool>()(v.mValue);\n    }\n};\n}  // namespace std\n\n#endif // WEBGPU_CPP_H_\n", "include/dawn/wire/client/webgpu_cpp.h": "// Copyright 2017 The Dawn & Tint Authors\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n#ifdef __EMSCRIPTEN__\n#error \"Do not include this header. Emscripten already provides headers needed for WebGPU.\"\n#endif\n\n#ifndef DAWN_WIRE_CLIENT_WEBGPU_CPP_H_\n#define DAWN_WIRE_CLIENT_WEBGPU_CPP_H_\n\n#include <cassert>\n#include <cmath>\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n#include <optional>\n#include <functional>\n#include <string_view>\n#include <type_traits>\n#include <utility>\n\n#include \"dawn/wire/client/webgpu.h\"\n#include \"webgpu/webgpu_cpp_chained_struct.h\"\n#include \"webgpu/webgpu_enum_class_bitmasks.h\"  // IWYU pragma: export\n\nnamespace wgpu {\n\nstatic constexpr uint32_t kArrayLayerCountUndefined = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\nstatic constexpr uint32_t kCopyStrideUndefined = WGPU_COPY_STRIDE_UNDEFINED;\nstatic constexpr uint32_t kDepthSliceUndefined = WGPU_DEPTH_SLICE_UNDEFINED;\nstatic constexpr uint32_t kLimitU32Undefined = WGPU_LIMIT_U32_UNDEFINED;\nstatic constexpr uint64_t kLimitU64Undefined = WGPU_LIMIT_U64_UNDEFINED;\nstatic constexpr uint32_t kMipLevelCountUndefined = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\nstatic constexpr uint32_t kQuerySetIndexUndefined = WGPU_QUERY_SET_INDEX_UNDEFINED;\nstatic constexpr size_t kStrlen = WGPU_STRLEN;\nstatic constexpr size_t kWholeMapSize = WGPU_WHOLE_MAP_SIZE;\nstatic constexpr uint64_t kWholeSize = WGPU_WHOLE_SIZE;\nenum class WGSLFeatureName : uint32_t {\n    ReadonlyAndReadwriteStorageTextures = WGPUWGSLFeatureName_ReadonlyAndReadwriteStorageTextures,\n    Packed4x8IntegerDotProduct = WGPUWGSLFeatureName_Packed4x8IntegerDotProduct,\n    UnrestrictedPointerParameters = WGPUWGSLFeatureName_UnrestrictedPointerParameters,\n    PointerCompositeAccess = WGPUWGSLFeatureName_PointerCompositeAccess,\n    ChromiumTestingUnimplemented = WGPUWGSLFeatureName_ChromiumTestingUnimplemented,\n    ChromiumTestingUnsafeExperimental = WGPUWGSLFeatureName_ChromiumTestingUnsafeExperimental,\n    ChromiumTestingExperimental = WGPUWGSLFeatureName_ChromiumTestingExperimental,\n    ChromiumTestingShippedWithKillswitch = WGPUWGSLFeatureName_ChromiumTestingShippedWithKillswitch,\n    ChromiumTestingShipped = WGPUWGSLFeatureName_ChromiumTestingShipped,\n};\nstatic_assert(sizeof(WGSLFeatureName) == sizeof(WGPUWGSLFeatureName), \"sizeof mismatch for WGSLFeatureName\");\nstatic_assert(alignof(WGSLFeatureName) == alignof(WGPUWGSLFeatureName), \"alignof mismatch for WGSLFeatureName\");\n\nenum class AdapterType : uint32_t {\n    DiscreteGPU = WGPUAdapterType_DiscreteGPU,\n    IntegratedGPU = WGPUAdapterType_IntegratedGPU,\n    CPU = WGPUAdapterType_CPU,\n    Unknown = WGPUAdapterType_Unknown,\n};\nstatic_assert(sizeof(AdapterType) == sizeof(WGPUAdapterType), \"sizeof mismatch for AdapterType\");\nstatic_assert(alignof(AdapterType) == alignof(WGPUAdapterType), \"alignof mismatch for AdapterType\");\n\nenum class AddressMode : uint32_t {\n    Undefined = WGPUAddressMode_Undefined,\n    ClampToEdge = WGPUAddressMode_ClampToEdge,\n    Repeat = WGPUAddressMode_Repeat,\n    MirrorRepeat = WGPUAddressMode_MirrorRepeat,\n};\nstatic_assert(sizeof(AddressMode) == sizeof(WGPUAddressMode), \"sizeof mismatch for AddressMode\");\nstatic_assert(alignof(AddressMode) == alignof(WGPUAddressMode), \"alignof mismatch for AddressMode\");\n\nenum class AlphaMode : uint32_t {\n    Opaque = WGPUAlphaMode_Opaque,\n    Premultiplied = WGPUAlphaMode_Premultiplied,\n    Unpremultiplied = WGPUAlphaMode_Unpremultiplied,\n};\nstatic_assert(sizeof(AlphaMode) == sizeof(WGPUAlphaMode), \"sizeof mismatch for AlphaMode\");\nstatic_assert(alignof(AlphaMode) == alignof(WGPUAlphaMode), \"alignof mismatch for AlphaMode\");\n\nenum class BackendType : uint32_t {\n    Undefined = WGPUBackendType_Undefined,\n    Null = WGPUBackendType_Null,\n    WebGPU = WGPUBackendType_WebGPU,\n    D3D11 = WGPUBackendType_D3D11,\n    D3D12 = WGPUBackendType_D3D12,\n    Metal = WGPUBackendType_Metal,\n    Vulkan = WGPUBackendType_Vulkan,\n    OpenGL = WGPUBackendType_OpenGL,\n    OpenGLES = WGPUBackendType_OpenGLES,\n};\nstatic_assert(sizeof(BackendType) == sizeof(WGPUBackendType), \"sizeof mismatch for BackendType\");\nstatic_assert(alignof(BackendType) == alignof(WGPUBackendType), \"alignof mismatch for BackendType\");\n\nenum class BlendFactor : uint32_t {\n    Undefined = WGPUBlendFactor_Undefined,\n    Zero = WGPUBlendFactor_Zero,\n    One = WGPUBlendFactor_One,\n    Src = WGPUBlendFactor_Src,\n    OneMinusSrc = WGPUBlendFactor_OneMinusSrc,\n    SrcAlpha = WGPUBlendFactor_SrcAlpha,\n    OneMinusSrcAlpha = WGPUBlendFactor_OneMinusSrcAlpha,\n    Dst = WGPUBlendFactor_Dst,\n    OneMinusDst = WGPUBlendFactor_OneMinusDst,\n    DstAlpha = WGPUBlendFactor_DstAlpha,\n    OneMinusDstAlpha = WGPUBlendFactor_OneMinusDstAlpha,\n    SrcAlphaSaturated = WGPUBlendFactor_SrcAlphaSaturated,\n    Constant = WGPUBlendFactor_Constant,\n    OneMinusConstant = WGPUBlendFactor_OneMinusConstant,\n    Src1 = WGPUBlendFactor_Src1,\n    OneMinusSrc1 = WGPUBlendFactor_OneMinusSrc1,\n    Src1Alpha = WGPUBlendFactor_Src1Alpha,\n    OneMinusSrc1Alpha = WGPUBlendFactor_OneMinusSrc1Alpha,\n};\nstatic_assert(sizeof(BlendFactor) == sizeof(WGPUBlendFactor), \"sizeof mismatch for BlendFactor\");\nstatic_assert(alignof(BlendFactor) == alignof(WGPUBlendFactor), \"alignof mismatch for BlendFactor\");\n\nenum class BlendOperation : uint32_t {\n    Undefined = WGPUBlendOperation_Undefined,\n    Add = WGPUBlendOperation_Add,\n    Subtract = WGPUBlendOperation_Subtract,\n    ReverseSubtract = WGPUBlendOperation_ReverseSubtract,\n    Min = WGPUBlendOperation_Min,\n    Max = WGPUBlendOperation_Max,\n};\nstatic_assert(sizeof(BlendOperation) == sizeof(WGPUBlendOperation), \"sizeof mismatch for BlendOperation\");\nstatic_assert(alignof(BlendOperation) == alignof(WGPUBlendOperation), \"alignof mismatch for BlendOperation\");\n\nenum class BufferBindingType : uint32_t {\n    BindingNotUsed = WGPUBufferBindingType_BindingNotUsed,\n    Uniform = WGPUBufferBindingType_Uniform,\n    Storage = WGPUBufferBindingType_Storage,\n    ReadOnlyStorage = WGPUBufferBindingType_ReadOnlyStorage,\n};\nstatic_assert(sizeof(BufferBindingType) == sizeof(WGPUBufferBindingType), \"sizeof mismatch for BufferBindingType\");\nstatic_assert(alignof(BufferBindingType) == alignof(WGPUBufferBindingType), \"alignof mismatch for BufferBindingType\");\n\nenum class BufferMapAsyncStatus : uint32_t {\n    Success = WGPUBufferMapAsyncStatus_Success,\n    InstanceDropped = WGPUBufferMapAsyncStatus_InstanceDropped,\n    ValidationError = WGPUBufferMapAsyncStatus_ValidationError,\n    Unknown = WGPUBufferMapAsyncStatus_Unknown,\n    DeviceLost = WGPUBufferMapAsyncStatus_DeviceLost,\n    DestroyedBeforeCallback = WGPUBufferMapAsyncStatus_DestroyedBeforeCallback,\n    UnmappedBeforeCallback = WGPUBufferMapAsyncStatus_UnmappedBeforeCallback,\n    MappingAlreadyPending = WGPUBufferMapAsyncStatus_MappingAlreadyPending,\n    OffsetOutOfRange = WGPUBufferMapAsyncStatus_OffsetOutOfRange,\n    SizeOutOfRange = WGPUBufferMapAsyncStatus_SizeOutOfRange,\n};\nstatic_assert(sizeof(BufferMapAsyncStatus) == sizeof(WGPUBufferMapAsyncStatus), \"sizeof mismatch for BufferMapAsyncStatus\");\nstatic_assert(alignof(BufferMapAsyncStatus) == alignof(WGPUBufferMapAsyncStatus), \"alignof mismatch for BufferMapAsyncStatus\");\n\nenum class BufferMapState : uint32_t {\n    Unmapped = WGPUBufferMapState_Unmapped,\n    Pending = WGPUBufferMapState_Pending,\n    Mapped = WGPUBufferMapState_Mapped,\n};\nstatic_assert(sizeof(BufferMapState) == sizeof(WGPUBufferMapState), \"sizeof mismatch for BufferMapState\");\nstatic_assert(alignof(BufferMapState) == alignof(WGPUBufferMapState), \"alignof mismatch for BufferMapState\");\n\nenum class CallbackMode : uint32_t {\n    WaitAnyOnly = WGPUCallbackMode_WaitAnyOnly,\n    AllowProcessEvents = WGPUCallbackMode_AllowProcessEvents,\n    AllowSpontaneous = WGPUCallbackMode_AllowSpontaneous,\n};\nstatic_assert(sizeof(CallbackMode) == sizeof(WGPUCallbackMode), \"sizeof mismatch for CallbackMode\");\nstatic_assert(alignof(CallbackMode) == alignof(WGPUCallbackMode), \"alignof mismatch for CallbackMode\");\n\nenum class CompareFunction : uint32_t {\n    Undefined = WGPUCompareFunction_Undefined,\n    Never = WGPUCompareFunction_Never,\n    Less = WGPUCompareFunction_Less,\n    Equal = WGPUCompareFunction_Equal,\n    LessEqual = WGPUCompareFunction_LessEqual,\n    Greater = WGPUCompareFunction_Greater,\n    NotEqual = WGPUCompareFunction_NotEqual,\n    GreaterEqual = WGPUCompareFunction_GreaterEqual,\n    Always = WGPUCompareFunction_Always,\n};\nstatic_assert(sizeof(CompareFunction) == sizeof(WGPUCompareFunction), \"sizeof mismatch for CompareFunction\");\nstatic_assert(alignof(CompareFunction) == alignof(WGPUCompareFunction), \"alignof mismatch for CompareFunction\");\n\nenum class CompilationInfoRequestStatus : uint32_t {\n    Success = WGPUCompilationInfoRequestStatus_Success,\n    InstanceDropped = WGPUCompilationInfoRequestStatus_InstanceDropped,\n    Error = WGPUCompilationInfoRequestStatus_Error,\n    DeviceLost = WGPUCompilationInfoRequestStatus_DeviceLost,\n    Unknown = WGPUCompilationInfoRequestStatus_Unknown,\n};\nstatic_assert(sizeof(CompilationInfoRequestStatus) == sizeof(WGPUCompilationInfoRequestStatus), \"sizeof mismatch for CompilationInfoRequestStatus\");\nstatic_assert(alignof(CompilationInfoRequestStatus) == alignof(WGPUCompilationInfoRequestStatus), \"alignof mismatch for CompilationInfoRequestStatus\");\n\nenum class CompilationMessageType : uint32_t {\n    Error = WGPUCompilationMessageType_Error,\n    Warning = WGPUCompilationMessageType_Warning,\n    Info = WGPUCompilationMessageType_Info,\n};\nstatic_assert(sizeof(CompilationMessageType) == sizeof(WGPUCompilationMessageType), \"sizeof mismatch for CompilationMessageType\");\nstatic_assert(alignof(CompilationMessageType) == alignof(WGPUCompilationMessageType), \"alignof mismatch for CompilationMessageType\");\n\nenum class CompositeAlphaMode : uint32_t {\n    Auto = WGPUCompositeAlphaMode_Auto,\n    Opaque = WGPUCompositeAlphaMode_Opaque,\n    Premultiplied = WGPUCompositeAlphaMode_Premultiplied,\n    Unpremultiplied = WGPUCompositeAlphaMode_Unpremultiplied,\n    Inherit = WGPUCompositeAlphaMode_Inherit,\n};\nstatic_assert(sizeof(CompositeAlphaMode) == sizeof(WGPUCompositeAlphaMode), \"sizeof mismatch for CompositeAlphaMode\");\nstatic_assert(alignof(CompositeAlphaMode) == alignof(WGPUCompositeAlphaMode), \"alignof mismatch for CompositeAlphaMode\");\n\nenum class CreatePipelineAsyncStatus : uint32_t {\n    Success = WGPUCreatePipelineAsyncStatus_Success,\n    InstanceDropped = WGPUCreatePipelineAsyncStatus_InstanceDropped,\n    ValidationError = WGPUCreatePipelineAsyncStatus_ValidationError,\n    InternalError = WGPUCreatePipelineAsyncStatus_InternalError,\n    DeviceLost = WGPUCreatePipelineAsyncStatus_DeviceLost,\n    DeviceDestroyed = WGPUCreatePipelineAsyncStatus_DeviceDestroyed,\n    Unknown = WGPUCreatePipelineAsyncStatus_Unknown,\n};\nstatic_assert(sizeof(CreatePipelineAsyncStatus) == sizeof(WGPUCreatePipelineAsyncStatus), \"sizeof mismatch for CreatePipelineAsyncStatus\");\nstatic_assert(alignof(CreatePipelineAsyncStatus) == alignof(WGPUCreatePipelineAsyncStatus), \"alignof mismatch for CreatePipelineAsyncStatus\");\n\nenum class CullMode : uint32_t {\n    Undefined = WGPUCullMode_Undefined,\n    None = WGPUCullMode_None,\n    Front = WGPUCullMode_Front,\n    Back = WGPUCullMode_Back,\n};\nstatic_assert(sizeof(CullMode) == sizeof(WGPUCullMode), \"sizeof mismatch for CullMode\");\nstatic_assert(alignof(CullMode) == alignof(WGPUCullMode), \"alignof mismatch for CullMode\");\n\nenum class DeviceLostReason : uint32_t {\n    Unknown = WGPUDeviceLostReason_Unknown,\n    Destroyed = WGPUDeviceLostReason_Destroyed,\n    InstanceDropped = WGPUDeviceLostReason_InstanceDropped,\n    FailedCreation = WGPUDeviceLostReason_FailedCreation,\n};\nstatic_assert(sizeof(DeviceLostReason) == sizeof(WGPUDeviceLostReason), \"sizeof mismatch for DeviceLostReason\");\nstatic_assert(alignof(DeviceLostReason) == alignof(WGPUDeviceLostReason), \"alignof mismatch for DeviceLostReason\");\n\nenum class ErrorFilter : uint32_t {\n    Validation = WGPUErrorFilter_Validation,\n    OutOfMemory = WGPUErrorFilter_OutOfMemory,\n    Internal = WGPUErrorFilter_Internal,\n};\nstatic_assert(sizeof(ErrorFilter) == sizeof(WGPUErrorFilter), \"sizeof mismatch for ErrorFilter\");\nstatic_assert(alignof(ErrorFilter) == alignof(WGPUErrorFilter), \"alignof mismatch for ErrorFilter\");\n\nenum class ErrorType : uint32_t {\n    NoError = WGPUErrorType_NoError,\n    Validation = WGPUErrorType_Validation,\n    OutOfMemory = WGPUErrorType_OutOfMemory,\n    Internal = WGPUErrorType_Internal,\n    Unknown = WGPUErrorType_Unknown,\n    DeviceLost = WGPUErrorType_DeviceLost,\n};\nstatic_assert(sizeof(ErrorType) == sizeof(WGPUErrorType), \"sizeof mismatch for ErrorType\");\nstatic_assert(alignof(ErrorType) == alignof(WGPUErrorType), \"alignof mismatch for ErrorType\");\n\nenum class ExternalTextureRotation : uint32_t {\n    Rotate0Degrees = WGPUExternalTextureRotation_Rotate0Degrees,\n    Rotate90Degrees = WGPUExternalTextureRotation_Rotate90Degrees,\n    Rotate180Degrees = WGPUExternalTextureRotation_Rotate180Degrees,\n    Rotate270Degrees = WGPUExternalTextureRotation_Rotate270Degrees,\n};\nstatic_assert(sizeof(ExternalTextureRotation) == sizeof(WGPUExternalTextureRotation), \"sizeof mismatch for ExternalTextureRotation\");\nstatic_assert(alignof(ExternalTextureRotation) == alignof(WGPUExternalTextureRotation), \"alignof mismatch for ExternalTextureRotation\");\n\nenum class FeatureName : uint32_t {\n    DepthClipControl = WGPUFeatureName_DepthClipControl,\n    Depth32FloatStencil8 = WGPUFeatureName_Depth32FloatStencil8,\n    TimestampQuery = WGPUFeatureName_TimestampQuery,\n    TextureCompressionBC = WGPUFeatureName_TextureCompressionBC,\n    TextureCompressionETC2 = WGPUFeatureName_TextureCompressionETC2,\n    TextureCompressionASTC = WGPUFeatureName_TextureCompressionASTC,\n    IndirectFirstInstance = WGPUFeatureName_IndirectFirstInstance,\n    ShaderF16 = WGPUFeatureName_ShaderF16,\n    RG11B10UfloatRenderable = WGPUFeatureName_RG11B10UfloatRenderable,\n    BGRA8UnormStorage = WGPUFeatureName_BGRA8UnormStorage,\n    Float32Filterable = WGPUFeatureName_Float32Filterable,\n    Float32Blendable = WGPUFeatureName_Float32Blendable,\n    Subgroups = WGPUFeatureName_Subgroups,\n    SubgroupsF16 = WGPUFeatureName_SubgroupsF16,\n    DawnInternalUsages = WGPUFeatureName_DawnInternalUsages,\n    DawnMultiPlanarFormats = WGPUFeatureName_DawnMultiPlanarFormats,\n    DawnNative = WGPUFeatureName_DawnNative,\n    ChromiumExperimentalTimestampQueryInsidePasses = WGPUFeatureName_ChromiumExperimentalTimestampQueryInsidePasses,\n    ImplicitDeviceSynchronization = WGPUFeatureName_ImplicitDeviceSynchronization,\n    ChromiumExperimentalImmediateData = WGPUFeatureName_ChromiumExperimentalImmediateData,\n    TransientAttachments = WGPUFeatureName_TransientAttachments,\n    MSAARenderToSingleSampled = WGPUFeatureName_MSAARenderToSingleSampled,\n    DualSourceBlending = WGPUFeatureName_DualSourceBlending,\n    D3D11MultithreadProtected = WGPUFeatureName_D3D11MultithreadProtected,\n    ANGLETextureSharing = WGPUFeatureName_ANGLETextureSharing,\n    PixelLocalStorageCoherent = WGPUFeatureName_PixelLocalStorageCoherent,\n    PixelLocalStorageNonCoherent = WGPUFeatureName_PixelLocalStorageNonCoherent,\n    Unorm16TextureFormats = WGPUFeatureName_Unorm16TextureFormats,\n    Snorm16TextureFormats = WGPUFeatureName_Snorm16TextureFormats,\n    MultiPlanarFormatExtendedUsages = WGPUFeatureName_MultiPlanarFormatExtendedUsages,\n    MultiPlanarFormatP010 = WGPUFeatureName_MultiPlanarFormatP010,\n    HostMappedPointer = WGPUFeatureName_HostMappedPointer,\n    MultiPlanarRenderTargets = WGPUFeatureName_MultiPlanarRenderTargets,\n    MultiPlanarFormatNv12a = WGPUFeatureName_MultiPlanarFormatNv12a,\n    FramebufferFetch = WGPUFeatureName_FramebufferFetch,\n    BufferMapExtendedUsages = WGPUFeatureName_BufferMapExtendedUsages,\n    AdapterPropertiesMemoryHeaps = WGPUFeatureName_AdapterPropertiesMemoryHeaps,\n    AdapterPropertiesD3D = WGPUFeatureName_AdapterPropertiesD3D,\n    AdapterPropertiesVk = WGPUFeatureName_AdapterPropertiesVk,\n    R8UnormStorage = WGPUFeatureName_R8UnormStorage,\n    FormatCapabilities = WGPUFeatureName_FormatCapabilities,\n    DrmFormatCapabilities = WGPUFeatureName_DrmFormatCapabilities,\n    Norm16TextureFormats = WGPUFeatureName_Norm16TextureFormats,\n    MultiPlanarFormatNv16 = WGPUFeatureName_MultiPlanarFormatNv16,\n    MultiPlanarFormatNv24 = WGPUFeatureName_MultiPlanarFormatNv24,\n    MultiPlanarFormatP210 = WGPUFeatureName_MultiPlanarFormatP210,\n    MultiPlanarFormatP410 = WGPUFeatureName_MultiPlanarFormatP410,\n    SharedTextureMemoryVkDedicatedAllocation = WGPUFeatureName_SharedTextureMemoryVkDedicatedAllocation,\n    SharedTextureMemoryAHardwareBuffer = WGPUFeatureName_SharedTextureMemoryAHardwareBuffer,\n    SharedTextureMemoryDmaBuf = WGPUFeatureName_SharedTextureMemoryDmaBuf,\n    SharedTextureMemoryOpaqueFD = WGPUFeatureName_SharedTextureMemoryOpaqueFD,\n    SharedTextureMemoryZirconHandle = WGPUFeatureName_SharedTextureMemoryZirconHandle,\n    SharedTextureMemoryDXGISharedHandle = WGPUFeatureName_SharedTextureMemoryDXGISharedHandle,\n    SharedTextureMemoryD3D11Texture2D = WGPUFeatureName_SharedTextureMemoryD3D11Texture2D,\n    SharedTextureMemoryIOSurface = WGPUFeatureName_SharedTextureMemoryIOSurface,\n    SharedTextureMemoryEGLImage = WGPUFeatureName_SharedTextureMemoryEGLImage,\n    SharedFenceVkSemaphoreOpaqueFD = WGPUFeatureName_SharedFenceVkSemaphoreOpaqueFD,\n    SharedFenceSyncFD = WGPUFeatureName_SharedFenceSyncFD,\n    SharedFenceVkSemaphoreZirconHandle = WGPUFeatureName_SharedFenceVkSemaphoreZirconHandle,\n    SharedFenceDXGISharedHandle = WGPUFeatureName_SharedFenceDXGISharedHandle,\n    SharedFenceMTLSharedEvent = WGPUFeatureName_SharedFenceMTLSharedEvent,\n    SharedBufferMemoryD3D12Resource = WGPUFeatureName_SharedBufferMemoryD3D12Resource,\n    StaticSamplers = WGPUFeatureName_StaticSamplers,\n    YCbCrVulkanSamplers = WGPUFeatureName_YCbCrVulkanSamplers,\n    ShaderModuleCompilationOptions = WGPUFeatureName_ShaderModuleCompilationOptions,\n    DawnLoadResolveTexture = WGPUFeatureName_DawnLoadResolveTexture,\n    DawnPartialLoadResolveTexture = WGPUFeatureName_DawnPartialLoadResolveTexture,\n    MultiDrawIndirect = WGPUFeatureName_MultiDrawIndirect,\n    ClipDistances = WGPUFeatureName_ClipDistances,\n    DawnTexelCopyBufferRowAlignment = WGPUFeatureName_DawnTexelCopyBufferRowAlignment,\n};\nstatic_assert(sizeof(FeatureName) == sizeof(WGPUFeatureName), \"sizeof mismatch for FeatureName\");\nstatic_assert(alignof(FeatureName) == alignof(WGPUFeatureName), \"alignof mismatch for FeatureName\");\n\nenum class FilterMode : uint32_t {\n    Undefined = WGPUFilterMode_Undefined,\n    Nearest = WGPUFilterMode_Nearest,\n    Linear = WGPUFilterMode_Linear,\n};\nstatic_assert(sizeof(FilterMode) == sizeof(WGPUFilterMode), \"sizeof mismatch for FilterMode\");\nstatic_assert(alignof(FilterMode) == alignof(WGPUFilterMode), \"alignof mismatch for FilterMode\");\n\nenum class FrontFace : uint32_t {\n    Undefined = WGPUFrontFace_Undefined,\n    CCW = WGPUFrontFace_CCW,\n    CW = WGPUFrontFace_CW,\n};\nstatic_assert(sizeof(FrontFace) == sizeof(WGPUFrontFace), \"sizeof mismatch for FrontFace\");\nstatic_assert(alignof(FrontFace) == alignof(WGPUFrontFace), \"alignof mismatch for FrontFace\");\n\nenum class IndexFormat : uint32_t {\n    Undefined = WGPUIndexFormat_Undefined,\n    Uint16 = WGPUIndexFormat_Uint16,\n    Uint32 = WGPUIndexFormat_Uint32,\n};\nstatic_assert(sizeof(IndexFormat) == sizeof(WGPUIndexFormat), \"sizeof mismatch for IndexFormat\");\nstatic_assert(alignof(IndexFormat) == alignof(WGPUIndexFormat), \"alignof mismatch for IndexFormat\");\n\nenum class LoadOp : uint32_t {\n    Undefined = WGPULoadOp_Undefined,\n    Load = WGPULoadOp_Load,\n    Clear = WGPULoadOp_Clear,\n    ExpandResolveTexture = WGPULoadOp_ExpandResolveTexture,\n};\nstatic_assert(sizeof(LoadOp) == sizeof(WGPULoadOp), \"sizeof mismatch for LoadOp\");\nstatic_assert(alignof(LoadOp) == alignof(WGPULoadOp), \"alignof mismatch for LoadOp\");\n\nenum class LoggingType : uint32_t {\n    Verbose = WGPULoggingType_Verbose,\n    Info = WGPULoggingType_Info,\n    Warning = WGPULoggingType_Warning,\n    Error = WGPULoggingType_Error,\n};\nstatic_assert(sizeof(LoggingType) == sizeof(WGPULoggingType), \"sizeof mismatch for LoggingType\");\nstatic_assert(alignof(LoggingType) == alignof(WGPULoggingType), \"alignof mismatch for LoggingType\");\n\nenum class MapAsyncStatus : uint32_t {\n    Success = WGPUMapAsyncStatus_Success,\n    InstanceDropped = WGPUMapAsyncStatus_InstanceDropped,\n    Error = WGPUMapAsyncStatus_Error,\n    Aborted = WGPUMapAsyncStatus_Aborted,\n    Unknown = WGPUMapAsyncStatus_Unknown,\n};\nstatic_assert(sizeof(MapAsyncStatus) == sizeof(WGPUMapAsyncStatus), \"sizeof mismatch for MapAsyncStatus\");\nstatic_assert(alignof(MapAsyncStatus) == alignof(WGPUMapAsyncStatus), \"alignof mismatch for MapAsyncStatus\");\n\nenum class MipmapFilterMode : uint32_t {\n    Undefined = WGPUMipmapFilterMode_Undefined,\n    Nearest = WGPUMipmapFilterMode_Nearest,\n    Linear = WGPUMipmapFilterMode_Linear,\n};\nstatic_assert(sizeof(MipmapFilterMode) == sizeof(WGPUMipmapFilterMode), \"sizeof mismatch for MipmapFilterMode\");\nstatic_assert(alignof(MipmapFilterMode) == alignof(WGPUMipmapFilterMode), \"alignof mismatch for MipmapFilterMode\");\n\nenum class PopErrorScopeStatus : uint32_t {\n    Success = WGPUPopErrorScopeStatus_Success,\n    InstanceDropped = WGPUPopErrorScopeStatus_InstanceDropped,\n};\nstatic_assert(sizeof(PopErrorScopeStatus) == sizeof(WGPUPopErrorScopeStatus), \"sizeof mismatch for PopErrorScopeStatus\");\nstatic_assert(alignof(PopErrorScopeStatus) == alignof(WGPUPopErrorScopeStatus), \"alignof mismatch for PopErrorScopeStatus\");\n\nenum class PowerPreference : uint32_t {\n    Undefined = WGPUPowerPreference_Undefined,\n    LowPower = WGPUPowerPreference_LowPower,\n    HighPerformance = WGPUPowerPreference_HighPerformance,\n};\nstatic_assert(sizeof(PowerPreference) == sizeof(WGPUPowerPreference), \"sizeof mismatch for PowerPreference\");\nstatic_assert(alignof(PowerPreference) == alignof(WGPUPowerPreference), \"alignof mismatch for PowerPreference\");\n\nenum class PresentMode : uint32_t {\n    Fifo = WGPUPresentMode_Fifo,\n    FifoRelaxed = WGPUPresentMode_FifoRelaxed,\n    Immediate = WGPUPresentMode_Immediate,\n    Mailbox = WGPUPresentMode_Mailbox,\n};\nstatic_assert(sizeof(PresentMode) == sizeof(WGPUPresentMode), \"sizeof mismatch for PresentMode\");\nstatic_assert(alignof(PresentMode) == alignof(WGPUPresentMode), \"alignof mismatch for PresentMode\");\n\nenum class PrimitiveTopology : uint32_t {\n    Undefined = WGPUPrimitiveTopology_Undefined,\n    PointList = WGPUPrimitiveTopology_PointList,\n    LineList = WGPUPrimitiveTopology_LineList,\n    LineStrip = WGPUPrimitiveTopology_LineStrip,\n    TriangleList = WGPUPrimitiveTopology_TriangleList,\n    TriangleStrip = WGPUPrimitiveTopology_TriangleStrip,\n};\nstatic_assert(sizeof(PrimitiveTopology) == sizeof(WGPUPrimitiveTopology), \"sizeof mismatch for PrimitiveTopology\");\nstatic_assert(alignof(PrimitiveTopology) == alignof(WGPUPrimitiveTopology), \"alignof mismatch for PrimitiveTopology\");\n\nenum class QueryType : uint32_t {\n    Occlusion = WGPUQueryType_Occlusion,\n    Timestamp = WGPUQueryType_Timestamp,\n};\nstatic_assert(sizeof(QueryType) == sizeof(WGPUQueryType), \"sizeof mismatch for QueryType\");\nstatic_assert(alignof(QueryType) == alignof(WGPUQueryType), \"alignof mismatch for QueryType\");\n\nenum class QueueWorkDoneStatus : uint32_t {\n    Success = WGPUQueueWorkDoneStatus_Success,\n    InstanceDropped = WGPUQueueWorkDoneStatus_InstanceDropped,\n    Error = WGPUQueueWorkDoneStatus_Error,\n    Unknown = WGPUQueueWorkDoneStatus_Unknown,\n    DeviceLost = WGPUQueueWorkDoneStatus_DeviceLost,\n};\nstatic_assert(sizeof(QueueWorkDoneStatus) == sizeof(WGPUQueueWorkDoneStatus), \"sizeof mismatch for QueueWorkDoneStatus\");\nstatic_assert(alignof(QueueWorkDoneStatus) == alignof(WGPUQueueWorkDoneStatus), \"alignof mismatch for QueueWorkDoneStatus\");\n\nenum class RequestAdapterStatus : uint32_t {\n    Success = WGPURequestAdapterStatus_Success,\n    InstanceDropped = WGPURequestAdapterStatus_InstanceDropped,\n    Unavailable = WGPURequestAdapterStatus_Unavailable,\n    Error = WGPURequestAdapterStatus_Error,\n    Unknown = WGPURequestAdapterStatus_Unknown,\n};\nstatic_assert(sizeof(RequestAdapterStatus) == sizeof(WGPURequestAdapterStatus), \"sizeof mismatch for RequestAdapterStatus\");\nstatic_assert(alignof(RequestAdapterStatus) == alignof(WGPURequestAdapterStatus), \"alignof mismatch for RequestAdapterStatus\");\n\nenum class RequestDeviceStatus : uint32_t {\n    Success = WGPURequestDeviceStatus_Success,\n    InstanceDropped = WGPURequestDeviceStatus_InstanceDropped,\n    Error = WGPURequestDeviceStatus_Error,\n    Unknown = WGPURequestDeviceStatus_Unknown,\n};\nstatic_assert(sizeof(RequestDeviceStatus) == sizeof(WGPURequestDeviceStatus), \"sizeof mismatch for RequestDeviceStatus\");\nstatic_assert(alignof(RequestDeviceStatus) == alignof(WGPURequestDeviceStatus), \"alignof mismatch for RequestDeviceStatus\");\n\nenum class SType : uint32_t {\n    ShaderSourceSPIRV = WGPUSType_ShaderSourceSPIRV,\n    ShaderSourceWGSL = WGPUSType_ShaderSourceWGSL,\n    RenderPassMaxDrawCount = WGPUSType_RenderPassMaxDrawCount,\n    SurfaceSourceMetalLayer = WGPUSType_SurfaceSourceMetalLayer,\n    SurfaceSourceWindowsHWND = WGPUSType_SurfaceSourceWindowsHWND,\n    SurfaceSourceXlibWindow = WGPUSType_SurfaceSourceXlibWindow,\n    SurfaceSourceWaylandSurface = WGPUSType_SurfaceSourceWaylandSurface,\n    SurfaceSourceAndroidNativeWindow = WGPUSType_SurfaceSourceAndroidNativeWindow,\n    SurfaceSourceXCBWindow = WGPUSType_SurfaceSourceXCBWindow,\n    AdapterPropertiesSubgroups = WGPUSType_AdapterPropertiesSubgroups,\n    TextureBindingViewDimensionDescriptor = WGPUSType_TextureBindingViewDimensionDescriptor,\n    SurfaceDescriptorFromWindowsCoreWindow = WGPUSType_SurfaceDescriptorFromWindowsCoreWindow,\n    ExternalTextureBindingEntry = WGPUSType_ExternalTextureBindingEntry,\n    ExternalTextureBindingLayout = WGPUSType_ExternalTextureBindingLayout,\n    SurfaceDescriptorFromWindowsSwapChainPanel = WGPUSType_SurfaceDescriptorFromWindowsSwapChainPanel,\n    DawnTextureInternalUsageDescriptor = WGPUSType_DawnTextureInternalUsageDescriptor,\n    DawnEncoderInternalUsageDescriptor = WGPUSType_DawnEncoderInternalUsageDescriptor,\n    DawnInstanceDescriptor = WGPUSType_DawnInstanceDescriptor,\n    DawnCacheDeviceDescriptor = WGPUSType_DawnCacheDeviceDescriptor,\n    DawnAdapterPropertiesPowerPreference = WGPUSType_DawnAdapterPropertiesPowerPreference,\n    DawnBufferDescriptorErrorInfoFromWireClient = WGPUSType_DawnBufferDescriptorErrorInfoFromWireClient,\n    DawnTogglesDescriptor = WGPUSType_DawnTogglesDescriptor,\n    DawnShaderModuleSPIRVOptionsDescriptor = WGPUSType_DawnShaderModuleSPIRVOptionsDescriptor,\n    RequestAdapterOptionsLUID = WGPUSType_RequestAdapterOptionsLUID,\n    RequestAdapterOptionsGetGLProc = WGPUSType_RequestAdapterOptionsGetGLProc,\n    RequestAdapterOptionsD3D11Device = WGPUSType_RequestAdapterOptionsD3D11Device,\n    DawnRenderPassColorAttachmentRenderToSingleSampled = WGPUSType_DawnRenderPassColorAttachmentRenderToSingleSampled,\n    RenderPassPixelLocalStorage = WGPUSType_RenderPassPixelLocalStorage,\n    PipelineLayoutPixelLocalStorage = WGPUSType_PipelineLayoutPixelLocalStorage,\n    BufferHostMappedPointer = WGPUSType_BufferHostMappedPointer,\n    DawnExperimentalSubgroupLimits = WGPUSType_DawnExperimentalSubgroupLimits,\n    AdapterPropertiesMemoryHeaps = WGPUSType_AdapterPropertiesMemoryHeaps,\n    AdapterPropertiesD3D = WGPUSType_AdapterPropertiesD3D,\n    AdapterPropertiesVk = WGPUSType_AdapterPropertiesVk,\n    DawnWireWGSLControl = WGPUSType_DawnWireWGSLControl,\n    DawnWGSLBlocklist = WGPUSType_DawnWGSLBlocklist,\n    DrmFormatCapabilities = WGPUSType_DrmFormatCapabilities,\n    ShaderModuleCompilationOptions = WGPUSType_ShaderModuleCompilationOptions,\n    ColorTargetStateExpandResolveTextureDawn = WGPUSType_ColorTargetStateExpandResolveTextureDawn,\n    RenderPassDescriptorExpandResolveRect = WGPUSType_RenderPassDescriptorExpandResolveRect,\n    SharedTextureMemoryVkDedicatedAllocationDescriptor = WGPUSType_SharedTextureMemoryVkDedicatedAllocationDescriptor,\n    SharedTextureMemoryAHardwareBufferDescriptor = WGPUSType_SharedTextureMemoryAHardwareBufferDescriptor,\n    SharedTextureMemoryDmaBufDescriptor = WGPUSType_SharedTextureMemoryDmaBufDescriptor,\n    SharedTextureMemoryOpaqueFDDescriptor = WGPUSType_SharedTextureMemoryOpaqueFDDescriptor,\n    SharedTextureMemoryZirconHandleDescriptor = WGPUSType_SharedTextureMemoryZirconHandleDescriptor,\n    SharedTextureMemoryDXGISharedHandleDescriptor = WGPUSType_SharedTextureMemoryDXGISharedHandleDescriptor,\n    SharedTextureMemoryD3D11Texture2DDescriptor = WGPUSType_SharedTextureMemoryD3D11Texture2DDescriptor,\n    SharedTextureMemoryIOSurfaceDescriptor = WGPUSType_SharedTextureMemoryIOSurfaceDescriptor,\n    SharedTextureMemoryEGLImageDescriptor = WGPUSType_SharedTextureMemoryEGLImageDescriptor,\n    SharedTextureMemoryInitializedBeginState = WGPUSType_SharedTextureMemoryInitializedBeginState,\n    SharedTextureMemoryInitializedEndState = WGPUSType_SharedTextureMemoryInitializedEndState,\n    SharedTextureMemoryVkImageLayoutBeginState = WGPUSType_SharedTextureMemoryVkImageLayoutBeginState,\n    SharedTextureMemoryVkImageLayoutEndState = WGPUSType_SharedTextureMemoryVkImageLayoutEndState,\n    SharedTextureMemoryD3DSwapchainBeginState = WGPUSType_SharedTextureMemoryD3DSwapchainBeginState,\n    SharedFenceVkSemaphoreOpaqueFDDescriptor = WGPUSType_SharedFenceVkSemaphoreOpaqueFDDescriptor,\n    SharedFenceVkSemaphoreOpaqueFDExportInfo = WGPUSType_SharedFenceVkSemaphoreOpaqueFDExportInfo,\n    SharedFenceSyncFDDescriptor = WGPUSType_SharedFenceSyncFDDescriptor,\n    SharedFenceSyncFDExportInfo = WGPUSType_SharedFenceSyncFDExportInfo,\n    SharedFenceVkSemaphoreZirconHandleDescriptor = WGPUSType_SharedFenceVkSemaphoreZirconHandleDescriptor,\n    SharedFenceVkSemaphoreZirconHandleExportInfo = WGPUSType_SharedFenceVkSemaphoreZirconHandleExportInfo,\n    SharedFenceDXGISharedHandleDescriptor = WGPUSType_SharedFenceDXGISharedHandleDescriptor,\n    SharedFenceDXGISharedHandleExportInfo = WGPUSType_SharedFenceDXGISharedHandleExportInfo,\n    SharedFenceMTLSharedEventDescriptor = WGPUSType_SharedFenceMTLSharedEventDescriptor,\n    SharedFenceMTLSharedEventExportInfo = WGPUSType_SharedFenceMTLSharedEventExportInfo,\n    SharedBufferMemoryD3D12ResourceDescriptor = WGPUSType_SharedBufferMemoryD3D12ResourceDescriptor,\n    StaticSamplerBindingLayout = WGPUSType_StaticSamplerBindingLayout,\n    YCbCrVkDescriptor = WGPUSType_YCbCrVkDescriptor,\n    SharedTextureMemoryAHardwareBufferProperties = WGPUSType_SharedTextureMemoryAHardwareBufferProperties,\n    AHardwareBufferProperties = WGPUSType_AHardwareBufferProperties,\n    DawnExperimentalImmediateDataLimits = WGPUSType_DawnExperimentalImmediateDataLimits,\n    DawnTexelCopyBufferRowAlignmentLimits = WGPUSType_DawnTexelCopyBufferRowAlignmentLimits,\n};\nstatic_assert(sizeof(SType) == sizeof(WGPUSType), \"sizeof mismatch for SType\");\nstatic_assert(alignof(SType) == alignof(WGPUSType), \"alignof mismatch for SType\");\n\nenum class SamplerBindingType : uint32_t {\n    BindingNotUsed = WGPUSamplerBindingType_BindingNotUsed,\n    Filtering = WGPUSamplerBindingType_Filtering,\n    NonFiltering = WGPUSamplerBindingType_NonFiltering,\n    Comparison = WGPUSamplerBindingType_Comparison,\n};\nstatic_assert(sizeof(SamplerBindingType) == sizeof(WGPUSamplerBindingType), \"sizeof mismatch for SamplerBindingType\");\nstatic_assert(alignof(SamplerBindingType) == alignof(WGPUSamplerBindingType), \"alignof mismatch for SamplerBindingType\");\n\nenum class SharedFenceType : uint32_t {\n    VkSemaphoreOpaqueFD = WGPUSharedFenceType_VkSemaphoreOpaqueFD,\n    SyncFD = WGPUSharedFenceType_SyncFD,\n    VkSemaphoreZirconHandle = WGPUSharedFenceType_VkSemaphoreZirconHandle,\n    DXGISharedHandle = WGPUSharedFenceType_DXGISharedHandle,\n    MTLSharedEvent = WGPUSharedFenceType_MTLSharedEvent,\n};\nstatic_assert(sizeof(SharedFenceType) == sizeof(WGPUSharedFenceType), \"sizeof mismatch for SharedFenceType\");\nstatic_assert(alignof(SharedFenceType) == alignof(WGPUSharedFenceType), \"alignof mismatch for SharedFenceType\");\n\nenum class Status : uint32_t {\n    Success = WGPUStatus_Success,\n    Error = WGPUStatus_Error,\n};\nstatic_assert(sizeof(Status) == sizeof(WGPUStatus), \"sizeof mismatch for Status\");\nstatic_assert(alignof(Status) == alignof(WGPUStatus), \"alignof mismatch for Status\");\n\nenum class StencilOperation : uint32_t {\n    Undefined = WGPUStencilOperation_Undefined,\n    Keep = WGPUStencilOperation_Keep,\n    Zero = WGPUStencilOperation_Zero,\n    Replace = WGPUStencilOperation_Replace,\n    Invert = WGPUStencilOperation_Invert,\n    IncrementClamp = WGPUStencilOperation_IncrementClamp,\n    DecrementClamp = WGPUStencilOperation_DecrementClamp,\n    IncrementWrap = WGPUStencilOperation_IncrementWrap,\n    DecrementWrap = WGPUStencilOperation_DecrementWrap,\n};\nstatic_assert(sizeof(StencilOperation) == sizeof(WGPUStencilOperation), \"sizeof mismatch for StencilOperation\");\nstatic_assert(alignof(StencilOperation) == alignof(WGPUStencilOperation), \"alignof mismatch for StencilOperation\");\n\nenum class StorageTextureAccess : uint32_t {\n    BindingNotUsed = WGPUStorageTextureAccess_BindingNotUsed,\n    WriteOnly = WGPUStorageTextureAccess_WriteOnly,\n    ReadOnly = WGPUStorageTextureAccess_ReadOnly,\n    ReadWrite = WGPUStorageTextureAccess_ReadWrite,\n};\nstatic_assert(sizeof(StorageTextureAccess) == sizeof(WGPUStorageTextureAccess), \"sizeof mismatch for StorageTextureAccess\");\nstatic_assert(alignof(StorageTextureAccess) == alignof(WGPUStorageTextureAccess), \"alignof mismatch for StorageTextureAccess\");\n\nenum class StoreOp : uint32_t {\n    Undefined = WGPUStoreOp_Undefined,\n    Store = WGPUStoreOp_Store,\n    Discard = WGPUStoreOp_Discard,\n};\nstatic_assert(sizeof(StoreOp) == sizeof(WGPUStoreOp), \"sizeof mismatch for StoreOp\");\nstatic_assert(alignof(StoreOp) == alignof(WGPUStoreOp), \"alignof mismatch for StoreOp\");\n\nenum class SurfaceGetCurrentTextureStatus : uint32_t {\n    Success = WGPUSurfaceGetCurrentTextureStatus_Success,\n    Timeout = WGPUSurfaceGetCurrentTextureStatus_Timeout,\n    Outdated = WGPUSurfaceGetCurrentTextureStatus_Outdated,\n    Lost = WGPUSurfaceGetCurrentTextureStatus_Lost,\n    OutOfMemory = WGPUSurfaceGetCurrentTextureStatus_OutOfMemory,\n    DeviceLost = WGPUSurfaceGetCurrentTextureStatus_DeviceLost,\n    Error = WGPUSurfaceGetCurrentTextureStatus_Error,\n};\nstatic_assert(sizeof(SurfaceGetCurrentTextureStatus) == sizeof(WGPUSurfaceGetCurrentTextureStatus), \"sizeof mismatch for SurfaceGetCurrentTextureStatus\");\nstatic_assert(alignof(SurfaceGetCurrentTextureStatus) == alignof(WGPUSurfaceGetCurrentTextureStatus), \"alignof mismatch for SurfaceGetCurrentTextureStatus\");\n\nenum class TextureAspect : uint32_t {\n    Undefined = WGPUTextureAspect_Undefined,\n    All = WGPUTextureAspect_All,\n    StencilOnly = WGPUTextureAspect_StencilOnly,\n    DepthOnly = WGPUTextureAspect_DepthOnly,\n    Plane0Only = WGPUTextureAspect_Plane0Only,\n    Plane1Only = WGPUTextureAspect_Plane1Only,\n    Plane2Only = WGPUTextureAspect_Plane2Only,\n};\nstatic_assert(sizeof(TextureAspect) == sizeof(WGPUTextureAspect), \"sizeof mismatch for TextureAspect\");\nstatic_assert(alignof(TextureAspect) == alignof(WGPUTextureAspect), \"alignof mismatch for TextureAspect\");\n\nenum class TextureDimension : uint32_t {\n    Undefined = WGPUTextureDimension_Undefined,\n    e1D = WGPUTextureDimension_1D,\n    e2D = WGPUTextureDimension_2D,\n    e3D = WGPUTextureDimension_3D,\n};\nstatic_assert(sizeof(TextureDimension) == sizeof(WGPUTextureDimension), \"sizeof mismatch for TextureDimension\");\nstatic_assert(alignof(TextureDimension) == alignof(WGPUTextureDimension), \"alignof mismatch for TextureDimension\");\n\nenum class TextureFormat : uint32_t {\n    Undefined = WGPUTextureFormat_Undefined,\n    R8Unorm = WGPUTextureFormat_R8Unorm,\n    R8Snorm = WGPUTextureFormat_R8Snorm,\n    R8Uint = WGPUTextureFormat_R8Uint,\n    R8Sint = WGPUTextureFormat_R8Sint,\n    R16Uint = WGPUTextureFormat_R16Uint,\n    R16Sint = WGPUTextureFormat_R16Sint,\n    R16Float = WGPUTextureFormat_R16Float,\n    RG8Unorm = WGPUTextureFormat_RG8Unorm,\n    RG8Snorm = WGPUTextureFormat_RG8Snorm,\n    RG8Uint = WGPUTextureFormat_RG8Uint,\n    RG8Sint = WGPUTextureFormat_RG8Sint,\n    R32Float = WGPUTextureFormat_R32Float,\n    R32Uint = WGPUTextureFormat_R32Uint,\n    R32Sint = WGPUTextureFormat_R32Sint,\n    RG16Uint = WGPUTextureFormat_RG16Uint,\n    RG16Sint = WGPUTextureFormat_RG16Sint,\n    RG16Float = WGPUTextureFormat_RG16Float,\n    RGBA8Unorm = WGPUTextureFormat_RGBA8Unorm,\n    RGBA8UnormSrgb = WGPUTextureFormat_RGBA8UnormSrgb,\n    RGBA8Snorm = WGPUTextureFormat_RGBA8Snorm,\n    RGBA8Uint = WGPUTextureFormat_RGBA8Uint,\n    RGBA8Sint = WGPUTextureFormat_RGBA8Sint,\n    BGRA8Unorm = WGPUTextureFormat_BGRA8Unorm,\n    BGRA8UnormSrgb = WGPUTextureFormat_BGRA8UnormSrgb,\n    RGB10A2Uint = WGPUTextureFormat_RGB10A2Uint,\n    RGB10A2Unorm = WGPUTextureFormat_RGB10A2Unorm,\n    RG11B10Ufloat = WGPUTextureFormat_RG11B10Ufloat,\n    RGB9E5Ufloat = WGPUTextureFormat_RGB9E5Ufloat,\n    RG32Float = WGPUTextureFormat_RG32Float,\n    RG32Uint = WGPUTextureFormat_RG32Uint,\n    RG32Sint = WGPUTextureFormat_RG32Sint,\n    RGBA16Uint = WGPUTextureFormat_RGBA16Uint,\n    RGBA16Sint = WGPUTextureFormat_RGBA16Sint,\n    RGBA16Float = WGPUTextureFormat_RGBA16Float,\n    RGBA32Float = WGPUTextureFormat_RGBA32Float,\n    RGBA32Uint = WGPUTextureFormat_RGBA32Uint,\n    RGBA32Sint = WGPUTextureFormat_RGBA32Sint,\n    Stencil8 = WGPUTextureFormat_Stencil8,\n    Depth16Unorm = WGPUTextureFormat_Depth16Unorm,\n    Depth24Plus = WGPUTextureFormat_Depth24Plus,\n    Depth24PlusStencil8 = WGPUTextureFormat_Depth24PlusStencil8,\n    Depth32Float = WGPUTextureFormat_Depth32Float,\n    Depth32FloatStencil8 = WGPUTextureFormat_Depth32FloatStencil8,\n    BC1RGBAUnorm = WGPUTextureFormat_BC1RGBAUnorm,\n    BC1RGBAUnormSrgb = WGPUTextureFormat_BC1RGBAUnormSrgb,\n    BC2RGBAUnorm = WGPUTextureFormat_BC2RGBAUnorm,\n    BC2RGBAUnormSrgb = WGPUTextureFormat_BC2RGBAUnormSrgb,\n    BC3RGBAUnorm = WGPUTextureFormat_BC3RGBAUnorm,\n    BC3RGBAUnormSrgb = WGPUTextureFormat_BC3RGBAUnormSrgb,\n    BC4RUnorm = WGPUTextureFormat_BC4RUnorm,\n    BC4RSnorm = WGPUTextureFormat_BC4RSnorm,\n    BC5RGUnorm = WGPUTextureFormat_BC5RGUnorm,\n    BC5RGSnorm = WGPUTextureFormat_BC5RGSnorm,\n    BC6HRGBUfloat = WGPUTextureFormat_BC6HRGBUfloat,\n    BC6HRGBFloat = WGPUTextureFormat_BC6HRGBFloat,\n    BC7RGBAUnorm = WGPUTextureFormat_BC7RGBAUnorm,\n    BC7RGBAUnormSrgb = WGPUTextureFormat_BC7RGBAUnormSrgb,\n    ETC2RGB8Unorm = WGPUTextureFormat_ETC2RGB8Unorm,\n    ETC2RGB8UnormSrgb = WGPUTextureFormat_ETC2RGB8UnormSrgb,\n    ETC2RGB8A1Unorm = WGPUTextureFormat_ETC2RGB8A1Unorm,\n    ETC2RGB8A1UnormSrgb = WGPUTextureFormat_ETC2RGB8A1UnormSrgb,\n    ETC2RGBA8Unorm = WGPUTextureFormat_ETC2RGBA8Unorm,\n    ETC2RGBA8UnormSrgb = WGPUTextureFormat_ETC2RGBA8UnormSrgb,\n    EACR11Unorm = WGPUTextureFormat_EACR11Unorm,\n    EACR11Snorm = WGPUTextureFormat_EACR11Snorm,\n    EACRG11Unorm = WGPUTextureFormat_EACRG11Unorm,\n    EACRG11Snorm = WGPUTextureFormat_EACRG11Snorm,\n    ASTC4x4Unorm = WGPUTextureFormat_ASTC4x4Unorm,\n    ASTC4x4UnormSrgb = WGPUTextureFormat_ASTC4x4UnormSrgb,\n    ASTC5x4Unorm = WGPUTextureFormat_ASTC5x4Unorm,\n    ASTC5x4UnormSrgb = WGPUTextureFormat_ASTC5x4UnormSrgb,\n    ASTC5x5Unorm = WGPUTextureFormat_ASTC5x5Unorm,\n    ASTC5x5UnormSrgb = WGPUTextureFormat_ASTC5x5UnormSrgb,\n    ASTC6x5Unorm = WGPUTextureFormat_ASTC6x5Unorm,\n    ASTC6x5UnormSrgb = WGPUTextureFormat_ASTC6x5UnormSrgb,\n    ASTC6x6Unorm = WGPUTextureFormat_ASTC6x6Unorm,\n    ASTC6x6UnormSrgb = WGPUTextureFormat_ASTC6x6UnormSrgb,\n    ASTC8x5Unorm = WGPUTextureFormat_ASTC8x5Unorm,\n    ASTC8x5UnormSrgb = WGPUTextureFormat_ASTC8x5UnormSrgb,\n    ASTC8x6Unorm = WGPUTextureFormat_ASTC8x6Unorm,\n    ASTC8x6UnormSrgb = WGPUTextureFormat_ASTC8x6UnormSrgb,\n    ASTC8x8Unorm = WGPUTextureFormat_ASTC8x8Unorm,\n    ASTC8x8UnormSrgb = WGPUTextureFormat_ASTC8x8UnormSrgb,\n    ASTC10x5Unorm = WGPUTextureFormat_ASTC10x5Unorm,\n    ASTC10x5UnormSrgb = WGPUTextureFormat_ASTC10x5UnormSrgb,\n    ASTC10x6Unorm = WGPUTextureFormat_ASTC10x6Unorm,\n    ASTC10x6UnormSrgb = WGPUTextureFormat_ASTC10x6UnormSrgb,\n    ASTC10x8Unorm = WGPUTextureFormat_ASTC10x8Unorm,\n    ASTC10x8UnormSrgb = WGPUTextureFormat_ASTC10x8UnormSrgb,\n    ASTC10x10Unorm = WGPUTextureFormat_ASTC10x10Unorm,\n    ASTC10x10UnormSrgb = WGPUTextureFormat_ASTC10x10UnormSrgb,\n    ASTC12x10Unorm = WGPUTextureFormat_ASTC12x10Unorm,\n    ASTC12x10UnormSrgb = WGPUTextureFormat_ASTC12x10UnormSrgb,\n    ASTC12x12Unorm = WGPUTextureFormat_ASTC12x12Unorm,\n    ASTC12x12UnormSrgb = WGPUTextureFormat_ASTC12x12UnormSrgb,\n    R16Unorm = WGPUTextureFormat_R16Unorm,\n    RG16Unorm = WGPUTextureFormat_RG16Unorm,\n    RGBA16Unorm = WGPUTextureFormat_RGBA16Unorm,\n    R16Snorm = WGPUTextureFormat_R16Snorm,\n    RG16Snorm = WGPUTextureFormat_RG16Snorm,\n    RGBA16Snorm = WGPUTextureFormat_RGBA16Snorm,\n    R8BG8Biplanar420Unorm = WGPUTextureFormat_R8BG8Biplanar420Unorm,\n    R10X6BG10X6Biplanar420Unorm = WGPUTextureFormat_R10X6BG10X6Biplanar420Unorm,\n    R8BG8A8Triplanar420Unorm = WGPUTextureFormat_R8BG8A8Triplanar420Unorm,\n    R8BG8Biplanar422Unorm = WGPUTextureFormat_R8BG8Biplanar422Unorm,\n    R8BG8Biplanar444Unorm = WGPUTextureFormat_R8BG8Biplanar444Unorm,\n    R10X6BG10X6Biplanar422Unorm = WGPUTextureFormat_R10X6BG10X6Biplanar422Unorm,\n    R10X6BG10X6Biplanar444Unorm = WGPUTextureFormat_R10X6BG10X6Biplanar444Unorm,\n    External = WGPUTextureFormat_External,\n};\nstatic_assert(sizeof(TextureFormat) == sizeof(WGPUTextureFormat), \"sizeof mismatch for TextureFormat\");\nstatic_assert(alignof(TextureFormat) == alignof(WGPUTextureFormat), \"alignof mismatch for TextureFormat\");\n\nenum class TextureSampleType : uint32_t {\n    BindingNotUsed = WGPUTextureSampleType_BindingNotUsed,\n    Float = WGPUTextureSampleType_Float,\n    UnfilterableFloat = WGPUTextureSampleType_UnfilterableFloat,\n    Depth = WGPUTextureSampleType_Depth,\n    Sint = WGPUTextureSampleType_Sint,\n    Uint = WGPUTextureSampleType_Uint,\n};\nstatic_assert(sizeof(TextureSampleType) == sizeof(WGPUTextureSampleType), \"sizeof mismatch for TextureSampleType\");\nstatic_assert(alignof(TextureSampleType) == alignof(WGPUTextureSampleType), \"alignof mismatch for TextureSampleType\");\n\nenum class TextureViewDimension : uint32_t {\n    Undefined = WGPUTextureViewDimension_Undefined,\n    e1D = WGPUTextureViewDimension_1D,\n    e2D = WGPUTextureViewDimension_2D,\n    e2DArray = WGPUTextureViewDimension_2DArray,\n    Cube = WGPUTextureViewDimension_Cube,\n    CubeArray = WGPUTextureViewDimension_CubeArray,\n    e3D = WGPUTextureViewDimension_3D,\n};\nstatic_assert(sizeof(TextureViewDimension) == sizeof(WGPUTextureViewDimension), \"sizeof mismatch for TextureViewDimension\");\nstatic_assert(alignof(TextureViewDimension) == alignof(WGPUTextureViewDimension), \"alignof mismatch for TextureViewDimension\");\n\nenum class VertexFormat : uint32_t {\n    Uint8 = WGPUVertexFormat_Uint8,\n    Uint8x2 = WGPUVertexFormat_Uint8x2,\n    Uint8x4 = WGPUVertexFormat_Uint8x4,\n    Sint8 = WGPUVertexFormat_Sint8,\n    Sint8x2 = WGPUVertexFormat_Sint8x2,\n    Sint8x4 = WGPUVertexFormat_Sint8x4,\n    Unorm8 = WGPUVertexFormat_Unorm8,\n    Unorm8x2 = WGPUVertexFormat_Unorm8x2,\n    Unorm8x4 = WGPUVertexFormat_Unorm8x4,\n    Snorm8 = WGPUVertexFormat_Snorm8,\n    Snorm8x2 = WGPUVertexFormat_Snorm8x2,\n    Snorm8x4 = WGPUVertexFormat_Snorm8x4,\n    Uint16 = WGPUVertexFormat_Uint16,\n    Uint16x2 = WGPUVertexFormat_Uint16x2,\n    Uint16x4 = WGPUVertexFormat_Uint16x4,\n    Sint16 = WGPUVertexFormat_Sint16,\n    Sint16x2 = WGPUVertexFormat_Sint16x2,\n    Sint16x4 = WGPUVertexFormat_Sint16x4,\n    Unorm16 = WGPUVertexFormat_Unorm16,\n    Unorm16x2 = WGPUVertexFormat_Unorm16x2,\n    Unorm16x4 = WGPUVertexFormat_Unorm16x4,\n    Snorm16 = WGPUVertexFormat_Snorm16,\n    Snorm16x2 = WGPUVertexFormat_Snorm16x2,\n    Snorm16x4 = WGPUVertexFormat_Snorm16x4,\n    Float16 = WGPUVertexFormat_Float16,\n    Float16x2 = WGPUVertexFormat_Float16x2,\n    Float16x4 = WGPUVertexFormat_Float16x4,\n    Float32 = WGPUVertexFormat_Float32,\n    Float32x2 = WGPUVertexFormat_Float32x2,\n    Float32x3 = WGPUVertexFormat_Float32x3,\n    Float32x4 = WGPUVertexFormat_Float32x4,\n    Uint32 = WGPUVertexFormat_Uint32,\n    Uint32x2 = WGPUVertexFormat_Uint32x2,\n    Uint32x3 = WGPUVertexFormat_Uint32x3,\n    Uint32x4 = WGPUVertexFormat_Uint32x4,\n    Sint32 = WGPUVertexFormat_Sint32,\n    Sint32x2 = WGPUVertexFormat_Sint32x2,\n    Sint32x3 = WGPUVertexFormat_Sint32x3,\n    Sint32x4 = WGPUVertexFormat_Sint32x4,\n    Unorm10_10_10_2 = WGPUVertexFormat_Unorm10_10_10_2,\n    Unorm8x4BGRA = WGPUVertexFormat_Unorm8x4BGRA,\n};\nstatic_assert(sizeof(VertexFormat) == sizeof(WGPUVertexFormat), \"sizeof mismatch for VertexFormat\");\nstatic_assert(alignof(VertexFormat) == alignof(WGPUVertexFormat), \"alignof mismatch for VertexFormat\");\n\nenum class VertexStepMode : uint32_t {\n    VertexBufferNotUsed = WGPUVertexStepMode_VertexBufferNotUsed,\n    Undefined = WGPUVertexStepMode_Undefined,\n    Vertex = WGPUVertexStepMode_Vertex,\n    Instance = WGPUVertexStepMode_Instance,\n};\nstatic_assert(sizeof(VertexStepMode) == sizeof(WGPUVertexStepMode), \"sizeof mismatch for VertexStepMode\");\nstatic_assert(alignof(VertexStepMode) == alignof(WGPUVertexStepMode), \"alignof mismatch for VertexStepMode\");\n\nenum class WaitStatus : uint32_t {\n    Success = WGPUWaitStatus_Success,\n    TimedOut = WGPUWaitStatus_TimedOut,\n    UnsupportedTimeout = WGPUWaitStatus_UnsupportedTimeout,\n    UnsupportedCount = WGPUWaitStatus_UnsupportedCount,\n    UnsupportedMixedSources = WGPUWaitStatus_UnsupportedMixedSources,\n    Unknown = WGPUWaitStatus_Unknown,\n};\nstatic_assert(sizeof(WaitStatus) == sizeof(WGPUWaitStatus), \"sizeof mismatch for WaitStatus\");\nstatic_assert(alignof(WaitStatus) == alignof(WGPUWaitStatus), \"alignof mismatch for WaitStatus\");\n\n\nenum class BufferUsage : uint64_t {\n    None = WGPUBufferUsage_None,\n    MapRead = WGPUBufferUsage_MapRead,\n    MapWrite = WGPUBufferUsage_MapWrite,\n    CopySrc = WGPUBufferUsage_CopySrc,\n    CopyDst = WGPUBufferUsage_CopyDst,\n    Index = WGPUBufferUsage_Index,\n    Vertex = WGPUBufferUsage_Vertex,\n    Uniform = WGPUBufferUsage_Uniform,\n    Storage = WGPUBufferUsage_Storage,\n    Indirect = WGPUBufferUsage_Indirect,\n    QueryResolve = WGPUBufferUsage_QueryResolve,\n};\nstatic_assert(sizeof(BufferUsage) == sizeof(WGPUBufferUsage), \"sizeof mismatch for BufferUsage\");\nstatic_assert(alignof(BufferUsage) == alignof(WGPUBufferUsage), \"alignof mismatch for BufferUsage\");\n\nenum class ColorWriteMask : uint64_t {\n    None = WGPUColorWriteMask_None,\n    Red = WGPUColorWriteMask_Red,\n    Green = WGPUColorWriteMask_Green,\n    Blue = WGPUColorWriteMask_Blue,\n    Alpha = WGPUColorWriteMask_Alpha,\n    All = WGPUColorWriteMask_All,\n};\nstatic_assert(sizeof(ColorWriteMask) == sizeof(WGPUColorWriteMask), \"sizeof mismatch for ColorWriteMask\");\nstatic_assert(alignof(ColorWriteMask) == alignof(WGPUColorWriteMask), \"alignof mismatch for ColorWriteMask\");\n\nenum class HeapProperty : uint64_t {\n    DeviceLocal = WGPUHeapProperty_DeviceLocal,\n    HostVisible = WGPUHeapProperty_HostVisible,\n    HostCoherent = WGPUHeapProperty_HostCoherent,\n    HostUncached = WGPUHeapProperty_HostUncached,\n    HostCached = WGPUHeapProperty_HostCached,\n};\nstatic_assert(sizeof(HeapProperty) == sizeof(WGPUHeapProperty), \"sizeof mismatch for HeapProperty\");\nstatic_assert(alignof(HeapProperty) == alignof(WGPUHeapProperty), \"alignof mismatch for HeapProperty\");\n\nenum class MapMode : uint64_t {\n    None = WGPUMapMode_None,\n    Read = WGPUMapMode_Read,\n    Write = WGPUMapMode_Write,\n};\nstatic_assert(sizeof(MapMode) == sizeof(WGPUMapMode), \"sizeof mismatch for MapMode\");\nstatic_assert(alignof(MapMode) == alignof(WGPUMapMode), \"alignof mismatch for MapMode\");\n\nenum class ShaderStage : uint64_t {\n    None = WGPUShaderStage_None,\n    Vertex = WGPUShaderStage_Vertex,\n    Fragment = WGPUShaderStage_Fragment,\n    Compute = WGPUShaderStage_Compute,\n};\nstatic_assert(sizeof(ShaderStage) == sizeof(WGPUShaderStage), \"sizeof mismatch for ShaderStage\");\nstatic_assert(alignof(ShaderStage) == alignof(WGPUShaderStage), \"alignof mismatch for ShaderStage\");\n\nenum class TextureUsage : uint64_t {\n    None = WGPUTextureUsage_None,\n    CopySrc = WGPUTextureUsage_CopySrc,\n    CopyDst = WGPUTextureUsage_CopyDst,\n    TextureBinding = WGPUTextureUsage_TextureBinding,\n    StorageBinding = WGPUTextureUsage_StorageBinding,\n    RenderAttachment = WGPUTextureUsage_RenderAttachment,\n    TransientAttachment = WGPUTextureUsage_TransientAttachment,\n    StorageAttachment = WGPUTextureUsage_StorageAttachment,\n};\nstatic_assert(sizeof(TextureUsage) == sizeof(WGPUTextureUsage), \"sizeof mismatch for TextureUsage\");\nstatic_assert(alignof(TextureUsage) == alignof(WGPUTextureUsage), \"alignof mismatch for TextureUsage\");\n\n\n// TODO(crbug.com/42241461): Update these to not be using the C callback types, and instead be\n// defined using C++ types instead. Note that when we remove these, the C++ callback info types\n// should also all be removed as they will no longer be necessary given the C++ templated\n// functions calls and setter utilities.\nusing BufferMapCallback = WGPUBufferMapCallback;\nusing Callback = WGPUCallback;\nusing CompilationInfoCallback = WGPUCompilationInfoCallback;\nusing CreateComputePipelineAsyncCallback = WGPUCreateComputePipelineAsyncCallback;\nusing CreateRenderPipelineAsyncCallback = WGPUCreateRenderPipelineAsyncCallback;\nusing DawnLoadCacheDataFunction = WGPUDawnLoadCacheDataFunction;\nusing DawnStoreCacheDataFunction = WGPUDawnStoreCacheDataFunction;\nusing DeviceLostCallback = WGPUDeviceLostCallback;\nusing DeviceLostCallbackNew = WGPUDeviceLostCallbackNew;\nusing ErrorCallback = WGPUErrorCallback;\nusing LoggingCallback = WGPULoggingCallback;\nusing PopErrorScopeCallback = WGPUPopErrorScopeCallback;\nusing Proc = WGPUProc;\nusing QueueWorkDoneCallback = WGPUQueueWorkDoneCallback;\nusing RequestAdapterCallback = WGPURequestAdapterCallback;\nusing RequestDeviceCallback = WGPURequestDeviceCallback;\n\n// Special class for booleans in order to allow implicit conversions.\nclass Bool {\n  public:\n    constexpr Bool() = default;\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr Bool(bool value) : mValue(static_cast<WGPUBool>(value)) {}\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    Bool(WGPUBool value): mValue(value) {}\n\n    constexpr operator bool() const { return static_cast<bool>(mValue); }\n\n  private:\n    friend struct std::hash<Bool>;\n    // Default to false.\n    WGPUBool mValue = static_cast<WGPUBool>(false);\n};\n\n// Special class for optional booleans in order to allow conversions.\nclass OptionalBool {\n  public:\n    constexpr OptionalBool() = default;\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr OptionalBool(bool value) : mValue(static_cast<WGPUOptionalBool>(value)) {}\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr OptionalBool(std::optional<bool> value) :\n        mValue(value ? static_cast<WGPUOptionalBool>(*value) : WGPUOptionalBool_Undefined) {}\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr OptionalBool(WGPUOptionalBool value): mValue(value) {}\n\n    // Define the values that are equivalent to the enums.\n    static const OptionalBool False;\n    static const OptionalBool True;\n    static const OptionalBool Undefined;\n\n    // Assignment operators.\n    OptionalBool& operator=(const bool& value) {\n        mValue = static_cast<WGPUOptionalBool>(value);\n        return *this;\n    }\n    OptionalBool& operator=(const std::optional<bool>& value) {\n        mValue = value ? static_cast<WGPUOptionalBool>(*value) : WGPUOptionalBool_Undefined;\n        return *this;\n    }\n    OptionalBool& operator=(const WGPUOptionalBool& value) {\n        mValue = value;\n        return *this;\n    }\n\n    // Conversion functions.\n    operator WGPUOptionalBool() const { return mValue; }\n    operator std::optional<bool>() const {\n        if (mValue == WGPUOptionalBool_Undefined) {\n            return std::nullopt;\n        }\n        return static_cast<bool>(mValue);\n    }\n\n    // Comparison functions.\n    friend bool operator==(const OptionalBool& lhs, const OptionalBool& rhs) {\n        return lhs.mValue == rhs.mValue;\n    }\n    friend bool operator!=(const OptionalBool& lhs, const OptionalBool& rhs) {\n        return lhs.mValue != rhs.mValue;\n    }\n\n  private:\n    friend struct std::hash<OptionalBool>;\n    // Default to undefined.\n    WGPUOptionalBool mValue = WGPUOptionalBool_Undefined;\n};\ninline const OptionalBool OptionalBool::False = OptionalBool(WGPUOptionalBool_False);\ninline const OptionalBool OptionalBool::True = OptionalBool(WGPUOptionalBool_True);\ninline const OptionalBool OptionalBool::Undefined = OptionalBool(WGPUOptionalBool_Undefined);\n\n// Helper class to wrap Status which allows implicit conversion to bool.\n// Used while callers switch to checking the Status enum instead of booleans.\n// TODO(crbug.com/42241199): Remove when all callers check the enum.\nstruct ConvertibleStatus {\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    constexpr ConvertibleStatus(Status status) : status(status) {}\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit conversion\n    constexpr operator bool() const {\n        return status == Status::Success;\n    }\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit conversion\n    constexpr operator Status() const {\n        return status;\n    }\n    Status status;\n};\n\ntemplate<typename Derived, typename CType>\nclass ObjectBase {\n  public:\n    ObjectBase() = default;\n    ObjectBase(CType handle): mHandle(handle) {\n        if (mHandle) Derived::WGPUAddRef(mHandle);\n    }\n    ~ObjectBase() {\n        if (mHandle) Derived::WGPURelease(mHandle);\n    }\n\n    ObjectBase(ObjectBase const& other)\n        : ObjectBase(other.Get()) {\n    }\n    Derived& operator=(ObjectBase const& other) {\n        if (&other != this) {\n            if (mHandle) Derived::WGPURelease(mHandle);\n            mHandle = other.mHandle;\n            if (mHandle) Derived::WGPUAddRef(mHandle);\n        }\n\n        return static_cast<Derived&>(*this);\n    }\n\n    ObjectBase(ObjectBase&& other) {\n        mHandle = other.mHandle;\n        other.mHandle = 0;\n    }\n    Derived& operator=(ObjectBase&& other) {\n        if (&other != this) {\n            if (mHandle) Derived::WGPURelease(mHandle);\n            mHandle = other.mHandle;\n            other.mHandle = 0;\n        }\n\n        return static_cast<Derived&>(*this);\n    }\n\n    ObjectBase(std::nullptr_t) {}\n    Derived& operator=(std::nullptr_t) {\n        if (mHandle != nullptr) {\n            Derived::WGPURelease(mHandle);\n            mHandle = nullptr;\n        }\n        return static_cast<Derived&>(*this);\n    }\n\n    bool operator==(std::nullptr_t) const {\n        return mHandle == nullptr;\n    }\n    bool operator!=(std::nullptr_t) const {\n        return mHandle != nullptr;\n    }\n\n    explicit operator bool() const {\n        return mHandle != nullptr;\n    }\n    CType Get() const {\n        return mHandle;\n    }\n    CType MoveToCHandle() {\n        CType result = mHandle;\n        mHandle = 0;\n        return result;\n    }\n    static Derived Acquire(CType handle) {\n        Derived result;\n        result.mHandle = handle;\n        return result;\n    }\n\n  protected:\n    CType mHandle = nullptr;\n};\n\n\n\n\n\nnamespace dawn::wire::client {\n\nclass Adapter;\nclass BindGroup;\nclass BindGroupLayout;\nclass Buffer;\nclass CommandBuffer;\nclass CommandEncoder;\nclass ComputePassEncoder;\nclass ComputePipeline;\nclass Device;\nclass ExternalTexture;\nclass Instance;\nclass PipelineLayout;\nclass QuerySet;\nclass Queue;\nclass RenderBundle;\nclass RenderBundleEncoder;\nclass RenderPassEncoder;\nclass RenderPipeline;\nclass Sampler;\nclass ShaderModule;\nclass SharedBufferMemory;\nclass SharedFence;\nclass SharedTextureMemory;\nclass Surface;\nclass Texture;\nclass TextureView;\n\nstruct AdapterPropertiesD3D;\nstruct AdapterPropertiesSubgroups;\nstruct AdapterPropertiesVk;\nstruct BindGroupEntry;\nstruct BlendComponent;\nstruct BufferBindingLayout;\nstruct BufferHostMappedPointer;\nstruct BufferMapCallbackInfo;\nstruct Color;\nstruct ColorTargetStateExpandResolveTextureDawn;\nstruct CompilationInfoCallbackInfo;\nstruct ComputePassTimestampWrites;\nstruct CopyTextureForBrowserOptions;\nstruct CreateComputePipelineAsyncCallbackInfo;\nstruct CreateRenderPipelineAsyncCallbackInfo;\nstruct DawnWGSLBlocklist;\nstruct DawnAdapterPropertiesPowerPreference;\nstruct DawnBufferDescriptorErrorInfoFromWireClient;\nstruct DawnEncoderInternalUsageDescriptor;\nstruct DawnExperimentalImmediateDataLimits;\nstruct DawnExperimentalSubgroupLimits;\nstruct DawnRenderPassColorAttachmentRenderToSingleSampled;\nstruct DawnShaderModuleSPIRVOptionsDescriptor;\nstruct DawnTexelCopyBufferRowAlignmentLimits;\nstruct DawnTextureInternalUsageDescriptor;\nstruct DawnTogglesDescriptor;\nstruct DawnWireWGSLControl;\nstruct DeviceLostCallbackInfo;\nstruct DrmFormatProperties;\nstruct Extent2D;\nstruct Extent3D;\nstruct ExternalTextureBindingEntry;\nstruct ExternalTextureBindingLayout;\nstruct FormatCapabilities;\nstruct Future;\nstruct InstanceFeatures;\nstruct Limits;\nstruct MemoryHeapInfo;\nstruct MultisampleState;\nstruct Origin2D;\nstruct Origin3D;\nstruct PipelineLayoutStorageAttachment;\nstruct PopErrorScopeCallbackInfo;\nstruct PrimitiveState;\nstruct QueueWorkDoneCallbackInfo;\nstruct RenderPassDepthStencilAttachment;\nstruct RenderPassDescriptorExpandResolveRect;\nstruct RenderPassMaxDrawCount;\nstruct RenderPassTimestampWrites;\nstruct RequestAdapterCallbackInfo;\nstruct RequestAdapterOptions;\nstruct RequestDeviceCallbackInfo;\nstruct SamplerBindingLayout;\nstruct ShaderModuleCompilationOptions;\nstruct ShaderSourceSPIRV;\nstruct SharedBufferMemoryBeginAccessDescriptor;\nstruct SharedBufferMemoryEndAccessState;\nstruct SharedBufferMemoryProperties;\nstruct SharedFenceDXGISharedHandleDescriptor;\nstruct SharedFenceDXGISharedHandleExportInfo;\nstruct SharedFenceMTLSharedEventDescriptor;\nstruct SharedFenceMTLSharedEventExportInfo;\nstruct SharedFenceExportInfo;\nstruct SharedFenceSyncFDDescriptor;\nstruct SharedFenceSyncFDExportInfo;\nstruct SharedFenceVkSemaphoreOpaqueFDDescriptor;\nstruct SharedFenceVkSemaphoreOpaqueFDExportInfo;\nstruct SharedFenceVkSemaphoreZirconHandleDescriptor;\nstruct SharedFenceVkSemaphoreZirconHandleExportInfo;\nstruct SharedTextureMemoryD3DSwapchainBeginState;\nstruct SharedTextureMemoryDXGISharedHandleDescriptor;\nstruct SharedTextureMemoryEGLImageDescriptor;\nstruct SharedTextureMemoryIOSurfaceDescriptor;\nstruct SharedTextureMemoryAHardwareBufferDescriptor;\nstruct SharedTextureMemoryBeginAccessDescriptor;\nstruct SharedTextureMemoryDmaBufPlane;\nstruct SharedTextureMemoryEndAccessState;\nstruct SharedTextureMemoryOpaqueFDDescriptor;\nstruct SharedTextureMemoryVkDedicatedAllocationDescriptor;\nstruct SharedTextureMemoryVkImageLayoutBeginState;\nstruct SharedTextureMemoryVkImageLayoutEndState;\nstruct SharedTextureMemoryZirconHandleDescriptor;\nstruct StaticSamplerBindingLayout;\nstruct StencilFaceState;\nstruct StorageTextureBindingLayout;\nstruct StringView;\nstruct SupportedFeatures;\nstruct SurfaceCapabilities;\nstruct SurfaceConfiguration;\nstruct SurfaceDescriptorFromWindowsCoreWindow;\nstruct SurfaceDescriptorFromWindowsSwapChainPanel;\nstruct SurfaceSourceXCBWindow;\nstruct SurfaceSourceAndroidNativeWindow;\nstruct SurfaceSourceMetalLayer;\nstruct SurfaceSourceWaylandSurface;\nstruct SurfaceSourceWindowsHWND;\nstruct SurfaceSourceXlibWindow;\nstruct SurfaceTexture;\nstruct TextureBindingLayout;\nstruct TextureBindingViewDimensionDescriptor;\nstruct TextureDataLayout;\nstruct UncapturedErrorCallbackInfo;\nstruct VertexAttribute;\nstruct YCbCrVkDescriptor;\nstruct AHardwareBufferProperties;\nstruct AdapterInfo;\nstruct AdapterPropertiesMemoryHeaps;\nstruct BindGroupDescriptor;\nstruct BindGroupLayoutEntry;\nstruct BlendState;\nstruct BufferDescriptor;\nstruct CommandBufferDescriptor;\nstruct CommandEncoderDescriptor;\nstruct CompilationMessage;\nstruct ComputePassDescriptor;\nstruct ConstantEntry;\nstruct DawnCacheDeviceDescriptor;\nstruct DepthStencilState;\nstruct DrmFormatCapabilities;\nstruct ExternalTextureDescriptor;\nstruct FutureWaitInfo;\nstruct ImageCopyBuffer;\nstruct ImageCopyExternalTexture;\nstruct ImageCopyTexture;\nstruct InstanceDescriptor;\nstruct PipelineLayoutDescriptor;\nstruct PipelineLayoutPixelLocalStorage;\nstruct QuerySetDescriptor;\nstruct QueueDescriptor;\nstruct RenderBundleDescriptor;\nstruct RenderBundleEncoderDescriptor;\nstruct RenderPassColorAttachment;\nstruct RenderPassStorageAttachment;\nstruct RequiredLimits;\nstruct SamplerDescriptor;\nstruct ShaderModuleDescriptor;\nstruct ShaderSourceWGSL;\nstruct SharedBufferMemoryDescriptor;\nstruct SharedFenceDescriptor;\nstruct SharedTextureMemoryAHardwareBufferProperties;\nstruct SharedTextureMemoryDescriptor;\nstruct SharedTextureMemoryDmaBufDescriptor;\nstruct SharedTextureMemoryProperties;\nstruct SupportedLimits;\nstruct SurfaceDescriptor;\nstruct TextureDescriptor;\nstruct TextureViewDescriptor;\nstruct VertexBufferLayout;\nstruct BindGroupLayoutDescriptor;\nstruct ColorTargetState;\nstruct CompilationInfo;\nstruct ComputeState;\nstruct DeviceDescriptor;\nstruct RenderPassDescriptor;\nstruct RenderPassPixelLocalStorage;\nstruct VertexState;\nstruct ComputePipelineDescriptor;\nstruct FragmentState;\nstruct RenderPipelineDescriptor;\n\n// TODO(42241188): Remove once all clients use StringView versions of the callbacks.\n// To make MSVC happy we need a StringView constructor from the adapter, so we first need to\n// forward declare StringViewAdapter here. Otherwise MSVC complains about an ambiguous conversion.\nnamespace detail {\n    struct StringViewAdapter;\n}  // namespace detail\n\nstruct StringView {\n    char const * data = nullptr;\n    size_t length = WGPU_STRLEN;\n\n    inline constexpr StringView() noexcept = default;\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(const std::string_view& sv) noexcept {\n        this->data = sv.data();\n        this->length = sv.length();\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(const char* s) {\n        this->data = s;\n        this->length = WGPU_STRLEN;  // use strlen\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(WGPUStringView s) {\n        this->data = s.data;\n        this->length = s.length;\n    }\n\n    inline constexpr StringView(const char* data, size_t length) {\n        this->data = data;\n        this->length = length;\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(std::nullptr_t) {\n        this->data = nullptr;\n        this->length = WGPU_STRLEN;\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit construction\n    inline constexpr StringView(std::nullopt_t) {\n        this->data = nullptr;\n        this->length = WGPU_STRLEN;\n    }\n\n    bool IsUndefined() const {\n        return this->data == nullptr && this->length == wgpu::kStrlen;\n    }\n\n    // NOLINTNEXTLINE(runtime/explicit) allow implicit conversion\n    operator std::string_view() const {\n        if (this->length == wgpu::kStrlen) {\n            if (IsUndefined()) {\n                return {};\n            }\n            return {this->data};\n        }\n        return {this->data, this->length};\n    }\n\n    template <typename View,\n              typename = std::enable_if_t<std::is_constructible_v<View, const char*, size_t>>>\n    explicit operator View() const {\n        if (this->length == wgpu::kStrlen) {\n            if (IsUndefined()) {\n                return {};\n            }\n            return {this->data};\n        }\n        return {this->data, this->length};\n    }\n\n\n    StringView(const detail::StringViewAdapter& s);\n};\n\nnamespace detail {\nconstexpr size_t ConstexprMax(size_t a, size_t b) {\n    return a > b ? a : b;\n}\n\ntemplate <typename T>\nstatic T& AsNonConstReference(const T& value) {\n    return const_cast<T&>(value);\n}\n\n// A wrapper around StringView that can be implicitly converted to const char* with temporary\n// storage that adds the \\0 for output strings that are all explicitly-sized.\n// TODO(42241188): Remove once all clients use StringView versions of the callbacks.\nstruct StringViewAdapter {\n    WGPUStringView sv;\n    char* nullTerminated = nullptr;\n\n    StringViewAdapter(WGPUStringView sv) : sv(sv) {}\n    ~StringViewAdapter() { delete[] nullTerminated; }\n    operator ::WGPUStringView() { return sv; }\n    operator StringView() { return {sv.data, sv.length}; }\n    operator const char*() {\n        assert(sv.length != WGPU_STRLEN);\n        assert(nullTerminated == nullptr);\n        nullTerminated = new char[sv.length + 1];\n        for (size_t i = 0; i < sv.length; i++) {\n            nullTerminated[i] = sv.data[i];\n        }\n        nullTerminated[sv.length] = 0;\n        return nullTerminated;\n    }\n};\n}  // namespace detail\n\ninline StringView::StringView(const detail::StringViewAdapter& s): data(s.sv.data), length(s.sv.length) {}\n\nnamespace detail {\n// For callbacks, we support two modes:\n//   1) No userdata where we allow a std::function type that can include argument captures.\n//   2) Explicit typed userdata where we only allow non-capturing lambdas or function pointers.\ntemplate <typename... Args>\nstruct CallbackTypeBase;\ntemplate <typename... Args>\nstruct CallbackTypeBase<std::tuple<Args...>> {\n    using Callback = std::function<void(Args...)>;\n};\ntemplate <typename... Args>\nstruct CallbackTypeBase<std::tuple<Args...>, void> {\n    using Callback = void (Args...);\n};\ntemplate <typename... Args, typename T>\nstruct CallbackTypeBase<std::tuple<Args...>, T> {\n    using Callback = void (Args..., T);\n};\n}  // namespace detail\n\n\ntemplate <typename... T>\nusing BufferMapCallback2 = typename detail::CallbackTypeBase<std::tuple<MapAsyncStatus , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing CompilationInfoCallback2 = typename detail::CallbackTypeBase<std::tuple<CompilationInfoRequestStatus , CompilationInfo const * >, T...>::Callback;\ntemplate <typename... T>\nusing CreateComputePipelineAsyncCallback2 = typename detail::CallbackTypeBase<std::tuple<CreatePipelineAsyncStatus , ComputePipeline , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing CreateRenderPipelineAsyncCallback2 = typename detail::CallbackTypeBase<std::tuple<CreatePipelineAsyncStatus , RenderPipeline , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing PopErrorScopeCallback2 = typename detail::CallbackTypeBase<std::tuple<PopErrorScopeStatus , ErrorType , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing QueueWorkDoneCallback2 = typename detail::CallbackTypeBase<std::tuple<QueueWorkDoneStatus >, T...>::Callback;\ntemplate <typename... T>\nusing RequestAdapterCallback2 = typename detail::CallbackTypeBase<std::tuple<RequestAdapterStatus , Adapter , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing RequestDeviceCallback2 = typename detail::CallbackTypeBase<std::tuple<RequestDeviceStatus , Device , StringView >, T...>::Callback;\ntemplate <typename... T>\nusing DeviceLostCallback2 = typename detail::CallbackTypeBase<std::tuple<const Device&, DeviceLostReason, StringView>, T...>::Callback;\ntemplate <typename... T>\nusing UncapturedErrorCallback = typename detail::CallbackTypeBase<std::tuple<const Device&, ErrorType, StringView>, T...>::Callback;\n\n\n\n\nclass Adapter : public ObjectBase<Adapter, WGPUAdapter> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline Device CreateDevice(DeviceDescriptor const * descriptor = nullptr) const;\n    inline void GetFeatures(SupportedFeatures * features) const;\n    inline ConvertibleStatus GetFormatCapabilities(TextureFormat format, FormatCapabilities * capabilities) const;\n    inline ConvertibleStatus GetInfo(AdapterInfo * info) const;\n    inline Instance GetInstance() const;\n    inline ConvertibleStatus GetLimits(SupportedLimits * limits) const;\n    inline Bool HasFeature(FeatureName feature) const;\n    inline void RequestDevice(DeviceDescriptor const * descriptor, RequestDeviceCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = RequestDeviceCallback2<T>,\n              typename CbChar = void (RequestDeviceStatus status, Device device, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future RequestDevice(DeviceDescriptor const * options, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = RequestDeviceCallback2<>,\n              typename CbChar = std::function<void(RequestDeviceStatus status, Device device, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future RequestDevice(DeviceDescriptor const * options, CallbackMode callbackMode, L callback) const;\n    inline Future RequestDevice(DeviceDescriptor const * options, RequestDeviceCallbackInfo callbackInfo) const;\n\n\n  private:\n    friend ObjectBase<Adapter, WGPUAdapter>;\n    static inline void WGPUAddRef(WGPUAdapter handle);\n    static inline void WGPURelease(WGPUAdapter handle);\n};\n\nclass BindGroup : public ObjectBase<BindGroup, WGPUBindGroup> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<BindGroup, WGPUBindGroup>;\n    static inline void WGPUAddRef(WGPUBindGroup handle);\n    static inline void WGPURelease(WGPUBindGroup handle);\n};\n\nclass BindGroupLayout : public ObjectBase<BindGroupLayout, WGPUBindGroupLayout> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<BindGroupLayout, WGPUBindGroupLayout>;\n    static inline void WGPUAddRef(WGPUBindGroupLayout handle);\n    static inline void WGPURelease(WGPUBindGroupLayout handle);\n};\n\nclass Buffer : public ObjectBase<Buffer, WGPUBuffer> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Destroy() const;\n    inline void const * GetConstMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n    inline BufferMapState GetMapState() const;\n    inline void * GetMappedRange(size_t offset = 0, size_t size = WGPU_WHOLE_MAP_SIZE) const;\n    inline uint64_t GetSize() const;\n    inline BufferUsage GetUsage() const;\n    inline void MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = BufferMapCallback2<T>,\n              typename CbChar = void (MapAsyncStatus status, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future MapAsync(MapMode mode, size_t offset, size_t size, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = BufferMapCallback2<>,\n              typename CbChar = std::function<void(MapAsyncStatus status, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future MapAsync(MapMode mode, size_t offset, size_t size, CallbackMode callbackMode, L callback) const;\n    inline Future MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallbackInfo callbackInfo) const;\n    inline void SetLabel(StringView label) const;\n    inline void Unmap() const;\n\n\n  private:\n    friend ObjectBase<Buffer, WGPUBuffer>;\n    static inline void WGPUAddRef(WGPUBuffer handle);\n    static inline void WGPURelease(WGPUBuffer handle);\n};\n\nclass CommandBuffer : public ObjectBase<CommandBuffer, WGPUCommandBuffer> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<CommandBuffer, WGPUCommandBuffer>;\n    static inline void WGPUAddRef(WGPUCommandBuffer handle);\n    static inline void WGPURelease(WGPUCommandBuffer handle);\n};\n\nclass CommandEncoder : public ObjectBase<CommandEncoder, WGPUCommandEncoder> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline ComputePassEncoder BeginComputePass(ComputePassDescriptor const * descriptor = nullptr) const;\n    inline RenderPassEncoder BeginRenderPass(RenderPassDescriptor const * descriptor) const;\n    inline void ClearBuffer(Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n    inline void CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const;\n    inline void CopyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n    inline void CopyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) const;\n    inline void CopyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const;\n    inline CommandBuffer Finish(CommandBufferDescriptor const * descriptor = nullptr) const;\n    inline void InjectValidationError(StringView message) const;\n    inline void InsertDebugMarker(StringView markerLabel) const;\n    inline void PopDebugGroup() const;\n    inline void PushDebugGroup(StringView groupLabel) const;\n    inline void ResolveQuerySet(QuerySet const& querySet, uint32_t firstQuery, uint32_t queryCount, Buffer const& destination, uint64_t destinationOffset) const;\n    inline void SetLabel(StringView label) const;\n    inline void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) const;\n    inline void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n\n  private:\n    friend ObjectBase<CommandEncoder, WGPUCommandEncoder>;\n    static inline void WGPUAddRef(WGPUCommandEncoder handle);\n    static inline void WGPURelease(WGPUCommandEncoder handle);\n};\n\nclass ComputePassEncoder : public ObjectBase<ComputePassEncoder, WGPUComputePassEncoder> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void DispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY = 1, uint32_t workgroupCountZ = 1) const;\n    inline void DispatchWorkgroupsIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline void End() const;\n    inline void InsertDebugMarker(StringView markerLabel) const;\n    inline void PopDebugGroup() const;\n    inline void PushDebugGroup(StringView groupLabel) const;\n    inline void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n    inline void SetLabel(StringView label) const;\n    inline void SetPipeline(ComputePipeline const& pipeline) const;\n    inline void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n\n  private:\n    friend ObjectBase<ComputePassEncoder, WGPUComputePassEncoder>;\n    static inline void WGPUAddRef(WGPUComputePassEncoder handle);\n    static inline void WGPURelease(WGPUComputePassEncoder handle);\n};\n\nclass ComputePipeline : public ObjectBase<ComputePipeline, WGPUComputePipeline> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<ComputePipeline, WGPUComputePipeline>;\n    static inline void WGPUAddRef(WGPUComputePipeline handle);\n    static inline void WGPURelease(WGPUComputePipeline handle);\n};\n\nclass Device : public ObjectBase<Device, WGPUDevice> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline BindGroup CreateBindGroup(BindGroupDescriptor const * descriptor) const;\n    inline BindGroupLayout CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const;\n    inline Buffer CreateBuffer(BufferDescriptor const * descriptor) const;\n    inline CommandEncoder CreateCommandEncoder(CommandEncoderDescriptor const * descriptor = nullptr) const;\n    inline ComputePipeline CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const;\n    inline void CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = CreateComputePipelineAsyncCallback2<T>,\n              typename CbChar = void (CreatePipelineAsyncStatus status, ComputePipeline pipeline, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = CreateComputePipelineAsyncCallback2<>,\n              typename CbChar = std::function<void(CreatePipelineAsyncStatus status, ComputePipeline pipeline, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CallbackMode callbackMode, L callback) const;\n    inline Future CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallbackInfo callbackInfo) const;\n    inline Buffer CreateErrorBuffer(BufferDescriptor const * descriptor) const;\n    inline ExternalTexture CreateErrorExternalTexture() const;\n    inline ShaderModule CreateErrorShaderModule(ShaderModuleDescriptor const * descriptor, StringView errorMessage) const;\n    inline Texture CreateErrorTexture(TextureDescriptor const * descriptor) const;\n    inline ExternalTexture CreateExternalTexture(ExternalTextureDescriptor const * externalTextureDescriptor) const;\n    inline PipelineLayout CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const;\n    inline QuerySet CreateQuerySet(QuerySetDescriptor const * descriptor) const;\n    inline RenderBundleEncoder CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const;\n    inline RenderPipeline CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const;\n    inline void CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = CreateRenderPipelineAsyncCallback2<T>,\n              typename CbChar = void (CreatePipelineAsyncStatus status, RenderPipeline pipeline, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = CreateRenderPipelineAsyncCallback2<>,\n              typename CbChar = std::function<void(CreatePipelineAsyncStatus status, RenderPipeline pipeline, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CallbackMode callbackMode, L callback) const;\n    inline Future CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallbackInfo callbackInfo) const;\n    inline Sampler CreateSampler(SamplerDescriptor const * descriptor = nullptr) const;\n    inline ShaderModule CreateShaderModule(ShaderModuleDescriptor const * descriptor) const;\n    inline Texture CreateTexture(TextureDescriptor const * descriptor) const;\n    inline void Destroy() const;\n    inline void ForceLoss(DeviceLostReason type, StringView message) const;\n    inline ConvertibleStatus GetAHardwareBufferProperties(void * handle, AHardwareBufferProperties * properties) const;\n    inline Adapter GetAdapter() const;\n    inline ConvertibleStatus GetAdapterInfo(AdapterInfo * adapterInfo) const;\n    inline void GetFeatures(SupportedFeatures * features) const;\n    inline ConvertibleStatus GetLimits(SupportedLimits * limits) const;\n    inline Future GetLostFuture() const;\n    inline Queue GetQueue() const;\n    inline Bool HasFeature(FeatureName feature) const;\n    inline SharedBufferMemory ImportSharedBufferMemory(SharedBufferMemoryDescriptor const * descriptor) const;\n    inline SharedFence ImportSharedFence(SharedFenceDescriptor const * descriptor) const;\n    inline SharedTextureMemory ImportSharedTextureMemory(SharedTextureMemoryDescriptor const * descriptor) const;\n    inline void InjectError(ErrorType type, StringView message) const;\n    inline void PopErrorScope(ErrorCallback oldCallback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = PopErrorScopeCallback2<T>,\n              typename CbChar = void (PopErrorScopeStatus status, ErrorType type, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future PopErrorScope(CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = PopErrorScopeCallback2<>,\n              typename CbChar = std::function<void(PopErrorScopeStatus status, ErrorType type, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future PopErrorScope(CallbackMode callbackMode, L callback) const;\n    inline Future PopErrorScope(PopErrorScopeCallbackInfo callbackInfo) const;\n    inline void PushErrorScope(ErrorFilter filter) const;\n    inline void SetLabel(StringView label) const;\n    inline void SetLoggingCallback(LoggingCallback callback, void * userdata) const;\n    inline void Tick() const;\n    inline void ValidateTextureDescriptor(TextureDescriptor const * descriptor) const;\n\n\n  private:\n    friend ObjectBase<Device, WGPUDevice>;\n    static inline void WGPUAddRef(WGPUDevice handle);\n    static inline void WGPURelease(WGPUDevice handle);\n};\n\nclass ExternalTexture : public ObjectBase<ExternalTexture, WGPUExternalTexture> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Destroy() const;\n    inline void Expire() const;\n    inline void Refresh() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<ExternalTexture, WGPUExternalTexture>;\n    static inline void WGPUAddRef(WGPUExternalTexture handle);\n    static inline void WGPURelease(WGPUExternalTexture handle);\n};\n\nclass Instance : public ObjectBase<Instance, WGPUInstance> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline Surface CreateSurface(SurfaceDescriptor const * descriptor) const;\n    inline size_t EnumerateWGSLLanguageFeatures(WGSLFeatureName * features) const;\n    inline Bool HasWGSLLanguageFeature(WGSLFeatureName feature) const;\n    inline void ProcessEvents() const;\n    inline void RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = RequestAdapterCallback2<T>,\n              typename CbChar = void (RequestAdapterStatus status, Adapter adapter, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future RequestAdapter(RequestAdapterOptions const * options, CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = RequestAdapterCallback2<>,\n              typename CbChar = std::function<void(RequestAdapterStatus status, Adapter adapter, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future RequestAdapter(RequestAdapterOptions const * options, CallbackMode callbackMode, L callback) const;\n    inline Future RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallbackInfo callbackInfo) const;\n    inline WaitStatus WaitAny(size_t futureCount, FutureWaitInfo * futures, uint64_t timeoutNS) const;\n\n    inline WaitStatus WaitAny(Future f, uint64_t timeout) const;\n\n  private:\n    friend ObjectBase<Instance, WGPUInstance>;\n    static inline void WGPUAddRef(WGPUInstance handle);\n    static inline void WGPURelease(WGPUInstance handle);\n};\n\nclass PipelineLayout : public ObjectBase<PipelineLayout, WGPUPipelineLayout> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<PipelineLayout, WGPUPipelineLayout>;\n    static inline void WGPUAddRef(WGPUPipelineLayout handle);\n    static inline void WGPURelease(WGPUPipelineLayout handle);\n};\n\nclass QuerySet : public ObjectBase<QuerySet, WGPUQuerySet> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Destroy() const;\n    inline uint32_t GetCount() const;\n    inline QueryType GetType() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<QuerySet, WGPUQuerySet>;\n    static inline void WGPUAddRef(WGPUQuerySet handle);\n    static inline void WGPURelease(WGPUQuerySet handle);\n};\n\nclass Queue : public ObjectBase<Queue, WGPUQueue> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void CopyExternalTextureForBrowser(ImageCopyExternalTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const;\n    inline void CopyTextureForBrowser(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const;\n    inline void OnSubmittedWorkDone(QueueWorkDoneCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = QueueWorkDoneCallback2<T>,\n              typename CbChar = void (QueueWorkDoneStatus status, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future OnSubmittedWorkDone(CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = QueueWorkDoneCallback2<>,\n              typename CbChar = std::function<void(QueueWorkDoneStatus status)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future OnSubmittedWorkDone(CallbackMode callbackMode, L callback) const;\n    inline Future OnSubmittedWorkDone(QueueWorkDoneCallbackInfo callbackInfo) const;\n    inline void SetLabel(StringView label) const;\n    inline void Submit(size_t commandCount, CommandBuffer const * commands) const;\n    inline void WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const;\n    inline void WriteTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) const;\n\n\n  private:\n    friend ObjectBase<Queue, WGPUQueue>;\n    static inline void WGPUAddRef(WGPUQueue handle);\n    static inline void WGPURelease(WGPUQueue handle);\n};\n\nclass RenderBundle : public ObjectBase<RenderBundle, WGPURenderBundle> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<RenderBundle, WGPURenderBundle>;\n    static inline void WGPUAddRef(WGPURenderBundle handle);\n    static inline void WGPURelease(WGPURenderBundle handle);\n};\n\nclass RenderBundleEncoder : public ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n    inline void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n    inline void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline RenderBundle Finish(RenderBundleDescriptor const * descriptor = nullptr) const;\n    inline void InsertDebugMarker(StringView markerLabel) const;\n    inline void PopDebugGroup() const;\n    inline void PushDebugGroup(StringView groupLabel) const;\n    inline void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n    inline void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n    inline void SetLabel(StringView label) const;\n    inline void SetPipeline(RenderPipeline const& pipeline) const;\n    inline void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n\n\n  private:\n    friend ObjectBase<RenderBundleEncoder, WGPURenderBundleEncoder>;\n    static inline void WGPUAddRef(WGPURenderBundleEncoder handle);\n    static inline void WGPURelease(WGPURenderBundleEncoder handle);\n};\n\nclass RenderPassEncoder : public ObjectBase<RenderPassEncoder, WGPURenderPassEncoder> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void BeginOcclusionQuery(uint32_t queryIndex) const;\n    inline void Draw(uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) const;\n    inline void DrawIndexed(uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t baseVertex = 0, uint32_t firstInstance = 0) const;\n    inline void DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline void DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const;\n    inline void End() const;\n    inline void EndOcclusionQuery() const;\n    inline void ExecuteBundles(size_t bundleCount, RenderBundle const * bundles) const;\n    inline void InsertDebugMarker(StringView markerLabel) const;\n    inline void MultiDrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset, uint32_t maxDrawCount, Buffer const& drawCountBuffer, uint64_t drawCountBufferOffset = 0) const;\n    inline void MultiDrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset, uint32_t maxDrawCount, Buffer const& drawCountBuffer, uint64_t drawCountBufferOffset = 0) const;\n    inline void PixelLocalStorageBarrier() const;\n    inline void PopDebugGroup() const;\n    inline void PushDebugGroup(StringView groupLabel) const;\n    inline void SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount = 0, uint32_t const * dynamicOffsets = nullptr) const;\n    inline void SetBlendConstant(Color const * color) const;\n    inline void SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n    inline void SetLabel(StringView label) const;\n    inline void SetPipeline(RenderPipeline const& pipeline) const;\n    inline void SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const;\n    inline void SetStencilReference(uint32_t reference) const;\n    inline void SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset = 0, uint64_t size = WGPU_WHOLE_SIZE) const;\n    inline void SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const;\n    inline void WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const;\n\n\n  private:\n    friend ObjectBase<RenderPassEncoder, WGPURenderPassEncoder>;\n    static inline void WGPUAddRef(WGPURenderPassEncoder handle);\n    static inline void WGPURelease(WGPURenderPassEncoder handle);\n};\n\nclass RenderPipeline : public ObjectBase<RenderPipeline, WGPURenderPipeline> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline BindGroupLayout GetBindGroupLayout(uint32_t groupIndex) const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<RenderPipeline, WGPURenderPipeline>;\n    static inline void WGPUAddRef(WGPURenderPipeline handle);\n    static inline void WGPURelease(WGPURenderPipeline handle);\n};\n\nclass Sampler : public ObjectBase<Sampler, WGPUSampler> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<Sampler, WGPUSampler>;\n    static inline void WGPUAddRef(WGPUSampler handle);\n    static inline void WGPURelease(WGPUSampler handle);\n};\n\nclass ShaderModule : public ObjectBase<ShaderModule, WGPUShaderModule> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void GetCompilationInfo(CompilationInfoCallback callback, void * userdata) const;\n    template <typename F, typename T,\n              typename Cb = CompilationInfoCallback2<T>,\n              typename CbChar = void (CompilationInfoRequestStatus status, CompilationInfo const * compilationInfo, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    Future GetCompilationInfo(CallbackMode callbackMode, F callback, T userdata) const;\n    template <typename L,\n              typename Cb = CompilationInfoCallback2<>,\n              typename CbChar = std::function<void(CompilationInfoRequestStatus status, CompilationInfo const * compilationInfo)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    Future GetCompilationInfo(CallbackMode callbackMode, L callback) const;\n    inline Future GetCompilationInfo(CompilationInfoCallbackInfo callbackInfo) const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<ShaderModule, WGPUShaderModule>;\n    static inline void WGPUAddRef(WGPUShaderModule handle);\n    static inline void WGPURelease(WGPUShaderModule handle);\n};\n\nclass SharedBufferMemory : public ObjectBase<SharedBufferMemory, WGPUSharedBufferMemory> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline ConvertibleStatus BeginAccess(Buffer const& buffer, SharedBufferMemoryBeginAccessDescriptor const * descriptor) const;\n    inline Buffer CreateBuffer(BufferDescriptor const * descriptor = nullptr) const;\n    inline ConvertibleStatus EndAccess(Buffer const& buffer, SharedBufferMemoryEndAccessState * descriptor) const;\n    inline ConvertibleStatus GetProperties(SharedBufferMemoryProperties * properties) const;\n    inline Bool IsDeviceLost() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<SharedBufferMemory, WGPUSharedBufferMemory>;\n    static inline void WGPUAddRef(WGPUSharedBufferMemory handle);\n    static inline void WGPURelease(WGPUSharedBufferMemory handle);\n};\n\nclass SharedFence : public ObjectBase<SharedFence, WGPUSharedFence> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void ExportInfo(SharedFenceExportInfo * info) const;\n\n\n  private:\n    friend ObjectBase<SharedFence, WGPUSharedFence>;\n    static inline void WGPUAddRef(WGPUSharedFence handle);\n    static inline void WGPURelease(WGPUSharedFence handle);\n};\n\nclass SharedTextureMemory : public ObjectBase<SharedTextureMemory, WGPUSharedTextureMemory> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline ConvertibleStatus BeginAccess(Texture const& texture, SharedTextureMemoryBeginAccessDescriptor const * descriptor) const;\n    inline Texture CreateTexture(TextureDescriptor const * descriptor = nullptr) const;\n    inline ConvertibleStatus EndAccess(Texture const& texture, SharedTextureMemoryEndAccessState * descriptor) const;\n    inline ConvertibleStatus GetProperties(SharedTextureMemoryProperties * properties) const;\n    inline Bool IsDeviceLost() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<SharedTextureMemory, WGPUSharedTextureMemory>;\n    static inline void WGPUAddRef(WGPUSharedTextureMemory handle);\n    static inline void WGPURelease(WGPUSharedTextureMemory handle);\n};\n\nclass Surface : public ObjectBase<Surface, WGPUSurface> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void Configure(SurfaceConfiguration const * config) const;\n    inline ConvertibleStatus GetCapabilities(Adapter const& adapter, SurfaceCapabilities * capabilities) const;\n    inline void GetCurrentTexture(SurfaceTexture * surfaceTexture) const;\n    inline void Present() const;\n    inline void SetLabel(StringView label) const;\n    inline void Unconfigure() const;\n\n\n  private:\n    friend ObjectBase<Surface, WGPUSurface>;\n    static inline void WGPUAddRef(WGPUSurface handle);\n    static inline void WGPURelease(WGPUSurface handle);\n};\n\nclass Texture : public ObjectBase<Texture, WGPUTexture> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline TextureView CreateErrorView(TextureViewDescriptor const * descriptor = nullptr) const;\n    inline TextureView CreateView(TextureViewDescriptor const * descriptor = nullptr) const;\n    inline void Destroy() const;\n    inline uint32_t GetDepthOrArrayLayers() const;\n    inline TextureDimension GetDimension() const;\n    inline TextureFormat GetFormat() const;\n    inline uint32_t GetHeight() const;\n    inline uint32_t GetMipLevelCount() const;\n    inline uint32_t GetSampleCount() const;\n    inline TextureUsage GetUsage() const;\n    inline uint32_t GetWidth() const;\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<Texture, WGPUTexture>;\n    static inline void WGPUAddRef(WGPUTexture handle);\n    static inline void WGPURelease(WGPUTexture handle);\n};\n\nclass TextureView : public ObjectBase<TextureView, WGPUTextureView> {\n  public:\n    using ObjectBase::ObjectBase;\n    using ObjectBase::operator=;\n\n    inline void SetLabel(StringView label) const;\n\n\n  private:\n    friend ObjectBase<TextureView, WGPUTextureView>;\n    static inline void WGPUAddRef(WGPUTextureView handle);\n    static inline void WGPURelease(WGPUTextureView handle);\n};\n\n\n// ChainedStruct\nstatic_assert(sizeof(ChainedStruct) == sizeof(WGPUChainedStruct),\n    \"sizeof mismatch for ChainedStruct\");\nstatic_assert(alignof(ChainedStruct) == alignof(WGPUChainedStruct),\n    \"alignof mismatch for ChainedStruct\");\nstatic_assert(offsetof(ChainedStruct, nextInChain) == offsetof(WGPUChainedStruct, next),\n    \"offsetof mismatch for ChainedStruct::nextInChain\");\nstatic_assert(offsetof(ChainedStruct, sType) == offsetof(WGPUChainedStruct, sType),\n    \"offsetof mismatch for ChainedStruct::sType\");\n\n\n// Can be chained in AdapterInfo\nstruct AdapterPropertiesD3D : ChainedStructOut {\n    inline AdapterPropertiesD3D();\n\n    struct Init;\n    inline AdapterPropertiesD3D(Init&& init);\n    inline operator const WGPUAdapterPropertiesD3D&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t shaderModel;\n};\n\n// Can be chained in AdapterInfo\nstruct AdapterPropertiesSubgroups : ChainedStructOut {\n    inline AdapterPropertiesSubgroups();\n\n    struct Init;\n    inline AdapterPropertiesSubgroups(Init&& init);\n    inline operator const WGPUAdapterPropertiesSubgroups&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t subgroupMinSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t subgroupMaxSize = WGPU_LIMIT_U32_UNDEFINED;\n};\n\n// Can be chained in AdapterInfo\nstruct AdapterPropertiesVk : ChainedStructOut {\n    inline AdapterPropertiesVk();\n\n    struct Init;\n    inline AdapterPropertiesVk(Init&& init);\n    inline operator const WGPUAdapterPropertiesVk&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t driverVersion;\n};\n\nstruct BindGroupEntry {\n    inline operator const WGPUBindGroupEntry&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint32_t binding;\n    Buffer buffer = nullptr;\n    uint64_t offset = 0;\n    uint64_t size = WGPU_WHOLE_SIZE;\n    Sampler sampler = nullptr;\n    TextureView textureView = nullptr;\n};\n\nstruct BlendComponent {\n    inline operator const WGPUBlendComponent&() const noexcept;\n\n    BlendOperation operation = BlendOperation::Add;\n    BlendFactor srcFactor = BlendFactor::One;\n    BlendFactor dstFactor = BlendFactor::Zero;\n};\n\nstruct BufferBindingLayout {\n    inline operator const WGPUBufferBindingLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    BufferBindingType type = BufferBindingType::BindingNotUsed;\n    Bool hasDynamicOffset = false;\n    uint64_t minBindingSize = 0;\n};\n\n// Can be chained in BufferDescriptor\nstruct BufferHostMappedPointer : ChainedStruct {\n    inline BufferHostMappedPointer();\n\n    struct Init;\n    inline BufferHostMappedPointer(Init&& init);\n    inline operator const WGPUBufferHostMappedPointer&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * pointer;\n    Callback disposeCallback;\n    void * userdata;\n};\n\nstruct BufferMapCallbackInfo {\n    inline operator const WGPUBufferMapCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    BufferMapCallback callback;\n    void * userdata;\n};\n\nstruct Color {\n    inline operator const WGPUColor&() const noexcept;\n\n    double r;\n    double g;\n    double b;\n    double a;\n};\n\n// Can be chained in ColorTargetState\nstruct ColorTargetStateExpandResolveTextureDawn : ChainedStruct {\n    inline ColorTargetStateExpandResolveTextureDawn();\n\n    struct Init;\n    inline ColorTargetStateExpandResolveTextureDawn(Init&& init);\n    inline operator const WGPUColorTargetStateExpandResolveTextureDawn&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool enabled = false;\n};\n\nstruct CompilationInfoCallbackInfo {\n    inline operator const WGPUCompilationInfoCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    CompilationInfoCallback callback;\n    void * userdata = nullptr;\n};\n\nstruct ComputePassTimestampWrites {\n    inline operator const WGPUComputePassTimestampWrites&() const noexcept;\n\n    QuerySet querySet;\n    uint32_t beginningOfPassWriteIndex = WGPU_QUERY_SET_INDEX_UNDEFINED;\n    uint32_t endOfPassWriteIndex = WGPU_QUERY_SET_INDEX_UNDEFINED;\n};\n\nstruct CopyTextureForBrowserOptions {\n    inline operator const WGPUCopyTextureForBrowserOptions&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Bool flipY = false;\n    Bool needsColorSpaceConversion = false;\n    AlphaMode srcAlphaMode = AlphaMode::Unpremultiplied;\n    float const * srcTransferFunctionParameters = nullptr;\n    float const * conversionMatrix = nullptr;\n    float const * dstTransferFunctionParameters = nullptr;\n    AlphaMode dstAlphaMode = AlphaMode::Unpremultiplied;\n    Bool internalUsage = false;\n};\n\nstruct CreateComputePipelineAsyncCallbackInfo {\n    inline operator const WGPUCreateComputePipelineAsyncCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    CreateComputePipelineAsyncCallback callback;\n    void * userdata;\n};\n\nstruct CreateRenderPipelineAsyncCallbackInfo {\n    inline operator const WGPUCreateRenderPipelineAsyncCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    CreateRenderPipelineAsyncCallback callback;\n    void * userdata;\n};\n\n// Can be chained in InstanceDescriptor\nstruct DawnWGSLBlocklist : ChainedStruct {\n    inline DawnWGSLBlocklist();\n\n    struct Init;\n    inline DawnWGSLBlocklist(Init&& init);\n    inline operator const WGPUDawnWGSLBlocklist&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(size_t ));\n    alignas(kFirstMemberAlignment) size_t blocklistedFeatureCount = 0;\n    const char* const * blocklistedFeatures;\n};\n\n// Can be chained in AdapterInfo\nstruct DawnAdapterPropertiesPowerPreference : ChainedStructOut {\n    inline DawnAdapterPropertiesPowerPreference();\n\n    struct Init;\n    inline DawnAdapterPropertiesPowerPreference(Init&& init);\n    inline operator const WGPUDawnAdapterPropertiesPowerPreference&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(PowerPreference ));\n    alignas(kFirstMemberAlignment) PowerPreference powerPreference = PowerPreference::Undefined;\n};\n\n// Can be chained in BufferDescriptor\nstruct DawnBufferDescriptorErrorInfoFromWireClient : ChainedStruct {\n    inline DawnBufferDescriptorErrorInfoFromWireClient();\n\n    struct Init;\n    inline DawnBufferDescriptorErrorInfoFromWireClient(Init&& init);\n    inline operator const WGPUDawnBufferDescriptorErrorInfoFromWireClient&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool outOfMemory = false;\n};\n\n// Can be chained in CommandEncoderDescriptor\nstruct DawnEncoderInternalUsageDescriptor : ChainedStruct {\n    inline DawnEncoderInternalUsageDescriptor();\n\n    struct Init;\n    inline DawnEncoderInternalUsageDescriptor(Init&& init);\n    inline operator const WGPUDawnEncoderInternalUsageDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool useInternalUsages = false;\n};\n\n// Can be chained in SupportedLimits\nstruct DawnExperimentalImmediateDataLimits : ChainedStructOut {\n    inline DawnExperimentalImmediateDataLimits();\n\n    struct Init;\n    inline DawnExperimentalImmediateDataLimits(Init&& init);\n    inline operator const WGPUDawnExperimentalImmediateDataLimits&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t maxImmediateDataRangeByteSize = WGPU_LIMIT_U32_UNDEFINED;\n};\n\n// Can be chained in SupportedLimits\nstruct DawnExperimentalSubgroupLimits : ChainedStructOut {\n    inline DawnExperimentalSubgroupLimits();\n\n    struct Init;\n    inline DawnExperimentalSubgroupLimits(Init&& init);\n    inline operator const WGPUDawnExperimentalSubgroupLimits&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t minSubgroupSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxSubgroupSize = WGPU_LIMIT_U32_UNDEFINED;\n};\n\n// Can be chained in RenderPassColorAttachment\nstruct DawnRenderPassColorAttachmentRenderToSingleSampled : ChainedStruct {\n    inline DawnRenderPassColorAttachmentRenderToSingleSampled();\n\n    struct Init;\n    inline DawnRenderPassColorAttachmentRenderToSingleSampled(Init&& init);\n    inline operator const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t implicitSampleCount = 1;\n};\n\n// Can be chained in ShaderModuleDescriptor\nstruct DawnShaderModuleSPIRVOptionsDescriptor : ChainedStruct {\n    inline DawnShaderModuleSPIRVOptionsDescriptor();\n\n    struct Init;\n    inline DawnShaderModuleSPIRVOptionsDescriptor(Init&& init);\n    inline operator const WGPUDawnShaderModuleSPIRVOptionsDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool allowNonUniformDerivatives = false;\n};\n\n// Can be chained in SupportedLimits\nstruct DawnTexelCopyBufferRowAlignmentLimits : ChainedStructOut {\n    inline DawnTexelCopyBufferRowAlignmentLimits();\n\n    struct Init;\n    inline DawnTexelCopyBufferRowAlignmentLimits(Init&& init);\n    inline operator const WGPUDawnTexelCopyBufferRowAlignmentLimits&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t minTexelCopyBufferRowAlignment = WGPU_LIMIT_U32_UNDEFINED;\n};\n\n// Can be chained in TextureDescriptor\nstruct DawnTextureInternalUsageDescriptor : ChainedStruct {\n    inline DawnTextureInternalUsageDescriptor();\n\n    struct Init;\n    inline DawnTextureInternalUsageDescriptor(Init&& init);\n    inline operator const WGPUDawnTextureInternalUsageDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(TextureUsage ));\n    alignas(kFirstMemberAlignment) TextureUsage internalUsage = TextureUsage::None;\n};\n\n// Can be chained in InstanceDescriptor\n// Can be chained in RequestAdapterOptions\n// Can be chained in DeviceDescriptor\nstruct DawnTogglesDescriptor : ChainedStruct {\n    inline DawnTogglesDescriptor();\n\n    struct Init;\n    inline DawnTogglesDescriptor(Init&& init);\n    inline operator const WGPUDawnTogglesDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(size_t ));\n    alignas(kFirstMemberAlignment) size_t enabledToggleCount = 0;\n    const char* const * enabledToggles;\n    size_t disabledToggleCount = 0;\n    const char* const * disabledToggles;\n};\n\n// Can be chained in InstanceDescriptor\nstruct DawnWireWGSLControl : ChainedStruct {\n    inline DawnWireWGSLControl();\n\n    struct Init;\n    inline DawnWireWGSLControl(Init&& init);\n    inline operator const WGPUDawnWireWGSLControl&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool enableExperimental = false;\n    Bool enableUnsafe = false;\n    Bool enableTesting = false;\n};\n\nstruct DeviceLostCallbackInfo {\n    inline operator const WGPUDeviceLostCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode = CallbackMode::WaitAnyOnly;\n    DeviceLostCallbackNew callback = nullptr;\n    void * userdata = nullptr;\n};\n\nstruct DrmFormatProperties {\n    inline operator const WGPUDrmFormatProperties&() const noexcept;\n\n    uint64_t modifier;\n    uint32_t modifierPlaneCount;\n};\n\nstruct Extent2D {\n    inline operator const WGPUExtent2D&() const noexcept;\n\n    uint32_t width;\n    uint32_t height;\n};\n\nstruct Extent3D {\n    inline operator const WGPUExtent3D&() const noexcept;\n\n    uint32_t width;\n    uint32_t height = 1;\n    uint32_t depthOrArrayLayers = 1;\n};\n\n// Can be chained in BindGroupEntry\nstruct ExternalTextureBindingEntry : ChainedStruct {\n    inline ExternalTextureBindingEntry();\n\n    struct Init;\n    inline ExternalTextureBindingEntry(Init&& init);\n    inline operator const WGPUExternalTextureBindingEntry&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(ExternalTexture ));\n    alignas(kFirstMemberAlignment) ExternalTexture externalTexture;\n};\n\n// Can be chained in BindGroupLayoutEntry\nstruct ExternalTextureBindingLayout : ChainedStruct {\n    inline ExternalTextureBindingLayout();\n\n    struct Init;\n    inline ExternalTextureBindingLayout(Init&& init);\n    inline operator const WGPUExternalTextureBindingLayout&() const noexcept;\n\n};\n\nstruct FormatCapabilities {\n    inline operator const WGPUFormatCapabilities&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n};\n\nstruct Future {\n    inline operator const WGPUFuture&() const noexcept;\n\n    uint64_t id;\n};\n\nstruct InstanceFeatures {\n    inline operator const WGPUInstanceFeatures&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Bool timedWaitAnyEnable = false;\n    size_t timedWaitAnyMaxCount = 0;\n};\n\nstruct Limits {\n    inline operator const WGPULimits&() const noexcept;\n\n    uint32_t maxTextureDimension1D = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxTextureDimension2D = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxTextureDimension3D = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxTextureArrayLayers = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxBindGroups = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxBindGroupsPlusVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxBindingsPerBindGroup = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxDynamicUniformBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxDynamicStorageBuffersPerPipelineLayout = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxSampledTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxSamplersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxStorageBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxStorageTexturesPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxUniformBuffersPerShaderStage = WGPU_LIMIT_U32_UNDEFINED;\n    uint64_t maxUniformBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n    uint64_t maxStorageBufferBindingSize = WGPU_LIMIT_U64_UNDEFINED;\n    uint32_t minUniformBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t minStorageBufferOffsetAlignment = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxVertexBuffers = WGPU_LIMIT_U32_UNDEFINED;\n    uint64_t maxBufferSize = WGPU_LIMIT_U64_UNDEFINED;\n    uint32_t maxVertexAttributes = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxVertexBufferArrayStride = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxInterStageShaderComponents = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxInterStageShaderVariables = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxColorAttachments = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxColorAttachmentBytesPerSample = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupStorageSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeInvocationsPerWorkgroup = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupSizeX = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupSizeY = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupSizeZ = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxComputeWorkgroupsPerDimension = WGPU_LIMIT_U32_UNDEFINED;\n};\n\nstruct MemoryHeapInfo {\n    inline operator const WGPUMemoryHeapInfo&() const noexcept;\n\n    HeapProperty properties;\n    uint64_t size;\n};\n\nstruct MultisampleState {\n    inline operator const WGPUMultisampleState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint32_t count = 1;\n    uint32_t mask = 0xFFFFFFFF;\n    Bool alphaToCoverageEnabled = false;\n};\n\nstruct Origin2D {\n    inline operator const WGPUOrigin2D&() const noexcept;\n\n    uint32_t x = 0;\n    uint32_t y = 0;\n};\n\nstruct Origin3D {\n    inline operator const WGPUOrigin3D&() const noexcept;\n\n    uint32_t x = 0;\n    uint32_t y = 0;\n    uint32_t z = 0;\n};\n\nstruct PipelineLayoutStorageAttachment {\n    inline operator const WGPUPipelineLayoutStorageAttachment&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint64_t offset = 0;\n    TextureFormat format;\n};\n\nstruct PopErrorScopeCallbackInfo {\n    inline operator const WGPUPopErrorScopeCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode = CallbackMode::WaitAnyOnly;\n    PopErrorScopeCallback callback;\n    ErrorCallback oldCallback;\n    void * userdata = nullptr;\n};\n\nstruct PrimitiveState {\n    inline operator const WGPUPrimitiveState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    PrimitiveTopology topology = PrimitiveTopology::TriangleList;\n    IndexFormat stripIndexFormat = IndexFormat::Undefined;\n    FrontFace frontFace = FrontFace::CCW;\n    CullMode cullMode = CullMode::None;\n    Bool unclippedDepth = false;\n};\n\nstruct QueueWorkDoneCallbackInfo {\n    inline operator const WGPUQueueWorkDoneCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    QueueWorkDoneCallback callback;\n    void * userdata;\n};\n\nstruct RenderPassDepthStencilAttachment {\n    inline operator const WGPURenderPassDepthStencilAttachment&() const noexcept;\n\n    TextureView view;\n    LoadOp depthLoadOp = LoadOp::Undefined;\n    StoreOp depthStoreOp = StoreOp::Undefined;\n    float depthClearValue = NAN;\n    Bool depthReadOnly = false;\n    LoadOp stencilLoadOp = LoadOp::Undefined;\n    StoreOp stencilStoreOp = StoreOp::Undefined;\n    uint32_t stencilClearValue = 0;\n    Bool stencilReadOnly = false;\n};\n\n// Can be chained in RenderPassDescriptor\nstruct RenderPassDescriptorExpandResolveRect : ChainedStruct {\n    inline RenderPassDescriptorExpandResolveRect();\n\n    struct Init;\n    inline RenderPassDescriptorExpandResolveRect(Init&& init);\n    inline operator const WGPURenderPassDescriptorExpandResolveRect&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t x;\n    uint32_t y;\n    uint32_t width;\n    uint32_t height;\n};\n\n// Can be chained in RenderPassDescriptor\nstruct RenderPassMaxDrawCount : ChainedStruct {\n    inline RenderPassMaxDrawCount();\n\n    struct Init;\n    inline RenderPassMaxDrawCount(Init&& init);\n    inline operator const WGPURenderPassMaxDrawCount&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n    alignas(kFirstMemberAlignment) uint64_t maxDrawCount = 50000000;\n};\n\nstruct RenderPassTimestampWrites {\n    inline operator const WGPURenderPassTimestampWrites&() const noexcept;\n\n    QuerySet querySet;\n    uint32_t beginningOfPassWriteIndex = WGPU_QUERY_SET_INDEX_UNDEFINED;\n    uint32_t endOfPassWriteIndex = WGPU_QUERY_SET_INDEX_UNDEFINED;\n};\n\nstruct RequestAdapterCallbackInfo {\n    inline operator const WGPURequestAdapterCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    RequestAdapterCallback callback;\n    void * userdata;\n};\n\nstruct RequestAdapterOptions {\n    inline operator const WGPURequestAdapterOptions&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Surface compatibleSurface = nullptr;\n    PowerPreference powerPreference = PowerPreference::Undefined;\n    BackendType backendType = BackendType::Undefined;\n    Bool forceFallbackAdapter = false;\n    Bool compatibilityMode = false;\n};\n\nstruct RequestDeviceCallbackInfo {\n    inline operator const WGPURequestDeviceCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    CallbackMode mode;\n    RequestDeviceCallback callback;\n    void * userdata;\n};\n\nstruct SamplerBindingLayout {\n    inline operator const WGPUSamplerBindingLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    SamplerBindingType type = SamplerBindingType::BindingNotUsed;\n};\n\n// Can be chained in ShaderModuleDescriptor\nstruct ShaderModuleCompilationOptions : ChainedStruct {\n    inline ShaderModuleCompilationOptions();\n\n    struct Init;\n    inline ShaderModuleCompilationOptions(Init&& init);\n    inline operator const WGPUShaderModuleCompilationOptions&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool strictMath;\n};\n\n// Can be chained in ShaderModuleDescriptor\nstruct ShaderSourceSPIRV : ChainedStruct {\n    inline ShaderSourceSPIRV();\n\n    struct Init;\n    inline ShaderSourceSPIRV(Init&& init);\n    inline operator const WGPUShaderSourceSPIRV&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t codeSize;\n    uint32_t const * code;\n};\n\nstruct SharedBufferMemoryBeginAccessDescriptor {\n    inline operator const WGPUSharedBufferMemoryBeginAccessDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Bool initialized;\n    size_t fenceCount = 0;\n    SharedFence const * fences;\n    uint64_t const * signaledValues;\n};\n\nstruct SharedBufferMemoryEndAccessState {\n    inline SharedBufferMemoryEndAccessState();\n    inline ~SharedBufferMemoryEndAccessState();\n    SharedBufferMemoryEndAccessState(const SharedBufferMemoryEndAccessState&) = delete;\n    SharedBufferMemoryEndAccessState& operator=(const SharedBufferMemoryEndAccessState&) = delete;\n    inline SharedBufferMemoryEndAccessState(SharedBufferMemoryEndAccessState&&);\n    inline SharedBufferMemoryEndAccessState& operator=(SharedBufferMemoryEndAccessState&&);\n    inline operator const WGPUSharedBufferMemoryEndAccessState&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    Bool const initialized = {};\n    size_t const fenceCount = 0;\n    SharedFence const * const fences = {};\n    uint64_t const * const signaledValues = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(SharedBufferMemoryEndAccessState& value);\n};\n\nstruct SharedBufferMemoryProperties {\n    inline operator const WGPUSharedBufferMemoryProperties&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    BufferUsage usage;\n    uint64_t size;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceDXGISharedHandleDescriptor : ChainedStruct {\n    inline SharedFenceDXGISharedHandleDescriptor();\n\n    struct Init;\n    inline SharedFenceDXGISharedHandleDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceDXGISharedHandleDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * handle;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceDXGISharedHandleExportInfo : ChainedStructOut {\n    inline SharedFenceDXGISharedHandleExportInfo();\n\n    struct Init;\n    inline SharedFenceDXGISharedHandleExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceDXGISharedHandleExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * handle;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceMTLSharedEventDescriptor : ChainedStruct {\n    inline SharedFenceMTLSharedEventDescriptor();\n\n    struct Init;\n    inline SharedFenceMTLSharedEventDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceMTLSharedEventDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * sharedEvent;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceMTLSharedEventExportInfo : ChainedStructOut {\n    inline SharedFenceMTLSharedEventExportInfo();\n\n    struct Init;\n    inline SharedFenceMTLSharedEventExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceMTLSharedEventExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * sharedEvent;\n};\n\nstruct SharedFenceExportInfo {\n    inline operator const WGPUSharedFenceExportInfo&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    SharedFenceType type;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceSyncFDDescriptor : ChainedStruct {\n    inline SharedFenceSyncFDDescriptor();\n\n    struct Init;\n    inline SharedFenceSyncFDDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceSyncFDDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n    alignas(kFirstMemberAlignment) int handle;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceSyncFDExportInfo : ChainedStructOut {\n    inline SharedFenceSyncFDExportInfo();\n\n    struct Init;\n    inline SharedFenceSyncFDExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceSyncFDExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n    alignas(kFirstMemberAlignment) int handle;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceVkSemaphoreOpaqueFDDescriptor : ChainedStruct {\n    inline SharedFenceVkSemaphoreOpaqueFDDescriptor();\n\n    struct Init;\n    inline SharedFenceVkSemaphoreOpaqueFDDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n    alignas(kFirstMemberAlignment) int handle;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceVkSemaphoreOpaqueFDExportInfo : ChainedStructOut {\n    inline SharedFenceVkSemaphoreOpaqueFDExportInfo();\n\n    struct Init;\n    inline SharedFenceVkSemaphoreOpaqueFDExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int ));\n    alignas(kFirstMemberAlignment) int handle;\n};\n\n// Can be chained in SharedFenceDescriptor\nstruct SharedFenceVkSemaphoreZirconHandleDescriptor : ChainedStruct {\n    inline SharedFenceVkSemaphoreZirconHandleDescriptor();\n\n    struct Init;\n    inline SharedFenceVkSemaphoreZirconHandleDescriptor(Init&& init);\n    inline operator const WGPUSharedFenceVkSemaphoreZirconHandleDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t handle;\n};\n\n// Can be chained in SharedFenceExportInfo\nstruct SharedFenceVkSemaphoreZirconHandleExportInfo : ChainedStructOut {\n    inline SharedFenceVkSemaphoreZirconHandleExportInfo();\n\n    struct Init;\n    inline SharedFenceVkSemaphoreZirconHandleExportInfo(Init&& init);\n    inline operator const WGPUSharedFenceVkSemaphoreZirconHandleExportInfo&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t handle;\n};\n\n// Can be chained in SharedTextureMemoryBeginAccessDescriptor\nstruct SharedTextureMemoryD3DSwapchainBeginState : ChainedStruct {\n    inline SharedTextureMemoryD3DSwapchainBeginState();\n\n    struct Init;\n    inline SharedTextureMemoryD3DSwapchainBeginState(Init&& init);\n    inline operator const WGPUSharedTextureMemoryD3DSwapchainBeginState&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool isSwapchain = false;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryDXGISharedHandleDescriptor : ChainedStruct {\n    inline SharedTextureMemoryDXGISharedHandleDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryDXGISharedHandleDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryDXGISharedHandleDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * handle;\n    Bool useKeyedMutex;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryEGLImageDescriptor : ChainedStruct {\n    inline SharedTextureMemoryEGLImageDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryEGLImageDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryEGLImageDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * image;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryIOSurfaceDescriptor : ChainedStruct {\n    inline SharedTextureMemoryIOSurfaceDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryIOSurfaceDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryIOSurfaceDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * ioSurface;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryAHardwareBufferDescriptor : ChainedStruct {\n    inline SharedTextureMemoryAHardwareBufferDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryAHardwareBufferDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryAHardwareBufferDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * handle;\n    Bool useExternalFormat;\n};\n\nstruct SharedTextureMemoryBeginAccessDescriptor {\n    inline operator const WGPUSharedTextureMemoryBeginAccessDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Bool concurrentRead;\n    Bool initialized;\n    size_t fenceCount;\n    SharedFence const * fences;\n    uint64_t const * signaledValues;\n};\n\nstruct SharedTextureMemoryDmaBufPlane {\n    inline operator const WGPUSharedTextureMemoryDmaBufPlane&() const noexcept;\n\n    int fd;\n    uint64_t offset;\n    uint32_t stride;\n};\n\nstruct SharedTextureMemoryEndAccessState {\n    inline SharedTextureMemoryEndAccessState();\n    inline ~SharedTextureMemoryEndAccessState();\n    SharedTextureMemoryEndAccessState(const SharedTextureMemoryEndAccessState&) = delete;\n    SharedTextureMemoryEndAccessState& operator=(const SharedTextureMemoryEndAccessState&) = delete;\n    inline SharedTextureMemoryEndAccessState(SharedTextureMemoryEndAccessState&&);\n    inline SharedTextureMemoryEndAccessState& operator=(SharedTextureMemoryEndAccessState&&);\n    inline operator const WGPUSharedTextureMemoryEndAccessState&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    Bool const initialized = {};\n    size_t const fenceCount = {};\n    SharedFence const * const fences = {};\n    uint64_t const * const signaledValues = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(SharedTextureMemoryEndAccessState& value);\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryOpaqueFDDescriptor : ChainedStruct {\n    inline SharedTextureMemoryOpaqueFDDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryOpaqueFDDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryOpaqueFDDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void const * ));\n    alignas(kFirstMemberAlignment) void const * vkImageCreateInfo;\n    int memoryFD;\n    uint32_t memoryTypeIndex;\n    uint64_t allocationSize;\n    Bool dedicatedAllocation;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryVkDedicatedAllocationDescriptor : ChainedStruct {\n    inline SharedTextureMemoryVkDedicatedAllocationDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryVkDedicatedAllocationDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Bool ));\n    alignas(kFirstMemberAlignment) Bool dedicatedAllocation;\n};\n\n// Can be chained in SharedTextureMemoryBeginAccessDescriptor\nstruct SharedTextureMemoryVkImageLayoutBeginState : ChainedStruct {\n    inline SharedTextureMemoryVkImageLayoutBeginState();\n\n    struct Init;\n    inline SharedTextureMemoryVkImageLayoutBeginState(Init&& init);\n    inline operator const WGPUSharedTextureMemoryVkImageLayoutBeginState&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int32_t ));\n    alignas(kFirstMemberAlignment) int32_t oldLayout;\n    int32_t newLayout;\n};\n\n// Can be chained in SharedTextureMemoryEndAccessState\nstruct SharedTextureMemoryVkImageLayoutEndState : ChainedStructOut {\n    inline SharedTextureMemoryVkImageLayoutEndState();\n\n    struct Init;\n    inline SharedTextureMemoryVkImageLayoutEndState(Init&& init);\n    inline operator const WGPUSharedTextureMemoryVkImageLayoutEndState&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(int32_t ));\n    alignas(kFirstMemberAlignment) int32_t oldLayout;\n    int32_t newLayout;\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryZirconHandleDescriptor : ChainedStruct {\n    inline SharedTextureMemoryZirconHandleDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryZirconHandleDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryZirconHandleDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t memoryFD;\n    uint64_t allocationSize;\n};\n\n// Can be chained in BindGroupLayoutEntry\nstruct StaticSamplerBindingLayout : ChainedStruct {\n    inline StaticSamplerBindingLayout();\n\n    struct Init;\n    inline StaticSamplerBindingLayout(Init&& init);\n    inline operator const WGPUStaticSamplerBindingLayout&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Sampler ));\n    alignas(kFirstMemberAlignment) Sampler sampler;\n    uint32_t sampledTextureBinding = WGPU_LIMIT_U32_UNDEFINED;\n};\n\nstruct StencilFaceState {\n    inline operator const WGPUStencilFaceState&() const noexcept;\n\n    CompareFunction compare = CompareFunction::Always;\n    StencilOperation failOp = StencilOperation::Keep;\n    StencilOperation depthFailOp = StencilOperation::Keep;\n    StencilOperation passOp = StencilOperation::Keep;\n};\n\nstruct StorageTextureBindingLayout {\n    inline operator const WGPUStorageTextureBindingLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StorageTextureAccess access = StorageTextureAccess::BindingNotUsed;\n    TextureFormat format = TextureFormat::Undefined;\n    TextureViewDimension viewDimension = TextureViewDimension::e2D;\n};\n\nstruct SupportedFeatures {\n    inline SupportedFeatures();\n    inline ~SupportedFeatures();\n    SupportedFeatures(const SupportedFeatures&) = delete;\n    SupportedFeatures& operator=(const SupportedFeatures&) = delete;\n    inline SupportedFeatures(SupportedFeatures&&);\n    inline SupportedFeatures& operator=(SupportedFeatures&&);\n    inline operator const WGPUSupportedFeatures&() const noexcept;\n\n    size_t const featureCount = {};\n    FeatureName const * const features = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(SupportedFeatures& value);\n};\n\nstruct SurfaceCapabilities {\n    inline SurfaceCapabilities();\n    inline ~SurfaceCapabilities();\n    SurfaceCapabilities(const SurfaceCapabilities&) = delete;\n    SurfaceCapabilities& operator=(const SurfaceCapabilities&) = delete;\n    inline SurfaceCapabilities(SurfaceCapabilities&&);\n    inline SurfaceCapabilities& operator=(SurfaceCapabilities&&);\n    inline operator const WGPUSurfaceCapabilities&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    TextureUsage const usages = {};\n    size_t const formatCount = {};\n    TextureFormat const * const formats = {};\n    size_t const presentModeCount = {};\n    PresentMode const * const presentModes = {};\n    size_t const alphaModeCount = {};\n    CompositeAlphaMode const * const alphaModes = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(SurfaceCapabilities& value);\n};\n\nstruct SurfaceConfiguration {\n    inline operator const WGPUSurfaceConfiguration&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Device device;\n    TextureFormat format;\n    TextureUsage usage = TextureUsage::RenderAttachment;\n    size_t viewFormatCount = 0;\n    TextureFormat const * viewFormats = nullptr;\n    CompositeAlphaMode alphaMode = CompositeAlphaMode::Auto;\n    uint32_t width;\n    uint32_t height;\n    PresentMode presentMode = PresentMode::Fifo;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceDescriptorFromWindowsCoreWindow : ChainedStruct {\n    inline SurfaceDescriptorFromWindowsCoreWindow();\n\n    struct Init;\n    inline SurfaceDescriptorFromWindowsCoreWindow(Init&& init);\n    inline operator const WGPUSurfaceDescriptorFromWindowsCoreWindow&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * coreWindow;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceDescriptorFromWindowsSwapChainPanel : ChainedStruct {\n    inline SurfaceDescriptorFromWindowsSwapChainPanel();\n\n    struct Init;\n    inline SurfaceDescriptorFromWindowsSwapChainPanel(Init&& init);\n    inline operator const WGPUSurfaceDescriptorFromWindowsSwapChainPanel&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * swapChainPanel;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceXCBWindow : ChainedStruct {\n    inline SurfaceSourceXCBWindow();\n\n    struct Init;\n    inline SurfaceSourceXCBWindow(Init&& init);\n    inline operator const WGPUSurfaceSourceXCBWindow&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * connection;\n    uint32_t window;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceAndroidNativeWindow : ChainedStruct {\n    inline SurfaceSourceAndroidNativeWindow();\n\n    struct Init;\n    inline SurfaceSourceAndroidNativeWindow(Init&& init);\n    inline operator const WGPUSurfaceSourceAndroidNativeWindow&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * window;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceMetalLayer : ChainedStruct {\n    inline SurfaceSourceMetalLayer();\n\n    struct Init;\n    inline SurfaceSourceMetalLayer(Init&& init);\n    inline operator const WGPUSurfaceSourceMetalLayer&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * layer;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceWaylandSurface : ChainedStruct {\n    inline SurfaceSourceWaylandSurface();\n\n    struct Init;\n    inline SurfaceSourceWaylandSurface(Init&& init);\n    inline operator const WGPUSurfaceSourceWaylandSurface&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * display;\n    void * surface;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceWindowsHWND : ChainedStruct {\n    inline SurfaceSourceWindowsHWND();\n\n    struct Init;\n    inline SurfaceSourceWindowsHWND(Init&& init);\n    inline operator const WGPUSurfaceSourceWindowsHWND&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * hinstance;\n    void * hwnd;\n};\n\n// Can be chained in SurfaceDescriptor\nstruct SurfaceSourceXlibWindow : ChainedStruct {\n    inline SurfaceSourceXlibWindow();\n\n    struct Init;\n    inline SurfaceSourceXlibWindow(Init&& init);\n    inline operator const WGPUSurfaceSourceXlibWindow&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(void * ));\n    alignas(kFirstMemberAlignment) void * display;\n    uint64_t window;\n};\n\nstruct SurfaceTexture {\n    inline operator const WGPUSurfaceTexture&() const noexcept;\n\n    Texture texture;\n    Bool suboptimal;\n    SurfaceGetCurrentTextureStatus status;\n};\n\nstruct TextureBindingLayout {\n    inline operator const WGPUTextureBindingLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    TextureSampleType sampleType = TextureSampleType::BindingNotUsed;\n    TextureViewDimension viewDimension = TextureViewDimension::e2D;\n    Bool multisampled = false;\n};\n\n// Can be chained in TextureDescriptor\nstruct TextureBindingViewDimensionDescriptor : ChainedStruct {\n    inline TextureBindingViewDimensionDescriptor();\n\n    struct Init;\n    inline TextureBindingViewDimensionDescriptor(Init&& init);\n    inline operator const WGPUTextureBindingViewDimensionDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(TextureViewDimension ));\n    alignas(kFirstMemberAlignment) TextureViewDimension textureBindingViewDimension = TextureViewDimension::Undefined;\n};\n\nstruct TextureDataLayout {\n    inline operator const WGPUTextureDataLayout&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint64_t offset = 0;\n    uint32_t bytesPerRow = WGPU_COPY_STRIDE_UNDEFINED;\n    uint32_t rowsPerImage = WGPU_COPY_STRIDE_UNDEFINED;\n};\n\nstruct UncapturedErrorCallbackInfo {\n    inline operator const WGPUUncapturedErrorCallbackInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ErrorCallback callback = nullptr;\n    void * userdata = nullptr;\n};\n\nstruct VertexAttribute {\n    inline operator const WGPUVertexAttribute&() const noexcept;\n\n    VertexFormat format;\n    uint64_t offset;\n    uint32_t shaderLocation;\n};\n\n// Can be chained in SamplerDescriptor\n// Can be chained in TextureViewDescriptor\nstruct YCbCrVkDescriptor : ChainedStruct {\n    inline YCbCrVkDescriptor();\n\n    struct Init;\n    inline YCbCrVkDescriptor(Init&& init);\n    inline operator const WGPUYCbCrVkDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint32_t ));\n    alignas(kFirstMemberAlignment) uint32_t vkFormat = 0;\n    uint32_t vkYCbCrModel = 0;\n    uint32_t vkYCbCrRange = 0;\n    uint32_t vkComponentSwizzleRed = 0;\n    uint32_t vkComponentSwizzleGreen = 0;\n    uint32_t vkComponentSwizzleBlue = 0;\n    uint32_t vkComponentSwizzleAlpha = 0;\n    uint32_t vkXChromaOffset = 0;\n    uint32_t vkYChromaOffset = 0;\n    FilterMode vkChromaFilter = FilterMode::Nearest;\n    Bool forceExplicitReconstruction = false;\n    uint64_t externalFormat = 0;\n};\n\nstruct AHardwareBufferProperties {\n    inline operator const WGPUAHardwareBufferProperties&() const noexcept;\n\n    YCbCrVkDescriptor yCbCrInfo = {};\n};\n\nstruct AdapterInfo {\n    inline AdapterInfo();\n    inline ~AdapterInfo();\n    AdapterInfo(const AdapterInfo&) = delete;\n    AdapterInfo& operator=(const AdapterInfo&) = delete;\n    inline AdapterInfo(AdapterInfo&&);\n    inline AdapterInfo& operator=(AdapterInfo&&);\n    inline operator const WGPUAdapterInfo&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    StringView const vendor = {};\n    StringView const architecture = {};\n    StringView const device = {};\n    StringView const description = {};\n    BackendType const backendType = {};\n    AdapterType const adapterType = {};\n    uint32_t const vendorID = {};\n    uint32_t const deviceID = {};\n    Bool const compatibilityMode = false;\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(AdapterInfo& value);\n};\n\n// Can be chained in AdapterInfo\nstruct AdapterPropertiesMemoryHeaps : ChainedStructOut {\n    inline AdapterPropertiesMemoryHeaps();\n\n    struct Init;\n    inline AdapterPropertiesMemoryHeaps(Init&& init);\n    inline ~AdapterPropertiesMemoryHeaps();\n    AdapterPropertiesMemoryHeaps(const AdapterPropertiesMemoryHeaps&) = delete;\n    AdapterPropertiesMemoryHeaps& operator=(const AdapterPropertiesMemoryHeaps&) = delete;\n    inline AdapterPropertiesMemoryHeaps(AdapterPropertiesMemoryHeaps&&);\n    inline AdapterPropertiesMemoryHeaps& operator=(AdapterPropertiesMemoryHeaps&&);\n    inline operator const WGPUAdapterPropertiesMemoryHeaps&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(size_t ));\n    alignas(kFirstMemberAlignment) size_t const heapCount = {};\n    MemoryHeapInfo const * const heapInfo = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(AdapterPropertiesMemoryHeaps& value);\n};\n\nstruct BindGroupDescriptor {\n    inline operator const WGPUBindGroupDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    BindGroupLayout layout;\n    size_t entryCount;\n    BindGroupEntry const * entries;\n};\n\nstruct BindGroupLayoutEntry {\n    inline operator const WGPUBindGroupLayoutEntry&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint32_t binding;\n    ShaderStage visibility;\n    BufferBindingLayout buffer = {};\n    SamplerBindingLayout sampler = {};\n    TextureBindingLayout texture = {};\n    StorageTextureBindingLayout storageTexture = {};\n};\n\nstruct BlendState {\n    inline operator const WGPUBlendState&() const noexcept;\n\n    BlendComponent color = {};\n    BlendComponent alpha = {};\n};\n\nstruct BufferDescriptor {\n    inline operator const WGPUBufferDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    BufferUsage usage;\n    uint64_t size;\n    Bool mappedAtCreation = false;\n};\n\nstruct CommandBufferDescriptor {\n    inline operator const WGPUCommandBufferDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct CommandEncoderDescriptor {\n    inline operator const WGPUCommandEncoderDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct CompilationMessage {\n    inline operator const WGPUCompilationMessage&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView message = {};\n    CompilationMessageType type;\n    uint64_t lineNum;\n    uint64_t linePos;\n    uint64_t offset;\n    uint64_t length;\n    uint64_t utf16LinePos;\n    uint64_t utf16Offset;\n    uint64_t utf16Length;\n};\n\nstruct ComputePassDescriptor {\n    inline operator const WGPUComputePassDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    ComputePassTimestampWrites const * timestampWrites = nullptr;\n};\n\nstruct ConstantEntry {\n    inline operator const WGPUConstantEntry&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView key = {};\n    double value;\n};\n\n// Can be chained in DeviceDescriptor\nstruct DawnCacheDeviceDescriptor : ChainedStruct {\n    inline DawnCacheDeviceDescriptor();\n\n    struct Init;\n    inline DawnCacheDeviceDescriptor(Init&& init);\n    inline operator const WGPUDawnCacheDeviceDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(StringView ));\n    alignas(kFirstMemberAlignment) StringView isolationKey = {};\n    DawnLoadCacheDataFunction loadDataFunction = nullptr;\n    DawnStoreCacheDataFunction storeDataFunction = nullptr;\n    void * functionUserdata = nullptr;\n};\n\nstruct DepthStencilState {\n    inline operator const WGPUDepthStencilState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    TextureFormat format;\n    OptionalBool depthWriteEnabled = OptionalBool::Undefined;\n    CompareFunction depthCompare = CompareFunction::Undefined;\n    StencilFaceState stencilFront = {};\n    StencilFaceState stencilBack = {};\n    uint32_t stencilReadMask = 0xFFFFFFFF;\n    uint32_t stencilWriteMask = 0xFFFFFFFF;\n    int32_t depthBias = 0;\n    float depthBiasSlopeScale = 0.0f;\n    float depthBiasClamp = 0.0f;\n};\n\n// Can be chained in FormatCapabilities\nstruct DrmFormatCapabilities : ChainedStructOut {\n    inline DrmFormatCapabilities();\n\n    struct Init;\n    inline DrmFormatCapabilities(Init&& init);\n    inline ~DrmFormatCapabilities();\n    DrmFormatCapabilities(const DrmFormatCapabilities&) = delete;\n    DrmFormatCapabilities& operator=(const DrmFormatCapabilities&) = delete;\n    inline DrmFormatCapabilities(DrmFormatCapabilities&&);\n    inline DrmFormatCapabilities& operator=(DrmFormatCapabilities&&);\n    inline operator const WGPUDrmFormatCapabilities&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(size_t ));\n    alignas(kFirstMemberAlignment) size_t const propertiesCount = {};\n    DrmFormatProperties const * const properties = {};\n\n  private:\n    inline void FreeMembers();\n    static inline void Reset(DrmFormatCapabilities& value);\n};\n\nstruct ExternalTextureDescriptor {\n    inline operator const WGPUExternalTextureDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    TextureView plane0;\n    TextureView plane1 = nullptr;\n    Origin2D cropOrigin = {};\n    Extent2D cropSize = {};\n    Extent2D apparentSize = {};\n    Bool doYuvToRgbConversionOnly = false;\n    float const * yuvToRgbConversionMatrix = nullptr;\n    float const * srcTransferFunctionParameters;\n    float const * dstTransferFunctionParameters;\n    float const * gamutConversionMatrix;\n    Bool mirrored = false;\n    ExternalTextureRotation rotation = ExternalTextureRotation::Rotate0Degrees;\n};\n\nstruct FutureWaitInfo {\n    inline operator const WGPUFutureWaitInfo&() const noexcept;\n\n    Future future = {};\n    Bool completed = false;\n};\n\nstruct ImageCopyBuffer {\n    inline operator const WGPUImageCopyBuffer&() const noexcept;\n\n    TextureDataLayout layout = {};\n    Buffer buffer;\n};\n\nstruct ImageCopyExternalTexture {\n    inline operator const WGPUImageCopyExternalTexture&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ExternalTexture externalTexture;\n    Origin3D origin = {};\n    Extent2D naturalSize = {};\n};\n\nstruct ImageCopyTexture {\n    inline operator const WGPUImageCopyTexture&() const noexcept;\n\n    Texture texture;\n    uint32_t mipLevel = 0;\n    Origin3D origin = {};\n    TextureAspect aspect = TextureAspect::All;\n};\n\nstruct InstanceDescriptor {\n    inline operator const WGPUInstanceDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    InstanceFeatures features = {};\n};\n\nstruct PipelineLayoutDescriptor {\n    inline operator const WGPUPipelineLayoutDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t bindGroupLayoutCount;\n    BindGroupLayout const * bindGroupLayouts = nullptr;\n    uint32_t immediateDataRangeByteSize = 0;\n};\n\n// Can be chained in PipelineLayoutDescriptor\nstruct PipelineLayoutPixelLocalStorage : ChainedStruct {\n    inline PipelineLayoutPixelLocalStorage();\n\n    struct Init;\n    inline PipelineLayoutPixelLocalStorage(Init&& init);\n    inline operator const WGPUPipelineLayoutPixelLocalStorage&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n    alignas(kFirstMemberAlignment) uint64_t totalPixelLocalStorageSize;\n    size_t storageAttachmentCount = 0;\n    PipelineLayoutStorageAttachment const * storageAttachments;\n};\n\nstruct QuerySetDescriptor {\n    inline operator const WGPUQuerySetDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    QueryType type;\n    uint32_t count;\n};\n\nstruct QueueDescriptor {\n    inline operator const WGPUQueueDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct RenderBundleDescriptor {\n    inline operator const WGPURenderBundleDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct RenderBundleEncoderDescriptor {\n    inline operator const WGPURenderBundleEncoderDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t colorFormatCount;\n    TextureFormat const * colorFormats;\n    TextureFormat depthStencilFormat = TextureFormat::Undefined;\n    uint32_t sampleCount = 1;\n    Bool depthReadOnly = false;\n    Bool stencilReadOnly = false;\n};\n\nstruct RenderPassColorAttachment {\n    inline operator const WGPURenderPassColorAttachment&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    TextureView view = nullptr;\n    uint32_t depthSlice = WGPU_DEPTH_SLICE_UNDEFINED;\n    TextureView resolveTarget = nullptr;\n    LoadOp loadOp;\n    StoreOp storeOp;\n    Color clearValue = {};\n};\n\nstruct RenderPassStorageAttachment {\n    inline operator const WGPURenderPassStorageAttachment&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    uint64_t offset = 0;\n    TextureView storage;\n    LoadOp loadOp;\n    StoreOp storeOp;\n    Color clearValue = {};\n};\n\nstruct RequiredLimits {\n    inline operator const WGPURequiredLimits&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    Limits limits = {};\n};\n\nstruct SamplerDescriptor {\n    inline operator const WGPUSamplerDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    AddressMode addressModeU = AddressMode::ClampToEdge;\n    AddressMode addressModeV = AddressMode::ClampToEdge;\n    AddressMode addressModeW = AddressMode::ClampToEdge;\n    FilterMode magFilter = FilterMode::Nearest;\n    FilterMode minFilter = FilterMode::Nearest;\n    MipmapFilterMode mipmapFilter = MipmapFilterMode::Nearest;\n    float lodMinClamp = 0.0f;\n    float lodMaxClamp = 32.0f;\n    CompareFunction compare = CompareFunction::Undefined;\n    uint16_t maxAnisotropy = 1;\n};\n\nstruct ShaderModuleDescriptor {\n    inline operator const WGPUShaderModuleDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\n// Can be chained in ShaderModuleDescriptor\nstruct ShaderSourceWGSL : ChainedStruct {\n    inline ShaderSourceWGSL();\n\n    struct Init;\n    inline ShaderSourceWGSL(Init&& init);\n    inline operator const WGPUShaderSourceWGSL&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(StringView ));\n    alignas(kFirstMemberAlignment) StringView code = {};\n};\n\nstruct SharedBufferMemoryDescriptor {\n    inline operator const WGPUSharedBufferMemoryDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct SharedFenceDescriptor {\n    inline operator const WGPUSharedFenceDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\n// Can be chained in SharedTextureMemoryProperties\nstruct SharedTextureMemoryAHardwareBufferProperties : ChainedStructOut {\n    inline SharedTextureMemoryAHardwareBufferProperties();\n\n    struct Init;\n    inline SharedTextureMemoryAHardwareBufferProperties(Init&& init);\n    inline operator const WGPUSharedTextureMemoryAHardwareBufferProperties&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(YCbCrVkDescriptor ));\n    alignas(kFirstMemberAlignment) YCbCrVkDescriptor yCbCrInfo = {};\n};\n\nstruct SharedTextureMemoryDescriptor {\n    inline operator const WGPUSharedTextureMemoryDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\n// Can be chained in SharedTextureMemoryDescriptor\nstruct SharedTextureMemoryDmaBufDescriptor : ChainedStruct {\n    inline SharedTextureMemoryDmaBufDescriptor();\n\n    struct Init;\n    inline SharedTextureMemoryDmaBufDescriptor(Init&& init);\n    inline operator const WGPUSharedTextureMemoryDmaBufDescriptor&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(Extent3D ));\n    alignas(kFirstMemberAlignment) Extent3D size = {};\n    uint32_t drmFormat;\n    uint64_t drmModifier;\n    size_t planeCount;\n    SharedTextureMemoryDmaBufPlane const * planes;\n};\n\nstruct SharedTextureMemoryProperties {\n    inline operator const WGPUSharedTextureMemoryProperties&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    TextureUsage usage;\n    Extent3D size = {};\n    TextureFormat format;\n};\n\nstruct SupportedLimits {\n    inline operator const WGPUSupportedLimits&() const noexcept;\n\n    ChainedStructOut  * nextInChain = nullptr;\n    Limits limits = {};\n};\n\nstruct SurfaceDescriptor {\n    inline operator const WGPUSurfaceDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n};\n\nstruct TextureDescriptor {\n    inline operator const WGPUTextureDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    TextureUsage usage;\n    TextureDimension dimension = TextureDimension::e2D;\n    Extent3D size = {};\n    TextureFormat format;\n    uint32_t mipLevelCount = 1;\n    uint32_t sampleCount = 1;\n    size_t viewFormatCount = 0;\n    TextureFormat const * viewFormats = nullptr;\n};\n\nstruct TextureViewDescriptor {\n    inline operator const WGPUTextureViewDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    TextureFormat format = TextureFormat::Undefined;\n    TextureViewDimension dimension = TextureViewDimension::Undefined;\n    uint32_t baseMipLevel = 0;\n    uint32_t mipLevelCount = WGPU_MIP_LEVEL_COUNT_UNDEFINED;\n    uint32_t baseArrayLayer = 0;\n    uint32_t arrayLayerCount = WGPU_ARRAY_LAYER_COUNT_UNDEFINED;\n    TextureAspect aspect = TextureAspect::All;\n    TextureUsage usage = TextureUsage::None;\n};\n\nstruct VertexBufferLayout {\n    inline operator const WGPUVertexBufferLayout&() const noexcept;\n\n    uint64_t arrayStride;\n    VertexStepMode stepMode;\n    size_t attributeCount;\n    VertexAttribute const * attributes;\n};\n\nstruct BindGroupLayoutDescriptor {\n    inline operator const WGPUBindGroupLayoutDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t entryCount;\n    BindGroupLayoutEntry const * entries;\n};\n\nstruct ColorTargetState {\n    inline operator const WGPUColorTargetState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    TextureFormat format;\n    BlendState const * blend = nullptr;\n    ColorWriteMask writeMask = ColorWriteMask::All;\n};\n\nstruct CompilationInfo {\n    inline operator const WGPUCompilationInfo&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    size_t messageCount;\n    CompilationMessage const * messages;\n};\n\nstruct ComputeState {\n    inline operator const WGPUComputeState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ShaderModule module;\n    StringView entryPoint = {};\n    size_t constantCount = 0;\n    ConstantEntry const * constants;\n};\n\nstruct RenderPassDescriptor {\n    inline operator const WGPURenderPassDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t colorAttachmentCount;\n    RenderPassColorAttachment const * colorAttachments;\n    RenderPassDepthStencilAttachment const * depthStencilAttachment = nullptr;\n    QuerySet occlusionQuerySet = nullptr;\n    RenderPassTimestampWrites const * timestampWrites = nullptr;\n};\n\n// Can be chained in RenderPassDescriptor\nstruct RenderPassPixelLocalStorage : ChainedStruct {\n    inline RenderPassPixelLocalStorage();\n\n    struct Init;\n    inline RenderPassPixelLocalStorage(Init&& init);\n    inline operator const WGPURenderPassPixelLocalStorage&() const noexcept;\n\n    static constexpr size_t kFirstMemberAlignment = detail::ConstexprMax(alignof(ChainedStruct), alignof(uint64_t ));\n    alignas(kFirstMemberAlignment) uint64_t totalPixelLocalStorageSize;\n    size_t storageAttachmentCount = 0;\n    RenderPassStorageAttachment const * storageAttachments;\n};\n\nstruct VertexState {\n    inline operator const WGPUVertexState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ShaderModule module;\n    StringView entryPoint = {};\n    size_t constantCount = 0;\n    ConstantEntry const * constants;\n    size_t bufferCount = 0;\n    VertexBufferLayout const * buffers;\n};\n\nstruct ComputePipelineDescriptor {\n    inline operator const WGPUComputePipelineDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    PipelineLayout layout = nullptr;\n    ComputeState compute = {};\n};\n\nstruct FragmentState {\n    inline operator const WGPUFragmentState&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    ShaderModule module;\n    StringView entryPoint = {};\n    size_t constantCount = 0;\n    ConstantEntry const * constants;\n    size_t targetCount;\n    ColorTargetState const * targets;\n};\n\nstruct RenderPipelineDescriptor {\n    inline operator const WGPURenderPipelineDescriptor&() const noexcept;\n\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    PipelineLayout layout = nullptr;\n    VertexState vertex = {};\n    PrimitiveState primitive = {};\n    DepthStencilState const * depthStencil = nullptr;\n    MultisampleState multisample = {};\n    FragmentState const * fragment = nullptr;\n};\n\n\nnamespace detail {\nstruct DeviceDescriptor {\n    ChainedStruct const * nextInChain = nullptr;\n    StringView label = {};\n    size_t requiredFeatureCount = 0;\n    FeatureName const * requiredFeatures = nullptr;\n    RequiredLimits const * requiredLimits = nullptr;\n    QueueDescriptor defaultQueue = {};\n    WGPUDeviceLostCallbackInfo2 deviceLostCallbackInfo2 = WGPU_DEVICE_LOST_CALLBACK_INFO_2_INIT;\n    WGPUUncapturedErrorCallbackInfo2 uncapturedErrorCallbackInfo2 = WGPU_UNCAPTURED_ERROR_CALLBACK_INFO_2_INIT;\n};\n}  // namespace detail\nstruct DeviceDescriptor : protected detail::DeviceDescriptor {\n    inline operator const WGPUDeviceDescriptor&() const noexcept;\n\n    using detail::DeviceDescriptor::nextInChain;\n    using detail::DeviceDescriptor::label;\n    using detail::DeviceDescriptor::requiredFeatureCount;\n    using detail::DeviceDescriptor::requiredFeatures;\n    using detail::DeviceDescriptor::requiredLimits;\n    using detail::DeviceDescriptor::defaultQueue;\n\n    inline DeviceDescriptor();\n    struct Init;\n    inline DeviceDescriptor(Init&& init);\n\n    template <typename F, typename T,\n              typename Cb = DeviceLostCallback2<T>,\n              typename CbChar = void (const Device& device, DeviceLostReason reason, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    void SetDeviceLostCallback(CallbackMode callbackMode, F callback, T userdata);\n    template <typename L,\n              typename Cb = DeviceLostCallback2<>,\n              typename CbChar = std::function<void(const Device& device, DeviceLostReason reason, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    void SetDeviceLostCallback(CallbackMode callbackMode, L callback);\n\n    template <typename F, typename T,\n              typename Cb = UncapturedErrorCallback<T>,\n              typename CbChar = void (const Device& device, ErrorType type, const char* message, T userdata),\n              typename = std::enable_if_t<std::is_convertible_v<F, Cb*> || std::is_convertible_v<F, CbChar*>>>\n    void SetUncapturedErrorCallback(F callback, T userdata);\n    template <typename L,\n              typename Cb = UncapturedErrorCallback<>,\n              typename CbChar = std::function<void(const Device& device, ErrorType type, const char* message)>,\n              typename = std::enable_if_t<std::is_convertible_v<L, Cb> || std::is_convertible_v<L, CbChar>>>\n    void SetUncapturedErrorCallback(L callback);\n};\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic push\n// error: 'offsetof' within non-standard-layout type 'wgpu::XXX' is conditionally-supported\n#pragma GCC diagnostic ignored \"-Winvalid-offsetof\"\n#endif\n\n// AdapterPropertiesD3D implementation\nAdapterPropertiesD3D::AdapterPropertiesD3D()\n  : ChainedStructOut { nullptr, SType::AdapterPropertiesD3D } {}\nstruct AdapterPropertiesD3D::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t shaderModel;\n};\nAdapterPropertiesD3D::AdapterPropertiesD3D(AdapterPropertiesD3D::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::AdapterPropertiesD3D }, \n    shaderModel(std::move(init.shaderModel)){}\n\nAdapterPropertiesD3D::operator const WGPUAdapterPropertiesD3D&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterPropertiesD3D*>(this);\n}\n\nstatic_assert(sizeof(AdapterPropertiesD3D) == sizeof(WGPUAdapterPropertiesD3D), \"sizeof mismatch for AdapterPropertiesD3D\");\nstatic_assert(alignof(AdapterPropertiesD3D) == alignof(WGPUAdapterPropertiesD3D), \"alignof mismatch for AdapterPropertiesD3D\");\nstatic_assert(offsetof(AdapterPropertiesD3D, shaderModel) == offsetof(WGPUAdapterPropertiesD3D, shaderModel),\n        \"offsetof mismatch for AdapterPropertiesD3D::shaderModel\");\n\n// AdapterPropertiesSubgroups implementation\nAdapterPropertiesSubgroups::AdapterPropertiesSubgroups()\n  : ChainedStructOut { nullptr, SType::AdapterPropertiesSubgroups } {}\nstruct AdapterPropertiesSubgroups::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t subgroupMinSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t subgroupMaxSize = WGPU_LIMIT_U32_UNDEFINED;\n};\nAdapterPropertiesSubgroups::AdapterPropertiesSubgroups(AdapterPropertiesSubgroups::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::AdapterPropertiesSubgroups }, \n    subgroupMinSize(std::move(init.subgroupMinSize)), \n    subgroupMaxSize(std::move(init.subgroupMaxSize)){}\n\nAdapterPropertiesSubgroups::operator const WGPUAdapterPropertiesSubgroups&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterPropertiesSubgroups*>(this);\n}\n\nstatic_assert(sizeof(AdapterPropertiesSubgroups) == sizeof(WGPUAdapterPropertiesSubgroups), \"sizeof mismatch for AdapterPropertiesSubgroups\");\nstatic_assert(alignof(AdapterPropertiesSubgroups) == alignof(WGPUAdapterPropertiesSubgroups), \"alignof mismatch for AdapterPropertiesSubgroups\");\nstatic_assert(offsetof(AdapterPropertiesSubgroups, subgroupMinSize) == offsetof(WGPUAdapterPropertiesSubgroups, subgroupMinSize),\n        \"offsetof mismatch for AdapterPropertiesSubgroups::subgroupMinSize\");\nstatic_assert(offsetof(AdapterPropertiesSubgroups, subgroupMaxSize) == offsetof(WGPUAdapterPropertiesSubgroups, subgroupMaxSize),\n        \"offsetof mismatch for AdapterPropertiesSubgroups::subgroupMaxSize\");\n\n// AdapterPropertiesVk implementation\nAdapterPropertiesVk::AdapterPropertiesVk()\n  : ChainedStructOut { nullptr, SType::AdapterPropertiesVk } {}\nstruct AdapterPropertiesVk::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t driverVersion;\n};\nAdapterPropertiesVk::AdapterPropertiesVk(AdapterPropertiesVk::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::AdapterPropertiesVk }, \n    driverVersion(std::move(init.driverVersion)){}\n\nAdapterPropertiesVk::operator const WGPUAdapterPropertiesVk&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterPropertiesVk*>(this);\n}\n\nstatic_assert(sizeof(AdapterPropertiesVk) == sizeof(WGPUAdapterPropertiesVk), \"sizeof mismatch for AdapterPropertiesVk\");\nstatic_assert(alignof(AdapterPropertiesVk) == alignof(WGPUAdapterPropertiesVk), \"alignof mismatch for AdapterPropertiesVk\");\nstatic_assert(offsetof(AdapterPropertiesVk, driverVersion) == offsetof(WGPUAdapterPropertiesVk, driverVersion),\n        \"offsetof mismatch for AdapterPropertiesVk::driverVersion\");\n\n// BindGroupEntry implementation\n\nBindGroupEntry::operator const WGPUBindGroupEntry&() const noexcept {\n    return *reinterpret_cast<const WGPUBindGroupEntry*>(this);\n}\n\nstatic_assert(sizeof(BindGroupEntry) == sizeof(WGPUBindGroupEntry), \"sizeof mismatch for BindGroupEntry\");\nstatic_assert(alignof(BindGroupEntry) == alignof(WGPUBindGroupEntry), \"alignof mismatch for BindGroupEntry\");\nstatic_assert(offsetof(BindGroupEntry, nextInChain) == offsetof(WGPUBindGroupEntry, nextInChain),\n        \"offsetof mismatch for BindGroupEntry::nextInChain\");\nstatic_assert(offsetof(BindGroupEntry, binding) == offsetof(WGPUBindGroupEntry, binding),\n        \"offsetof mismatch for BindGroupEntry::binding\");\nstatic_assert(offsetof(BindGroupEntry, buffer) == offsetof(WGPUBindGroupEntry, buffer),\n        \"offsetof mismatch for BindGroupEntry::buffer\");\nstatic_assert(offsetof(BindGroupEntry, offset) == offsetof(WGPUBindGroupEntry, offset),\n        \"offsetof mismatch for BindGroupEntry::offset\");\nstatic_assert(offsetof(BindGroupEntry, size) == offsetof(WGPUBindGroupEntry, size),\n        \"offsetof mismatch for BindGroupEntry::size\");\nstatic_assert(offsetof(BindGroupEntry, sampler) == offsetof(WGPUBindGroupEntry, sampler),\n        \"offsetof mismatch for BindGroupEntry::sampler\");\nstatic_assert(offsetof(BindGroupEntry, textureView) == offsetof(WGPUBindGroupEntry, textureView),\n        \"offsetof mismatch for BindGroupEntry::textureView\");\n\n// BlendComponent implementation\n\nBlendComponent::operator const WGPUBlendComponent&() const noexcept {\n    return *reinterpret_cast<const WGPUBlendComponent*>(this);\n}\n\nstatic_assert(sizeof(BlendComponent) == sizeof(WGPUBlendComponent), \"sizeof mismatch for BlendComponent\");\nstatic_assert(alignof(BlendComponent) == alignof(WGPUBlendComponent), \"alignof mismatch for BlendComponent\");\nstatic_assert(offsetof(BlendComponent, operation) == offsetof(WGPUBlendComponent, operation),\n        \"offsetof mismatch for BlendComponent::operation\");\nstatic_assert(offsetof(BlendComponent, srcFactor) == offsetof(WGPUBlendComponent, srcFactor),\n        \"offsetof mismatch for BlendComponent::srcFactor\");\nstatic_assert(offsetof(BlendComponent, dstFactor) == offsetof(WGPUBlendComponent, dstFactor),\n        \"offsetof mismatch for BlendComponent::dstFactor\");\n\n// BufferBindingLayout implementation\n\nBufferBindingLayout::operator const WGPUBufferBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUBufferBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(BufferBindingLayout) == sizeof(WGPUBufferBindingLayout), \"sizeof mismatch for BufferBindingLayout\");\nstatic_assert(alignof(BufferBindingLayout) == alignof(WGPUBufferBindingLayout), \"alignof mismatch for BufferBindingLayout\");\nstatic_assert(offsetof(BufferBindingLayout, nextInChain) == offsetof(WGPUBufferBindingLayout, nextInChain),\n        \"offsetof mismatch for BufferBindingLayout::nextInChain\");\nstatic_assert(offsetof(BufferBindingLayout, type) == offsetof(WGPUBufferBindingLayout, type),\n        \"offsetof mismatch for BufferBindingLayout::type\");\nstatic_assert(offsetof(BufferBindingLayout, hasDynamicOffset) == offsetof(WGPUBufferBindingLayout, hasDynamicOffset),\n        \"offsetof mismatch for BufferBindingLayout::hasDynamicOffset\");\nstatic_assert(offsetof(BufferBindingLayout, minBindingSize) == offsetof(WGPUBufferBindingLayout, minBindingSize),\n        \"offsetof mismatch for BufferBindingLayout::minBindingSize\");\n\n// BufferHostMappedPointer implementation\nBufferHostMappedPointer::BufferHostMappedPointer()\n  : ChainedStruct { nullptr, SType::BufferHostMappedPointer } {}\nstruct BufferHostMappedPointer::Init {\n    ChainedStruct * const nextInChain;\n    void * pointer;\n    Callback disposeCallback;\n    void * userdata;\n};\nBufferHostMappedPointer::BufferHostMappedPointer(BufferHostMappedPointer::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::BufferHostMappedPointer }, \n    pointer(std::move(init.pointer)), \n    disposeCallback(std::move(init.disposeCallback)), \n    userdata(std::move(init.userdata)){}\n\nBufferHostMappedPointer::operator const WGPUBufferHostMappedPointer&() const noexcept {\n    return *reinterpret_cast<const WGPUBufferHostMappedPointer*>(this);\n}\n\nstatic_assert(sizeof(BufferHostMappedPointer) == sizeof(WGPUBufferHostMappedPointer), \"sizeof mismatch for BufferHostMappedPointer\");\nstatic_assert(alignof(BufferHostMappedPointer) == alignof(WGPUBufferHostMappedPointer), \"alignof mismatch for BufferHostMappedPointer\");\nstatic_assert(offsetof(BufferHostMappedPointer, pointer) == offsetof(WGPUBufferHostMappedPointer, pointer),\n        \"offsetof mismatch for BufferHostMappedPointer::pointer\");\nstatic_assert(offsetof(BufferHostMappedPointer, disposeCallback) == offsetof(WGPUBufferHostMappedPointer, disposeCallback),\n        \"offsetof mismatch for BufferHostMappedPointer::disposeCallback\");\nstatic_assert(offsetof(BufferHostMappedPointer, userdata) == offsetof(WGPUBufferHostMappedPointer, userdata),\n        \"offsetof mismatch for BufferHostMappedPointer::userdata\");\n\n// BufferMapCallbackInfo implementation\n\nBufferMapCallbackInfo::operator const WGPUBufferMapCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUBufferMapCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(BufferMapCallbackInfo) == sizeof(WGPUBufferMapCallbackInfo), \"sizeof mismatch for BufferMapCallbackInfo\");\nstatic_assert(alignof(BufferMapCallbackInfo) == alignof(WGPUBufferMapCallbackInfo), \"alignof mismatch for BufferMapCallbackInfo\");\nstatic_assert(offsetof(BufferMapCallbackInfo, nextInChain) == offsetof(WGPUBufferMapCallbackInfo, nextInChain),\n        \"offsetof mismatch for BufferMapCallbackInfo::nextInChain\");\nstatic_assert(offsetof(BufferMapCallbackInfo, mode) == offsetof(WGPUBufferMapCallbackInfo, mode),\n        \"offsetof mismatch for BufferMapCallbackInfo::mode\");\nstatic_assert(offsetof(BufferMapCallbackInfo, callback) == offsetof(WGPUBufferMapCallbackInfo, callback),\n        \"offsetof mismatch for BufferMapCallbackInfo::callback\");\nstatic_assert(offsetof(BufferMapCallbackInfo, userdata) == offsetof(WGPUBufferMapCallbackInfo, userdata),\n        \"offsetof mismatch for BufferMapCallbackInfo::userdata\");\n\n// Color implementation\n\nColor::operator const WGPUColor&() const noexcept {\n    return *reinterpret_cast<const WGPUColor*>(this);\n}\n\nstatic_assert(sizeof(Color) == sizeof(WGPUColor), \"sizeof mismatch for Color\");\nstatic_assert(alignof(Color) == alignof(WGPUColor), \"alignof mismatch for Color\");\nstatic_assert(offsetof(Color, r) == offsetof(WGPUColor, r),\n        \"offsetof mismatch for Color::r\");\nstatic_assert(offsetof(Color, g) == offsetof(WGPUColor, g),\n        \"offsetof mismatch for Color::g\");\nstatic_assert(offsetof(Color, b) == offsetof(WGPUColor, b),\n        \"offsetof mismatch for Color::b\");\nstatic_assert(offsetof(Color, a) == offsetof(WGPUColor, a),\n        \"offsetof mismatch for Color::a\");\n\n// ColorTargetStateExpandResolveTextureDawn implementation\nColorTargetStateExpandResolveTextureDawn::ColorTargetStateExpandResolveTextureDawn()\n  : ChainedStruct { nullptr, SType::ColorTargetStateExpandResolveTextureDawn } {}\nstruct ColorTargetStateExpandResolveTextureDawn::Init {\n    ChainedStruct * const nextInChain;\n    Bool enabled = false;\n};\nColorTargetStateExpandResolveTextureDawn::ColorTargetStateExpandResolveTextureDawn(ColorTargetStateExpandResolveTextureDawn::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ColorTargetStateExpandResolveTextureDawn }, \n    enabled(std::move(init.enabled)){}\n\nColorTargetStateExpandResolveTextureDawn::operator const WGPUColorTargetStateExpandResolveTextureDawn&() const noexcept {\n    return *reinterpret_cast<const WGPUColorTargetStateExpandResolveTextureDawn*>(this);\n}\n\nstatic_assert(sizeof(ColorTargetStateExpandResolveTextureDawn) == sizeof(WGPUColorTargetStateExpandResolveTextureDawn), \"sizeof mismatch for ColorTargetStateExpandResolveTextureDawn\");\nstatic_assert(alignof(ColorTargetStateExpandResolveTextureDawn) == alignof(WGPUColorTargetStateExpandResolveTextureDawn), \"alignof mismatch for ColorTargetStateExpandResolveTextureDawn\");\nstatic_assert(offsetof(ColorTargetStateExpandResolveTextureDawn, enabled) == offsetof(WGPUColorTargetStateExpandResolveTextureDawn, enabled),\n        \"offsetof mismatch for ColorTargetStateExpandResolveTextureDawn::enabled\");\n\n// CompilationInfoCallbackInfo implementation\n\nCompilationInfoCallbackInfo::operator const WGPUCompilationInfoCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUCompilationInfoCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(CompilationInfoCallbackInfo) == sizeof(WGPUCompilationInfoCallbackInfo), \"sizeof mismatch for CompilationInfoCallbackInfo\");\nstatic_assert(alignof(CompilationInfoCallbackInfo) == alignof(WGPUCompilationInfoCallbackInfo), \"alignof mismatch for CompilationInfoCallbackInfo\");\nstatic_assert(offsetof(CompilationInfoCallbackInfo, nextInChain) == offsetof(WGPUCompilationInfoCallbackInfo, nextInChain),\n        \"offsetof mismatch for CompilationInfoCallbackInfo::nextInChain\");\nstatic_assert(offsetof(CompilationInfoCallbackInfo, mode) == offsetof(WGPUCompilationInfoCallbackInfo, mode),\n        \"offsetof mismatch for CompilationInfoCallbackInfo::mode\");\nstatic_assert(offsetof(CompilationInfoCallbackInfo, callback) == offsetof(WGPUCompilationInfoCallbackInfo, callback),\n        \"offsetof mismatch for CompilationInfoCallbackInfo::callback\");\nstatic_assert(offsetof(CompilationInfoCallbackInfo, userdata) == offsetof(WGPUCompilationInfoCallbackInfo, userdata),\n        \"offsetof mismatch for CompilationInfoCallbackInfo::userdata\");\n\n// ComputePassTimestampWrites implementation\n\nComputePassTimestampWrites::operator const WGPUComputePassTimestampWrites&() const noexcept {\n    return *reinterpret_cast<const WGPUComputePassTimestampWrites*>(this);\n}\n\nstatic_assert(sizeof(ComputePassTimestampWrites) == sizeof(WGPUComputePassTimestampWrites), \"sizeof mismatch for ComputePassTimestampWrites\");\nstatic_assert(alignof(ComputePassTimestampWrites) == alignof(WGPUComputePassTimestampWrites), \"alignof mismatch for ComputePassTimestampWrites\");\nstatic_assert(offsetof(ComputePassTimestampWrites, querySet) == offsetof(WGPUComputePassTimestampWrites, querySet),\n        \"offsetof mismatch for ComputePassTimestampWrites::querySet\");\nstatic_assert(offsetof(ComputePassTimestampWrites, beginningOfPassWriteIndex) == offsetof(WGPUComputePassTimestampWrites, beginningOfPassWriteIndex),\n        \"offsetof mismatch for ComputePassTimestampWrites::beginningOfPassWriteIndex\");\nstatic_assert(offsetof(ComputePassTimestampWrites, endOfPassWriteIndex) == offsetof(WGPUComputePassTimestampWrites, endOfPassWriteIndex),\n        \"offsetof mismatch for ComputePassTimestampWrites::endOfPassWriteIndex\");\n\n// CopyTextureForBrowserOptions implementation\n\nCopyTextureForBrowserOptions::operator const WGPUCopyTextureForBrowserOptions&() const noexcept {\n    return *reinterpret_cast<const WGPUCopyTextureForBrowserOptions*>(this);\n}\n\nstatic_assert(sizeof(CopyTextureForBrowserOptions) == sizeof(WGPUCopyTextureForBrowserOptions), \"sizeof mismatch for CopyTextureForBrowserOptions\");\nstatic_assert(alignof(CopyTextureForBrowserOptions) == alignof(WGPUCopyTextureForBrowserOptions), \"alignof mismatch for CopyTextureForBrowserOptions\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, nextInChain) == offsetof(WGPUCopyTextureForBrowserOptions, nextInChain),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::nextInChain\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, flipY) == offsetof(WGPUCopyTextureForBrowserOptions, flipY),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::flipY\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, needsColorSpaceConversion) == offsetof(WGPUCopyTextureForBrowserOptions, needsColorSpaceConversion),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::needsColorSpaceConversion\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, srcAlphaMode) == offsetof(WGPUCopyTextureForBrowserOptions, srcAlphaMode),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::srcAlphaMode\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, srcTransferFunctionParameters) == offsetof(WGPUCopyTextureForBrowserOptions, srcTransferFunctionParameters),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::srcTransferFunctionParameters\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, conversionMatrix) == offsetof(WGPUCopyTextureForBrowserOptions, conversionMatrix),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::conversionMatrix\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, dstTransferFunctionParameters) == offsetof(WGPUCopyTextureForBrowserOptions, dstTransferFunctionParameters),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::dstTransferFunctionParameters\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, dstAlphaMode) == offsetof(WGPUCopyTextureForBrowserOptions, dstAlphaMode),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::dstAlphaMode\");\nstatic_assert(offsetof(CopyTextureForBrowserOptions, internalUsage) == offsetof(WGPUCopyTextureForBrowserOptions, internalUsage),\n        \"offsetof mismatch for CopyTextureForBrowserOptions::internalUsage\");\n\n// CreateComputePipelineAsyncCallbackInfo implementation\n\nCreateComputePipelineAsyncCallbackInfo::operator const WGPUCreateComputePipelineAsyncCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUCreateComputePipelineAsyncCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(CreateComputePipelineAsyncCallbackInfo) == sizeof(WGPUCreateComputePipelineAsyncCallbackInfo), \"sizeof mismatch for CreateComputePipelineAsyncCallbackInfo\");\nstatic_assert(alignof(CreateComputePipelineAsyncCallbackInfo) == alignof(WGPUCreateComputePipelineAsyncCallbackInfo), \"alignof mismatch for CreateComputePipelineAsyncCallbackInfo\");\nstatic_assert(offsetof(CreateComputePipelineAsyncCallbackInfo, nextInChain) == offsetof(WGPUCreateComputePipelineAsyncCallbackInfo, nextInChain),\n        \"offsetof mismatch for CreateComputePipelineAsyncCallbackInfo::nextInChain\");\nstatic_assert(offsetof(CreateComputePipelineAsyncCallbackInfo, mode) == offsetof(WGPUCreateComputePipelineAsyncCallbackInfo, mode),\n        \"offsetof mismatch for CreateComputePipelineAsyncCallbackInfo::mode\");\nstatic_assert(offsetof(CreateComputePipelineAsyncCallbackInfo, callback) == offsetof(WGPUCreateComputePipelineAsyncCallbackInfo, callback),\n        \"offsetof mismatch for CreateComputePipelineAsyncCallbackInfo::callback\");\nstatic_assert(offsetof(CreateComputePipelineAsyncCallbackInfo, userdata) == offsetof(WGPUCreateComputePipelineAsyncCallbackInfo, userdata),\n        \"offsetof mismatch for CreateComputePipelineAsyncCallbackInfo::userdata\");\n\n// CreateRenderPipelineAsyncCallbackInfo implementation\n\nCreateRenderPipelineAsyncCallbackInfo::operator const WGPUCreateRenderPipelineAsyncCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUCreateRenderPipelineAsyncCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(CreateRenderPipelineAsyncCallbackInfo) == sizeof(WGPUCreateRenderPipelineAsyncCallbackInfo), \"sizeof mismatch for CreateRenderPipelineAsyncCallbackInfo\");\nstatic_assert(alignof(CreateRenderPipelineAsyncCallbackInfo) == alignof(WGPUCreateRenderPipelineAsyncCallbackInfo), \"alignof mismatch for CreateRenderPipelineAsyncCallbackInfo\");\nstatic_assert(offsetof(CreateRenderPipelineAsyncCallbackInfo, nextInChain) == offsetof(WGPUCreateRenderPipelineAsyncCallbackInfo, nextInChain),\n        \"offsetof mismatch for CreateRenderPipelineAsyncCallbackInfo::nextInChain\");\nstatic_assert(offsetof(CreateRenderPipelineAsyncCallbackInfo, mode) == offsetof(WGPUCreateRenderPipelineAsyncCallbackInfo, mode),\n        \"offsetof mismatch for CreateRenderPipelineAsyncCallbackInfo::mode\");\nstatic_assert(offsetof(CreateRenderPipelineAsyncCallbackInfo, callback) == offsetof(WGPUCreateRenderPipelineAsyncCallbackInfo, callback),\n        \"offsetof mismatch for CreateRenderPipelineAsyncCallbackInfo::callback\");\nstatic_assert(offsetof(CreateRenderPipelineAsyncCallbackInfo, userdata) == offsetof(WGPUCreateRenderPipelineAsyncCallbackInfo, userdata),\n        \"offsetof mismatch for CreateRenderPipelineAsyncCallbackInfo::userdata\");\n\n// DawnWGSLBlocklist implementation\nDawnWGSLBlocklist::DawnWGSLBlocklist()\n  : ChainedStruct { nullptr, SType::DawnWGSLBlocklist } {}\nstruct DawnWGSLBlocklist::Init {\n    ChainedStruct * const nextInChain;\n    size_t blocklistedFeatureCount = 0;\n    const char* const * blocklistedFeatures;\n};\nDawnWGSLBlocklist::DawnWGSLBlocklist(DawnWGSLBlocklist::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnWGSLBlocklist }, \n    blocklistedFeatureCount(std::move(init.blocklistedFeatureCount)), \n    blocklistedFeatures(std::move(init.blocklistedFeatures)){}\n\nDawnWGSLBlocklist::operator const WGPUDawnWGSLBlocklist&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnWGSLBlocklist*>(this);\n}\n\nstatic_assert(sizeof(DawnWGSLBlocklist) == sizeof(WGPUDawnWGSLBlocklist), \"sizeof mismatch for DawnWGSLBlocklist\");\nstatic_assert(alignof(DawnWGSLBlocklist) == alignof(WGPUDawnWGSLBlocklist), \"alignof mismatch for DawnWGSLBlocklist\");\nstatic_assert(offsetof(DawnWGSLBlocklist, blocklistedFeatureCount) == offsetof(WGPUDawnWGSLBlocklist, blocklistedFeatureCount),\n        \"offsetof mismatch for DawnWGSLBlocklist::blocklistedFeatureCount\");\nstatic_assert(offsetof(DawnWGSLBlocklist, blocklistedFeatures) == offsetof(WGPUDawnWGSLBlocklist, blocklistedFeatures),\n        \"offsetof mismatch for DawnWGSLBlocklist::blocklistedFeatures\");\n\n// DawnAdapterPropertiesPowerPreference implementation\nDawnAdapterPropertiesPowerPreference::DawnAdapterPropertiesPowerPreference()\n  : ChainedStructOut { nullptr, SType::DawnAdapterPropertiesPowerPreference } {}\nstruct DawnAdapterPropertiesPowerPreference::Init {\n    ChainedStructOut *  nextInChain;\n    PowerPreference powerPreference = PowerPreference::Undefined;\n};\nDawnAdapterPropertiesPowerPreference::DawnAdapterPropertiesPowerPreference(DawnAdapterPropertiesPowerPreference::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DawnAdapterPropertiesPowerPreference }, \n    powerPreference(std::move(init.powerPreference)){}\n\nDawnAdapterPropertiesPowerPreference::operator const WGPUDawnAdapterPropertiesPowerPreference&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnAdapterPropertiesPowerPreference*>(this);\n}\n\nstatic_assert(sizeof(DawnAdapterPropertiesPowerPreference) == sizeof(WGPUDawnAdapterPropertiesPowerPreference), \"sizeof mismatch for DawnAdapterPropertiesPowerPreference\");\nstatic_assert(alignof(DawnAdapterPropertiesPowerPreference) == alignof(WGPUDawnAdapterPropertiesPowerPreference), \"alignof mismatch for DawnAdapterPropertiesPowerPreference\");\nstatic_assert(offsetof(DawnAdapterPropertiesPowerPreference, powerPreference) == offsetof(WGPUDawnAdapterPropertiesPowerPreference, powerPreference),\n        \"offsetof mismatch for DawnAdapterPropertiesPowerPreference::powerPreference\");\n\n// DawnBufferDescriptorErrorInfoFromWireClient implementation\nDawnBufferDescriptorErrorInfoFromWireClient::DawnBufferDescriptorErrorInfoFromWireClient()\n  : ChainedStruct { nullptr, SType::DawnBufferDescriptorErrorInfoFromWireClient } {}\nstruct DawnBufferDescriptorErrorInfoFromWireClient::Init {\n    ChainedStruct * const nextInChain;\n    Bool outOfMemory = false;\n};\nDawnBufferDescriptorErrorInfoFromWireClient::DawnBufferDescriptorErrorInfoFromWireClient(DawnBufferDescriptorErrorInfoFromWireClient::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnBufferDescriptorErrorInfoFromWireClient }, \n    outOfMemory(std::move(init.outOfMemory)){}\n\nDawnBufferDescriptorErrorInfoFromWireClient::operator const WGPUDawnBufferDescriptorErrorInfoFromWireClient&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnBufferDescriptorErrorInfoFromWireClient*>(this);\n}\n\nstatic_assert(sizeof(DawnBufferDescriptorErrorInfoFromWireClient) == sizeof(WGPUDawnBufferDescriptorErrorInfoFromWireClient), \"sizeof mismatch for DawnBufferDescriptorErrorInfoFromWireClient\");\nstatic_assert(alignof(DawnBufferDescriptorErrorInfoFromWireClient) == alignof(WGPUDawnBufferDescriptorErrorInfoFromWireClient), \"alignof mismatch for DawnBufferDescriptorErrorInfoFromWireClient\");\nstatic_assert(offsetof(DawnBufferDescriptorErrorInfoFromWireClient, outOfMemory) == offsetof(WGPUDawnBufferDescriptorErrorInfoFromWireClient, outOfMemory),\n        \"offsetof mismatch for DawnBufferDescriptorErrorInfoFromWireClient::outOfMemory\");\n\n// DawnEncoderInternalUsageDescriptor implementation\nDawnEncoderInternalUsageDescriptor::DawnEncoderInternalUsageDescriptor()\n  : ChainedStruct { nullptr, SType::DawnEncoderInternalUsageDescriptor } {}\nstruct DawnEncoderInternalUsageDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    Bool useInternalUsages = false;\n};\nDawnEncoderInternalUsageDescriptor::DawnEncoderInternalUsageDescriptor(DawnEncoderInternalUsageDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnEncoderInternalUsageDescriptor }, \n    useInternalUsages(std::move(init.useInternalUsages)){}\n\nDawnEncoderInternalUsageDescriptor::operator const WGPUDawnEncoderInternalUsageDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnEncoderInternalUsageDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnEncoderInternalUsageDescriptor) == sizeof(WGPUDawnEncoderInternalUsageDescriptor), \"sizeof mismatch for DawnEncoderInternalUsageDescriptor\");\nstatic_assert(alignof(DawnEncoderInternalUsageDescriptor) == alignof(WGPUDawnEncoderInternalUsageDescriptor), \"alignof mismatch for DawnEncoderInternalUsageDescriptor\");\nstatic_assert(offsetof(DawnEncoderInternalUsageDescriptor, useInternalUsages) == offsetof(WGPUDawnEncoderInternalUsageDescriptor, useInternalUsages),\n        \"offsetof mismatch for DawnEncoderInternalUsageDescriptor::useInternalUsages\");\n\n// DawnExperimentalImmediateDataLimits implementation\nDawnExperimentalImmediateDataLimits::DawnExperimentalImmediateDataLimits()\n  : ChainedStructOut { nullptr, SType::DawnExperimentalImmediateDataLimits } {}\nstruct DawnExperimentalImmediateDataLimits::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t maxImmediateDataRangeByteSize = WGPU_LIMIT_U32_UNDEFINED;\n};\nDawnExperimentalImmediateDataLimits::DawnExperimentalImmediateDataLimits(DawnExperimentalImmediateDataLimits::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DawnExperimentalImmediateDataLimits }, \n    maxImmediateDataRangeByteSize(std::move(init.maxImmediateDataRangeByteSize)){}\n\nDawnExperimentalImmediateDataLimits::operator const WGPUDawnExperimentalImmediateDataLimits&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnExperimentalImmediateDataLimits*>(this);\n}\n\nstatic_assert(sizeof(DawnExperimentalImmediateDataLimits) == sizeof(WGPUDawnExperimentalImmediateDataLimits), \"sizeof mismatch for DawnExperimentalImmediateDataLimits\");\nstatic_assert(alignof(DawnExperimentalImmediateDataLimits) == alignof(WGPUDawnExperimentalImmediateDataLimits), \"alignof mismatch for DawnExperimentalImmediateDataLimits\");\nstatic_assert(offsetof(DawnExperimentalImmediateDataLimits, maxImmediateDataRangeByteSize) == offsetof(WGPUDawnExperimentalImmediateDataLimits, maxImmediateDataRangeByteSize),\n        \"offsetof mismatch for DawnExperimentalImmediateDataLimits::maxImmediateDataRangeByteSize\");\n\n// DawnExperimentalSubgroupLimits implementation\nDawnExperimentalSubgroupLimits::DawnExperimentalSubgroupLimits()\n  : ChainedStructOut { nullptr, SType::DawnExperimentalSubgroupLimits } {}\nstruct DawnExperimentalSubgroupLimits::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t minSubgroupSize = WGPU_LIMIT_U32_UNDEFINED;\n    uint32_t maxSubgroupSize = WGPU_LIMIT_U32_UNDEFINED;\n};\nDawnExperimentalSubgroupLimits::DawnExperimentalSubgroupLimits(DawnExperimentalSubgroupLimits::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DawnExperimentalSubgroupLimits }, \n    minSubgroupSize(std::move(init.minSubgroupSize)), \n    maxSubgroupSize(std::move(init.maxSubgroupSize)){}\n\nDawnExperimentalSubgroupLimits::operator const WGPUDawnExperimentalSubgroupLimits&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnExperimentalSubgroupLimits*>(this);\n}\n\nstatic_assert(sizeof(DawnExperimentalSubgroupLimits) == sizeof(WGPUDawnExperimentalSubgroupLimits), \"sizeof mismatch for DawnExperimentalSubgroupLimits\");\nstatic_assert(alignof(DawnExperimentalSubgroupLimits) == alignof(WGPUDawnExperimentalSubgroupLimits), \"alignof mismatch for DawnExperimentalSubgroupLimits\");\nstatic_assert(offsetof(DawnExperimentalSubgroupLimits, minSubgroupSize) == offsetof(WGPUDawnExperimentalSubgroupLimits, minSubgroupSize),\n        \"offsetof mismatch for DawnExperimentalSubgroupLimits::minSubgroupSize\");\nstatic_assert(offsetof(DawnExperimentalSubgroupLimits, maxSubgroupSize) == offsetof(WGPUDawnExperimentalSubgroupLimits, maxSubgroupSize),\n        \"offsetof mismatch for DawnExperimentalSubgroupLimits::maxSubgroupSize\");\n\n// DawnRenderPassColorAttachmentRenderToSingleSampled implementation\nDawnRenderPassColorAttachmentRenderToSingleSampled::DawnRenderPassColorAttachmentRenderToSingleSampled()\n  : ChainedStruct { nullptr, SType::DawnRenderPassColorAttachmentRenderToSingleSampled } {}\nstruct DawnRenderPassColorAttachmentRenderToSingleSampled::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t implicitSampleCount = 1;\n};\nDawnRenderPassColorAttachmentRenderToSingleSampled::DawnRenderPassColorAttachmentRenderToSingleSampled(DawnRenderPassColorAttachmentRenderToSingleSampled::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnRenderPassColorAttachmentRenderToSingleSampled }, \n    implicitSampleCount(std::move(init.implicitSampleCount)){}\n\nDawnRenderPassColorAttachmentRenderToSingleSampled::operator const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnRenderPassColorAttachmentRenderToSingleSampled*>(this);\n}\n\nstatic_assert(sizeof(DawnRenderPassColorAttachmentRenderToSingleSampled) == sizeof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled), \"sizeof mismatch for DawnRenderPassColorAttachmentRenderToSingleSampled\");\nstatic_assert(alignof(DawnRenderPassColorAttachmentRenderToSingleSampled) == alignof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled), \"alignof mismatch for DawnRenderPassColorAttachmentRenderToSingleSampled\");\nstatic_assert(offsetof(DawnRenderPassColorAttachmentRenderToSingleSampled, implicitSampleCount) == offsetof(WGPUDawnRenderPassColorAttachmentRenderToSingleSampled, implicitSampleCount),\n        \"offsetof mismatch for DawnRenderPassColorAttachmentRenderToSingleSampled::implicitSampleCount\");\n\n// DawnShaderModuleSPIRVOptionsDescriptor implementation\nDawnShaderModuleSPIRVOptionsDescriptor::DawnShaderModuleSPIRVOptionsDescriptor()\n  : ChainedStruct { nullptr, SType::DawnShaderModuleSPIRVOptionsDescriptor } {}\nstruct DawnShaderModuleSPIRVOptionsDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    Bool allowNonUniformDerivatives = false;\n};\nDawnShaderModuleSPIRVOptionsDescriptor::DawnShaderModuleSPIRVOptionsDescriptor(DawnShaderModuleSPIRVOptionsDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnShaderModuleSPIRVOptionsDescriptor }, \n    allowNonUniformDerivatives(std::move(init.allowNonUniformDerivatives)){}\n\nDawnShaderModuleSPIRVOptionsDescriptor::operator const WGPUDawnShaderModuleSPIRVOptionsDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnShaderModuleSPIRVOptionsDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnShaderModuleSPIRVOptionsDescriptor) == sizeof(WGPUDawnShaderModuleSPIRVOptionsDescriptor), \"sizeof mismatch for DawnShaderModuleSPIRVOptionsDescriptor\");\nstatic_assert(alignof(DawnShaderModuleSPIRVOptionsDescriptor) == alignof(WGPUDawnShaderModuleSPIRVOptionsDescriptor), \"alignof mismatch for DawnShaderModuleSPIRVOptionsDescriptor\");\nstatic_assert(offsetof(DawnShaderModuleSPIRVOptionsDescriptor, allowNonUniformDerivatives) == offsetof(WGPUDawnShaderModuleSPIRVOptionsDescriptor, allowNonUniformDerivatives),\n        \"offsetof mismatch for DawnShaderModuleSPIRVOptionsDescriptor::allowNonUniformDerivatives\");\n\n// DawnTexelCopyBufferRowAlignmentLimits implementation\nDawnTexelCopyBufferRowAlignmentLimits::DawnTexelCopyBufferRowAlignmentLimits()\n  : ChainedStructOut { nullptr, SType::DawnTexelCopyBufferRowAlignmentLimits } {}\nstruct DawnTexelCopyBufferRowAlignmentLimits::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t minTexelCopyBufferRowAlignment = WGPU_LIMIT_U32_UNDEFINED;\n};\nDawnTexelCopyBufferRowAlignmentLimits::DawnTexelCopyBufferRowAlignmentLimits(DawnTexelCopyBufferRowAlignmentLimits::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DawnTexelCopyBufferRowAlignmentLimits }, \n    minTexelCopyBufferRowAlignment(std::move(init.minTexelCopyBufferRowAlignment)){}\n\nDawnTexelCopyBufferRowAlignmentLimits::operator const WGPUDawnTexelCopyBufferRowAlignmentLimits&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnTexelCopyBufferRowAlignmentLimits*>(this);\n}\n\nstatic_assert(sizeof(DawnTexelCopyBufferRowAlignmentLimits) == sizeof(WGPUDawnTexelCopyBufferRowAlignmentLimits), \"sizeof mismatch for DawnTexelCopyBufferRowAlignmentLimits\");\nstatic_assert(alignof(DawnTexelCopyBufferRowAlignmentLimits) == alignof(WGPUDawnTexelCopyBufferRowAlignmentLimits), \"alignof mismatch for DawnTexelCopyBufferRowAlignmentLimits\");\nstatic_assert(offsetof(DawnTexelCopyBufferRowAlignmentLimits, minTexelCopyBufferRowAlignment) == offsetof(WGPUDawnTexelCopyBufferRowAlignmentLimits, minTexelCopyBufferRowAlignment),\n        \"offsetof mismatch for DawnTexelCopyBufferRowAlignmentLimits::minTexelCopyBufferRowAlignment\");\n\n// DawnTextureInternalUsageDescriptor implementation\nDawnTextureInternalUsageDescriptor::DawnTextureInternalUsageDescriptor()\n  : ChainedStruct { nullptr, SType::DawnTextureInternalUsageDescriptor } {}\nstruct DawnTextureInternalUsageDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    TextureUsage internalUsage = TextureUsage::None;\n};\nDawnTextureInternalUsageDescriptor::DawnTextureInternalUsageDescriptor(DawnTextureInternalUsageDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnTextureInternalUsageDescriptor }, \n    internalUsage(std::move(init.internalUsage)){}\n\nDawnTextureInternalUsageDescriptor::operator const WGPUDawnTextureInternalUsageDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnTextureInternalUsageDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnTextureInternalUsageDescriptor) == sizeof(WGPUDawnTextureInternalUsageDescriptor), \"sizeof mismatch for DawnTextureInternalUsageDescriptor\");\nstatic_assert(alignof(DawnTextureInternalUsageDescriptor) == alignof(WGPUDawnTextureInternalUsageDescriptor), \"alignof mismatch for DawnTextureInternalUsageDescriptor\");\nstatic_assert(offsetof(DawnTextureInternalUsageDescriptor, internalUsage) == offsetof(WGPUDawnTextureInternalUsageDescriptor, internalUsage),\n        \"offsetof mismatch for DawnTextureInternalUsageDescriptor::internalUsage\");\n\n// DawnTogglesDescriptor implementation\nDawnTogglesDescriptor::DawnTogglesDescriptor()\n  : ChainedStruct { nullptr, SType::DawnTogglesDescriptor } {}\nstruct DawnTogglesDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    size_t enabledToggleCount = 0;\n    const char* const * enabledToggles;\n    size_t disabledToggleCount = 0;\n    const char* const * disabledToggles;\n};\nDawnTogglesDescriptor::DawnTogglesDescriptor(DawnTogglesDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnTogglesDescriptor }, \n    enabledToggleCount(std::move(init.enabledToggleCount)), \n    enabledToggles(std::move(init.enabledToggles)), \n    disabledToggleCount(std::move(init.disabledToggleCount)), \n    disabledToggles(std::move(init.disabledToggles)){}\n\nDawnTogglesDescriptor::operator const WGPUDawnTogglesDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnTogglesDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnTogglesDescriptor) == sizeof(WGPUDawnTogglesDescriptor), \"sizeof mismatch for DawnTogglesDescriptor\");\nstatic_assert(alignof(DawnTogglesDescriptor) == alignof(WGPUDawnTogglesDescriptor), \"alignof mismatch for DawnTogglesDescriptor\");\nstatic_assert(offsetof(DawnTogglesDescriptor, enabledToggleCount) == offsetof(WGPUDawnTogglesDescriptor, enabledToggleCount),\n        \"offsetof mismatch for DawnTogglesDescriptor::enabledToggleCount\");\nstatic_assert(offsetof(DawnTogglesDescriptor, enabledToggles) == offsetof(WGPUDawnTogglesDescriptor, enabledToggles),\n        \"offsetof mismatch for DawnTogglesDescriptor::enabledToggles\");\nstatic_assert(offsetof(DawnTogglesDescriptor, disabledToggleCount) == offsetof(WGPUDawnTogglesDescriptor, disabledToggleCount),\n        \"offsetof mismatch for DawnTogglesDescriptor::disabledToggleCount\");\nstatic_assert(offsetof(DawnTogglesDescriptor, disabledToggles) == offsetof(WGPUDawnTogglesDescriptor, disabledToggles),\n        \"offsetof mismatch for DawnTogglesDescriptor::disabledToggles\");\n\n// DawnWireWGSLControl implementation\nDawnWireWGSLControl::DawnWireWGSLControl()\n  : ChainedStruct { nullptr, SType::DawnWireWGSLControl } {}\nstruct DawnWireWGSLControl::Init {\n    ChainedStruct * const nextInChain;\n    Bool enableExperimental = false;\n    Bool enableUnsafe = false;\n    Bool enableTesting = false;\n};\nDawnWireWGSLControl::DawnWireWGSLControl(DawnWireWGSLControl::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnWireWGSLControl }, \n    enableExperimental(std::move(init.enableExperimental)), \n    enableUnsafe(std::move(init.enableUnsafe)), \n    enableTesting(std::move(init.enableTesting)){}\n\nDawnWireWGSLControl::operator const WGPUDawnWireWGSLControl&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnWireWGSLControl*>(this);\n}\n\nstatic_assert(sizeof(DawnWireWGSLControl) == sizeof(WGPUDawnWireWGSLControl), \"sizeof mismatch for DawnWireWGSLControl\");\nstatic_assert(alignof(DawnWireWGSLControl) == alignof(WGPUDawnWireWGSLControl), \"alignof mismatch for DawnWireWGSLControl\");\nstatic_assert(offsetof(DawnWireWGSLControl, enableExperimental) == offsetof(WGPUDawnWireWGSLControl, enableExperimental),\n        \"offsetof mismatch for DawnWireWGSLControl::enableExperimental\");\nstatic_assert(offsetof(DawnWireWGSLControl, enableUnsafe) == offsetof(WGPUDawnWireWGSLControl, enableUnsafe),\n        \"offsetof mismatch for DawnWireWGSLControl::enableUnsafe\");\nstatic_assert(offsetof(DawnWireWGSLControl, enableTesting) == offsetof(WGPUDawnWireWGSLControl, enableTesting),\n        \"offsetof mismatch for DawnWireWGSLControl::enableTesting\");\n\n// DeviceLostCallbackInfo implementation\n\nDeviceLostCallbackInfo::operator const WGPUDeviceLostCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUDeviceLostCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(DeviceLostCallbackInfo) == sizeof(WGPUDeviceLostCallbackInfo), \"sizeof mismatch for DeviceLostCallbackInfo\");\nstatic_assert(alignof(DeviceLostCallbackInfo) == alignof(WGPUDeviceLostCallbackInfo), \"alignof mismatch for DeviceLostCallbackInfo\");\nstatic_assert(offsetof(DeviceLostCallbackInfo, nextInChain) == offsetof(WGPUDeviceLostCallbackInfo, nextInChain),\n        \"offsetof mismatch for DeviceLostCallbackInfo::nextInChain\");\nstatic_assert(offsetof(DeviceLostCallbackInfo, mode) == offsetof(WGPUDeviceLostCallbackInfo, mode),\n        \"offsetof mismatch for DeviceLostCallbackInfo::mode\");\nstatic_assert(offsetof(DeviceLostCallbackInfo, callback) == offsetof(WGPUDeviceLostCallbackInfo, callback),\n        \"offsetof mismatch for DeviceLostCallbackInfo::callback\");\nstatic_assert(offsetof(DeviceLostCallbackInfo, userdata) == offsetof(WGPUDeviceLostCallbackInfo, userdata),\n        \"offsetof mismatch for DeviceLostCallbackInfo::userdata\");\n\n// DrmFormatProperties implementation\n\nDrmFormatProperties::operator const WGPUDrmFormatProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUDrmFormatProperties*>(this);\n}\n\nstatic_assert(sizeof(DrmFormatProperties) == sizeof(WGPUDrmFormatProperties), \"sizeof mismatch for DrmFormatProperties\");\nstatic_assert(alignof(DrmFormatProperties) == alignof(WGPUDrmFormatProperties), \"alignof mismatch for DrmFormatProperties\");\nstatic_assert(offsetof(DrmFormatProperties, modifier) == offsetof(WGPUDrmFormatProperties, modifier),\n        \"offsetof mismatch for DrmFormatProperties::modifier\");\nstatic_assert(offsetof(DrmFormatProperties, modifierPlaneCount) == offsetof(WGPUDrmFormatProperties, modifierPlaneCount),\n        \"offsetof mismatch for DrmFormatProperties::modifierPlaneCount\");\n\n// Extent2D implementation\n\nExtent2D::operator const WGPUExtent2D&() const noexcept {\n    return *reinterpret_cast<const WGPUExtent2D*>(this);\n}\n\nstatic_assert(sizeof(Extent2D) == sizeof(WGPUExtent2D), \"sizeof mismatch for Extent2D\");\nstatic_assert(alignof(Extent2D) == alignof(WGPUExtent2D), \"alignof mismatch for Extent2D\");\nstatic_assert(offsetof(Extent2D, width) == offsetof(WGPUExtent2D, width),\n        \"offsetof mismatch for Extent2D::width\");\nstatic_assert(offsetof(Extent2D, height) == offsetof(WGPUExtent2D, height),\n        \"offsetof mismatch for Extent2D::height\");\n\n// Extent3D implementation\n\nExtent3D::operator const WGPUExtent3D&() const noexcept {\n    return *reinterpret_cast<const WGPUExtent3D*>(this);\n}\n\nstatic_assert(sizeof(Extent3D) == sizeof(WGPUExtent3D), \"sizeof mismatch for Extent3D\");\nstatic_assert(alignof(Extent3D) == alignof(WGPUExtent3D), \"alignof mismatch for Extent3D\");\nstatic_assert(offsetof(Extent3D, width) == offsetof(WGPUExtent3D, width),\n        \"offsetof mismatch for Extent3D::width\");\nstatic_assert(offsetof(Extent3D, height) == offsetof(WGPUExtent3D, height),\n        \"offsetof mismatch for Extent3D::height\");\nstatic_assert(offsetof(Extent3D, depthOrArrayLayers) == offsetof(WGPUExtent3D, depthOrArrayLayers),\n        \"offsetof mismatch for Extent3D::depthOrArrayLayers\");\n\n// ExternalTextureBindingEntry implementation\nExternalTextureBindingEntry::ExternalTextureBindingEntry()\n  : ChainedStruct { nullptr, SType::ExternalTextureBindingEntry } {}\nstruct ExternalTextureBindingEntry::Init {\n    ChainedStruct * const nextInChain;\n    ExternalTexture externalTexture;\n};\nExternalTextureBindingEntry::ExternalTextureBindingEntry(ExternalTextureBindingEntry::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ExternalTextureBindingEntry }, \n    externalTexture(std::move(init.externalTexture)){}\n\nExternalTextureBindingEntry::operator const WGPUExternalTextureBindingEntry&() const noexcept {\n    return *reinterpret_cast<const WGPUExternalTextureBindingEntry*>(this);\n}\n\nstatic_assert(sizeof(ExternalTextureBindingEntry) == sizeof(WGPUExternalTextureBindingEntry), \"sizeof mismatch for ExternalTextureBindingEntry\");\nstatic_assert(alignof(ExternalTextureBindingEntry) == alignof(WGPUExternalTextureBindingEntry), \"alignof mismatch for ExternalTextureBindingEntry\");\nstatic_assert(offsetof(ExternalTextureBindingEntry, externalTexture) == offsetof(WGPUExternalTextureBindingEntry, externalTexture),\n        \"offsetof mismatch for ExternalTextureBindingEntry::externalTexture\");\n\n// ExternalTextureBindingLayout implementation\nExternalTextureBindingLayout::ExternalTextureBindingLayout()\n  : ChainedStruct { nullptr, SType::ExternalTextureBindingLayout } {}\nstruct ExternalTextureBindingLayout::Init {\n    ChainedStruct * const nextInChain;\n};\nExternalTextureBindingLayout::ExternalTextureBindingLayout(ExternalTextureBindingLayout::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ExternalTextureBindingLayout }{}\n\nExternalTextureBindingLayout::operator const WGPUExternalTextureBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUExternalTextureBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(ExternalTextureBindingLayout) == sizeof(WGPUExternalTextureBindingLayout), \"sizeof mismatch for ExternalTextureBindingLayout\");\nstatic_assert(alignof(ExternalTextureBindingLayout) == alignof(WGPUExternalTextureBindingLayout), \"alignof mismatch for ExternalTextureBindingLayout\");\n\n// FormatCapabilities implementation\n\nFormatCapabilities::operator const WGPUFormatCapabilities&() const noexcept {\n    return *reinterpret_cast<const WGPUFormatCapabilities*>(this);\n}\n\nstatic_assert(sizeof(FormatCapabilities) == sizeof(WGPUFormatCapabilities), \"sizeof mismatch for FormatCapabilities\");\nstatic_assert(alignof(FormatCapabilities) == alignof(WGPUFormatCapabilities), \"alignof mismatch for FormatCapabilities\");\nstatic_assert(offsetof(FormatCapabilities, nextInChain) == offsetof(WGPUFormatCapabilities, nextInChain),\n        \"offsetof mismatch for FormatCapabilities::nextInChain\");\n\n// Future implementation\n\nFuture::operator const WGPUFuture&() const noexcept {\n    return *reinterpret_cast<const WGPUFuture*>(this);\n}\n\nstatic_assert(sizeof(Future) == sizeof(WGPUFuture), \"sizeof mismatch for Future\");\nstatic_assert(alignof(Future) == alignof(WGPUFuture), \"alignof mismatch for Future\");\nstatic_assert(offsetof(Future, id) == offsetof(WGPUFuture, id),\n        \"offsetof mismatch for Future::id\");\n\n// InstanceFeatures implementation\n\nInstanceFeatures::operator const WGPUInstanceFeatures&() const noexcept {\n    return *reinterpret_cast<const WGPUInstanceFeatures*>(this);\n}\n\nstatic_assert(sizeof(InstanceFeatures) == sizeof(WGPUInstanceFeatures), \"sizeof mismatch for InstanceFeatures\");\nstatic_assert(alignof(InstanceFeatures) == alignof(WGPUInstanceFeatures), \"alignof mismatch for InstanceFeatures\");\nstatic_assert(offsetof(InstanceFeatures, nextInChain) == offsetof(WGPUInstanceFeatures, nextInChain),\n        \"offsetof mismatch for InstanceFeatures::nextInChain\");\nstatic_assert(offsetof(InstanceFeatures, timedWaitAnyEnable) == offsetof(WGPUInstanceFeatures, timedWaitAnyEnable),\n        \"offsetof mismatch for InstanceFeatures::timedWaitAnyEnable\");\nstatic_assert(offsetof(InstanceFeatures, timedWaitAnyMaxCount) == offsetof(WGPUInstanceFeatures, timedWaitAnyMaxCount),\n        \"offsetof mismatch for InstanceFeatures::timedWaitAnyMaxCount\");\n\n// Limits implementation\n\nLimits::operator const WGPULimits&() const noexcept {\n    return *reinterpret_cast<const WGPULimits*>(this);\n}\n\nstatic_assert(sizeof(Limits) == sizeof(WGPULimits), \"sizeof mismatch for Limits\");\nstatic_assert(alignof(Limits) == alignof(WGPULimits), \"alignof mismatch for Limits\");\nstatic_assert(offsetof(Limits, maxTextureDimension1D) == offsetof(WGPULimits, maxTextureDimension1D),\n        \"offsetof mismatch for Limits::maxTextureDimension1D\");\nstatic_assert(offsetof(Limits, maxTextureDimension2D) == offsetof(WGPULimits, maxTextureDimension2D),\n        \"offsetof mismatch for Limits::maxTextureDimension2D\");\nstatic_assert(offsetof(Limits, maxTextureDimension3D) == offsetof(WGPULimits, maxTextureDimension3D),\n        \"offsetof mismatch for Limits::maxTextureDimension3D\");\nstatic_assert(offsetof(Limits, maxTextureArrayLayers) == offsetof(WGPULimits, maxTextureArrayLayers),\n        \"offsetof mismatch for Limits::maxTextureArrayLayers\");\nstatic_assert(offsetof(Limits, maxBindGroups) == offsetof(WGPULimits, maxBindGroups),\n        \"offsetof mismatch for Limits::maxBindGroups\");\nstatic_assert(offsetof(Limits, maxBindGroupsPlusVertexBuffers) == offsetof(WGPULimits, maxBindGroupsPlusVertexBuffers),\n        \"offsetof mismatch for Limits::maxBindGroupsPlusVertexBuffers\");\nstatic_assert(offsetof(Limits, maxBindingsPerBindGroup) == offsetof(WGPULimits, maxBindingsPerBindGroup),\n        \"offsetof mismatch for Limits::maxBindingsPerBindGroup\");\nstatic_assert(offsetof(Limits, maxDynamicUniformBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicUniformBuffersPerPipelineLayout),\n        \"offsetof mismatch for Limits::maxDynamicUniformBuffersPerPipelineLayout\");\nstatic_assert(offsetof(Limits, maxDynamicStorageBuffersPerPipelineLayout) == offsetof(WGPULimits, maxDynamicStorageBuffersPerPipelineLayout),\n        \"offsetof mismatch for Limits::maxDynamicStorageBuffersPerPipelineLayout\");\nstatic_assert(offsetof(Limits, maxSampledTexturesPerShaderStage) == offsetof(WGPULimits, maxSampledTexturesPerShaderStage),\n        \"offsetof mismatch for Limits::maxSampledTexturesPerShaderStage\");\nstatic_assert(offsetof(Limits, maxSamplersPerShaderStage) == offsetof(WGPULimits, maxSamplersPerShaderStage),\n        \"offsetof mismatch for Limits::maxSamplersPerShaderStage\");\nstatic_assert(offsetof(Limits, maxStorageBuffersPerShaderStage) == offsetof(WGPULimits, maxStorageBuffersPerShaderStage),\n        \"offsetof mismatch for Limits::maxStorageBuffersPerShaderStage\");\nstatic_assert(offsetof(Limits, maxStorageTexturesPerShaderStage) == offsetof(WGPULimits, maxStorageTexturesPerShaderStage),\n        \"offsetof mismatch for Limits::maxStorageTexturesPerShaderStage\");\nstatic_assert(offsetof(Limits, maxUniformBuffersPerShaderStage) == offsetof(WGPULimits, maxUniformBuffersPerShaderStage),\n        \"offsetof mismatch for Limits::maxUniformBuffersPerShaderStage\");\nstatic_assert(offsetof(Limits, maxUniformBufferBindingSize) == offsetof(WGPULimits, maxUniformBufferBindingSize),\n        \"offsetof mismatch for Limits::maxUniformBufferBindingSize\");\nstatic_assert(offsetof(Limits, maxStorageBufferBindingSize) == offsetof(WGPULimits, maxStorageBufferBindingSize),\n        \"offsetof mismatch for Limits::maxStorageBufferBindingSize\");\nstatic_assert(offsetof(Limits, minUniformBufferOffsetAlignment) == offsetof(WGPULimits, minUniformBufferOffsetAlignment),\n        \"offsetof mismatch for Limits::minUniformBufferOffsetAlignment\");\nstatic_assert(offsetof(Limits, minStorageBufferOffsetAlignment) == offsetof(WGPULimits, minStorageBufferOffsetAlignment),\n        \"offsetof mismatch for Limits::minStorageBufferOffsetAlignment\");\nstatic_assert(offsetof(Limits, maxVertexBuffers) == offsetof(WGPULimits, maxVertexBuffers),\n        \"offsetof mismatch for Limits::maxVertexBuffers\");\nstatic_assert(offsetof(Limits, maxBufferSize) == offsetof(WGPULimits, maxBufferSize),\n        \"offsetof mismatch for Limits::maxBufferSize\");\nstatic_assert(offsetof(Limits, maxVertexAttributes) == offsetof(WGPULimits, maxVertexAttributes),\n        \"offsetof mismatch for Limits::maxVertexAttributes\");\nstatic_assert(offsetof(Limits, maxVertexBufferArrayStride) == offsetof(WGPULimits, maxVertexBufferArrayStride),\n        \"offsetof mismatch for Limits::maxVertexBufferArrayStride\");\nstatic_assert(offsetof(Limits, maxInterStageShaderComponents) == offsetof(WGPULimits, maxInterStageShaderComponents),\n        \"offsetof mismatch for Limits::maxInterStageShaderComponents\");\nstatic_assert(offsetof(Limits, maxInterStageShaderVariables) == offsetof(WGPULimits, maxInterStageShaderVariables),\n        \"offsetof mismatch for Limits::maxInterStageShaderVariables\");\nstatic_assert(offsetof(Limits, maxColorAttachments) == offsetof(WGPULimits, maxColorAttachments),\n        \"offsetof mismatch for Limits::maxColorAttachments\");\nstatic_assert(offsetof(Limits, maxColorAttachmentBytesPerSample) == offsetof(WGPULimits, maxColorAttachmentBytesPerSample),\n        \"offsetof mismatch for Limits::maxColorAttachmentBytesPerSample\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupStorageSize) == offsetof(WGPULimits, maxComputeWorkgroupStorageSize),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupStorageSize\");\nstatic_assert(offsetof(Limits, maxComputeInvocationsPerWorkgroup) == offsetof(WGPULimits, maxComputeInvocationsPerWorkgroup),\n        \"offsetof mismatch for Limits::maxComputeInvocationsPerWorkgroup\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupSizeX) == offsetof(WGPULimits, maxComputeWorkgroupSizeX),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupSizeX\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupSizeY) == offsetof(WGPULimits, maxComputeWorkgroupSizeY),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupSizeY\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupSizeZ) == offsetof(WGPULimits, maxComputeWorkgroupSizeZ),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupSizeZ\");\nstatic_assert(offsetof(Limits, maxComputeWorkgroupsPerDimension) == offsetof(WGPULimits, maxComputeWorkgroupsPerDimension),\n        \"offsetof mismatch for Limits::maxComputeWorkgroupsPerDimension\");\n\n// MemoryHeapInfo implementation\n\nMemoryHeapInfo::operator const WGPUMemoryHeapInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUMemoryHeapInfo*>(this);\n}\n\nstatic_assert(sizeof(MemoryHeapInfo) == sizeof(WGPUMemoryHeapInfo), \"sizeof mismatch for MemoryHeapInfo\");\nstatic_assert(alignof(MemoryHeapInfo) == alignof(WGPUMemoryHeapInfo), \"alignof mismatch for MemoryHeapInfo\");\nstatic_assert(offsetof(MemoryHeapInfo, properties) == offsetof(WGPUMemoryHeapInfo, properties),\n        \"offsetof mismatch for MemoryHeapInfo::properties\");\nstatic_assert(offsetof(MemoryHeapInfo, size) == offsetof(WGPUMemoryHeapInfo, size),\n        \"offsetof mismatch for MemoryHeapInfo::size\");\n\n// MultisampleState implementation\n\nMultisampleState::operator const WGPUMultisampleState&() const noexcept {\n    return *reinterpret_cast<const WGPUMultisampleState*>(this);\n}\n\nstatic_assert(sizeof(MultisampleState) == sizeof(WGPUMultisampleState), \"sizeof mismatch for MultisampleState\");\nstatic_assert(alignof(MultisampleState) == alignof(WGPUMultisampleState), \"alignof mismatch for MultisampleState\");\nstatic_assert(offsetof(MultisampleState, nextInChain) == offsetof(WGPUMultisampleState, nextInChain),\n        \"offsetof mismatch for MultisampleState::nextInChain\");\nstatic_assert(offsetof(MultisampleState, count) == offsetof(WGPUMultisampleState, count),\n        \"offsetof mismatch for MultisampleState::count\");\nstatic_assert(offsetof(MultisampleState, mask) == offsetof(WGPUMultisampleState, mask),\n        \"offsetof mismatch for MultisampleState::mask\");\nstatic_assert(offsetof(MultisampleState, alphaToCoverageEnabled) == offsetof(WGPUMultisampleState, alphaToCoverageEnabled),\n        \"offsetof mismatch for MultisampleState::alphaToCoverageEnabled\");\n\n// Origin2D implementation\n\nOrigin2D::operator const WGPUOrigin2D&() const noexcept {\n    return *reinterpret_cast<const WGPUOrigin2D*>(this);\n}\n\nstatic_assert(sizeof(Origin2D) == sizeof(WGPUOrigin2D), \"sizeof mismatch for Origin2D\");\nstatic_assert(alignof(Origin2D) == alignof(WGPUOrigin2D), \"alignof mismatch for Origin2D\");\nstatic_assert(offsetof(Origin2D, x) == offsetof(WGPUOrigin2D, x),\n        \"offsetof mismatch for Origin2D::x\");\nstatic_assert(offsetof(Origin2D, y) == offsetof(WGPUOrigin2D, y),\n        \"offsetof mismatch for Origin2D::y\");\n\n// Origin3D implementation\n\nOrigin3D::operator const WGPUOrigin3D&() const noexcept {\n    return *reinterpret_cast<const WGPUOrigin3D*>(this);\n}\n\nstatic_assert(sizeof(Origin3D) == sizeof(WGPUOrigin3D), \"sizeof mismatch for Origin3D\");\nstatic_assert(alignof(Origin3D) == alignof(WGPUOrigin3D), \"alignof mismatch for Origin3D\");\nstatic_assert(offsetof(Origin3D, x) == offsetof(WGPUOrigin3D, x),\n        \"offsetof mismatch for Origin3D::x\");\nstatic_assert(offsetof(Origin3D, y) == offsetof(WGPUOrigin3D, y),\n        \"offsetof mismatch for Origin3D::y\");\nstatic_assert(offsetof(Origin3D, z) == offsetof(WGPUOrigin3D, z),\n        \"offsetof mismatch for Origin3D::z\");\n\n// PipelineLayoutStorageAttachment implementation\n\nPipelineLayoutStorageAttachment::operator const WGPUPipelineLayoutStorageAttachment&() const noexcept {\n    return *reinterpret_cast<const WGPUPipelineLayoutStorageAttachment*>(this);\n}\n\nstatic_assert(sizeof(PipelineLayoutStorageAttachment) == sizeof(WGPUPipelineLayoutStorageAttachment), \"sizeof mismatch for PipelineLayoutStorageAttachment\");\nstatic_assert(alignof(PipelineLayoutStorageAttachment) == alignof(WGPUPipelineLayoutStorageAttachment), \"alignof mismatch for PipelineLayoutStorageAttachment\");\nstatic_assert(offsetof(PipelineLayoutStorageAttachment, nextInChain) == offsetof(WGPUPipelineLayoutStorageAttachment, nextInChain),\n        \"offsetof mismatch for PipelineLayoutStorageAttachment::nextInChain\");\nstatic_assert(offsetof(PipelineLayoutStorageAttachment, offset) == offsetof(WGPUPipelineLayoutStorageAttachment, offset),\n        \"offsetof mismatch for PipelineLayoutStorageAttachment::offset\");\nstatic_assert(offsetof(PipelineLayoutStorageAttachment, format) == offsetof(WGPUPipelineLayoutStorageAttachment, format),\n        \"offsetof mismatch for PipelineLayoutStorageAttachment::format\");\n\n// PopErrorScopeCallbackInfo implementation\n\nPopErrorScopeCallbackInfo::operator const WGPUPopErrorScopeCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUPopErrorScopeCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(PopErrorScopeCallbackInfo) == sizeof(WGPUPopErrorScopeCallbackInfo), \"sizeof mismatch for PopErrorScopeCallbackInfo\");\nstatic_assert(alignof(PopErrorScopeCallbackInfo) == alignof(WGPUPopErrorScopeCallbackInfo), \"alignof mismatch for PopErrorScopeCallbackInfo\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, nextInChain) == offsetof(WGPUPopErrorScopeCallbackInfo, nextInChain),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::nextInChain\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, mode) == offsetof(WGPUPopErrorScopeCallbackInfo, mode),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::mode\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, callback) == offsetof(WGPUPopErrorScopeCallbackInfo, callback),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::callback\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, oldCallback) == offsetof(WGPUPopErrorScopeCallbackInfo, oldCallback),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::oldCallback\");\nstatic_assert(offsetof(PopErrorScopeCallbackInfo, userdata) == offsetof(WGPUPopErrorScopeCallbackInfo, userdata),\n        \"offsetof mismatch for PopErrorScopeCallbackInfo::userdata\");\n\n// PrimitiveState implementation\n\nPrimitiveState::operator const WGPUPrimitiveState&() const noexcept {\n    return *reinterpret_cast<const WGPUPrimitiveState*>(this);\n}\n\nstatic_assert(sizeof(PrimitiveState) == sizeof(WGPUPrimitiveState), \"sizeof mismatch for PrimitiveState\");\nstatic_assert(alignof(PrimitiveState) == alignof(WGPUPrimitiveState), \"alignof mismatch for PrimitiveState\");\nstatic_assert(offsetof(PrimitiveState, nextInChain) == offsetof(WGPUPrimitiveState, nextInChain),\n        \"offsetof mismatch for PrimitiveState::nextInChain\");\nstatic_assert(offsetof(PrimitiveState, topology) == offsetof(WGPUPrimitiveState, topology),\n        \"offsetof mismatch for PrimitiveState::topology\");\nstatic_assert(offsetof(PrimitiveState, stripIndexFormat) == offsetof(WGPUPrimitiveState, stripIndexFormat),\n        \"offsetof mismatch for PrimitiveState::stripIndexFormat\");\nstatic_assert(offsetof(PrimitiveState, frontFace) == offsetof(WGPUPrimitiveState, frontFace),\n        \"offsetof mismatch for PrimitiveState::frontFace\");\nstatic_assert(offsetof(PrimitiveState, cullMode) == offsetof(WGPUPrimitiveState, cullMode),\n        \"offsetof mismatch for PrimitiveState::cullMode\");\nstatic_assert(offsetof(PrimitiveState, unclippedDepth) == offsetof(WGPUPrimitiveState, unclippedDepth),\n        \"offsetof mismatch for PrimitiveState::unclippedDepth\");\n\n// QueueWorkDoneCallbackInfo implementation\n\nQueueWorkDoneCallbackInfo::operator const WGPUQueueWorkDoneCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUQueueWorkDoneCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(QueueWorkDoneCallbackInfo) == sizeof(WGPUQueueWorkDoneCallbackInfo), \"sizeof mismatch for QueueWorkDoneCallbackInfo\");\nstatic_assert(alignof(QueueWorkDoneCallbackInfo) == alignof(WGPUQueueWorkDoneCallbackInfo), \"alignof mismatch for QueueWorkDoneCallbackInfo\");\nstatic_assert(offsetof(QueueWorkDoneCallbackInfo, nextInChain) == offsetof(WGPUQueueWorkDoneCallbackInfo, nextInChain),\n        \"offsetof mismatch for QueueWorkDoneCallbackInfo::nextInChain\");\nstatic_assert(offsetof(QueueWorkDoneCallbackInfo, mode) == offsetof(WGPUQueueWorkDoneCallbackInfo, mode),\n        \"offsetof mismatch for QueueWorkDoneCallbackInfo::mode\");\nstatic_assert(offsetof(QueueWorkDoneCallbackInfo, callback) == offsetof(WGPUQueueWorkDoneCallbackInfo, callback),\n        \"offsetof mismatch for QueueWorkDoneCallbackInfo::callback\");\nstatic_assert(offsetof(QueueWorkDoneCallbackInfo, userdata) == offsetof(WGPUQueueWorkDoneCallbackInfo, userdata),\n        \"offsetof mismatch for QueueWorkDoneCallbackInfo::userdata\");\n\n// RenderPassDepthStencilAttachment implementation\n\nRenderPassDepthStencilAttachment::operator const WGPURenderPassDepthStencilAttachment&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassDepthStencilAttachment*>(this);\n}\n\nstatic_assert(sizeof(RenderPassDepthStencilAttachment) == sizeof(WGPURenderPassDepthStencilAttachment), \"sizeof mismatch for RenderPassDepthStencilAttachment\");\nstatic_assert(alignof(RenderPassDepthStencilAttachment) == alignof(WGPURenderPassDepthStencilAttachment), \"alignof mismatch for RenderPassDepthStencilAttachment\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, view) == offsetof(WGPURenderPassDepthStencilAttachment, view),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::view\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, depthLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthLoadOp),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::depthLoadOp\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, depthStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, depthStoreOp),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::depthStoreOp\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, depthClearValue) == offsetof(WGPURenderPassDepthStencilAttachment, depthClearValue),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::depthClearValue\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, depthReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, depthReadOnly),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::depthReadOnly\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, stencilLoadOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilLoadOp),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilLoadOp\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, stencilStoreOp) == offsetof(WGPURenderPassDepthStencilAttachment, stencilStoreOp),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilStoreOp\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, stencilClearValue) == offsetof(WGPURenderPassDepthStencilAttachment, stencilClearValue),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilClearValue\");\nstatic_assert(offsetof(RenderPassDepthStencilAttachment, stencilReadOnly) == offsetof(WGPURenderPassDepthStencilAttachment, stencilReadOnly),\n        \"offsetof mismatch for RenderPassDepthStencilAttachment::stencilReadOnly\");\n\n// RenderPassDescriptorExpandResolveRect implementation\nRenderPassDescriptorExpandResolveRect::RenderPassDescriptorExpandResolveRect()\n  : ChainedStruct { nullptr, SType::RenderPassDescriptorExpandResolveRect } {}\nstruct RenderPassDescriptorExpandResolveRect::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t x;\n    uint32_t y;\n    uint32_t width;\n    uint32_t height;\n};\nRenderPassDescriptorExpandResolveRect::RenderPassDescriptorExpandResolveRect(RenderPassDescriptorExpandResolveRect::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::RenderPassDescriptorExpandResolveRect }, \n    x(std::move(init.x)), \n    y(std::move(init.y)), \n    width(std::move(init.width)), \n    height(std::move(init.height)){}\n\nRenderPassDescriptorExpandResolveRect::operator const WGPURenderPassDescriptorExpandResolveRect&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassDescriptorExpandResolveRect*>(this);\n}\n\nstatic_assert(sizeof(RenderPassDescriptorExpandResolveRect) == sizeof(WGPURenderPassDescriptorExpandResolveRect), \"sizeof mismatch for RenderPassDescriptorExpandResolveRect\");\nstatic_assert(alignof(RenderPassDescriptorExpandResolveRect) == alignof(WGPURenderPassDescriptorExpandResolveRect), \"alignof mismatch for RenderPassDescriptorExpandResolveRect\");\nstatic_assert(offsetof(RenderPassDescriptorExpandResolveRect, x) == offsetof(WGPURenderPassDescriptorExpandResolveRect, x),\n        \"offsetof mismatch for RenderPassDescriptorExpandResolveRect::x\");\nstatic_assert(offsetof(RenderPassDescriptorExpandResolveRect, y) == offsetof(WGPURenderPassDescriptorExpandResolveRect, y),\n        \"offsetof mismatch for RenderPassDescriptorExpandResolveRect::y\");\nstatic_assert(offsetof(RenderPassDescriptorExpandResolveRect, width) == offsetof(WGPURenderPassDescriptorExpandResolveRect, width),\n        \"offsetof mismatch for RenderPassDescriptorExpandResolveRect::width\");\nstatic_assert(offsetof(RenderPassDescriptorExpandResolveRect, height) == offsetof(WGPURenderPassDescriptorExpandResolveRect, height),\n        \"offsetof mismatch for RenderPassDescriptorExpandResolveRect::height\");\n\n// RenderPassMaxDrawCount implementation\nRenderPassMaxDrawCount::RenderPassMaxDrawCount()\n  : ChainedStruct { nullptr, SType::RenderPassMaxDrawCount } {}\nstruct RenderPassMaxDrawCount::Init {\n    ChainedStruct * const nextInChain;\n    uint64_t maxDrawCount = 50000000;\n};\nRenderPassMaxDrawCount::RenderPassMaxDrawCount(RenderPassMaxDrawCount::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::RenderPassMaxDrawCount }, \n    maxDrawCount(std::move(init.maxDrawCount)){}\n\nRenderPassMaxDrawCount::operator const WGPURenderPassMaxDrawCount&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassMaxDrawCount*>(this);\n}\n\nstatic_assert(sizeof(RenderPassMaxDrawCount) == sizeof(WGPURenderPassMaxDrawCount), \"sizeof mismatch for RenderPassMaxDrawCount\");\nstatic_assert(alignof(RenderPassMaxDrawCount) == alignof(WGPURenderPassMaxDrawCount), \"alignof mismatch for RenderPassMaxDrawCount\");\nstatic_assert(offsetof(RenderPassMaxDrawCount, maxDrawCount) == offsetof(WGPURenderPassMaxDrawCount, maxDrawCount),\n        \"offsetof mismatch for RenderPassMaxDrawCount::maxDrawCount\");\n\n// RenderPassTimestampWrites implementation\n\nRenderPassTimestampWrites::operator const WGPURenderPassTimestampWrites&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassTimestampWrites*>(this);\n}\n\nstatic_assert(sizeof(RenderPassTimestampWrites) == sizeof(WGPURenderPassTimestampWrites), \"sizeof mismatch for RenderPassTimestampWrites\");\nstatic_assert(alignof(RenderPassTimestampWrites) == alignof(WGPURenderPassTimestampWrites), \"alignof mismatch for RenderPassTimestampWrites\");\nstatic_assert(offsetof(RenderPassTimestampWrites, querySet) == offsetof(WGPURenderPassTimestampWrites, querySet),\n        \"offsetof mismatch for RenderPassTimestampWrites::querySet\");\nstatic_assert(offsetof(RenderPassTimestampWrites, beginningOfPassWriteIndex) == offsetof(WGPURenderPassTimestampWrites, beginningOfPassWriteIndex),\n        \"offsetof mismatch for RenderPassTimestampWrites::beginningOfPassWriteIndex\");\nstatic_assert(offsetof(RenderPassTimestampWrites, endOfPassWriteIndex) == offsetof(WGPURenderPassTimestampWrites, endOfPassWriteIndex),\n        \"offsetof mismatch for RenderPassTimestampWrites::endOfPassWriteIndex\");\n\n// RequestAdapterCallbackInfo implementation\n\nRequestAdapterCallbackInfo::operator const WGPURequestAdapterCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPURequestAdapterCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(RequestAdapterCallbackInfo) == sizeof(WGPURequestAdapterCallbackInfo), \"sizeof mismatch for RequestAdapterCallbackInfo\");\nstatic_assert(alignof(RequestAdapterCallbackInfo) == alignof(WGPURequestAdapterCallbackInfo), \"alignof mismatch for RequestAdapterCallbackInfo\");\nstatic_assert(offsetof(RequestAdapterCallbackInfo, nextInChain) == offsetof(WGPURequestAdapterCallbackInfo, nextInChain),\n        \"offsetof mismatch for RequestAdapterCallbackInfo::nextInChain\");\nstatic_assert(offsetof(RequestAdapterCallbackInfo, mode) == offsetof(WGPURequestAdapterCallbackInfo, mode),\n        \"offsetof mismatch for RequestAdapterCallbackInfo::mode\");\nstatic_assert(offsetof(RequestAdapterCallbackInfo, callback) == offsetof(WGPURequestAdapterCallbackInfo, callback),\n        \"offsetof mismatch for RequestAdapterCallbackInfo::callback\");\nstatic_assert(offsetof(RequestAdapterCallbackInfo, userdata) == offsetof(WGPURequestAdapterCallbackInfo, userdata),\n        \"offsetof mismatch for RequestAdapterCallbackInfo::userdata\");\n\n// RequestAdapterOptions implementation\n\nRequestAdapterOptions::operator const WGPURequestAdapterOptions&() const noexcept {\n    return *reinterpret_cast<const WGPURequestAdapterOptions*>(this);\n}\n\nstatic_assert(sizeof(RequestAdapterOptions) == sizeof(WGPURequestAdapterOptions), \"sizeof mismatch for RequestAdapterOptions\");\nstatic_assert(alignof(RequestAdapterOptions) == alignof(WGPURequestAdapterOptions), \"alignof mismatch for RequestAdapterOptions\");\nstatic_assert(offsetof(RequestAdapterOptions, nextInChain) == offsetof(WGPURequestAdapterOptions, nextInChain),\n        \"offsetof mismatch for RequestAdapterOptions::nextInChain\");\nstatic_assert(offsetof(RequestAdapterOptions, compatibleSurface) == offsetof(WGPURequestAdapterOptions, compatibleSurface),\n        \"offsetof mismatch for RequestAdapterOptions::compatibleSurface\");\nstatic_assert(offsetof(RequestAdapterOptions, powerPreference) == offsetof(WGPURequestAdapterOptions, powerPreference),\n        \"offsetof mismatch for RequestAdapterOptions::powerPreference\");\nstatic_assert(offsetof(RequestAdapterOptions, backendType) == offsetof(WGPURequestAdapterOptions, backendType),\n        \"offsetof mismatch for RequestAdapterOptions::backendType\");\nstatic_assert(offsetof(RequestAdapterOptions, forceFallbackAdapter) == offsetof(WGPURequestAdapterOptions, forceFallbackAdapter),\n        \"offsetof mismatch for RequestAdapterOptions::forceFallbackAdapter\");\nstatic_assert(offsetof(RequestAdapterOptions, compatibilityMode) == offsetof(WGPURequestAdapterOptions, compatibilityMode),\n        \"offsetof mismatch for RequestAdapterOptions::compatibilityMode\");\n\n// RequestDeviceCallbackInfo implementation\n\nRequestDeviceCallbackInfo::operator const WGPURequestDeviceCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPURequestDeviceCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(RequestDeviceCallbackInfo) == sizeof(WGPURequestDeviceCallbackInfo), \"sizeof mismatch for RequestDeviceCallbackInfo\");\nstatic_assert(alignof(RequestDeviceCallbackInfo) == alignof(WGPURequestDeviceCallbackInfo), \"alignof mismatch for RequestDeviceCallbackInfo\");\nstatic_assert(offsetof(RequestDeviceCallbackInfo, nextInChain) == offsetof(WGPURequestDeviceCallbackInfo, nextInChain),\n        \"offsetof mismatch for RequestDeviceCallbackInfo::nextInChain\");\nstatic_assert(offsetof(RequestDeviceCallbackInfo, mode) == offsetof(WGPURequestDeviceCallbackInfo, mode),\n        \"offsetof mismatch for RequestDeviceCallbackInfo::mode\");\nstatic_assert(offsetof(RequestDeviceCallbackInfo, callback) == offsetof(WGPURequestDeviceCallbackInfo, callback),\n        \"offsetof mismatch for RequestDeviceCallbackInfo::callback\");\nstatic_assert(offsetof(RequestDeviceCallbackInfo, userdata) == offsetof(WGPURequestDeviceCallbackInfo, userdata),\n        \"offsetof mismatch for RequestDeviceCallbackInfo::userdata\");\n\n// SamplerBindingLayout implementation\n\nSamplerBindingLayout::operator const WGPUSamplerBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUSamplerBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(SamplerBindingLayout) == sizeof(WGPUSamplerBindingLayout), \"sizeof mismatch for SamplerBindingLayout\");\nstatic_assert(alignof(SamplerBindingLayout) == alignof(WGPUSamplerBindingLayout), \"alignof mismatch for SamplerBindingLayout\");\nstatic_assert(offsetof(SamplerBindingLayout, nextInChain) == offsetof(WGPUSamplerBindingLayout, nextInChain),\n        \"offsetof mismatch for SamplerBindingLayout::nextInChain\");\nstatic_assert(offsetof(SamplerBindingLayout, type) == offsetof(WGPUSamplerBindingLayout, type),\n        \"offsetof mismatch for SamplerBindingLayout::type\");\n\n// ShaderModuleCompilationOptions implementation\nShaderModuleCompilationOptions::ShaderModuleCompilationOptions()\n  : ChainedStruct { nullptr, SType::ShaderModuleCompilationOptions } {}\nstruct ShaderModuleCompilationOptions::Init {\n    ChainedStruct * const nextInChain;\n    Bool strictMath;\n};\nShaderModuleCompilationOptions::ShaderModuleCompilationOptions(ShaderModuleCompilationOptions::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ShaderModuleCompilationOptions }, \n    strictMath(std::move(init.strictMath)){}\n\nShaderModuleCompilationOptions::operator const WGPUShaderModuleCompilationOptions&() const noexcept {\n    return *reinterpret_cast<const WGPUShaderModuleCompilationOptions*>(this);\n}\n\nstatic_assert(sizeof(ShaderModuleCompilationOptions) == sizeof(WGPUShaderModuleCompilationOptions), \"sizeof mismatch for ShaderModuleCompilationOptions\");\nstatic_assert(alignof(ShaderModuleCompilationOptions) == alignof(WGPUShaderModuleCompilationOptions), \"alignof mismatch for ShaderModuleCompilationOptions\");\nstatic_assert(offsetof(ShaderModuleCompilationOptions, strictMath) == offsetof(WGPUShaderModuleCompilationOptions, strictMath),\n        \"offsetof mismatch for ShaderModuleCompilationOptions::strictMath\");\n\n// ShaderSourceSPIRV implementation\nShaderSourceSPIRV::ShaderSourceSPIRV()\n  : ChainedStruct { nullptr, SType::ShaderSourceSPIRV } {}\nstruct ShaderSourceSPIRV::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t codeSize;\n    uint32_t const * code;\n};\nShaderSourceSPIRV::ShaderSourceSPIRV(ShaderSourceSPIRV::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ShaderSourceSPIRV }, \n    codeSize(std::move(init.codeSize)), \n    code(std::move(init.code)){}\n\nShaderSourceSPIRV::operator const WGPUShaderSourceSPIRV&() const noexcept {\n    return *reinterpret_cast<const WGPUShaderSourceSPIRV*>(this);\n}\n\nstatic_assert(sizeof(ShaderSourceSPIRV) == sizeof(WGPUShaderSourceSPIRV), \"sizeof mismatch for ShaderSourceSPIRV\");\nstatic_assert(alignof(ShaderSourceSPIRV) == alignof(WGPUShaderSourceSPIRV), \"alignof mismatch for ShaderSourceSPIRV\");\nstatic_assert(offsetof(ShaderSourceSPIRV, codeSize) == offsetof(WGPUShaderSourceSPIRV, codeSize),\n        \"offsetof mismatch for ShaderSourceSPIRV::codeSize\");\nstatic_assert(offsetof(ShaderSourceSPIRV, code) == offsetof(WGPUShaderSourceSPIRV, code),\n        \"offsetof mismatch for ShaderSourceSPIRV::code\");\n\n// SharedBufferMemoryBeginAccessDescriptor implementation\n\nSharedBufferMemoryBeginAccessDescriptor::operator const WGPUSharedBufferMemoryBeginAccessDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedBufferMemoryBeginAccessDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedBufferMemoryBeginAccessDescriptor) == sizeof(WGPUSharedBufferMemoryBeginAccessDescriptor), \"sizeof mismatch for SharedBufferMemoryBeginAccessDescriptor\");\nstatic_assert(alignof(SharedBufferMemoryBeginAccessDescriptor) == alignof(WGPUSharedBufferMemoryBeginAccessDescriptor), \"alignof mismatch for SharedBufferMemoryBeginAccessDescriptor\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, nextInChain) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, nextInChain),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, initialized) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, initialized),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::initialized\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, fenceCount) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, fenceCount),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::fenceCount\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, fences) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, fences),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::fences\");\nstatic_assert(offsetof(SharedBufferMemoryBeginAccessDescriptor, signaledValues) == offsetof(WGPUSharedBufferMemoryBeginAccessDescriptor, signaledValues),\n        \"offsetof mismatch for SharedBufferMemoryBeginAccessDescriptor::signaledValues\");\n\n// SharedBufferMemoryEndAccessState implementation\nSharedBufferMemoryEndAccessState::SharedBufferMemoryEndAccessState() = default;\nSharedBufferMemoryEndAccessState::~SharedBufferMemoryEndAccessState() {\n    FreeMembers();\n}\n\nSharedBufferMemoryEndAccessState::SharedBufferMemoryEndAccessState(SharedBufferMemoryEndAccessState&& rhs)\n    : initialized(rhs.initialized),\n            fenceCount(rhs.fenceCount),\n            fences(rhs.fences),\n            signaledValues(rhs.signaledValues){\n    Reset(rhs);\n}\n\nSharedBufferMemoryEndAccessState& SharedBufferMemoryEndAccessState::operator=(SharedBufferMemoryEndAccessState&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->initialized) = std::move(rhs.initialized);\n    detail::AsNonConstReference(this->fenceCount) = std::move(rhs.fenceCount);\n    detail::AsNonConstReference(this->fences) = std::move(rhs.fences);\n    detail::AsNonConstReference(this->signaledValues) = std::move(rhs.signaledValues);\n    Reset(rhs);\n    return *this;\n}\n\nvoid SharedBufferMemoryEndAccessState::FreeMembers() {\n    bool needsFreeing = false;    if (this->fences != nullptr) { needsFreeing = true; }    if (this->signaledValues != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuDawnWireClientSharedBufferMemoryEndAccessStateFreeMembers(\n            *reinterpret_cast<WGPUSharedBufferMemoryEndAccessState*>(this));\n    }\n}\n\n// static\nvoid SharedBufferMemoryEndAccessState::Reset(SharedBufferMemoryEndAccessState& value) {\n    SharedBufferMemoryEndAccessState defaultValue{};\n    detail::AsNonConstReference(value.initialized) = defaultValue.initialized;\n    detail::AsNonConstReference(value.fenceCount) = defaultValue.fenceCount;\n    detail::AsNonConstReference(value.fences) = defaultValue.fences;\n    detail::AsNonConstReference(value.signaledValues) = defaultValue.signaledValues;\n}\n\nSharedBufferMemoryEndAccessState::operator const WGPUSharedBufferMemoryEndAccessState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedBufferMemoryEndAccessState*>(this);\n}\n\nstatic_assert(sizeof(SharedBufferMemoryEndAccessState) == sizeof(WGPUSharedBufferMemoryEndAccessState), \"sizeof mismatch for SharedBufferMemoryEndAccessState\");\nstatic_assert(alignof(SharedBufferMemoryEndAccessState) == alignof(WGPUSharedBufferMemoryEndAccessState), \"alignof mismatch for SharedBufferMemoryEndAccessState\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, nextInChain) == offsetof(WGPUSharedBufferMemoryEndAccessState, nextInChain),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::nextInChain\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, initialized) == offsetof(WGPUSharedBufferMemoryEndAccessState, initialized),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::initialized\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, fenceCount) == offsetof(WGPUSharedBufferMemoryEndAccessState, fenceCount),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::fenceCount\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, fences) == offsetof(WGPUSharedBufferMemoryEndAccessState, fences),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::fences\");\nstatic_assert(offsetof(SharedBufferMemoryEndAccessState, signaledValues) == offsetof(WGPUSharedBufferMemoryEndAccessState, signaledValues),\n        \"offsetof mismatch for SharedBufferMemoryEndAccessState::signaledValues\");\n\n// SharedBufferMemoryProperties implementation\n\nSharedBufferMemoryProperties::operator const WGPUSharedBufferMemoryProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedBufferMemoryProperties*>(this);\n}\n\nstatic_assert(sizeof(SharedBufferMemoryProperties) == sizeof(WGPUSharedBufferMemoryProperties), \"sizeof mismatch for SharedBufferMemoryProperties\");\nstatic_assert(alignof(SharedBufferMemoryProperties) == alignof(WGPUSharedBufferMemoryProperties), \"alignof mismatch for SharedBufferMemoryProperties\");\nstatic_assert(offsetof(SharedBufferMemoryProperties, nextInChain) == offsetof(WGPUSharedBufferMemoryProperties, nextInChain),\n        \"offsetof mismatch for SharedBufferMemoryProperties::nextInChain\");\nstatic_assert(offsetof(SharedBufferMemoryProperties, usage) == offsetof(WGPUSharedBufferMemoryProperties, usage),\n        \"offsetof mismatch for SharedBufferMemoryProperties::usage\");\nstatic_assert(offsetof(SharedBufferMemoryProperties, size) == offsetof(WGPUSharedBufferMemoryProperties, size),\n        \"offsetof mismatch for SharedBufferMemoryProperties::size\");\n\n// SharedFenceDXGISharedHandleDescriptor implementation\nSharedFenceDXGISharedHandleDescriptor::SharedFenceDXGISharedHandleDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceDXGISharedHandleDescriptor } {}\nstruct SharedFenceDXGISharedHandleDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * handle;\n};\nSharedFenceDXGISharedHandleDescriptor::SharedFenceDXGISharedHandleDescriptor(SharedFenceDXGISharedHandleDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceDXGISharedHandleDescriptor }, \n    handle(std::move(init.handle)){}\n\nSharedFenceDXGISharedHandleDescriptor::operator const WGPUSharedFenceDXGISharedHandleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceDXGISharedHandleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceDXGISharedHandleDescriptor) == sizeof(WGPUSharedFenceDXGISharedHandleDescriptor), \"sizeof mismatch for SharedFenceDXGISharedHandleDescriptor\");\nstatic_assert(alignof(SharedFenceDXGISharedHandleDescriptor) == alignof(WGPUSharedFenceDXGISharedHandleDescriptor), \"alignof mismatch for SharedFenceDXGISharedHandleDescriptor\");\nstatic_assert(offsetof(SharedFenceDXGISharedHandleDescriptor, handle) == offsetof(WGPUSharedFenceDXGISharedHandleDescriptor, handle),\n        \"offsetof mismatch for SharedFenceDXGISharedHandleDescriptor::handle\");\n\n// SharedFenceDXGISharedHandleExportInfo implementation\nSharedFenceDXGISharedHandleExportInfo::SharedFenceDXGISharedHandleExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceDXGISharedHandleExportInfo } {}\nstruct SharedFenceDXGISharedHandleExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    void * handle;\n};\nSharedFenceDXGISharedHandleExportInfo::SharedFenceDXGISharedHandleExportInfo(SharedFenceDXGISharedHandleExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceDXGISharedHandleExportInfo }, \n    handle(std::move(init.handle)){}\n\nSharedFenceDXGISharedHandleExportInfo::operator const WGPUSharedFenceDXGISharedHandleExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceDXGISharedHandleExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceDXGISharedHandleExportInfo) == sizeof(WGPUSharedFenceDXGISharedHandleExportInfo), \"sizeof mismatch for SharedFenceDXGISharedHandleExportInfo\");\nstatic_assert(alignof(SharedFenceDXGISharedHandleExportInfo) == alignof(WGPUSharedFenceDXGISharedHandleExportInfo), \"alignof mismatch for SharedFenceDXGISharedHandleExportInfo\");\nstatic_assert(offsetof(SharedFenceDXGISharedHandleExportInfo, handle) == offsetof(WGPUSharedFenceDXGISharedHandleExportInfo, handle),\n        \"offsetof mismatch for SharedFenceDXGISharedHandleExportInfo::handle\");\n\n// SharedFenceMTLSharedEventDescriptor implementation\nSharedFenceMTLSharedEventDescriptor::SharedFenceMTLSharedEventDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceMTLSharedEventDescriptor } {}\nstruct SharedFenceMTLSharedEventDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * sharedEvent;\n};\nSharedFenceMTLSharedEventDescriptor::SharedFenceMTLSharedEventDescriptor(SharedFenceMTLSharedEventDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceMTLSharedEventDescriptor }, \n    sharedEvent(std::move(init.sharedEvent)){}\n\nSharedFenceMTLSharedEventDescriptor::operator const WGPUSharedFenceMTLSharedEventDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceMTLSharedEventDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceMTLSharedEventDescriptor) == sizeof(WGPUSharedFenceMTLSharedEventDescriptor), \"sizeof mismatch for SharedFenceMTLSharedEventDescriptor\");\nstatic_assert(alignof(SharedFenceMTLSharedEventDescriptor) == alignof(WGPUSharedFenceMTLSharedEventDescriptor), \"alignof mismatch for SharedFenceMTLSharedEventDescriptor\");\nstatic_assert(offsetof(SharedFenceMTLSharedEventDescriptor, sharedEvent) == offsetof(WGPUSharedFenceMTLSharedEventDescriptor, sharedEvent),\n        \"offsetof mismatch for SharedFenceMTLSharedEventDescriptor::sharedEvent\");\n\n// SharedFenceMTLSharedEventExportInfo implementation\nSharedFenceMTLSharedEventExportInfo::SharedFenceMTLSharedEventExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceMTLSharedEventExportInfo } {}\nstruct SharedFenceMTLSharedEventExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    void * sharedEvent;\n};\nSharedFenceMTLSharedEventExportInfo::SharedFenceMTLSharedEventExportInfo(SharedFenceMTLSharedEventExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceMTLSharedEventExportInfo }, \n    sharedEvent(std::move(init.sharedEvent)){}\n\nSharedFenceMTLSharedEventExportInfo::operator const WGPUSharedFenceMTLSharedEventExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceMTLSharedEventExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceMTLSharedEventExportInfo) == sizeof(WGPUSharedFenceMTLSharedEventExportInfo), \"sizeof mismatch for SharedFenceMTLSharedEventExportInfo\");\nstatic_assert(alignof(SharedFenceMTLSharedEventExportInfo) == alignof(WGPUSharedFenceMTLSharedEventExportInfo), \"alignof mismatch for SharedFenceMTLSharedEventExportInfo\");\nstatic_assert(offsetof(SharedFenceMTLSharedEventExportInfo, sharedEvent) == offsetof(WGPUSharedFenceMTLSharedEventExportInfo, sharedEvent),\n        \"offsetof mismatch for SharedFenceMTLSharedEventExportInfo::sharedEvent\");\n\n// SharedFenceExportInfo implementation\n\nSharedFenceExportInfo::operator const WGPUSharedFenceExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceExportInfo) == sizeof(WGPUSharedFenceExportInfo), \"sizeof mismatch for SharedFenceExportInfo\");\nstatic_assert(alignof(SharedFenceExportInfo) == alignof(WGPUSharedFenceExportInfo), \"alignof mismatch for SharedFenceExportInfo\");\nstatic_assert(offsetof(SharedFenceExportInfo, nextInChain) == offsetof(WGPUSharedFenceExportInfo, nextInChain),\n        \"offsetof mismatch for SharedFenceExportInfo::nextInChain\");\nstatic_assert(offsetof(SharedFenceExportInfo, type) == offsetof(WGPUSharedFenceExportInfo, type),\n        \"offsetof mismatch for SharedFenceExportInfo::type\");\n\n// SharedFenceSyncFDDescriptor implementation\nSharedFenceSyncFDDescriptor::SharedFenceSyncFDDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceSyncFDDescriptor } {}\nstruct SharedFenceSyncFDDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    int handle;\n};\nSharedFenceSyncFDDescriptor::SharedFenceSyncFDDescriptor(SharedFenceSyncFDDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceSyncFDDescriptor }, \n    handle(std::move(init.handle)){}\n\nSharedFenceSyncFDDescriptor::operator const WGPUSharedFenceSyncFDDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceSyncFDDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceSyncFDDescriptor) == sizeof(WGPUSharedFenceSyncFDDescriptor), \"sizeof mismatch for SharedFenceSyncFDDescriptor\");\nstatic_assert(alignof(SharedFenceSyncFDDescriptor) == alignof(WGPUSharedFenceSyncFDDescriptor), \"alignof mismatch for SharedFenceSyncFDDescriptor\");\nstatic_assert(offsetof(SharedFenceSyncFDDescriptor, handle) == offsetof(WGPUSharedFenceSyncFDDescriptor, handle),\n        \"offsetof mismatch for SharedFenceSyncFDDescriptor::handle\");\n\n// SharedFenceSyncFDExportInfo implementation\nSharedFenceSyncFDExportInfo::SharedFenceSyncFDExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceSyncFDExportInfo } {}\nstruct SharedFenceSyncFDExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    int handle;\n};\nSharedFenceSyncFDExportInfo::SharedFenceSyncFDExportInfo(SharedFenceSyncFDExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceSyncFDExportInfo }, \n    handle(std::move(init.handle)){}\n\nSharedFenceSyncFDExportInfo::operator const WGPUSharedFenceSyncFDExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceSyncFDExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceSyncFDExportInfo) == sizeof(WGPUSharedFenceSyncFDExportInfo), \"sizeof mismatch for SharedFenceSyncFDExportInfo\");\nstatic_assert(alignof(SharedFenceSyncFDExportInfo) == alignof(WGPUSharedFenceSyncFDExportInfo), \"alignof mismatch for SharedFenceSyncFDExportInfo\");\nstatic_assert(offsetof(SharedFenceSyncFDExportInfo, handle) == offsetof(WGPUSharedFenceSyncFDExportInfo, handle),\n        \"offsetof mismatch for SharedFenceSyncFDExportInfo::handle\");\n\n// SharedFenceVkSemaphoreOpaqueFDDescriptor implementation\nSharedFenceVkSemaphoreOpaqueFDDescriptor::SharedFenceVkSemaphoreOpaqueFDDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceVkSemaphoreOpaqueFDDescriptor } {}\nstruct SharedFenceVkSemaphoreOpaqueFDDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    int handle;\n};\nSharedFenceVkSemaphoreOpaqueFDDescriptor::SharedFenceVkSemaphoreOpaqueFDDescriptor(SharedFenceVkSemaphoreOpaqueFDDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceVkSemaphoreOpaqueFDDescriptor }, \n    handle(std::move(init.handle)){}\n\nSharedFenceVkSemaphoreOpaqueFDDescriptor::operator const WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceVkSemaphoreOpaqueFDDescriptor) == sizeof(WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor), \"sizeof mismatch for SharedFenceVkSemaphoreOpaqueFDDescriptor\");\nstatic_assert(alignof(SharedFenceVkSemaphoreOpaqueFDDescriptor) == alignof(WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor), \"alignof mismatch for SharedFenceVkSemaphoreOpaqueFDDescriptor\");\nstatic_assert(offsetof(SharedFenceVkSemaphoreOpaqueFDDescriptor, handle) == offsetof(WGPUSharedFenceVkSemaphoreOpaqueFDDescriptor, handle),\n        \"offsetof mismatch for SharedFenceVkSemaphoreOpaqueFDDescriptor::handle\");\n\n// SharedFenceVkSemaphoreOpaqueFDExportInfo implementation\nSharedFenceVkSemaphoreOpaqueFDExportInfo::SharedFenceVkSemaphoreOpaqueFDExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceVkSemaphoreOpaqueFDExportInfo } {}\nstruct SharedFenceVkSemaphoreOpaqueFDExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    int handle;\n};\nSharedFenceVkSemaphoreOpaqueFDExportInfo::SharedFenceVkSemaphoreOpaqueFDExportInfo(SharedFenceVkSemaphoreOpaqueFDExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceVkSemaphoreOpaqueFDExportInfo }, \n    handle(std::move(init.handle)){}\n\nSharedFenceVkSemaphoreOpaqueFDExportInfo::operator const WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceVkSemaphoreOpaqueFDExportInfo) == sizeof(WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo), \"sizeof mismatch for SharedFenceVkSemaphoreOpaqueFDExportInfo\");\nstatic_assert(alignof(SharedFenceVkSemaphoreOpaqueFDExportInfo) == alignof(WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo), \"alignof mismatch for SharedFenceVkSemaphoreOpaqueFDExportInfo\");\nstatic_assert(offsetof(SharedFenceVkSemaphoreOpaqueFDExportInfo, handle) == offsetof(WGPUSharedFenceVkSemaphoreOpaqueFDExportInfo, handle),\n        \"offsetof mismatch for SharedFenceVkSemaphoreOpaqueFDExportInfo::handle\");\n\n// SharedFenceVkSemaphoreZirconHandleDescriptor implementation\nSharedFenceVkSemaphoreZirconHandleDescriptor::SharedFenceVkSemaphoreZirconHandleDescriptor()\n  : ChainedStruct { nullptr, SType::SharedFenceVkSemaphoreZirconHandleDescriptor } {}\nstruct SharedFenceVkSemaphoreZirconHandleDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t handle;\n};\nSharedFenceVkSemaphoreZirconHandleDescriptor::SharedFenceVkSemaphoreZirconHandleDescriptor(SharedFenceVkSemaphoreZirconHandleDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedFenceVkSemaphoreZirconHandleDescriptor }, \n    handle(std::move(init.handle)){}\n\nSharedFenceVkSemaphoreZirconHandleDescriptor::operator const WGPUSharedFenceVkSemaphoreZirconHandleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceVkSemaphoreZirconHandleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceVkSemaphoreZirconHandleDescriptor) == sizeof(WGPUSharedFenceVkSemaphoreZirconHandleDescriptor), \"sizeof mismatch for SharedFenceVkSemaphoreZirconHandleDescriptor\");\nstatic_assert(alignof(SharedFenceVkSemaphoreZirconHandleDescriptor) == alignof(WGPUSharedFenceVkSemaphoreZirconHandleDescriptor), \"alignof mismatch for SharedFenceVkSemaphoreZirconHandleDescriptor\");\nstatic_assert(offsetof(SharedFenceVkSemaphoreZirconHandleDescriptor, handle) == offsetof(WGPUSharedFenceVkSemaphoreZirconHandleDescriptor, handle),\n        \"offsetof mismatch for SharedFenceVkSemaphoreZirconHandleDescriptor::handle\");\n\n// SharedFenceVkSemaphoreZirconHandleExportInfo implementation\nSharedFenceVkSemaphoreZirconHandleExportInfo::SharedFenceVkSemaphoreZirconHandleExportInfo()\n  : ChainedStructOut { nullptr, SType::SharedFenceVkSemaphoreZirconHandleExportInfo } {}\nstruct SharedFenceVkSemaphoreZirconHandleExportInfo::Init {\n    ChainedStructOut *  nextInChain;\n    uint32_t handle;\n};\nSharedFenceVkSemaphoreZirconHandleExportInfo::SharedFenceVkSemaphoreZirconHandleExportInfo(SharedFenceVkSemaphoreZirconHandleExportInfo::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedFenceVkSemaphoreZirconHandleExportInfo }, \n    handle(std::move(init.handle)){}\n\nSharedFenceVkSemaphoreZirconHandleExportInfo::operator const WGPUSharedFenceVkSemaphoreZirconHandleExportInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceVkSemaphoreZirconHandleExportInfo*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceVkSemaphoreZirconHandleExportInfo) == sizeof(WGPUSharedFenceVkSemaphoreZirconHandleExportInfo), \"sizeof mismatch for SharedFenceVkSemaphoreZirconHandleExportInfo\");\nstatic_assert(alignof(SharedFenceVkSemaphoreZirconHandleExportInfo) == alignof(WGPUSharedFenceVkSemaphoreZirconHandleExportInfo), \"alignof mismatch for SharedFenceVkSemaphoreZirconHandleExportInfo\");\nstatic_assert(offsetof(SharedFenceVkSemaphoreZirconHandleExportInfo, handle) == offsetof(WGPUSharedFenceVkSemaphoreZirconHandleExportInfo, handle),\n        \"offsetof mismatch for SharedFenceVkSemaphoreZirconHandleExportInfo::handle\");\n\n// SharedTextureMemoryD3DSwapchainBeginState implementation\nSharedTextureMemoryD3DSwapchainBeginState::SharedTextureMemoryD3DSwapchainBeginState()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryD3DSwapchainBeginState } {}\nstruct SharedTextureMemoryD3DSwapchainBeginState::Init {\n    ChainedStruct * const nextInChain;\n    Bool isSwapchain = false;\n};\nSharedTextureMemoryD3DSwapchainBeginState::SharedTextureMemoryD3DSwapchainBeginState(SharedTextureMemoryD3DSwapchainBeginState::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryD3DSwapchainBeginState }, \n    isSwapchain(std::move(init.isSwapchain)){}\n\nSharedTextureMemoryD3DSwapchainBeginState::operator const WGPUSharedTextureMemoryD3DSwapchainBeginState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryD3DSwapchainBeginState*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryD3DSwapchainBeginState) == sizeof(WGPUSharedTextureMemoryD3DSwapchainBeginState), \"sizeof mismatch for SharedTextureMemoryD3DSwapchainBeginState\");\nstatic_assert(alignof(SharedTextureMemoryD3DSwapchainBeginState) == alignof(WGPUSharedTextureMemoryD3DSwapchainBeginState), \"alignof mismatch for SharedTextureMemoryD3DSwapchainBeginState\");\nstatic_assert(offsetof(SharedTextureMemoryD3DSwapchainBeginState, isSwapchain) == offsetof(WGPUSharedTextureMemoryD3DSwapchainBeginState, isSwapchain),\n        \"offsetof mismatch for SharedTextureMemoryD3DSwapchainBeginState::isSwapchain\");\n\n// SharedTextureMemoryDXGISharedHandleDescriptor implementation\nSharedTextureMemoryDXGISharedHandleDescriptor::SharedTextureMemoryDXGISharedHandleDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryDXGISharedHandleDescriptor } {}\nstruct SharedTextureMemoryDXGISharedHandleDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * handle;\n    Bool useKeyedMutex;\n};\nSharedTextureMemoryDXGISharedHandleDescriptor::SharedTextureMemoryDXGISharedHandleDescriptor(SharedTextureMemoryDXGISharedHandleDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryDXGISharedHandleDescriptor }, \n    handle(std::move(init.handle)), \n    useKeyedMutex(std::move(init.useKeyedMutex)){}\n\nSharedTextureMemoryDXGISharedHandleDescriptor::operator const WGPUSharedTextureMemoryDXGISharedHandleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryDXGISharedHandleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryDXGISharedHandleDescriptor) == sizeof(WGPUSharedTextureMemoryDXGISharedHandleDescriptor), \"sizeof mismatch for SharedTextureMemoryDXGISharedHandleDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryDXGISharedHandleDescriptor) == alignof(WGPUSharedTextureMemoryDXGISharedHandleDescriptor), \"alignof mismatch for SharedTextureMemoryDXGISharedHandleDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryDXGISharedHandleDescriptor, handle) == offsetof(WGPUSharedTextureMemoryDXGISharedHandleDescriptor, handle),\n        \"offsetof mismatch for SharedTextureMemoryDXGISharedHandleDescriptor::handle\");\nstatic_assert(offsetof(SharedTextureMemoryDXGISharedHandleDescriptor, useKeyedMutex) == offsetof(WGPUSharedTextureMemoryDXGISharedHandleDescriptor, useKeyedMutex),\n        \"offsetof mismatch for SharedTextureMemoryDXGISharedHandleDescriptor::useKeyedMutex\");\n\n// SharedTextureMemoryEGLImageDescriptor implementation\nSharedTextureMemoryEGLImageDescriptor::SharedTextureMemoryEGLImageDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryEGLImageDescriptor } {}\nstruct SharedTextureMemoryEGLImageDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * image;\n};\nSharedTextureMemoryEGLImageDescriptor::SharedTextureMemoryEGLImageDescriptor(SharedTextureMemoryEGLImageDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryEGLImageDescriptor }, \n    image(std::move(init.image)){}\n\nSharedTextureMemoryEGLImageDescriptor::operator const WGPUSharedTextureMemoryEGLImageDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryEGLImageDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryEGLImageDescriptor) == sizeof(WGPUSharedTextureMemoryEGLImageDescriptor), \"sizeof mismatch for SharedTextureMemoryEGLImageDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryEGLImageDescriptor) == alignof(WGPUSharedTextureMemoryEGLImageDescriptor), \"alignof mismatch for SharedTextureMemoryEGLImageDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryEGLImageDescriptor, image) == offsetof(WGPUSharedTextureMemoryEGLImageDescriptor, image),\n        \"offsetof mismatch for SharedTextureMemoryEGLImageDescriptor::image\");\n\n// SharedTextureMemoryIOSurfaceDescriptor implementation\nSharedTextureMemoryIOSurfaceDescriptor::SharedTextureMemoryIOSurfaceDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryIOSurfaceDescriptor } {}\nstruct SharedTextureMemoryIOSurfaceDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * ioSurface;\n};\nSharedTextureMemoryIOSurfaceDescriptor::SharedTextureMemoryIOSurfaceDescriptor(SharedTextureMemoryIOSurfaceDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryIOSurfaceDescriptor }, \n    ioSurface(std::move(init.ioSurface)){}\n\nSharedTextureMemoryIOSurfaceDescriptor::operator const WGPUSharedTextureMemoryIOSurfaceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryIOSurfaceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryIOSurfaceDescriptor) == sizeof(WGPUSharedTextureMemoryIOSurfaceDescriptor), \"sizeof mismatch for SharedTextureMemoryIOSurfaceDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryIOSurfaceDescriptor) == alignof(WGPUSharedTextureMemoryIOSurfaceDescriptor), \"alignof mismatch for SharedTextureMemoryIOSurfaceDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryIOSurfaceDescriptor, ioSurface) == offsetof(WGPUSharedTextureMemoryIOSurfaceDescriptor, ioSurface),\n        \"offsetof mismatch for SharedTextureMemoryIOSurfaceDescriptor::ioSurface\");\n\n// SharedTextureMemoryAHardwareBufferDescriptor implementation\nSharedTextureMemoryAHardwareBufferDescriptor::SharedTextureMemoryAHardwareBufferDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryAHardwareBufferDescriptor } {}\nstruct SharedTextureMemoryAHardwareBufferDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void * handle;\n    Bool useExternalFormat;\n};\nSharedTextureMemoryAHardwareBufferDescriptor::SharedTextureMemoryAHardwareBufferDescriptor(SharedTextureMemoryAHardwareBufferDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryAHardwareBufferDescriptor }, \n    handle(std::move(init.handle)), \n    useExternalFormat(std::move(init.useExternalFormat)){}\n\nSharedTextureMemoryAHardwareBufferDescriptor::operator const WGPUSharedTextureMemoryAHardwareBufferDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryAHardwareBufferDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryAHardwareBufferDescriptor) == sizeof(WGPUSharedTextureMemoryAHardwareBufferDescriptor), \"sizeof mismatch for SharedTextureMemoryAHardwareBufferDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryAHardwareBufferDescriptor) == alignof(WGPUSharedTextureMemoryAHardwareBufferDescriptor), \"alignof mismatch for SharedTextureMemoryAHardwareBufferDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryAHardwareBufferDescriptor, handle) == offsetof(WGPUSharedTextureMemoryAHardwareBufferDescriptor, handle),\n        \"offsetof mismatch for SharedTextureMemoryAHardwareBufferDescriptor::handle\");\nstatic_assert(offsetof(SharedTextureMemoryAHardwareBufferDescriptor, useExternalFormat) == offsetof(WGPUSharedTextureMemoryAHardwareBufferDescriptor, useExternalFormat),\n        \"offsetof mismatch for SharedTextureMemoryAHardwareBufferDescriptor::useExternalFormat\");\n\n// SharedTextureMemoryBeginAccessDescriptor implementation\n\nSharedTextureMemoryBeginAccessDescriptor::operator const WGPUSharedTextureMemoryBeginAccessDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryBeginAccessDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryBeginAccessDescriptor) == sizeof(WGPUSharedTextureMemoryBeginAccessDescriptor), \"sizeof mismatch for SharedTextureMemoryBeginAccessDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryBeginAccessDescriptor) == alignof(WGPUSharedTextureMemoryBeginAccessDescriptor), \"alignof mismatch for SharedTextureMemoryBeginAccessDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, nextInChain) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, nextInChain),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, concurrentRead) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, concurrentRead),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::concurrentRead\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, initialized) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, initialized),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::initialized\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, fenceCount) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, fenceCount),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::fenceCount\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, fences) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, fences),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::fences\");\nstatic_assert(offsetof(SharedTextureMemoryBeginAccessDescriptor, signaledValues) == offsetof(WGPUSharedTextureMemoryBeginAccessDescriptor, signaledValues),\n        \"offsetof mismatch for SharedTextureMemoryBeginAccessDescriptor::signaledValues\");\n\n// SharedTextureMemoryDmaBufPlane implementation\n\nSharedTextureMemoryDmaBufPlane::operator const WGPUSharedTextureMemoryDmaBufPlane&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryDmaBufPlane*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryDmaBufPlane) == sizeof(WGPUSharedTextureMemoryDmaBufPlane), \"sizeof mismatch for SharedTextureMemoryDmaBufPlane\");\nstatic_assert(alignof(SharedTextureMemoryDmaBufPlane) == alignof(WGPUSharedTextureMemoryDmaBufPlane), \"alignof mismatch for SharedTextureMemoryDmaBufPlane\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufPlane, fd) == offsetof(WGPUSharedTextureMemoryDmaBufPlane, fd),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufPlane::fd\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufPlane, offset) == offsetof(WGPUSharedTextureMemoryDmaBufPlane, offset),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufPlane::offset\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufPlane, stride) == offsetof(WGPUSharedTextureMemoryDmaBufPlane, stride),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufPlane::stride\");\n\n// SharedTextureMemoryEndAccessState implementation\nSharedTextureMemoryEndAccessState::SharedTextureMemoryEndAccessState() = default;\nSharedTextureMemoryEndAccessState::~SharedTextureMemoryEndAccessState() {\n    FreeMembers();\n}\n\nSharedTextureMemoryEndAccessState::SharedTextureMemoryEndAccessState(SharedTextureMemoryEndAccessState&& rhs)\n    : initialized(rhs.initialized),\n            fenceCount(rhs.fenceCount),\n            fences(rhs.fences),\n            signaledValues(rhs.signaledValues){\n    Reset(rhs);\n}\n\nSharedTextureMemoryEndAccessState& SharedTextureMemoryEndAccessState::operator=(SharedTextureMemoryEndAccessState&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->initialized) = std::move(rhs.initialized);\n    detail::AsNonConstReference(this->fenceCount) = std::move(rhs.fenceCount);\n    detail::AsNonConstReference(this->fences) = std::move(rhs.fences);\n    detail::AsNonConstReference(this->signaledValues) = std::move(rhs.signaledValues);\n    Reset(rhs);\n    return *this;\n}\n\nvoid SharedTextureMemoryEndAccessState::FreeMembers() {\n    bool needsFreeing = false;    if (this->fences != nullptr) { needsFreeing = true; }    if (this->signaledValues != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuDawnWireClientSharedTextureMemoryEndAccessStateFreeMembers(\n            *reinterpret_cast<WGPUSharedTextureMemoryEndAccessState*>(this));\n    }\n}\n\n// static\nvoid SharedTextureMemoryEndAccessState::Reset(SharedTextureMemoryEndAccessState& value) {\n    SharedTextureMemoryEndAccessState defaultValue{};\n    detail::AsNonConstReference(value.initialized) = defaultValue.initialized;\n    detail::AsNonConstReference(value.fenceCount) = defaultValue.fenceCount;\n    detail::AsNonConstReference(value.fences) = defaultValue.fences;\n    detail::AsNonConstReference(value.signaledValues) = defaultValue.signaledValues;\n}\n\nSharedTextureMemoryEndAccessState::operator const WGPUSharedTextureMemoryEndAccessState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryEndAccessState*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryEndAccessState) == sizeof(WGPUSharedTextureMemoryEndAccessState), \"sizeof mismatch for SharedTextureMemoryEndAccessState\");\nstatic_assert(alignof(SharedTextureMemoryEndAccessState) == alignof(WGPUSharedTextureMemoryEndAccessState), \"alignof mismatch for SharedTextureMemoryEndAccessState\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, nextInChain) == offsetof(WGPUSharedTextureMemoryEndAccessState, nextInChain),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::nextInChain\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, initialized) == offsetof(WGPUSharedTextureMemoryEndAccessState, initialized),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::initialized\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, fenceCount) == offsetof(WGPUSharedTextureMemoryEndAccessState, fenceCount),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::fenceCount\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, fences) == offsetof(WGPUSharedTextureMemoryEndAccessState, fences),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::fences\");\nstatic_assert(offsetof(SharedTextureMemoryEndAccessState, signaledValues) == offsetof(WGPUSharedTextureMemoryEndAccessState, signaledValues),\n        \"offsetof mismatch for SharedTextureMemoryEndAccessState::signaledValues\");\n\n// SharedTextureMemoryOpaqueFDDescriptor implementation\nSharedTextureMemoryOpaqueFDDescriptor::SharedTextureMemoryOpaqueFDDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryOpaqueFDDescriptor } {}\nstruct SharedTextureMemoryOpaqueFDDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    void const * vkImageCreateInfo;\n    int memoryFD;\n    uint32_t memoryTypeIndex;\n    uint64_t allocationSize;\n    Bool dedicatedAllocation;\n};\nSharedTextureMemoryOpaqueFDDescriptor::SharedTextureMemoryOpaqueFDDescriptor(SharedTextureMemoryOpaqueFDDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryOpaqueFDDescriptor }, \n    vkImageCreateInfo(std::move(init.vkImageCreateInfo)), \n    memoryFD(std::move(init.memoryFD)), \n    memoryTypeIndex(std::move(init.memoryTypeIndex)), \n    allocationSize(std::move(init.allocationSize)), \n    dedicatedAllocation(std::move(init.dedicatedAllocation)){}\n\nSharedTextureMemoryOpaqueFDDescriptor::operator const WGPUSharedTextureMemoryOpaqueFDDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryOpaqueFDDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryOpaqueFDDescriptor) == sizeof(WGPUSharedTextureMemoryOpaqueFDDescriptor), \"sizeof mismatch for SharedTextureMemoryOpaqueFDDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryOpaqueFDDescriptor) == alignof(WGPUSharedTextureMemoryOpaqueFDDescriptor), \"alignof mismatch for SharedTextureMemoryOpaqueFDDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, vkImageCreateInfo) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, vkImageCreateInfo),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::vkImageCreateInfo\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, memoryFD) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, memoryFD),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::memoryFD\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, memoryTypeIndex) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, memoryTypeIndex),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::memoryTypeIndex\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, allocationSize) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, allocationSize),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::allocationSize\");\nstatic_assert(offsetof(SharedTextureMemoryOpaqueFDDescriptor, dedicatedAllocation) == offsetof(WGPUSharedTextureMemoryOpaqueFDDescriptor, dedicatedAllocation),\n        \"offsetof mismatch for SharedTextureMemoryOpaqueFDDescriptor::dedicatedAllocation\");\n\n// SharedTextureMemoryVkDedicatedAllocationDescriptor implementation\nSharedTextureMemoryVkDedicatedAllocationDescriptor::SharedTextureMemoryVkDedicatedAllocationDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryVkDedicatedAllocationDescriptor } {}\nstruct SharedTextureMemoryVkDedicatedAllocationDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    Bool dedicatedAllocation;\n};\nSharedTextureMemoryVkDedicatedAllocationDescriptor::SharedTextureMemoryVkDedicatedAllocationDescriptor(SharedTextureMemoryVkDedicatedAllocationDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryVkDedicatedAllocationDescriptor }, \n    dedicatedAllocation(std::move(init.dedicatedAllocation)){}\n\nSharedTextureMemoryVkDedicatedAllocationDescriptor::operator const WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryVkDedicatedAllocationDescriptor) == sizeof(WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor), \"sizeof mismatch for SharedTextureMemoryVkDedicatedAllocationDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryVkDedicatedAllocationDescriptor) == alignof(WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor), \"alignof mismatch for SharedTextureMemoryVkDedicatedAllocationDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryVkDedicatedAllocationDescriptor, dedicatedAllocation) == offsetof(WGPUSharedTextureMemoryVkDedicatedAllocationDescriptor, dedicatedAllocation),\n        \"offsetof mismatch for SharedTextureMemoryVkDedicatedAllocationDescriptor::dedicatedAllocation\");\n\n// SharedTextureMemoryVkImageLayoutBeginState implementation\nSharedTextureMemoryVkImageLayoutBeginState::SharedTextureMemoryVkImageLayoutBeginState()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryVkImageLayoutBeginState } {}\nstruct SharedTextureMemoryVkImageLayoutBeginState::Init {\n    ChainedStruct * const nextInChain;\n    int32_t oldLayout;\n    int32_t newLayout;\n};\nSharedTextureMemoryVkImageLayoutBeginState::SharedTextureMemoryVkImageLayoutBeginState(SharedTextureMemoryVkImageLayoutBeginState::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryVkImageLayoutBeginState }, \n    oldLayout(std::move(init.oldLayout)), \n    newLayout(std::move(init.newLayout)){}\n\nSharedTextureMemoryVkImageLayoutBeginState::operator const WGPUSharedTextureMemoryVkImageLayoutBeginState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryVkImageLayoutBeginState*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryVkImageLayoutBeginState) == sizeof(WGPUSharedTextureMemoryVkImageLayoutBeginState), \"sizeof mismatch for SharedTextureMemoryVkImageLayoutBeginState\");\nstatic_assert(alignof(SharedTextureMemoryVkImageLayoutBeginState) == alignof(WGPUSharedTextureMemoryVkImageLayoutBeginState), \"alignof mismatch for SharedTextureMemoryVkImageLayoutBeginState\");\nstatic_assert(offsetof(SharedTextureMemoryVkImageLayoutBeginState, oldLayout) == offsetof(WGPUSharedTextureMemoryVkImageLayoutBeginState, oldLayout),\n        \"offsetof mismatch for SharedTextureMemoryVkImageLayoutBeginState::oldLayout\");\nstatic_assert(offsetof(SharedTextureMemoryVkImageLayoutBeginState, newLayout) == offsetof(WGPUSharedTextureMemoryVkImageLayoutBeginState, newLayout),\n        \"offsetof mismatch for SharedTextureMemoryVkImageLayoutBeginState::newLayout\");\n\n// SharedTextureMemoryVkImageLayoutEndState implementation\nSharedTextureMemoryVkImageLayoutEndState::SharedTextureMemoryVkImageLayoutEndState()\n  : ChainedStructOut { nullptr, SType::SharedTextureMemoryVkImageLayoutEndState } {}\nstruct SharedTextureMemoryVkImageLayoutEndState::Init {\n    ChainedStructOut *  nextInChain;\n    int32_t oldLayout;\n    int32_t newLayout;\n};\nSharedTextureMemoryVkImageLayoutEndState::SharedTextureMemoryVkImageLayoutEndState(SharedTextureMemoryVkImageLayoutEndState::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedTextureMemoryVkImageLayoutEndState }, \n    oldLayout(std::move(init.oldLayout)), \n    newLayout(std::move(init.newLayout)){}\n\nSharedTextureMemoryVkImageLayoutEndState::operator const WGPUSharedTextureMemoryVkImageLayoutEndState&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryVkImageLayoutEndState*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryVkImageLayoutEndState) == sizeof(WGPUSharedTextureMemoryVkImageLayoutEndState), \"sizeof mismatch for SharedTextureMemoryVkImageLayoutEndState\");\nstatic_assert(alignof(SharedTextureMemoryVkImageLayoutEndState) == alignof(WGPUSharedTextureMemoryVkImageLayoutEndState), \"alignof mismatch for SharedTextureMemoryVkImageLayoutEndState\");\nstatic_assert(offsetof(SharedTextureMemoryVkImageLayoutEndState, oldLayout) == offsetof(WGPUSharedTextureMemoryVkImageLayoutEndState, oldLayout),\n        \"offsetof mismatch for SharedTextureMemoryVkImageLayoutEndState::oldLayout\");\nstatic_assert(offsetof(SharedTextureMemoryVkImageLayoutEndState, newLayout) == offsetof(WGPUSharedTextureMemoryVkImageLayoutEndState, newLayout),\n        \"offsetof mismatch for SharedTextureMemoryVkImageLayoutEndState::newLayout\");\n\n// SharedTextureMemoryZirconHandleDescriptor implementation\nSharedTextureMemoryZirconHandleDescriptor::SharedTextureMemoryZirconHandleDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryZirconHandleDescriptor } {}\nstruct SharedTextureMemoryZirconHandleDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t memoryFD;\n    uint64_t allocationSize;\n};\nSharedTextureMemoryZirconHandleDescriptor::SharedTextureMemoryZirconHandleDescriptor(SharedTextureMemoryZirconHandleDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryZirconHandleDescriptor }, \n    memoryFD(std::move(init.memoryFD)), \n    allocationSize(std::move(init.allocationSize)){}\n\nSharedTextureMemoryZirconHandleDescriptor::operator const WGPUSharedTextureMemoryZirconHandleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryZirconHandleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryZirconHandleDescriptor) == sizeof(WGPUSharedTextureMemoryZirconHandleDescriptor), \"sizeof mismatch for SharedTextureMemoryZirconHandleDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryZirconHandleDescriptor) == alignof(WGPUSharedTextureMemoryZirconHandleDescriptor), \"alignof mismatch for SharedTextureMemoryZirconHandleDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryZirconHandleDescriptor, memoryFD) == offsetof(WGPUSharedTextureMemoryZirconHandleDescriptor, memoryFD),\n        \"offsetof mismatch for SharedTextureMemoryZirconHandleDescriptor::memoryFD\");\nstatic_assert(offsetof(SharedTextureMemoryZirconHandleDescriptor, allocationSize) == offsetof(WGPUSharedTextureMemoryZirconHandleDescriptor, allocationSize),\n        \"offsetof mismatch for SharedTextureMemoryZirconHandleDescriptor::allocationSize\");\n\n// StaticSamplerBindingLayout implementation\nStaticSamplerBindingLayout::StaticSamplerBindingLayout()\n  : ChainedStruct { nullptr, SType::StaticSamplerBindingLayout } {}\nstruct StaticSamplerBindingLayout::Init {\n    ChainedStruct * const nextInChain;\n    Sampler sampler;\n    uint32_t sampledTextureBinding = WGPU_LIMIT_U32_UNDEFINED;\n};\nStaticSamplerBindingLayout::StaticSamplerBindingLayout(StaticSamplerBindingLayout::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::StaticSamplerBindingLayout }, \n    sampler(std::move(init.sampler)), \n    sampledTextureBinding(std::move(init.sampledTextureBinding)){}\n\nStaticSamplerBindingLayout::operator const WGPUStaticSamplerBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUStaticSamplerBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(StaticSamplerBindingLayout) == sizeof(WGPUStaticSamplerBindingLayout), \"sizeof mismatch for StaticSamplerBindingLayout\");\nstatic_assert(alignof(StaticSamplerBindingLayout) == alignof(WGPUStaticSamplerBindingLayout), \"alignof mismatch for StaticSamplerBindingLayout\");\nstatic_assert(offsetof(StaticSamplerBindingLayout, sampler) == offsetof(WGPUStaticSamplerBindingLayout, sampler),\n        \"offsetof mismatch for StaticSamplerBindingLayout::sampler\");\nstatic_assert(offsetof(StaticSamplerBindingLayout, sampledTextureBinding) == offsetof(WGPUStaticSamplerBindingLayout, sampledTextureBinding),\n        \"offsetof mismatch for StaticSamplerBindingLayout::sampledTextureBinding\");\n\n// StencilFaceState implementation\n\nStencilFaceState::operator const WGPUStencilFaceState&() const noexcept {\n    return *reinterpret_cast<const WGPUStencilFaceState*>(this);\n}\n\nstatic_assert(sizeof(StencilFaceState) == sizeof(WGPUStencilFaceState), \"sizeof mismatch for StencilFaceState\");\nstatic_assert(alignof(StencilFaceState) == alignof(WGPUStencilFaceState), \"alignof mismatch for StencilFaceState\");\nstatic_assert(offsetof(StencilFaceState, compare) == offsetof(WGPUStencilFaceState, compare),\n        \"offsetof mismatch for StencilFaceState::compare\");\nstatic_assert(offsetof(StencilFaceState, failOp) == offsetof(WGPUStencilFaceState, failOp),\n        \"offsetof mismatch for StencilFaceState::failOp\");\nstatic_assert(offsetof(StencilFaceState, depthFailOp) == offsetof(WGPUStencilFaceState, depthFailOp),\n        \"offsetof mismatch for StencilFaceState::depthFailOp\");\nstatic_assert(offsetof(StencilFaceState, passOp) == offsetof(WGPUStencilFaceState, passOp),\n        \"offsetof mismatch for StencilFaceState::passOp\");\n\n// StorageTextureBindingLayout implementation\n\nStorageTextureBindingLayout::operator const WGPUStorageTextureBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUStorageTextureBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(StorageTextureBindingLayout) == sizeof(WGPUStorageTextureBindingLayout), \"sizeof mismatch for StorageTextureBindingLayout\");\nstatic_assert(alignof(StorageTextureBindingLayout) == alignof(WGPUStorageTextureBindingLayout), \"alignof mismatch for StorageTextureBindingLayout\");\nstatic_assert(offsetof(StorageTextureBindingLayout, nextInChain) == offsetof(WGPUStorageTextureBindingLayout, nextInChain),\n        \"offsetof mismatch for StorageTextureBindingLayout::nextInChain\");\nstatic_assert(offsetof(StorageTextureBindingLayout, access) == offsetof(WGPUStorageTextureBindingLayout, access),\n        \"offsetof mismatch for StorageTextureBindingLayout::access\");\nstatic_assert(offsetof(StorageTextureBindingLayout, format) == offsetof(WGPUStorageTextureBindingLayout, format),\n        \"offsetof mismatch for StorageTextureBindingLayout::format\");\nstatic_assert(offsetof(StorageTextureBindingLayout, viewDimension) == offsetof(WGPUStorageTextureBindingLayout, viewDimension),\n        \"offsetof mismatch for StorageTextureBindingLayout::viewDimension\");\n\n// SupportedFeatures implementation\nSupportedFeatures::SupportedFeatures() = default;\nSupportedFeatures::~SupportedFeatures() {\n    FreeMembers();\n}\n\nSupportedFeatures::SupportedFeatures(SupportedFeatures&& rhs)\n    : featureCount(rhs.featureCount),\n            features(rhs.features){\n    Reset(rhs);\n}\n\nSupportedFeatures& SupportedFeatures::operator=(SupportedFeatures&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->featureCount) = std::move(rhs.featureCount);\n    detail::AsNonConstReference(this->features) = std::move(rhs.features);\n    Reset(rhs);\n    return *this;\n}\n\nvoid SupportedFeatures::FreeMembers() {\n    bool needsFreeing = false;    if (this->features != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuDawnWireClientSupportedFeaturesFreeMembers(\n            *reinterpret_cast<WGPUSupportedFeatures*>(this));\n    }\n}\n\n// static\nvoid SupportedFeatures::Reset(SupportedFeatures& value) {\n    SupportedFeatures defaultValue{};\n    detail::AsNonConstReference(value.featureCount) = defaultValue.featureCount;\n    detail::AsNonConstReference(value.features) = defaultValue.features;\n}\n\nSupportedFeatures::operator const WGPUSupportedFeatures&() const noexcept {\n    return *reinterpret_cast<const WGPUSupportedFeatures*>(this);\n}\n\nstatic_assert(sizeof(SupportedFeatures) == sizeof(WGPUSupportedFeatures), \"sizeof mismatch for SupportedFeatures\");\nstatic_assert(alignof(SupportedFeatures) == alignof(WGPUSupportedFeatures), \"alignof mismatch for SupportedFeatures\");\nstatic_assert(offsetof(SupportedFeatures, featureCount) == offsetof(WGPUSupportedFeatures, featureCount),\n        \"offsetof mismatch for SupportedFeatures::featureCount\");\nstatic_assert(offsetof(SupportedFeatures, features) == offsetof(WGPUSupportedFeatures, features),\n        \"offsetof mismatch for SupportedFeatures::features\");\n\n// SurfaceCapabilities implementation\nSurfaceCapabilities::SurfaceCapabilities() = default;\nSurfaceCapabilities::~SurfaceCapabilities() {\n    FreeMembers();\n}\n\nSurfaceCapabilities::SurfaceCapabilities(SurfaceCapabilities&& rhs)\n    : usages(rhs.usages),\n            formatCount(rhs.formatCount),\n            formats(rhs.formats),\n            presentModeCount(rhs.presentModeCount),\n            presentModes(rhs.presentModes),\n            alphaModeCount(rhs.alphaModeCount),\n            alphaModes(rhs.alphaModes){\n    Reset(rhs);\n}\n\nSurfaceCapabilities& SurfaceCapabilities::operator=(SurfaceCapabilities&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->usages) = std::move(rhs.usages);\n    detail::AsNonConstReference(this->formatCount) = std::move(rhs.formatCount);\n    detail::AsNonConstReference(this->formats) = std::move(rhs.formats);\n    detail::AsNonConstReference(this->presentModeCount) = std::move(rhs.presentModeCount);\n    detail::AsNonConstReference(this->presentModes) = std::move(rhs.presentModes);\n    detail::AsNonConstReference(this->alphaModeCount) = std::move(rhs.alphaModeCount);\n    detail::AsNonConstReference(this->alphaModes) = std::move(rhs.alphaModes);\n    Reset(rhs);\n    return *this;\n}\n\nvoid SurfaceCapabilities::FreeMembers() {\n    bool needsFreeing = false;    if (this->formats != nullptr) { needsFreeing = true; }    if (this->presentModes != nullptr) { needsFreeing = true; }    if (this->alphaModes != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuDawnWireClientSurfaceCapabilitiesFreeMembers(\n            *reinterpret_cast<WGPUSurfaceCapabilities*>(this));\n    }\n}\n\n// static\nvoid SurfaceCapabilities::Reset(SurfaceCapabilities& value) {\n    SurfaceCapabilities defaultValue{};\n    detail::AsNonConstReference(value.usages) = defaultValue.usages;\n    detail::AsNonConstReference(value.formatCount) = defaultValue.formatCount;\n    detail::AsNonConstReference(value.formats) = defaultValue.formats;\n    detail::AsNonConstReference(value.presentModeCount) = defaultValue.presentModeCount;\n    detail::AsNonConstReference(value.presentModes) = defaultValue.presentModes;\n    detail::AsNonConstReference(value.alphaModeCount) = defaultValue.alphaModeCount;\n    detail::AsNonConstReference(value.alphaModes) = defaultValue.alphaModes;\n}\n\nSurfaceCapabilities::operator const WGPUSurfaceCapabilities&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceCapabilities*>(this);\n}\n\nstatic_assert(sizeof(SurfaceCapabilities) == sizeof(WGPUSurfaceCapabilities), \"sizeof mismatch for SurfaceCapabilities\");\nstatic_assert(alignof(SurfaceCapabilities) == alignof(WGPUSurfaceCapabilities), \"alignof mismatch for SurfaceCapabilities\");\nstatic_assert(offsetof(SurfaceCapabilities, nextInChain) == offsetof(WGPUSurfaceCapabilities, nextInChain),\n        \"offsetof mismatch for SurfaceCapabilities::nextInChain\");\nstatic_assert(offsetof(SurfaceCapabilities, usages) == offsetof(WGPUSurfaceCapabilities, usages),\n        \"offsetof mismatch for SurfaceCapabilities::usages\");\nstatic_assert(offsetof(SurfaceCapabilities, formatCount) == offsetof(WGPUSurfaceCapabilities, formatCount),\n        \"offsetof mismatch for SurfaceCapabilities::formatCount\");\nstatic_assert(offsetof(SurfaceCapabilities, formats) == offsetof(WGPUSurfaceCapabilities, formats),\n        \"offsetof mismatch for SurfaceCapabilities::formats\");\nstatic_assert(offsetof(SurfaceCapabilities, presentModeCount) == offsetof(WGPUSurfaceCapabilities, presentModeCount),\n        \"offsetof mismatch for SurfaceCapabilities::presentModeCount\");\nstatic_assert(offsetof(SurfaceCapabilities, presentModes) == offsetof(WGPUSurfaceCapabilities, presentModes),\n        \"offsetof mismatch for SurfaceCapabilities::presentModes\");\nstatic_assert(offsetof(SurfaceCapabilities, alphaModeCount) == offsetof(WGPUSurfaceCapabilities, alphaModeCount),\n        \"offsetof mismatch for SurfaceCapabilities::alphaModeCount\");\nstatic_assert(offsetof(SurfaceCapabilities, alphaModes) == offsetof(WGPUSurfaceCapabilities, alphaModes),\n        \"offsetof mismatch for SurfaceCapabilities::alphaModes\");\n\n// SurfaceConfiguration implementation\n\nSurfaceConfiguration::operator const WGPUSurfaceConfiguration&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceConfiguration*>(this);\n}\n\nstatic_assert(sizeof(SurfaceConfiguration) == sizeof(WGPUSurfaceConfiguration), \"sizeof mismatch for SurfaceConfiguration\");\nstatic_assert(alignof(SurfaceConfiguration) == alignof(WGPUSurfaceConfiguration), \"alignof mismatch for SurfaceConfiguration\");\nstatic_assert(offsetof(SurfaceConfiguration, nextInChain) == offsetof(WGPUSurfaceConfiguration, nextInChain),\n        \"offsetof mismatch for SurfaceConfiguration::nextInChain\");\nstatic_assert(offsetof(SurfaceConfiguration, device) == offsetof(WGPUSurfaceConfiguration, device),\n        \"offsetof mismatch for SurfaceConfiguration::device\");\nstatic_assert(offsetof(SurfaceConfiguration, format) == offsetof(WGPUSurfaceConfiguration, format),\n        \"offsetof mismatch for SurfaceConfiguration::format\");\nstatic_assert(offsetof(SurfaceConfiguration, usage) == offsetof(WGPUSurfaceConfiguration, usage),\n        \"offsetof mismatch for SurfaceConfiguration::usage\");\nstatic_assert(offsetof(SurfaceConfiguration, viewFormatCount) == offsetof(WGPUSurfaceConfiguration, viewFormatCount),\n        \"offsetof mismatch for SurfaceConfiguration::viewFormatCount\");\nstatic_assert(offsetof(SurfaceConfiguration, viewFormats) == offsetof(WGPUSurfaceConfiguration, viewFormats),\n        \"offsetof mismatch for SurfaceConfiguration::viewFormats\");\nstatic_assert(offsetof(SurfaceConfiguration, alphaMode) == offsetof(WGPUSurfaceConfiguration, alphaMode),\n        \"offsetof mismatch for SurfaceConfiguration::alphaMode\");\nstatic_assert(offsetof(SurfaceConfiguration, width) == offsetof(WGPUSurfaceConfiguration, width),\n        \"offsetof mismatch for SurfaceConfiguration::width\");\nstatic_assert(offsetof(SurfaceConfiguration, height) == offsetof(WGPUSurfaceConfiguration, height),\n        \"offsetof mismatch for SurfaceConfiguration::height\");\nstatic_assert(offsetof(SurfaceConfiguration, presentMode) == offsetof(WGPUSurfaceConfiguration, presentMode),\n        \"offsetof mismatch for SurfaceConfiguration::presentMode\");\n\n// SurfaceDescriptorFromWindowsCoreWindow implementation\nSurfaceDescriptorFromWindowsCoreWindow::SurfaceDescriptorFromWindowsCoreWindow()\n  : ChainedStruct { nullptr, SType::SurfaceDescriptorFromWindowsCoreWindow } {}\nstruct SurfaceDescriptorFromWindowsCoreWindow::Init {\n    ChainedStruct * const nextInChain;\n    void * coreWindow;\n};\nSurfaceDescriptorFromWindowsCoreWindow::SurfaceDescriptorFromWindowsCoreWindow(SurfaceDescriptorFromWindowsCoreWindow::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceDescriptorFromWindowsCoreWindow }, \n    coreWindow(std::move(init.coreWindow)){}\n\nSurfaceDescriptorFromWindowsCoreWindow::operator const WGPUSurfaceDescriptorFromWindowsCoreWindow&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsCoreWindow*>(this);\n}\n\nstatic_assert(sizeof(SurfaceDescriptorFromWindowsCoreWindow) == sizeof(WGPUSurfaceDescriptorFromWindowsCoreWindow), \"sizeof mismatch for SurfaceDescriptorFromWindowsCoreWindow\");\nstatic_assert(alignof(SurfaceDescriptorFromWindowsCoreWindow) == alignof(WGPUSurfaceDescriptorFromWindowsCoreWindow), \"alignof mismatch for SurfaceDescriptorFromWindowsCoreWindow\");\nstatic_assert(offsetof(SurfaceDescriptorFromWindowsCoreWindow, coreWindow) == offsetof(WGPUSurfaceDescriptorFromWindowsCoreWindow, coreWindow),\n        \"offsetof mismatch for SurfaceDescriptorFromWindowsCoreWindow::coreWindow\");\n\n// SurfaceDescriptorFromWindowsSwapChainPanel implementation\nSurfaceDescriptorFromWindowsSwapChainPanel::SurfaceDescriptorFromWindowsSwapChainPanel()\n  : ChainedStruct { nullptr, SType::SurfaceDescriptorFromWindowsSwapChainPanel } {}\nstruct SurfaceDescriptorFromWindowsSwapChainPanel::Init {\n    ChainedStruct * const nextInChain;\n    void * swapChainPanel;\n};\nSurfaceDescriptorFromWindowsSwapChainPanel::SurfaceDescriptorFromWindowsSwapChainPanel(SurfaceDescriptorFromWindowsSwapChainPanel::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceDescriptorFromWindowsSwapChainPanel }, \n    swapChainPanel(std::move(init.swapChainPanel)){}\n\nSurfaceDescriptorFromWindowsSwapChainPanel::operator const WGPUSurfaceDescriptorFromWindowsSwapChainPanel&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceDescriptorFromWindowsSwapChainPanel*>(this);\n}\n\nstatic_assert(sizeof(SurfaceDescriptorFromWindowsSwapChainPanel) == sizeof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel), \"sizeof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel\");\nstatic_assert(alignof(SurfaceDescriptorFromWindowsSwapChainPanel) == alignof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel), \"alignof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel\");\nstatic_assert(offsetof(SurfaceDescriptorFromWindowsSwapChainPanel, swapChainPanel) == offsetof(WGPUSurfaceDescriptorFromWindowsSwapChainPanel, swapChainPanel),\n        \"offsetof mismatch for SurfaceDescriptorFromWindowsSwapChainPanel::swapChainPanel\");\n\n// SurfaceSourceXCBWindow implementation\nSurfaceSourceXCBWindow::SurfaceSourceXCBWindow()\n  : ChainedStruct { nullptr, SType::SurfaceSourceXCBWindow } {}\nstruct SurfaceSourceXCBWindow::Init {\n    ChainedStruct * const nextInChain;\n    void * connection;\n    uint32_t window;\n};\nSurfaceSourceXCBWindow::SurfaceSourceXCBWindow(SurfaceSourceXCBWindow::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceXCBWindow }, \n    connection(std::move(init.connection)), \n    window(std::move(init.window)){}\n\nSurfaceSourceXCBWindow::operator const WGPUSurfaceSourceXCBWindow&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceXCBWindow*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceXCBWindow) == sizeof(WGPUSurfaceSourceXCBWindow), \"sizeof mismatch for SurfaceSourceXCBWindow\");\nstatic_assert(alignof(SurfaceSourceXCBWindow) == alignof(WGPUSurfaceSourceXCBWindow), \"alignof mismatch for SurfaceSourceXCBWindow\");\nstatic_assert(offsetof(SurfaceSourceXCBWindow, connection) == offsetof(WGPUSurfaceSourceXCBWindow, connection),\n        \"offsetof mismatch for SurfaceSourceXCBWindow::connection\");\nstatic_assert(offsetof(SurfaceSourceXCBWindow, window) == offsetof(WGPUSurfaceSourceXCBWindow, window),\n        \"offsetof mismatch for SurfaceSourceXCBWindow::window\");\n\n// SurfaceSourceAndroidNativeWindow implementation\nSurfaceSourceAndroidNativeWindow::SurfaceSourceAndroidNativeWindow()\n  : ChainedStruct { nullptr, SType::SurfaceSourceAndroidNativeWindow } {}\nstruct SurfaceSourceAndroidNativeWindow::Init {\n    ChainedStruct * const nextInChain;\n    void * window;\n};\nSurfaceSourceAndroidNativeWindow::SurfaceSourceAndroidNativeWindow(SurfaceSourceAndroidNativeWindow::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceAndroidNativeWindow }, \n    window(std::move(init.window)){}\n\nSurfaceSourceAndroidNativeWindow::operator const WGPUSurfaceSourceAndroidNativeWindow&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceAndroidNativeWindow*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceAndroidNativeWindow) == sizeof(WGPUSurfaceSourceAndroidNativeWindow), \"sizeof mismatch for SurfaceSourceAndroidNativeWindow\");\nstatic_assert(alignof(SurfaceSourceAndroidNativeWindow) == alignof(WGPUSurfaceSourceAndroidNativeWindow), \"alignof mismatch for SurfaceSourceAndroidNativeWindow\");\nstatic_assert(offsetof(SurfaceSourceAndroidNativeWindow, window) == offsetof(WGPUSurfaceSourceAndroidNativeWindow, window),\n        \"offsetof mismatch for SurfaceSourceAndroidNativeWindow::window\");\n\n// SurfaceSourceMetalLayer implementation\nSurfaceSourceMetalLayer::SurfaceSourceMetalLayer()\n  : ChainedStruct { nullptr, SType::SurfaceSourceMetalLayer } {}\nstruct SurfaceSourceMetalLayer::Init {\n    ChainedStruct * const nextInChain;\n    void * layer;\n};\nSurfaceSourceMetalLayer::SurfaceSourceMetalLayer(SurfaceSourceMetalLayer::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceMetalLayer }, \n    layer(std::move(init.layer)){}\n\nSurfaceSourceMetalLayer::operator const WGPUSurfaceSourceMetalLayer&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceMetalLayer*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceMetalLayer) == sizeof(WGPUSurfaceSourceMetalLayer), \"sizeof mismatch for SurfaceSourceMetalLayer\");\nstatic_assert(alignof(SurfaceSourceMetalLayer) == alignof(WGPUSurfaceSourceMetalLayer), \"alignof mismatch for SurfaceSourceMetalLayer\");\nstatic_assert(offsetof(SurfaceSourceMetalLayer, layer) == offsetof(WGPUSurfaceSourceMetalLayer, layer),\n        \"offsetof mismatch for SurfaceSourceMetalLayer::layer\");\n\n// SurfaceSourceWaylandSurface implementation\nSurfaceSourceWaylandSurface::SurfaceSourceWaylandSurface()\n  : ChainedStruct { nullptr, SType::SurfaceSourceWaylandSurface } {}\nstruct SurfaceSourceWaylandSurface::Init {\n    ChainedStruct * const nextInChain;\n    void * display;\n    void * surface;\n};\nSurfaceSourceWaylandSurface::SurfaceSourceWaylandSurface(SurfaceSourceWaylandSurface::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceWaylandSurface }, \n    display(std::move(init.display)), \n    surface(std::move(init.surface)){}\n\nSurfaceSourceWaylandSurface::operator const WGPUSurfaceSourceWaylandSurface&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceWaylandSurface*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceWaylandSurface) == sizeof(WGPUSurfaceSourceWaylandSurface), \"sizeof mismatch for SurfaceSourceWaylandSurface\");\nstatic_assert(alignof(SurfaceSourceWaylandSurface) == alignof(WGPUSurfaceSourceWaylandSurface), \"alignof mismatch for SurfaceSourceWaylandSurface\");\nstatic_assert(offsetof(SurfaceSourceWaylandSurface, display) == offsetof(WGPUSurfaceSourceWaylandSurface, display),\n        \"offsetof mismatch for SurfaceSourceWaylandSurface::display\");\nstatic_assert(offsetof(SurfaceSourceWaylandSurface, surface) == offsetof(WGPUSurfaceSourceWaylandSurface, surface),\n        \"offsetof mismatch for SurfaceSourceWaylandSurface::surface\");\n\n// SurfaceSourceWindowsHWND implementation\nSurfaceSourceWindowsHWND::SurfaceSourceWindowsHWND()\n  : ChainedStruct { nullptr, SType::SurfaceSourceWindowsHWND } {}\nstruct SurfaceSourceWindowsHWND::Init {\n    ChainedStruct * const nextInChain;\n    void * hinstance;\n    void * hwnd;\n};\nSurfaceSourceWindowsHWND::SurfaceSourceWindowsHWND(SurfaceSourceWindowsHWND::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceWindowsHWND }, \n    hinstance(std::move(init.hinstance)), \n    hwnd(std::move(init.hwnd)){}\n\nSurfaceSourceWindowsHWND::operator const WGPUSurfaceSourceWindowsHWND&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceWindowsHWND*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceWindowsHWND) == sizeof(WGPUSurfaceSourceWindowsHWND), \"sizeof mismatch for SurfaceSourceWindowsHWND\");\nstatic_assert(alignof(SurfaceSourceWindowsHWND) == alignof(WGPUSurfaceSourceWindowsHWND), \"alignof mismatch for SurfaceSourceWindowsHWND\");\nstatic_assert(offsetof(SurfaceSourceWindowsHWND, hinstance) == offsetof(WGPUSurfaceSourceWindowsHWND, hinstance),\n        \"offsetof mismatch for SurfaceSourceWindowsHWND::hinstance\");\nstatic_assert(offsetof(SurfaceSourceWindowsHWND, hwnd) == offsetof(WGPUSurfaceSourceWindowsHWND, hwnd),\n        \"offsetof mismatch for SurfaceSourceWindowsHWND::hwnd\");\n\n// SurfaceSourceXlibWindow implementation\nSurfaceSourceXlibWindow::SurfaceSourceXlibWindow()\n  : ChainedStruct { nullptr, SType::SurfaceSourceXlibWindow } {}\nstruct SurfaceSourceXlibWindow::Init {\n    ChainedStruct * const nextInChain;\n    void * display;\n    uint64_t window;\n};\nSurfaceSourceXlibWindow::SurfaceSourceXlibWindow(SurfaceSourceXlibWindow::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SurfaceSourceXlibWindow }, \n    display(std::move(init.display)), \n    window(std::move(init.window)){}\n\nSurfaceSourceXlibWindow::operator const WGPUSurfaceSourceXlibWindow&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceSourceXlibWindow*>(this);\n}\n\nstatic_assert(sizeof(SurfaceSourceXlibWindow) == sizeof(WGPUSurfaceSourceXlibWindow), \"sizeof mismatch for SurfaceSourceXlibWindow\");\nstatic_assert(alignof(SurfaceSourceXlibWindow) == alignof(WGPUSurfaceSourceXlibWindow), \"alignof mismatch for SurfaceSourceXlibWindow\");\nstatic_assert(offsetof(SurfaceSourceXlibWindow, display) == offsetof(WGPUSurfaceSourceXlibWindow, display),\n        \"offsetof mismatch for SurfaceSourceXlibWindow::display\");\nstatic_assert(offsetof(SurfaceSourceXlibWindow, window) == offsetof(WGPUSurfaceSourceXlibWindow, window),\n        \"offsetof mismatch for SurfaceSourceXlibWindow::window\");\n\n// SurfaceTexture implementation\n\nSurfaceTexture::operator const WGPUSurfaceTexture&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceTexture*>(this);\n}\n\nstatic_assert(sizeof(SurfaceTexture) == sizeof(WGPUSurfaceTexture), \"sizeof mismatch for SurfaceTexture\");\nstatic_assert(alignof(SurfaceTexture) == alignof(WGPUSurfaceTexture), \"alignof mismatch for SurfaceTexture\");\nstatic_assert(offsetof(SurfaceTexture, texture) == offsetof(WGPUSurfaceTexture, texture),\n        \"offsetof mismatch for SurfaceTexture::texture\");\nstatic_assert(offsetof(SurfaceTexture, suboptimal) == offsetof(WGPUSurfaceTexture, suboptimal),\n        \"offsetof mismatch for SurfaceTexture::suboptimal\");\nstatic_assert(offsetof(SurfaceTexture, status) == offsetof(WGPUSurfaceTexture, status),\n        \"offsetof mismatch for SurfaceTexture::status\");\n\n// TextureBindingLayout implementation\n\nTextureBindingLayout::operator const WGPUTextureBindingLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureBindingLayout*>(this);\n}\n\nstatic_assert(sizeof(TextureBindingLayout) == sizeof(WGPUTextureBindingLayout), \"sizeof mismatch for TextureBindingLayout\");\nstatic_assert(alignof(TextureBindingLayout) == alignof(WGPUTextureBindingLayout), \"alignof mismatch for TextureBindingLayout\");\nstatic_assert(offsetof(TextureBindingLayout, nextInChain) == offsetof(WGPUTextureBindingLayout, nextInChain),\n        \"offsetof mismatch for TextureBindingLayout::nextInChain\");\nstatic_assert(offsetof(TextureBindingLayout, sampleType) == offsetof(WGPUTextureBindingLayout, sampleType),\n        \"offsetof mismatch for TextureBindingLayout::sampleType\");\nstatic_assert(offsetof(TextureBindingLayout, viewDimension) == offsetof(WGPUTextureBindingLayout, viewDimension),\n        \"offsetof mismatch for TextureBindingLayout::viewDimension\");\nstatic_assert(offsetof(TextureBindingLayout, multisampled) == offsetof(WGPUTextureBindingLayout, multisampled),\n        \"offsetof mismatch for TextureBindingLayout::multisampled\");\n\n// TextureBindingViewDimensionDescriptor implementation\nTextureBindingViewDimensionDescriptor::TextureBindingViewDimensionDescriptor()\n  : ChainedStruct { nullptr, SType::TextureBindingViewDimensionDescriptor } {}\nstruct TextureBindingViewDimensionDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    TextureViewDimension textureBindingViewDimension = TextureViewDimension::Undefined;\n};\nTextureBindingViewDimensionDescriptor::TextureBindingViewDimensionDescriptor(TextureBindingViewDimensionDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::TextureBindingViewDimensionDescriptor }, \n    textureBindingViewDimension(std::move(init.textureBindingViewDimension)){}\n\nTextureBindingViewDimensionDescriptor::operator const WGPUTextureBindingViewDimensionDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureBindingViewDimensionDescriptor*>(this);\n}\n\nstatic_assert(sizeof(TextureBindingViewDimensionDescriptor) == sizeof(WGPUTextureBindingViewDimensionDescriptor), \"sizeof mismatch for TextureBindingViewDimensionDescriptor\");\nstatic_assert(alignof(TextureBindingViewDimensionDescriptor) == alignof(WGPUTextureBindingViewDimensionDescriptor), \"alignof mismatch for TextureBindingViewDimensionDescriptor\");\nstatic_assert(offsetof(TextureBindingViewDimensionDescriptor, textureBindingViewDimension) == offsetof(WGPUTextureBindingViewDimensionDescriptor, textureBindingViewDimension),\n        \"offsetof mismatch for TextureBindingViewDimensionDescriptor::textureBindingViewDimension\");\n\n// TextureDataLayout implementation\n\nTextureDataLayout::operator const WGPUTextureDataLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureDataLayout*>(this);\n}\n\nstatic_assert(sizeof(TextureDataLayout) == sizeof(WGPUTextureDataLayout), \"sizeof mismatch for TextureDataLayout\");\nstatic_assert(alignof(TextureDataLayout) == alignof(WGPUTextureDataLayout), \"alignof mismatch for TextureDataLayout\");\nstatic_assert(offsetof(TextureDataLayout, nextInChain) == offsetof(WGPUTextureDataLayout, nextInChain),\n        \"offsetof mismatch for TextureDataLayout::nextInChain\");\nstatic_assert(offsetof(TextureDataLayout, offset) == offsetof(WGPUTextureDataLayout, offset),\n        \"offsetof mismatch for TextureDataLayout::offset\");\nstatic_assert(offsetof(TextureDataLayout, bytesPerRow) == offsetof(WGPUTextureDataLayout, bytesPerRow),\n        \"offsetof mismatch for TextureDataLayout::bytesPerRow\");\nstatic_assert(offsetof(TextureDataLayout, rowsPerImage) == offsetof(WGPUTextureDataLayout, rowsPerImage),\n        \"offsetof mismatch for TextureDataLayout::rowsPerImage\");\n\n// UncapturedErrorCallbackInfo implementation\n\nUncapturedErrorCallbackInfo::operator const WGPUUncapturedErrorCallbackInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUUncapturedErrorCallbackInfo*>(this);\n}\n\nstatic_assert(sizeof(UncapturedErrorCallbackInfo) == sizeof(WGPUUncapturedErrorCallbackInfo), \"sizeof mismatch for UncapturedErrorCallbackInfo\");\nstatic_assert(alignof(UncapturedErrorCallbackInfo) == alignof(WGPUUncapturedErrorCallbackInfo), \"alignof mismatch for UncapturedErrorCallbackInfo\");\nstatic_assert(offsetof(UncapturedErrorCallbackInfo, nextInChain) == offsetof(WGPUUncapturedErrorCallbackInfo, nextInChain),\n        \"offsetof mismatch for UncapturedErrorCallbackInfo::nextInChain\");\nstatic_assert(offsetof(UncapturedErrorCallbackInfo, callback) == offsetof(WGPUUncapturedErrorCallbackInfo, callback),\n        \"offsetof mismatch for UncapturedErrorCallbackInfo::callback\");\nstatic_assert(offsetof(UncapturedErrorCallbackInfo, userdata) == offsetof(WGPUUncapturedErrorCallbackInfo, userdata),\n        \"offsetof mismatch for UncapturedErrorCallbackInfo::userdata\");\n\n// VertexAttribute implementation\n\nVertexAttribute::operator const WGPUVertexAttribute&() const noexcept {\n    return *reinterpret_cast<const WGPUVertexAttribute*>(this);\n}\n\nstatic_assert(sizeof(VertexAttribute) == sizeof(WGPUVertexAttribute), \"sizeof mismatch for VertexAttribute\");\nstatic_assert(alignof(VertexAttribute) == alignof(WGPUVertexAttribute), \"alignof mismatch for VertexAttribute\");\nstatic_assert(offsetof(VertexAttribute, format) == offsetof(WGPUVertexAttribute, format),\n        \"offsetof mismatch for VertexAttribute::format\");\nstatic_assert(offsetof(VertexAttribute, offset) == offsetof(WGPUVertexAttribute, offset),\n        \"offsetof mismatch for VertexAttribute::offset\");\nstatic_assert(offsetof(VertexAttribute, shaderLocation) == offsetof(WGPUVertexAttribute, shaderLocation),\n        \"offsetof mismatch for VertexAttribute::shaderLocation\");\n\n// YCbCrVkDescriptor implementation\nYCbCrVkDescriptor::YCbCrVkDescriptor()\n  : ChainedStruct { nullptr, SType::YCbCrVkDescriptor } {}\nstruct YCbCrVkDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    uint32_t vkFormat = 0;\n    uint32_t vkYCbCrModel = 0;\n    uint32_t vkYCbCrRange = 0;\n    uint32_t vkComponentSwizzleRed = 0;\n    uint32_t vkComponentSwizzleGreen = 0;\n    uint32_t vkComponentSwizzleBlue = 0;\n    uint32_t vkComponentSwizzleAlpha = 0;\n    uint32_t vkXChromaOffset = 0;\n    uint32_t vkYChromaOffset = 0;\n    FilterMode vkChromaFilter = FilterMode::Nearest;\n    Bool forceExplicitReconstruction = false;\n    uint64_t externalFormat = 0;\n};\nYCbCrVkDescriptor::YCbCrVkDescriptor(YCbCrVkDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::YCbCrVkDescriptor }, \n    vkFormat(std::move(init.vkFormat)), \n    vkYCbCrModel(std::move(init.vkYCbCrModel)), \n    vkYCbCrRange(std::move(init.vkYCbCrRange)), \n    vkComponentSwizzleRed(std::move(init.vkComponentSwizzleRed)), \n    vkComponentSwizzleGreen(std::move(init.vkComponentSwizzleGreen)), \n    vkComponentSwizzleBlue(std::move(init.vkComponentSwizzleBlue)), \n    vkComponentSwizzleAlpha(std::move(init.vkComponentSwizzleAlpha)), \n    vkXChromaOffset(std::move(init.vkXChromaOffset)), \n    vkYChromaOffset(std::move(init.vkYChromaOffset)), \n    vkChromaFilter(std::move(init.vkChromaFilter)), \n    forceExplicitReconstruction(std::move(init.forceExplicitReconstruction)), \n    externalFormat(std::move(init.externalFormat)){}\n\nYCbCrVkDescriptor::operator const WGPUYCbCrVkDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUYCbCrVkDescriptor*>(this);\n}\n\nstatic_assert(sizeof(YCbCrVkDescriptor) == sizeof(WGPUYCbCrVkDescriptor), \"sizeof mismatch for YCbCrVkDescriptor\");\nstatic_assert(alignof(YCbCrVkDescriptor) == alignof(WGPUYCbCrVkDescriptor), \"alignof mismatch for YCbCrVkDescriptor\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkFormat) == offsetof(WGPUYCbCrVkDescriptor, vkFormat),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkFormat\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkYCbCrModel) == offsetof(WGPUYCbCrVkDescriptor, vkYCbCrModel),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkYCbCrModel\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkYCbCrRange) == offsetof(WGPUYCbCrVkDescriptor, vkYCbCrRange),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkYCbCrRange\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkComponentSwizzleRed) == offsetof(WGPUYCbCrVkDescriptor, vkComponentSwizzleRed),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkComponentSwizzleRed\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkComponentSwizzleGreen) == offsetof(WGPUYCbCrVkDescriptor, vkComponentSwizzleGreen),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkComponentSwizzleGreen\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkComponentSwizzleBlue) == offsetof(WGPUYCbCrVkDescriptor, vkComponentSwizzleBlue),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkComponentSwizzleBlue\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkComponentSwizzleAlpha) == offsetof(WGPUYCbCrVkDescriptor, vkComponentSwizzleAlpha),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkComponentSwizzleAlpha\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkXChromaOffset) == offsetof(WGPUYCbCrVkDescriptor, vkXChromaOffset),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkXChromaOffset\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkYChromaOffset) == offsetof(WGPUYCbCrVkDescriptor, vkYChromaOffset),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkYChromaOffset\");\nstatic_assert(offsetof(YCbCrVkDescriptor, vkChromaFilter) == offsetof(WGPUYCbCrVkDescriptor, vkChromaFilter),\n        \"offsetof mismatch for YCbCrVkDescriptor::vkChromaFilter\");\nstatic_assert(offsetof(YCbCrVkDescriptor, forceExplicitReconstruction) == offsetof(WGPUYCbCrVkDescriptor, forceExplicitReconstruction),\n        \"offsetof mismatch for YCbCrVkDescriptor::forceExplicitReconstruction\");\nstatic_assert(offsetof(YCbCrVkDescriptor, externalFormat) == offsetof(WGPUYCbCrVkDescriptor, externalFormat),\n        \"offsetof mismatch for YCbCrVkDescriptor::externalFormat\");\n\n// AHardwareBufferProperties implementation\n\nAHardwareBufferProperties::operator const WGPUAHardwareBufferProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUAHardwareBufferProperties*>(this);\n}\n\nstatic_assert(sizeof(AHardwareBufferProperties) == sizeof(WGPUAHardwareBufferProperties), \"sizeof mismatch for AHardwareBufferProperties\");\nstatic_assert(alignof(AHardwareBufferProperties) == alignof(WGPUAHardwareBufferProperties), \"alignof mismatch for AHardwareBufferProperties\");\nstatic_assert(offsetof(AHardwareBufferProperties, yCbCrInfo) == offsetof(WGPUAHardwareBufferProperties, yCbCrInfo),\n        \"offsetof mismatch for AHardwareBufferProperties::yCbCrInfo\");\n\n// AdapterInfo implementation\nAdapterInfo::AdapterInfo() = default;\nAdapterInfo::~AdapterInfo() {\n    FreeMembers();\n}\n\nAdapterInfo::AdapterInfo(AdapterInfo&& rhs)\n    : vendor(rhs.vendor),\n            architecture(rhs.architecture),\n            device(rhs.device),\n            description(rhs.description),\n            backendType(rhs.backendType),\n            adapterType(rhs.adapterType),\n            vendorID(rhs.vendorID),\n            deviceID(rhs.deviceID),\n            compatibilityMode(rhs.compatibilityMode){\n    Reset(rhs);\n}\n\nAdapterInfo& AdapterInfo::operator=(AdapterInfo&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->vendor) = std::move(rhs.vendor);\n    detail::AsNonConstReference(this->architecture) = std::move(rhs.architecture);\n    detail::AsNonConstReference(this->device) = std::move(rhs.device);\n    detail::AsNonConstReference(this->description) = std::move(rhs.description);\n    detail::AsNonConstReference(this->backendType) = std::move(rhs.backendType);\n    detail::AsNonConstReference(this->adapterType) = std::move(rhs.adapterType);\n    detail::AsNonConstReference(this->vendorID) = std::move(rhs.vendorID);\n    detail::AsNonConstReference(this->deviceID) = std::move(rhs.deviceID);\n    detail::AsNonConstReference(this->compatibilityMode) = std::move(rhs.compatibilityMode);\n    Reset(rhs);\n    return *this;\n}\n\nvoid AdapterInfo::FreeMembers() {\n    bool needsFreeing = false;    if (this->vendor.data != nullptr) { needsFreeing = true; }    if (this->architecture.data != nullptr) { needsFreeing = true; }    if (this->device.data != nullptr) { needsFreeing = true; }    if (this->description.data != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuDawnWireClientAdapterInfoFreeMembers(\n            *reinterpret_cast<WGPUAdapterInfo*>(this));\n    }\n}\n\n// static\nvoid AdapterInfo::Reset(AdapterInfo& value) {\n    AdapterInfo defaultValue{};\n    detail::AsNonConstReference(value.vendor) = defaultValue.vendor;\n    detail::AsNonConstReference(value.architecture) = defaultValue.architecture;\n    detail::AsNonConstReference(value.device) = defaultValue.device;\n    detail::AsNonConstReference(value.description) = defaultValue.description;\n    detail::AsNonConstReference(value.backendType) = defaultValue.backendType;\n    detail::AsNonConstReference(value.adapterType) = defaultValue.adapterType;\n    detail::AsNonConstReference(value.vendorID) = defaultValue.vendorID;\n    detail::AsNonConstReference(value.deviceID) = defaultValue.deviceID;\n    detail::AsNonConstReference(value.compatibilityMode) = defaultValue.compatibilityMode;\n}\n\nAdapterInfo::operator const WGPUAdapterInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterInfo*>(this);\n}\n\nstatic_assert(sizeof(AdapterInfo) == sizeof(WGPUAdapterInfo), \"sizeof mismatch for AdapterInfo\");\nstatic_assert(alignof(AdapterInfo) == alignof(WGPUAdapterInfo), \"alignof mismatch for AdapterInfo\");\nstatic_assert(offsetof(AdapterInfo, nextInChain) == offsetof(WGPUAdapterInfo, nextInChain),\n        \"offsetof mismatch for AdapterInfo::nextInChain\");\nstatic_assert(offsetof(AdapterInfo, vendor) == offsetof(WGPUAdapterInfo, vendor),\n        \"offsetof mismatch for AdapterInfo::vendor\");\nstatic_assert(offsetof(AdapterInfo, architecture) == offsetof(WGPUAdapterInfo, architecture),\n        \"offsetof mismatch for AdapterInfo::architecture\");\nstatic_assert(offsetof(AdapterInfo, device) == offsetof(WGPUAdapterInfo, device),\n        \"offsetof mismatch for AdapterInfo::device\");\nstatic_assert(offsetof(AdapterInfo, description) == offsetof(WGPUAdapterInfo, description),\n        \"offsetof mismatch for AdapterInfo::description\");\nstatic_assert(offsetof(AdapterInfo, backendType) == offsetof(WGPUAdapterInfo, backendType),\n        \"offsetof mismatch for AdapterInfo::backendType\");\nstatic_assert(offsetof(AdapterInfo, adapterType) == offsetof(WGPUAdapterInfo, adapterType),\n        \"offsetof mismatch for AdapterInfo::adapterType\");\nstatic_assert(offsetof(AdapterInfo, vendorID) == offsetof(WGPUAdapterInfo, vendorID),\n        \"offsetof mismatch for AdapterInfo::vendorID\");\nstatic_assert(offsetof(AdapterInfo, deviceID) == offsetof(WGPUAdapterInfo, deviceID),\n        \"offsetof mismatch for AdapterInfo::deviceID\");\nstatic_assert(offsetof(AdapterInfo, compatibilityMode) == offsetof(WGPUAdapterInfo, compatibilityMode),\n        \"offsetof mismatch for AdapterInfo::compatibilityMode\");\n\n// AdapterPropertiesMemoryHeaps implementation\nAdapterPropertiesMemoryHeaps::AdapterPropertiesMemoryHeaps()\n  : ChainedStructOut { nullptr, SType::AdapterPropertiesMemoryHeaps } {}\nstruct AdapterPropertiesMemoryHeaps::Init {\n    ChainedStructOut *  nextInChain;\n    size_t const heapCount = {};\n    MemoryHeapInfo const * const heapInfo = {};\n};\nAdapterPropertiesMemoryHeaps::AdapterPropertiesMemoryHeaps(AdapterPropertiesMemoryHeaps::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::AdapterPropertiesMemoryHeaps }, \n    heapCount(std::move(init.heapCount)), \n    heapInfo(std::move(init.heapInfo)){}\nAdapterPropertiesMemoryHeaps::~AdapterPropertiesMemoryHeaps() {\n    FreeMembers();\n}\n\nAdapterPropertiesMemoryHeaps::AdapterPropertiesMemoryHeaps(AdapterPropertiesMemoryHeaps&& rhs)\n    : heapCount(rhs.heapCount),\n            heapInfo(rhs.heapInfo){\n    Reset(rhs);\n}\n\nAdapterPropertiesMemoryHeaps& AdapterPropertiesMemoryHeaps::operator=(AdapterPropertiesMemoryHeaps&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->heapCount) = std::move(rhs.heapCount);\n    detail::AsNonConstReference(this->heapInfo) = std::move(rhs.heapInfo);\n    Reset(rhs);\n    return *this;\n}\n\nvoid AdapterPropertiesMemoryHeaps::FreeMembers() {\n    bool needsFreeing = false;    if (this->heapInfo != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuDawnWireClientAdapterPropertiesMemoryHeapsFreeMembers(\n            *reinterpret_cast<WGPUAdapterPropertiesMemoryHeaps*>(this));\n    }\n}\n\n// static\nvoid AdapterPropertiesMemoryHeaps::Reset(AdapterPropertiesMemoryHeaps& value) {\n    AdapterPropertiesMemoryHeaps defaultValue{};\n    detail::AsNonConstReference(value.heapCount) = defaultValue.heapCount;\n    detail::AsNonConstReference(value.heapInfo) = defaultValue.heapInfo;\n}\n\nAdapterPropertiesMemoryHeaps::operator const WGPUAdapterPropertiesMemoryHeaps&() const noexcept {\n    return *reinterpret_cast<const WGPUAdapterPropertiesMemoryHeaps*>(this);\n}\n\nstatic_assert(sizeof(AdapterPropertiesMemoryHeaps) == sizeof(WGPUAdapterPropertiesMemoryHeaps), \"sizeof mismatch for AdapterPropertiesMemoryHeaps\");\nstatic_assert(alignof(AdapterPropertiesMemoryHeaps) == alignof(WGPUAdapterPropertiesMemoryHeaps), \"alignof mismatch for AdapterPropertiesMemoryHeaps\");\nstatic_assert(offsetof(AdapterPropertiesMemoryHeaps, heapCount) == offsetof(WGPUAdapterPropertiesMemoryHeaps, heapCount),\n        \"offsetof mismatch for AdapterPropertiesMemoryHeaps::heapCount\");\nstatic_assert(offsetof(AdapterPropertiesMemoryHeaps, heapInfo) == offsetof(WGPUAdapterPropertiesMemoryHeaps, heapInfo),\n        \"offsetof mismatch for AdapterPropertiesMemoryHeaps::heapInfo\");\n\n// BindGroupDescriptor implementation\n\nBindGroupDescriptor::operator const WGPUBindGroupDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUBindGroupDescriptor*>(this);\n}\n\nstatic_assert(sizeof(BindGroupDescriptor) == sizeof(WGPUBindGroupDescriptor), \"sizeof mismatch for BindGroupDescriptor\");\nstatic_assert(alignof(BindGroupDescriptor) == alignof(WGPUBindGroupDescriptor), \"alignof mismatch for BindGroupDescriptor\");\nstatic_assert(offsetof(BindGroupDescriptor, nextInChain) == offsetof(WGPUBindGroupDescriptor, nextInChain),\n        \"offsetof mismatch for BindGroupDescriptor::nextInChain\");\nstatic_assert(offsetof(BindGroupDescriptor, label) == offsetof(WGPUBindGroupDescriptor, label),\n        \"offsetof mismatch for BindGroupDescriptor::label\");\nstatic_assert(offsetof(BindGroupDescriptor, layout) == offsetof(WGPUBindGroupDescriptor, layout),\n        \"offsetof mismatch for BindGroupDescriptor::layout\");\nstatic_assert(offsetof(BindGroupDescriptor, entryCount) == offsetof(WGPUBindGroupDescriptor, entryCount),\n        \"offsetof mismatch for BindGroupDescriptor::entryCount\");\nstatic_assert(offsetof(BindGroupDescriptor, entries) == offsetof(WGPUBindGroupDescriptor, entries),\n        \"offsetof mismatch for BindGroupDescriptor::entries\");\n\n// BindGroupLayoutEntry implementation\n\nBindGroupLayoutEntry::operator const WGPUBindGroupLayoutEntry&() const noexcept {\n    return *reinterpret_cast<const WGPUBindGroupLayoutEntry*>(this);\n}\n\nstatic_assert(sizeof(BindGroupLayoutEntry) == sizeof(WGPUBindGroupLayoutEntry), \"sizeof mismatch for BindGroupLayoutEntry\");\nstatic_assert(alignof(BindGroupLayoutEntry) == alignof(WGPUBindGroupLayoutEntry), \"alignof mismatch for BindGroupLayoutEntry\");\nstatic_assert(offsetof(BindGroupLayoutEntry, nextInChain) == offsetof(WGPUBindGroupLayoutEntry, nextInChain),\n        \"offsetof mismatch for BindGroupLayoutEntry::nextInChain\");\nstatic_assert(offsetof(BindGroupLayoutEntry, binding) == offsetof(WGPUBindGroupLayoutEntry, binding),\n        \"offsetof mismatch for BindGroupLayoutEntry::binding\");\nstatic_assert(offsetof(BindGroupLayoutEntry, visibility) == offsetof(WGPUBindGroupLayoutEntry, visibility),\n        \"offsetof mismatch for BindGroupLayoutEntry::visibility\");\nstatic_assert(offsetof(BindGroupLayoutEntry, buffer) == offsetof(WGPUBindGroupLayoutEntry, buffer),\n        \"offsetof mismatch for BindGroupLayoutEntry::buffer\");\nstatic_assert(offsetof(BindGroupLayoutEntry, sampler) == offsetof(WGPUBindGroupLayoutEntry, sampler),\n        \"offsetof mismatch for BindGroupLayoutEntry::sampler\");\nstatic_assert(offsetof(BindGroupLayoutEntry, texture) == offsetof(WGPUBindGroupLayoutEntry, texture),\n        \"offsetof mismatch for BindGroupLayoutEntry::texture\");\nstatic_assert(offsetof(BindGroupLayoutEntry, storageTexture) == offsetof(WGPUBindGroupLayoutEntry, storageTexture),\n        \"offsetof mismatch for BindGroupLayoutEntry::storageTexture\");\n\n// BlendState implementation\n\nBlendState::operator const WGPUBlendState&() const noexcept {\n    return *reinterpret_cast<const WGPUBlendState*>(this);\n}\n\nstatic_assert(sizeof(BlendState) == sizeof(WGPUBlendState), \"sizeof mismatch for BlendState\");\nstatic_assert(alignof(BlendState) == alignof(WGPUBlendState), \"alignof mismatch for BlendState\");\nstatic_assert(offsetof(BlendState, color) == offsetof(WGPUBlendState, color),\n        \"offsetof mismatch for BlendState::color\");\nstatic_assert(offsetof(BlendState, alpha) == offsetof(WGPUBlendState, alpha),\n        \"offsetof mismatch for BlendState::alpha\");\n\n// BufferDescriptor implementation\n\nBufferDescriptor::operator const WGPUBufferDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUBufferDescriptor*>(this);\n}\n\nstatic_assert(sizeof(BufferDescriptor) == sizeof(WGPUBufferDescriptor), \"sizeof mismatch for BufferDescriptor\");\nstatic_assert(alignof(BufferDescriptor) == alignof(WGPUBufferDescriptor), \"alignof mismatch for BufferDescriptor\");\nstatic_assert(offsetof(BufferDescriptor, nextInChain) == offsetof(WGPUBufferDescriptor, nextInChain),\n        \"offsetof mismatch for BufferDescriptor::nextInChain\");\nstatic_assert(offsetof(BufferDescriptor, label) == offsetof(WGPUBufferDescriptor, label),\n        \"offsetof mismatch for BufferDescriptor::label\");\nstatic_assert(offsetof(BufferDescriptor, usage) == offsetof(WGPUBufferDescriptor, usage),\n        \"offsetof mismatch for BufferDescriptor::usage\");\nstatic_assert(offsetof(BufferDescriptor, size) == offsetof(WGPUBufferDescriptor, size),\n        \"offsetof mismatch for BufferDescriptor::size\");\nstatic_assert(offsetof(BufferDescriptor, mappedAtCreation) == offsetof(WGPUBufferDescriptor, mappedAtCreation),\n        \"offsetof mismatch for BufferDescriptor::mappedAtCreation\");\n\n// CommandBufferDescriptor implementation\n\nCommandBufferDescriptor::operator const WGPUCommandBufferDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUCommandBufferDescriptor*>(this);\n}\n\nstatic_assert(sizeof(CommandBufferDescriptor) == sizeof(WGPUCommandBufferDescriptor), \"sizeof mismatch for CommandBufferDescriptor\");\nstatic_assert(alignof(CommandBufferDescriptor) == alignof(WGPUCommandBufferDescriptor), \"alignof mismatch for CommandBufferDescriptor\");\nstatic_assert(offsetof(CommandBufferDescriptor, nextInChain) == offsetof(WGPUCommandBufferDescriptor, nextInChain),\n        \"offsetof mismatch for CommandBufferDescriptor::nextInChain\");\nstatic_assert(offsetof(CommandBufferDescriptor, label) == offsetof(WGPUCommandBufferDescriptor, label),\n        \"offsetof mismatch for CommandBufferDescriptor::label\");\n\n// CommandEncoderDescriptor implementation\n\nCommandEncoderDescriptor::operator const WGPUCommandEncoderDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUCommandEncoderDescriptor*>(this);\n}\n\nstatic_assert(sizeof(CommandEncoderDescriptor) == sizeof(WGPUCommandEncoderDescriptor), \"sizeof mismatch for CommandEncoderDescriptor\");\nstatic_assert(alignof(CommandEncoderDescriptor) == alignof(WGPUCommandEncoderDescriptor), \"alignof mismatch for CommandEncoderDescriptor\");\nstatic_assert(offsetof(CommandEncoderDescriptor, nextInChain) == offsetof(WGPUCommandEncoderDescriptor, nextInChain),\n        \"offsetof mismatch for CommandEncoderDescriptor::nextInChain\");\nstatic_assert(offsetof(CommandEncoderDescriptor, label) == offsetof(WGPUCommandEncoderDescriptor, label),\n        \"offsetof mismatch for CommandEncoderDescriptor::label\");\n\n// CompilationMessage implementation\n\nCompilationMessage::operator const WGPUCompilationMessage&() const noexcept {\n    return *reinterpret_cast<const WGPUCompilationMessage*>(this);\n}\n\nstatic_assert(sizeof(CompilationMessage) == sizeof(WGPUCompilationMessage), \"sizeof mismatch for CompilationMessage\");\nstatic_assert(alignof(CompilationMessage) == alignof(WGPUCompilationMessage), \"alignof mismatch for CompilationMessage\");\nstatic_assert(offsetof(CompilationMessage, nextInChain) == offsetof(WGPUCompilationMessage, nextInChain),\n        \"offsetof mismatch for CompilationMessage::nextInChain\");\nstatic_assert(offsetof(CompilationMessage, message) == offsetof(WGPUCompilationMessage, message),\n        \"offsetof mismatch for CompilationMessage::message\");\nstatic_assert(offsetof(CompilationMessage, type) == offsetof(WGPUCompilationMessage, type),\n        \"offsetof mismatch for CompilationMessage::type\");\nstatic_assert(offsetof(CompilationMessage, lineNum) == offsetof(WGPUCompilationMessage, lineNum),\n        \"offsetof mismatch for CompilationMessage::lineNum\");\nstatic_assert(offsetof(CompilationMessage, linePos) == offsetof(WGPUCompilationMessage, linePos),\n        \"offsetof mismatch for CompilationMessage::linePos\");\nstatic_assert(offsetof(CompilationMessage, offset) == offsetof(WGPUCompilationMessage, offset),\n        \"offsetof mismatch for CompilationMessage::offset\");\nstatic_assert(offsetof(CompilationMessage, length) == offsetof(WGPUCompilationMessage, length),\n        \"offsetof mismatch for CompilationMessage::length\");\nstatic_assert(offsetof(CompilationMessage, utf16LinePos) == offsetof(WGPUCompilationMessage, utf16LinePos),\n        \"offsetof mismatch for CompilationMessage::utf16LinePos\");\nstatic_assert(offsetof(CompilationMessage, utf16Offset) == offsetof(WGPUCompilationMessage, utf16Offset),\n        \"offsetof mismatch for CompilationMessage::utf16Offset\");\nstatic_assert(offsetof(CompilationMessage, utf16Length) == offsetof(WGPUCompilationMessage, utf16Length),\n        \"offsetof mismatch for CompilationMessage::utf16Length\");\n\n// ComputePassDescriptor implementation\n\nComputePassDescriptor::operator const WGPUComputePassDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUComputePassDescriptor*>(this);\n}\n\nstatic_assert(sizeof(ComputePassDescriptor) == sizeof(WGPUComputePassDescriptor), \"sizeof mismatch for ComputePassDescriptor\");\nstatic_assert(alignof(ComputePassDescriptor) == alignof(WGPUComputePassDescriptor), \"alignof mismatch for ComputePassDescriptor\");\nstatic_assert(offsetof(ComputePassDescriptor, nextInChain) == offsetof(WGPUComputePassDescriptor, nextInChain),\n        \"offsetof mismatch for ComputePassDescriptor::nextInChain\");\nstatic_assert(offsetof(ComputePassDescriptor, label) == offsetof(WGPUComputePassDescriptor, label),\n        \"offsetof mismatch for ComputePassDescriptor::label\");\nstatic_assert(offsetof(ComputePassDescriptor, timestampWrites) == offsetof(WGPUComputePassDescriptor, timestampWrites),\n        \"offsetof mismatch for ComputePassDescriptor::timestampWrites\");\n\n// ConstantEntry implementation\n\nConstantEntry::operator const WGPUConstantEntry&() const noexcept {\n    return *reinterpret_cast<const WGPUConstantEntry*>(this);\n}\n\nstatic_assert(sizeof(ConstantEntry) == sizeof(WGPUConstantEntry), \"sizeof mismatch for ConstantEntry\");\nstatic_assert(alignof(ConstantEntry) == alignof(WGPUConstantEntry), \"alignof mismatch for ConstantEntry\");\nstatic_assert(offsetof(ConstantEntry, nextInChain) == offsetof(WGPUConstantEntry, nextInChain),\n        \"offsetof mismatch for ConstantEntry::nextInChain\");\nstatic_assert(offsetof(ConstantEntry, key) == offsetof(WGPUConstantEntry, key),\n        \"offsetof mismatch for ConstantEntry::key\");\nstatic_assert(offsetof(ConstantEntry, value) == offsetof(WGPUConstantEntry, value),\n        \"offsetof mismatch for ConstantEntry::value\");\n\n// DawnCacheDeviceDescriptor implementation\nDawnCacheDeviceDescriptor::DawnCacheDeviceDescriptor()\n  : ChainedStruct { nullptr, SType::DawnCacheDeviceDescriptor } {}\nstruct DawnCacheDeviceDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    StringView isolationKey = {};\n    DawnLoadCacheDataFunction loadDataFunction = nullptr;\n    DawnStoreCacheDataFunction storeDataFunction = nullptr;\n    void * functionUserdata = nullptr;\n};\nDawnCacheDeviceDescriptor::DawnCacheDeviceDescriptor(DawnCacheDeviceDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::DawnCacheDeviceDescriptor }, \n    isolationKey(std::move(init.isolationKey)), \n    loadDataFunction(std::move(init.loadDataFunction)), \n    storeDataFunction(std::move(init.storeDataFunction)), \n    functionUserdata(std::move(init.functionUserdata)){}\n\nDawnCacheDeviceDescriptor::operator const WGPUDawnCacheDeviceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDawnCacheDeviceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(DawnCacheDeviceDescriptor) == sizeof(WGPUDawnCacheDeviceDescriptor), \"sizeof mismatch for DawnCacheDeviceDescriptor\");\nstatic_assert(alignof(DawnCacheDeviceDescriptor) == alignof(WGPUDawnCacheDeviceDescriptor), \"alignof mismatch for DawnCacheDeviceDescriptor\");\nstatic_assert(offsetof(DawnCacheDeviceDescriptor, isolationKey) == offsetof(WGPUDawnCacheDeviceDescriptor, isolationKey),\n        \"offsetof mismatch for DawnCacheDeviceDescriptor::isolationKey\");\nstatic_assert(offsetof(DawnCacheDeviceDescriptor, loadDataFunction) == offsetof(WGPUDawnCacheDeviceDescriptor, loadDataFunction),\n        \"offsetof mismatch for DawnCacheDeviceDescriptor::loadDataFunction\");\nstatic_assert(offsetof(DawnCacheDeviceDescriptor, storeDataFunction) == offsetof(WGPUDawnCacheDeviceDescriptor, storeDataFunction),\n        \"offsetof mismatch for DawnCacheDeviceDescriptor::storeDataFunction\");\nstatic_assert(offsetof(DawnCacheDeviceDescriptor, functionUserdata) == offsetof(WGPUDawnCacheDeviceDescriptor, functionUserdata),\n        \"offsetof mismatch for DawnCacheDeviceDescriptor::functionUserdata\");\n\n// DepthStencilState implementation\n\nDepthStencilState::operator const WGPUDepthStencilState&() const noexcept {\n    return *reinterpret_cast<const WGPUDepthStencilState*>(this);\n}\n\nstatic_assert(sizeof(DepthStencilState) == sizeof(WGPUDepthStencilState), \"sizeof mismatch for DepthStencilState\");\nstatic_assert(alignof(DepthStencilState) == alignof(WGPUDepthStencilState), \"alignof mismatch for DepthStencilState\");\nstatic_assert(offsetof(DepthStencilState, nextInChain) == offsetof(WGPUDepthStencilState, nextInChain),\n        \"offsetof mismatch for DepthStencilState::nextInChain\");\nstatic_assert(offsetof(DepthStencilState, format) == offsetof(WGPUDepthStencilState, format),\n        \"offsetof mismatch for DepthStencilState::format\");\nstatic_assert(offsetof(DepthStencilState, depthWriteEnabled) == offsetof(WGPUDepthStencilState, depthWriteEnabled),\n        \"offsetof mismatch for DepthStencilState::depthWriteEnabled\");\nstatic_assert(offsetof(DepthStencilState, depthCompare) == offsetof(WGPUDepthStencilState, depthCompare),\n        \"offsetof mismatch for DepthStencilState::depthCompare\");\nstatic_assert(offsetof(DepthStencilState, stencilFront) == offsetof(WGPUDepthStencilState, stencilFront),\n        \"offsetof mismatch for DepthStencilState::stencilFront\");\nstatic_assert(offsetof(DepthStencilState, stencilBack) == offsetof(WGPUDepthStencilState, stencilBack),\n        \"offsetof mismatch for DepthStencilState::stencilBack\");\nstatic_assert(offsetof(DepthStencilState, stencilReadMask) == offsetof(WGPUDepthStencilState, stencilReadMask),\n        \"offsetof mismatch for DepthStencilState::stencilReadMask\");\nstatic_assert(offsetof(DepthStencilState, stencilWriteMask) == offsetof(WGPUDepthStencilState, stencilWriteMask),\n        \"offsetof mismatch for DepthStencilState::stencilWriteMask\");\nstatic_assert(offsetof(DepthStencilState, depthBias) == offsetof(WGPUDepthStencilState, depthBias),\n        \"offsetof mismatch for DepthStencilState::depthBias\");\nstatic_assert(offsetof(DepthStencilState, depthBiasSlopeScale) == offsetof(WGPUDepthStencilState, depthBiasSlopeScale),\n        \"offsetof mismatch for DepthStencilState::depthBiasSlopeScale\");\nstatic_assert(offsetof(DepthStencilState, depthBiasClamp) == offsetof(WGPUDepthStencilState, depthBiasClamp),\n        \"offsetof mismatch for DepthStencilState::depthBiasClamp\");\n\n// DrmFormatCapabilities implementation\nDrmFormatCapabilities::DrmFormatCapabilities()\n  : ChainedStructOut { nullptr, SType::DrmFormatCapabilities } {}\nstruct DrmFormatCapabilities::Init {\n    ChainedStructOut *  nextInChain;\n    size_t const propertiesCount = {};\n    DrmFormatProperties const * const properties = {};\n};\nDrmFormatCapabilities::DrmFormatCapabilities(DrmFormatCapabilities::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::DrmFormatCapabilities }, \n    propertiesCount(std::move(init.propertiesCount)), \n    properties(std::move(init.properties)){}\nDrmFormatCapabilities::~DrmFormatCapabilities() {\n    FreeMembers();\n}\n\nDrmFormatCapabilities::DrmFormatCapabilities(DrmFormatCapabilities&& rhs)\n    : propertiesCount(rhs.propertiesCount),\n            properties(rhs.properties){\n    Reset(rhs);\n}\n\nDrmFormatCapabilities& DrmFormatCapabilities::operator=(DrmFormatCapabilities&& rhs) {\n    if (&rhs == this) {\n        return *this;\n    }\n    FreeMembers();\n    detail::AsNonConstReference(this->propertiesCount) = std::move(rhs.propertiesCount);\n    detail::AsNonConstReference(this->properties) = std::move(rhs.properties);\n    Reset(rhs);\n    return *this;\n}\n\nvoid DrmFormatCapabilities::FreeMembers() {\n    bool needsFreeing = false;    if (this->properties != nullptr) { needsFreeing = true; }if (needsFreeing) {\n        wgpuDawnWireClientDrmFormatCapabilitiesFreeMembers(\n            *reinterpret_cast<WGPUDrmFormatCapabilities*>(this));\n    }\n}\n\n// static\nvoid DrmFormatCapabilities::Reset(DrmFormatCapabilities& value) {\n    DrmFormatCapabilities defaultValue{};\n    detail::AsNonConstReference(value.propertiesCount) = defaultValue.propertiesCount;\n    detail::AsNonConstReference(value.properties) = defaultValue.properties;\n}\n\nDrmFormatCapabilities::operator const WGPUDrmFormatCapabilities&() const noexcept {\n    return *reinterpret_cast<const WGPUDrmFormatCapabilities*>(this);\n}\n\nstatic_assert(sizeof(DrmFormatCapabilities) == sizeof(WGPUDrmFormatCapabilities), \"sizeof mismatch for DrmFormatCapabilities\");\nstatic_assert(alignof(DrmFormatCapabilities) == alignof(WGPUDrmFormatCapabilities), \"alignof mismatch for DrmFormatCapabilities\");\nstatic_assert(offsetof(DrmFormatCapabilities, propertiesCount) == offsetof(WGPUDrmFormatCapabilities, propertiesCount),\n        \"offsetof mismatch for DrmFormatCapabilities::propertiesCount\");\nstatic_assert(offsetof(DrmFormatCapabilities, properties) == offsetof(WGPUDrmFormatCapabilities, properties),\n        \"offsetof mismatch for DrmFormatCapabilities::properties\");\n\n// ExternalTextureDescriptor implementation\n\nExternalTextureDescriptor::operator const WGPUExternalTextureDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUExternalTextureDescriptor*>(this);\n}\n\nstatic_assert(sizeof(ExternalTextureDescriptor) == sizeof(WGPUExternalTextureDescriptor), \"sizeof mismatch for ExternalTextureDescriptor\");\nstatic_assert(alignof(ExternalTextureDescriptor) == alignof(WGPUExternalTextureDescriptor), \"alignof mismatch for ExternalTextureDescriptor\");\nstatic_assert(offsetof(ExternalTextureDescriptor, nextInChain) == offsetof(WGPUExternalTextureDescriptor, nextInChain),\n        \"offsetof mismatch for ExternalTextureDescriptor::nextInChain\");\nstatic_assert(offsetof(ExternalTextureDescriptor, label) == offsetof(WGPUExternalTextureDescriptor, label),\n        \"offsetof mismatch for ExternalTextureDescriptor::label\");\nstatic_assert(offsetof(ExternalTextureDescriptor, plane0) == offsetof(WGPUExternalTextureDescriptor, plane0),\n        \"offsetof mismatch for ExternalTextureDescriptor::plane0\");\nstatic_assert(offsetof(ExternalTextureDescriptor, plane1) == offsetof(WGPUExternalTextureDescriptor, plane1),\n        \"offsetof mismatch for ExternalTextureDescriptor::plane1\");\nstatic_assert(offsetof(ExternalTextureDescriptor, cropOrigin) == offsetof(WGPUExternalTextureDescriptor, cropOrigin),\n        \"offsetof mismatch for ExternalTextureDescriptor::cropOrigin\");\nstatic_assert(offsetof(ExternalTextureDescriptor, cropSize) == offsetof(WGPUExternalTextureDescriptor, cropSize),\n        \"offsetof mismatch for ExternalTextureDescriptor::cropSize\");\nstatic_assert(offsetof(ExternalTextureDescriptor, apparentSize) == offsetof(WGPUExternalTextureDescriptor, apparentSize),\n        \"offsetof mismatch for ExternalTextureDescriptor::apparentSize\");\nstatic_assert(offsetof(ExternalTextureDescriptor, doYuvToRgbConversionOnly) == offsetof(WGPUExternalTextureDescriptor, doYuvToRgbConversionOnly),\n        \"offsetof mismatch for ExternalTextureDescriptor::doYuvToRgbConversionOnly\");\nstatic_assert(offsetof(ExternalTextureDescriptor, yuvToRgbConversionMatrix) == offsetof(WGPUExternalTextureDescriptor, yuvToRgbConversionMatrix),\n        \"offsetof mismatch for ExternalTextureDescriptor::yuvToRgbConversionMatrix\");\nstatic_assert(offsetof(ExternalTextureDescriptor, srcTransferFunctionParameters) == offsetof(WGPUExternalTextureDescriptor, srcTransferFunctionParameters),\n        \"offsetof mismatch for ExternalTextureDescriptor::srcTransferFunctionParameters\");\nstatic_assert(offsetof(ExternalTextureDescriptor, dstTransferFunctionParameters) == offsetof(WGPUExternalTextureDescriptor, dstTransferFunctionParameters),\n        \"offsetof mismatch for ExternalTextureDescriptor::dstTransferFunctionParameters\");\nstatic_assert(offsetof(ExternalTextureDescriptor, gamutConversionMatrix) == offsetof(WGPUExternalTextureDescriptor, gamutConversionMatrix),\n        \"offsetof mismatch for ExternalTextureDescriptor::gamutConversionMatrix\");\nstatic_assert(offsetof(ExternalTextureDescriptor, mirrored) == offsetof(WGPUExternalTextureDescriptor, mirrored),\n        \"offsetof mismatch for ExternalTextureDescriptor::mirrored\");\nstatic_assert(offsetof(ExternalTextureDescriptor, rotation) == offsetof(WGPUExternalTextureDescriptor, rotation),\n        \"offsetof mismatch for ExternalTextureDescriptor::rotation\");\n\n// FutureWaitInfo implementation\n\nFutureWaitInfo::operator const WGPUFutureWaitInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUFutureWaitInfo*>(this);\n}\n\nstatic_assert(sizeof(FutureWaitInfo) == sizeof(WGPUFutureWaitInfo), \"sizeof mismatch for FutureWaitInfo\");\nstatic_assert(alignof(FutureWaitInfo) == alignof(WGPUFutureWaitInfo), \"alignof mismatch for FutureWaitInfo\");\nstatic_assert(offsetof(FutureWaitInfo, future) == offsetof(WGPUFutureWaitInfo, future),\n        \"offsetof mismatch for FutureWaitInfo::future\");\nstatic_assert(offsetof(FutureWaitInfo, completed) == offsetof(WGPUFutureWaitInfo, completed),\n        \"offsetof mismatch for FutureWaitInfo::completed\");\n\n// ImageCopyBuffer implementation\n\nImageCopyBuffer::operator const WGPUImageCopyBuffer&() const noexcept {\n    return *reinterpret_cast<const WGPUImageCopyBuffer*>(this);\n}\n\nstatic_assert(sizeof(ImageCopyBuffer) == sizeof(WGPUImageCopyBuffer), \"sizeof mismatch for ImageCopyBuffer\");\nstatic_assert(alignof(ImageCopyBuffer) == alignof(WGPUImageCopyBuffer), \"alignof mismatch for ImageCopyBuffer\");\nstatic_assert(offsetof(ImageCopyBuffer, layout) == offsetof(WGPUImageCopyBuffer, layout),\n        \"offsetof mismatch for ImageCopyBuffer::layout\");\nstatic_assert(offsetof(ImageCopyBuffer, buffer) == offsetof(WGPUImageCopyBuffer, buffer),\n        \"offsetof mismatch for ImageCopyBuffer::buffer\");\n\n// ImageCopyExternalTexture implementation\n\nImageCopyExternalTexture::operator const WGPUImageCopyExternalTexture&() const noexcept {\n    return *reinterpret_cast<const WGPUImageCopyExternalTexture*>(this);\n}\n\nstatic_assert(sizeof(ImageCopyExternalTexture) == sizeof(WGPUImageCopyExternalTexture), \"sizeof mismatch for ImageCopyExternalTexture\");\nstatic_assert(alignof(ImageCopyExternalTexture) == alignof(WGPUImageCopyExternalTexture), \"alignof mismatch for ImageCopyExternalTexture\");\nstatic_assert(offsetof(ImageCopyExternalTexture, nextInChain) == offsetof(WGPUImageCopyExternalTexture, nextInChain),\n        \"offsetof mismatch for ImageCopyExternalTexture::nextInChain\");\nstatic_assert(offsetof(ImageCopyExternalTexture, externalTexture) == offsetof(WGPUImageCopyExternalTexture, externalTexture),\n        \"offsetof mismatch for ImageCopyExternalTexture::externalTexture\");\nstatic_assert(offsetof(ImageCopyExternalTexture, origin) == offsetof(WGPUImageCopyExternalTexture, origin),\n        \"offsetof mismatch for ImageCopyExternalTexture::origin\");\nstatic_assert(offsetof(ImageCopyExternalTexture, naturalSize) == offsetof(WGPUImageCopyExternalTexture, naturalSize),\n        \"offsetof mismatch for ImageCopyExternalTexture::naturalSize\");\n\n// ImageCopyTexture implementation\n\nImageCopyTexture::operator const WGPUImageCopyTexture&() const noexcept {\n    return *reinterpret_cast<const WGPUImageCopyTexture*>(this);\n}\n\nstatic_assert(sizeof(ImageCopyTexture) == sizeof(WGPUImageCopyTexture), \"sizeof mismatch for ImageCopyTexture\");\nstatic_assert(alignof(ImageCopyTexture) == alignof(WGPUImageCopyTexture), \"alignof mismatch for ImageCopyTexture\");\nstatic_assert(offsetof(ImageCopyTexture, texture) == offsetof(WGPUImageCopyTexture, texture),\n        \"offsetof mismatch for ImageCopyTexture::texture\");\nstatic_assert(offsetof(ImageCopyTexture, mipLevel) == offsetof(WGPUImageCopyTexture, mipLevel),\n        \"offsetof mismatch for ImageCopyTexture::mipLevel\");\nstatic_assert(offsetof(ImageCopyTexture, origin) == offsetof(WGPUImageCopyTexture, origin),\n        \"offsetof mismatch for ImageCopyTexture::origin\");\nstatic_assert(offsetof(ImageCopyTexture, aspect) == offsetof(WGPUImageCopyTexture, aspect),\n        \"offsetof mismatch for ImageCopyTexture::aspect\");\n\n// InstanceDescriptor implementation\n\nInstanceDescriptor::operator const WGPUInstanceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUInstanceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(InstanceDescriptor) == sizeof(WGPUInstanceDescriptor), \"sizeof mismatch for InstanceDescriptor\");\nstatic_assert(alignof(InstanceDescriptor) == alignof(WGPUInstanceDescriptor), \"alignof mismatch for InstanceDescriptor\");\nstatic_assert(offsetof(InstanceDescriptor, nextInChain) == offsetof(WGPUInstanceDescriptor, nextInChain),\n        \"offsetof mismatch for InstanceDescriptor::nextInChain\");\nstatic_assert(offsetof(InstanceDescriptor, features) == offsetof(WGPUInstanceDescriptor, features),\n        \"offsetof mismatch for InstanceDescriptor::features\");\n\n// PipelineLayoutDescriptor implementation\n\nPipelineLayoutDescriptor::operator const WGPUPipelineLayoutDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUPipelineLayoutDescriptor*>(this);\n}\n\nstatic_assert(sizeof(PipelineLayoutDescriptor) == sizeof(WGPUPipelineLayoutDescriptor), \"sizeof mismatch for PipelineLayoutDescriptor\");\nstatic_assert(alignof(PipelineLayoutDescriptor) == alignof(WGPUPipelineLayoutDescriptor), \"alignof mismatch for PipelineLayoutDescriptor\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, nextInChain) == offsetof(WGPUPipelineLayoutDescriptor, nextInChain),\n        \"offsetof mismatch for PipelineLayoutDescriptor::nextInChain\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, label) == offsetof(WGPUPipelineLayoutDescriptor, label),\n        \"offsetof mismatch for PipelineLayoutDescriptor::label\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayoutCount) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayoutCount),\n        \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayoutCount\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, bindGroupLayouts) == offsetof(WGPUPipelineLayoutDescriptor, bindGroupLayouts),\n        \"offsetof mismatch for PipelineLayoutDescriptor::bindGroupLayouts\");\nstatic_assert(offsetof(PipelineLayoutDescriptor, immediateDataRangeByteSize) == offsetof(WGPUPipelineLayoutDescriptor, immediateDataRangeByteSize),\n        \"offsetof mismatch for PipelineLayoutDescriptor::immediateDataRangeByteSize\");\n\n// PipelineLayoutPixelLocalStorage implementation\nPipelineLayoutPixelLocalStorage::PipelineLayoutPixelLocalStorage()\n  : ChainedStruct { nullptr, SType::PipelineLayoutPixelLocalStorage } {}\nstruct PipelineLayoutPixelLocalStorage::Init {\n    ChainedStruct * const nextInChain;\n    uint64_t totalPixelLocalStorageSize;\n    size_t storageAttachmentCount = 0;\n    PipelineLayoutStorageAttachment const * storageAttachments;\n};\nPipelineLayoutPixelLocalStorage::PipelineLayoutPixelLocalStorage(PipelineLayoutPixelLocalStorage::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::PipelineLayoutPixelLocalStorage }, \n    totalPixelLocalStorageSize(std::move(init.totalPixelLocalStorageSize)), \n    storageAttachmentCount(std::move(init.storageAttachmentCount)), \n    storageAttachments(std::move(init.storageAttachments)){}\n\nPipelineLayoutPixelLocalStorage::operator const WGPUPipelineLayoutPixelLocalStorage&() const noexcept {\n    return *reinterpret_cast<const WGPUPipelineLayoutPixelLocalStorage*>(this);\n}\n\nstatic_assert(sizeof(PipelineLayoutPixelLocalStorage) == sizeof(WGPUPipelineLayoutPixelLocalStorage), \"sizeof mismatch for PipelineLayoutPixelLocalStorage\");\nstatic_assert(alignof(PipelineLayoutPixelLocalStorage) == alignof(WGPUPipelineLayoutPixelLocalStorage), \"alignof mismatch for PipelineLayoutPixelLocalStorage\");\nstatic_assert(offsetof(PipelineLayoutPixelLocalStorage, totalPixelLocalStorageSize) == offsetof(WGPUPipelineLayoutPixelLocalStorage, totalPixelLocalStorageSize),\n        \"offsetof mismatch for PipelineLayoutPixelLocalStorage::totalPixelLocalStorageSize\");\nstatic_assert(offsetof(PipelineLayoutPixelLocalStorage, storageAttachmentCount) == offsetof(WGPUPipelineLayoutPixelLocalStorage, storageAttachmentCount),\n        \"offsetof mismatch for PipelineLayoutPixelLocalStorage::storageAttachmentCount\");\nstatic_assert(offsetof(PipelineLayoutPixelLocalStorage, storageAttachments) == offsetof(WGPUPipelineLayoutPixelLocalStorage, storageAttachments),\n        \"offsetof mismatch for PipelineLayoutPixelLocalStorage::storageAttachments\");\n\n// QuerySetDescriptor implementation\n\nQuerySetDescriptor::operator const WGPUQuerySetDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUQuerySetDescriptor*>(this);\n}\n\nstatic_assert(sizeof(QuerySetDescriptor) == sizeof(WGPUQuerySetDescriptor), \"sizeof mismatch for QuerySetDescriptor\");\nstatic_assert(alignof(QuerySetDescriptor) == alignof(WGPUQuerySetDescriptor), \"alignof mismatch for QuerySetDescriptor\");\nstatic_assert(offsetof(QuerySetDescriptor, nextInChain) == offsetof(WGPUQuerySetDescriptor, nextInChain),\n        \"offsetof mismatch for QuerySetDescriptor::nextInChain\");\nstatic_assert(offsetof(QuerySetDescriptor, label) == offsetof(WGPUQuerySetDescriptor, label),\n        \"offsetof mismatch for QuerySetDescriptor::label\");\nstatic_assert(offsetof(QuerySetDescriptor, type) == offsetof(WGPUQuerySetDescriptor, type),\n        \"offsetof mismatch for QuerySetDescriptor::type\");\nstatic_assert(offsetof(QuerySetDescriptor, count) == offsetof(WGPUQuerySetDescriptor, count),\n        \"offsetof mismatch for QuerySetDescriptor::count\");\n\n// QueueDescriptor implementation\n\nQueueDescriptor::operator const WGPUQueueDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUQueueDescriptor*>(this);\n}\n\nstatic_assert(sizeof(QueueDescriptor) == sizeof(WGPUQueueDescriptor), \"sizeof mismatch for QueueDescriptor\");\nstatic_assert(alignof(QueueDescriptor) == alignof(WGPUQueueDescriptor), \"alignof mismatch for QueueDescriptor\");\nstatic_assert(offsetof(QueueDescriptor, nextInChain) == offsetof(WGPUQueueDescriptor, nextInChain),\n        \"offsetof mismatch for QueueDescriptor::nextInChain\");\nstatic_assert(offsetof(QueueDescriptor, label) == offsetof(WGPUQueueDescriptor, label),\n        \"offsetof mismatch for QueueDescriptor::label\");\n\n// RenderBundleDescriptor implementation\n\nRenderBundleDescriptor::operator const WGPURenderBundleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPURenderBundleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(RenderBundleDescriptor) == sizeof(WGPURenderBundleDescriptor), \"sizeof mismatch for RenderBundleDescriptor\");\nstatic_assert(alignof(RenderBundleDescriptor) == alignof(WGPURenderBundleDescriptor), \"alignof mismatch for RenderBundleDescriptor\");\nstatic_assert(offsetof(RenderBundleDescriptor, nextInChain) == offsetof(WGPURenderBundleDescriptor, nextInChain),\n        \"offsetof mismatch for RenderBundleDescriptor::nextInChain\");\nstatic_assert(offsetof(RenderBundleDescriptor, label) == offsetof(WGPURenderBundleDescriptor, label),\n        \"offsetof mismatch for RenderBundleDescriptor::label\");\n\n// RenderBundleEncoderDescriptor implementation\n\nRenderBundleEncoderDescriptor::operator const WGPURenderBundleEncoderDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPURenderBundleEncoderDescriptor*>(this);\n}\n\nstatic_assert(sizeof(RenderBundleEncoderDescriptor) == sizeof(WGPURenderBundleEncoderDescriptor), \"sizeof mismatch for RenderBundleEncoderDescriptor\");\nstatic_assert(alignof(RenderBundleEncoderDescriptor) == alignof(WGPURenderBundleEncoderDescriptor), \"alignof mismatch for RenderBundleEncoderDescriptor\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, nextInChain) == offsetof(WGPURenderBundleEncoderDescriptor, nextInChain),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::nextInChain\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, label) == offsetof(WGPURenderBundleEncoderDescriptor, label),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::label\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, colorFormatCount) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormatCount),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormatCount\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, colorFormats) == offsetof(WGPURenderBundleEncoderDescriptor, colorFormats),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::colorFormats\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, depthStencilFormat) == offsetof(WGPURenderBundleEncoderDescriptor, depthStencilFormat),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::depthStencilFormat\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, sampleCount) == offsetof(WGPURenderBundleEncoderDescriptor, sampleCount),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::sampleCount\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, depthReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, depthReadOnly),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::depthReadOnly\");\nstatic_assert(offsetof(RenderBundleEncoderDescriptor, stencilReadOnly) == offsetof(WGPURenderBundleEncoderDescriptor, stencilReadOnly),\n        \"offsetof mismatch for RenderBundleEncoderDescriptor::stencilReadOnly\");\n\n// RenderPassColorAttachment implementation\n\nRenderPassColorAttachment::operator const WGPURenderPassColorAttachment&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassColorAttachment*>(this);\n}\n\nstatic_assert(sizeof(RenderPassColorAttachment) == sizeof(WGPURenderPassColorAttachment), \"sizeof mismatch for RenderPassColorAttachment\");\nstatic_assert(alignof(RenderPassColorAttachment) == alignof(WGPURenderPassColorAttachment), \"alignof mismatch for RenderPassColorAttachment\");\nstatic_assert(offsetof(RenderPassColorAttachment, nextInChain) == offsetof(WGPURenderPassColorAttachment, nextInChain),\n        \"offsetof mismatch for RenderPassColorAttachment::nextInChain\");\nstatic_assert(offsetof(RenderPassColorAttachment, view) == offsetof(WGPURenderPassColorAttachment, view),\n        \"offsetof mismatch for RenderPassColorAttachment::view\");\nstatic_assert(offsetof(RenderPassColorAttachment, depthSlice) == offsetof(WGPURenderPassColorAttachment, depthSlice),\n        \"offsetof mismatch for RenderPassColorAttachment::depthSlice\");\nstatic_assert(offsetof(RenderPassColorAttachment, resolveTarget) == offsetof(WGPURenderPassColorAttachment, resolveTarget),\n        \"offsetof mismatch for RenderPassColorAttachment::resolveTarget\");\nstatic_assert(offsetof(RenderPassColorAttachment, loadOp) == offsetof(WGPURenderPassColorAttachment, loadOp),\n        \"offsetof mismatch for RenderPassColorAttachment::loadOp\");\nstatic_assert(offsetof(RenderPassColorAttachment, storeOp) == offsetof(WGPURenderPassColorAttachment, storeOp),\n        \"offsetof mismatch for RenderPassColorAttachment::storeOp\");\nstatic_assert(offsetof(RenderPassColorAttachment, clearValue) == offsetof(WGPURenderPassColorAttachment, clearValue),\n        \"offsetof mismatch for RenderPassColorAttachment::clearValue\");\n\n// RenderPassStorageAttachment implementation\n\nRenderPassStorageAttachment::operator const WGPURenderPassStorageAttachment&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassStorageAttachment*>(this);\n}\n\nstatic_assert(sizeof(RenderPassStorageAttachment) == sizeof(WGPURenderPassStorageAttachment), \"sizeof mismatch for RenderPassStorageAttachment\");\nstatic_assert(alignof(RenderPassStorageAttachment) == alignof(WGPURenderPassStorageAttachment), \"alignof mismatch for RenderPassStorageAttachment\");\nstatic_assert(offsetof(RenderPassStorageAttachment, nextInChain) == offsetof(WGPURenderPassStorageAttachment, nextInChain),\n        \"offsetof mismatch for RenderPassStorageAttachment::nextInChain\");\nstatic_assert(offsetof(RenderPassStorageAttachment, offset) == offsetof(WGPURenderPassStorageAttachment, offset),\n        \"offsetof mismatch for RenderPassStorageAttachment::offset\");\nstatic_assert(offsetof(RenderPassStorageAttachment, storage) == offsetof(WGPURenderPassStorageAttachment, storage),\n        \"offsetof mismatch for RenderPassStorageAttachment::storage\");\nstatic_assert(offsetof(RenderPassStorageAttachment, loadOp) == offsetof(WGPURenderPassStorageAttachment, loadOp),\n        \"offsetof mismatch for RenderPassStorageAttachment::loadOp\");\nstatic_assert(offsetof(RenderPassStorageAttachment, storeOp) == offsetof(WGPURenderPassStorageAttachment, storeOp),\n        \"offsetof mismatch for RenderPassStorageAttachment::storeOp\");\nstatic_assert(offsetof(RenderPassStorageAttachment, clearValue) == offsetof(WGPURenderPassStorageAttachment, clearValue),\n        \"offsetof mismatch for RenderPassStorageAttachment::clearValue\");\n\n// RequiredLimits implementation\n\nRequiredLimits::operator const WGPURequiredLimits&() const noexcept {\n    return *reinterpret_cast<const WGPURequiredLimits*>(this);\n}\n\nstatic_assert(sizeof(RequiredLimits) == sizeof(WGPURequiredLimits), \"sizeof mismatch for RequiredLimits\");\nstatic_assert(alignof(RequiredLimits) == alignof(WGPURequiredLimits), \"alignof mismatch for RequiredLimits\");\nstatic_assert(offsetof(RequiredLimits, nextInChain) == offsetof(WGPURequiredLimits, nextInChain),\n        \"offsetof mismatch for RequiredLimits::nextInChain\");\nstatic_assert(offsetof(RequiredLimits, limits) == offsetof(WGPURequiredLimits, limits),\n        \"offsetof mismatch for RequiredLimits::limits\");\n\n// SamplerDescriptor implementation\n\nSamplerDescriptor::operator const WGPUSamplerDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSamplerDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SamplerDescriptor) == sizeof(WGPUSamplerDescriptor), \"sizeof mismatch for SamplerDescriptor\");\nstatic_assert(alignof(SamplerDescriptor) == alignof(WGPUSamplerDescriptor), \"alignof mismatch for SamplerDescriptor\");\nstatic_assert(offsetof(SamplerDescriptor, nextInChain) == offsetof(WGPUSamplerDescriptor, nextInChain),\n        \"offsetof mismatch for SamplerDescriptor::nextInChain\");\nstatic_assert(offsetof(SamplerDescriptor, label) == offsetof(WGPUSamplerDescriptor, label),\n        \"offsetof mismatch for SamplerDescriptor::label\");\nstatic_assert(offsetof(SamplerDescriptor, addressModeU) == offsetof(WGPUSamplerDescriptor, addressModeU),\n        \"offsetof mismatch for SamplerDescriptor::addressModeU\");\nstatic_assert(offsetof(SamplerDescriptor, addressModeV) == offsetof(WGPUSamplerDescriptor, addressModeV),\n        \"offsetof mismatch for SamplerDescriptor::addressModeV\");\nstatic_assert(offsetof(SamplerDescriptor, addressModeW) == offsetof(WGPUSamplerDescriptor, addressModeW),\n        \"offsetof mismatch for SamplerDescriptor::addressModeW\");\nstatic_assert(offsetof(SamplerDescriptor, magFilter) == offsetof(WGPUSamplerDescriptor, magFilter),\n        \"offsetof mismatch for SamplerDescriptor::magFilter\");\nstatic_assert(offsetof(SamplerDescriptor, minFilter) == offsetof(WGPUSamplerDescriptor, minFilter),\n        \"offsetof mismatch for SamplerDescriptor::minFilter\");\nstatic_assert(offsetof(SamplerDescriptor, mipmapFilter) == offsetof(WGPUSamplerDescriptor, mipmapFilter),\n        \"offsetof mismatch for SamplerDescriptor::mipmapFilter\");\nstatic_assert(offsetof(SamplerDescriptor, lodMinClamp) == offsetof(WGPUSamplerDescriptor, lodMinClamp),\n        \"offsetof mismatch for SamplerDescriptor::lodMinClamp\");\nstatic_assert(offsetof(SamplerDescriptor, lodMaxClamp) == offsetof(WGPUSamplerDescriptor, lodMaxClamp),\n        \"offsetof mismatch for SamplerDescriptor::lodMaxClamp\");\nstatic_assert(offsetof(SamplerDescriptor, compare) == offsetof(WGPUSamplerDescriptor, compare),\n        \"offsetof mismatch for SamplerDescriptor::compare\");\nstatic_assert(offsetof(SamplerDescriptor, maxAnisotropy) == offsetof(WGPUSamplerDescriptor, maxAnisotropy),\n        \"offsetof mismatch for SamplerDescriptor::maxAnisotropy\");\n\n// ShaderModuleDescriptor implementation\n\nShaderModuleDescriptor::operator const WGPUShaderModuleDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUShaderModuleDescriptor*>(this);\n}\n\nstatic_assert(sizeof(ShaderModuleDescriptor) == sizeof(WGPUShaderModuleDescriptor), \"sizeof mismatch for ShaderModuleDescriptor\");\nstatic_assert(alignof(ShaderModuleDescriptor) == alignof(WGPUShaderModuleDescriptor), \"alignof mismatch for ShaderModuleDescriptor\");\nstatic_assert(offsetof(ShaderModuleDescriptor, nextInChain) == offsetof(WGPUShaderModuleDescriptor, nextInChain),\n        \"offsetof mismatch for ShaderModuleDescriptor::nextInChain\");\nstatic_assert(offsetof(ShaderModuleDescriptor, label) == offsetof(WGPUShaderModuleDescriptor, label),\n        \"offsetof mismatch for ShaderModuleDescriptor::label\");\n\n// ShaderSourceWGSL implementation\nShaderSourceWGSL::ShaderSourceWGSL()\n  : ChainedStruct { nullptr, SType::ShaderSourceWGSL } {}\nstruct ShaderSourceWGSL::Init {\n    ChainedStruct * const nextInChain;\n    StringView code = {};\n};\nShaderSourceWGSL::ShaderSourceWGSL(ShaderSourceWGSL::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::ShaderSourceWGSL }, \n    code(std::move(init.code)){}\n\nShaderSourceWGSL::operator const WGPUShaderSourceWGSL&() const noexcept {\n    return *reinterpret_cast<const WGPUShaderSourceWGSL*>(this);\n}\n\nstatic_assert(sizeof(ShaderSourceWGSL) == sizeof(WGPUShaderSourceWGSL), \"sizeof mismatch for ShaderSourceWGSL\");\nstatic_assert(alignof(ShaderSourceWGSL) == alignof(WGPUShaderSourceWGSL), \"alignof mismatch for ShaderSourceWGSL\");\nstatic_assert(offsetof(ShaderSourceWGSL, code) == offsetof(WGPUShaderSourceWGSL, code),\n        \"offsetof mismatch for ShaderSourceWGSL::code\");\n\n// SharedBufferMemoryDescriptor implementation\n\nSharedBufferMemoryDescriptor::operator const WGPUSharedBufferMemoryDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedBufferMemoryDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedBufferMemoryDescriptor) == sizeof(WGPUSharedBufferMemoryDescriptor), \"sizeof mismatch for SharedBufferMemoryDescriptor\");\nstatic_assert(alignof(SharedBufferMemoryDescriptor) == alignof(WGPUSharedBufferMemoryDescriptor), \"alignof mismatch for SharedBufferMemoryDescriptor\");\nstatic_assert(offsetof(SharedBufferMemoryDescriptor, nextInChain) == offsetof(WGPUSharedBufferMemoryDescriptor, nextInChain),\n        \"offsetof mismatch for SharedBufferMemoryDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedBufferMemoryDescriptor, label) == offsetof(WGPUSharedBufferMemoryDescriptor, label),\n        \"offsetof mismatch for SharedBufferMemoryDescriptor::label\");\n\n// SharedFenceDescriptor implementation\n\nSharedFenceDescriptor::operator const WGPUSharedFenceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedFenceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedFenceDescriptor) == sizeof(WGPUSharedFenceDescriptor), \"sizeof mismatch for SharedFenceDescriptor\");\nstatic_assert(alignof(SharedFenceDescriptor) == alignof(WGPUSharedFenceDescriptor), \"alignof mismatch for SharedFenceDescriptor\");\nstatic_assert(offsetof(SharedFenceDescriptor, nextInChain) == offsetof(WGPUSharedFenceDescriptor, nextInChain),\n        \"offsetof mismatch for SharedFenceDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedFenceDescriptor, label) == offsetof(WGPUSharedFenceDescriptor, label),\n        \"offsetof mismatch for SharedFenceDescriptor::label\");\n\n// SharedTextureMemoryAHardwareBufferProperties implementation\nSharedTextureMemoryAHardwareBufferProperties::SharedTextureMemoryAHardwareBufferProperties()\n  : ChainedStructOut { nullptr, SType::SharedTextureMemoryAHardwareBufferProperties } {}\nstruct SharedTextureMemoryAHardwareBufferProperties::Init {\n    ChainedStructOut *  nextInChain;\n    YCbCrVkDescriptor yCbCrInfo = {};\n};\nSharedTextureMemoryAHardwareBufferProperties::SharedTextureMemoryAHardwareBufferProperties(SharedTextureMemoryAHardwareBufferProperties::Init&& init)\n  : ChainedStructOut { init.nextInChain, SType::SharedTextureMemoryAHardwareBufferProperties }, \n    yCbCrInfo(std::move(init.yCbCrInfo)){}\n\nSharedTextureMemoryAHardwareBufferProperties::operator const WGPUSharedTextureMemoryAHardwareBufferProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryAHardwareBufferProperties*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryAHardwareBufferProperties) == sizeof(WGPUSharedTextureMemoryAHardwareBufferProperties), \"sizeof mismatch for SharedTextureMemoryAHardwareBufferProperties\");\nstatic_assert(alignof(SharedTextureMemoryAHardwareBufferProperties) == alignof(WGPUSharedTextureMemoryAHardwareBufferProperties), \"alignof mismatch for SharedTextureMemoryAHardwareBufferProperties\");\nstatic_assert(offsetof(SharedTextureMemoryAHardwareBufferProperties, yCbCrInfo) == offsetof(WGPUSharedTextureMemoryAHardwareBufferProperties, yCbCrInfo),\n        \"offsetof mismatch for SharedTextureMemoryAHardwareBufferProperties::yCbCrInfo\");\n\n// SharedTextureMemoryDescriptor implementation\n\nSharedTextureMemoryDescriptor::operator const WGPUSharedTextureMemoryDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryDescriptor) == sizeof(WGPUSharedTextureMemoryDescriptor), \"sizeof mismatch for SharedTextureMemoryDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryDescriptor) == alignof(WGPUSharedTextureMemoryDescriptor), \"alignof mismatch for SharedTextureMemoryDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryDescriptor, nextInChain) == offsetof(WGPUSharedTextureMemoryDescriptor, nextInChain),\n        \"offsetof mismatch for SharedTextureMemoryDescriptor::nextInChain\");\nstatic_assert(offsetof(SharedTextureMemoryDescriptor, label) == offsetof(WGPUSharedTextureMemoryDescriptor, label),\n        \"offsetof mismatch for SharedTextureMemoryDescriptor::label\");\n\n// SharedTextureMemoryDmaBufDescriptor implementation\nSharedTextureMemoryDmaBufDescriptor::SharedTextureMemoryDmaBufDescriptor()\n  : ChainedStruct { nullptr, SType::SharedTextureMemoryDmaBufDescriptor } {}\nstruct SharedTextureMemoryDmaBufDescriptor::Init {\n    ChainedStruct * const nextInChain;\n    Extent3D size = {};\n    uint32_t drmFormat;\n    uint64_t drmModifier;\n    size_t planeCount;\n    SharedTextureMemoryDmaBufPlane const * planes;\n};\nSharedTextureMemoryDmaBufDescriptor::SharedTextureMemoryDmaBufDescriptor(SharedTextureMemoryDmaBufDescriptor::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::SharedTextureMemoryDmaBufDescriptor }, \n    size(std::move(init.size)), \n    drmFormat(std::move(init.drmFormat)), \n    drmModifier(std::move(init.drmModifier)), \n    planeCount(std::move(init.planeCount)), \n    planes(std::move(init.planes)){}\n\nSharedTextureMemoryDmaBufDescriptor::operator const WGPUSharedTextureMemoryDmaBufDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryDmaBufDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryDmaBufDescriptor) == sizeof(WGPUSharedTextureMemoryDmaBufDescriptor), \"sizeof mismatch for SharedTextureMemoryDmaBufDescriptor\");\nstatic_assert(alignof(SharedTextureMemoryDmaBufDescriptor) == alignof(WGPUSharedTextureMemoryDmaBufDescriptor), \"alignof mismatch for SharedTextureMemoryDmaBufDescriptor\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, size) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, size),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::size\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, drmFormat) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, drmFormat),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::drmFormat\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, drmModifier) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, drmModifier),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::drmModifier\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, planeCount) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, planeCount),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::planeCount\");\nstatic_assert(offsetof(SharedTextureMemoryDmaBufDescriptor, planes) == offsetof(WGPUSharedTextureMemoryDmaBufDescriptor, planes),\n        \"offsetof mismatch for SharedTextureMemoryDmaBufDescriptor::planes\");\n\n// SharedTextureMemoryProperties implementation\n\nSharedTextureMemoryProperties::operator const WGPUSharedTextureMemoryProperties&() const noexcept {\n    return *reinterpret_cast<const WGPUSharedTextureMemoryProperties*>(this);\n}\n\nstatic_assert(sizeof(SharedTextureMemoryProperties) == sizeof(WGPUSharedTextureMemoryProperties), \"sizeof mismatch for SharedTextureMemoryProperties\");\nstatic_assert(alignof(SharedTextureMemoryProperties) == alignof(WGPUSharedTextureMemoryProperties), \"alignof mismatch for SharedTextureMemoryProperties\");\nstatic_assert(offsetof(SharedTextureMemoryProperties, nextInChain) == offsetof(WGPUSharedTextureMemoryProperties, nextInChain),\n        \"offsetof mismatch for SharedTextureMemoryProperties::nextInChain\");\nstatic_assert(offsetof(SharedTextureMemoryProperties, usage) == offsetof(WGPUSharedTextureMemoryProperties, usage),\n        \"offsetof mismatch for SharedTextureMemoryProperties::usage\");\nstatic_assert(offsetof(SharedTextureMemoryProperties, size) == offsetof(WGPUSharedTextureMemoryProperties, size),\n        \"offsetof mismatch for SharedTextureMemoryProperties::size\");\nstatic_assert(offsetof(SharedTextureMemoryProperties, format) == offsetof(WGPUSharedTextureMemoryProperties, format),\n        \"offsetof mismatch for SharedTextureMemoryProperties::format\");\n\n// SupportedLimits implementation\n\nSupportedLimits::operator const WGPUSupportedLimits&() const noexcept {\n    return *reinterpret_cast<const WGPUSupportedLimits*>(this);\n}\n\nstatic_assert(sizeof(SupportedLimits) == sizeof(WGPUSupportedLimits), \"sizeof mismatch for SupportedLimits\");\nstatic_assert(alignof(SupportedLimits) == alignof(WGPUSupportedLimits), \"alignof mismatch for SupportedLimits\");\nstatic_assert(offsetof(SupportedLimits, nextInChain) == offsetof(WGPUSupportedLimits, nextInChain),\n        \"offsetof mismatch for SupportedLimits::nextInChain\");\nstatic_assert(offsetof(SupportedLimits, limits) == offsetof(WGPUSupportedLimits, limits),\n        \"offsetof mismatch for SupportedLimits::limits\");\n\n// SurfaceDescriptor implementation\n\nSurfaceDescriptor::operator const WGPUSurfaceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUSurfaceDescriptor*>(this);\n}\n\nstatic_assert(sizeof(SurfaceDescriptor) == sizeof(WGPUSurfaceDescriptor), \"sizeof mismatch for SurfaceDescriptor\");\nstatic_assert(alignof(SurfaceDescriptor) == alignof(WGPUSurfaceDescriptor), \"alignof mismatch for SurfaceDescriptor\");\nstatic_assert(offsetof(SurfaceDescriptor, nextInChain) == offsetof(WGPUSurfaceDescriptor, nextInChain),\n        \"offsetof mismatch for SurfaceDescriptor::nextInChain\");\nstatic_assert(offsetof(SurfaceDescriptor, label) == offsetof(WGPUSurfaceDescriptor, label),\n        \"offsetof mismatch for SurfaceDescriptor::label\");\n\n// TextureDescriptor implementation\n\nTextureDescriptor::operator const WGPUTextureDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureDescriptor*>(this);\n}\n\nstatic_assert(sizeof(TextureDescriptor) == sizeof(WGPUTextureDescriptor), \"sizeof mismatch for TextureDescriptor\");\nstatic_assert(alignof(TextureDescriptor) == alignof(WGPUTextureDescriptor), \"alignof mismatch for TextureDescriptor\");\nstatic_assert(offsetof(TextureDescriptor, nextInChain) == offsetof(WGPUTextureDescriptor, nextInChain),\n        \"offsetof mismatch for TextureDescriptor::nextInChain\");\nstatic_assert(offsetof(TextureDescriptor, label) == offsetof(WGPUTextureDescriptor, label),\n        \"offsetof mismatch for TextureDescriptor::label\");\nstatic_assert(offsetof(TextureDescriptor, usage) == offsetof(WGPUTextureDescriptor, usage),\n        \"offsetof mismatch for TextureDescriptor::usage\");\nstatic_assert(offsetof(TextureDescriptor, dimension) == offsetof(WGPUTextureDescriptor, dimension),\n        \"offsetof mismatch for TextureDescriptor::dimension\");\nstatic_assert(offsetof(TextureDescriptor, size) == offsetof(WGPUTextureDescriptor, size),\n        \"offsetof mismatch for TextureDescriptor::size\");\nstatic_assert(offsetof(TextureDescriptor, format) == offsetof(WGPUTextureDescriptor, format),\n        \"offsetof mismatch for TextureDescriptor::format\");\nstatic_assert(offsetof(TextureDescriptor, mipLevelCount) == offsetof(WGPUTextureDescriptor, mipLevelCount),\n        \"offsetof mismatch for TextureDescriptor::mipLevelCount\");\nstatic_assert(offsetof(TextureDescriptor, sampleCount) == offsetof(WGPUTextureDescriptor, sampleCount),\n        \"offsetof mismatch for TextureDescriptor::sampleCount\");\nstatic_assert(offsetof(TextureDescriptor, viewFormatCount) == offsetof(WGPUTextureDescriptor, viewFormatCount),\n        \"offsetof mismatch for TextureDescriptor::viewFormatCount\");\nstatic_assert(offsetof(TextureDescriptor, viewFormats) == offsetof(WGPUTextureDescriptor, viewFormats),\n        \"offsetof mismatch for TextureDescriptor::viewFormats\");\n\n// TextureViewDescriptor implementation\n\nTextureViewDescriptor::operator const WGPUTextureViewDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUTextureViewDescriptor*>(this);\n}\n\nstatic_assert(sizeof(TextureViewDescriptor) == sizeof(WGPUTextureViewDescriptor), \"sizeof mismatch for TextureViewDescriptor\");\nstatic_assert(alignof(TextureViewDescriptor) == alignof(WGPUTextureViewDescriptor), \"alignof mismatch for TextureViewDescriptor\");\nstatic_assert(offsetof(TextureViewDescriptor, nextInChain) == offsetof(WGPUTextureViewDescriptor, nextInChain),\n        \"offsetof mismatch for TextureViewDescriptor::nextInChain\");\nstatic_assert(offsetof(TextureViewDescriptor, label) == offsetof(WGPUTextureViewDescriptor, label),\n        \"offsetof mismatch for TextureViewDescriptor::label\");\nstatic_assert(offsetof(TextureViewDescriptor, format) == offsetof(WGPUTextureViewDescriptor, format),\n        \"offsetof mismatch for TextureViewDescriptor::format\");\nstatic_assert(offsetof(TextureViewDescriptor, dimension) == offsetof(WGPUTextureViewDescriptor, dimension),\n        \"offsetof mismatch for TextureViewDescriptor::dimension\");\nstatic_assert(offsetof(TextureViewDescriptor, baseMipLevel) == offsetof(WGPUTextureViewDescriptor, baseMipLevel),\n        \"offsetof mismatch for TextureViewDescriptor::baseMipLevel\");\nstatic_assert(offsetof(TextureViewDescriptor, mipLevelCount) == offsetof(WGPUTextureViewDescriptor, mipLevelCount),\n        \"offsetof mismatch for TextureViewDescriptor::mipLevelCount\");\nstatic_assert(offsetof(TextureViewDescriptor, baseArrayLayer) == offsetof(WGPUTextureViewDescriptor, baseArrayLayer),\n        \"offsetof mismatch for TextureViewDescriptor::baseArrayLayer\");\nstatic_assert(offsetof(TextureViewDescriptor, arrayLayerCount) == offsetof(WGPUTextureViewDescriptor, arrayLayerCount),\n        \"offsetof mismatch for TextureViewDescriptor::arrayLayerCount\");\nstatic_assert(offsetof(TextureViewDescriptor, aspect) == offsetof(WGPUTextureViewDescriptor, aspect),\n        \"offsetof mismatch for TextureViewDescriptor::aspect\");\nstatic_assert(offsetof(TextureViewDescriptor, usage) == offsetof(WGPUTextureViewDescriptor, usage),\n        \"offsetof mismatch for TextureViewDescriptor::usage\");\n\n// VertexBufferLayout implementation\n\nVertexBufferLayout::operator const WGPUVertexBufferLayout&() const noexcept {\n    return *reinterpret_cast<const WGPUVertexBufferLayout*>(this);\n}\n\nstatic_assert(sizeof(VertexBufferLayout) == sizeof(WGPUVertexBufferLayout), \"sizeof mismatch for VertexBufferLayout\");\nstatic_assert(alignof(VertexBufferLayout) == alignof(WGPUVertexBufferLayout), \"alignof mismatch for VertexBufferLayout\");\nstatic_assert(offsetof(VertexBufferLayout, arrayStride) == offsetof(WGPUVertexBufferLayout, arrayStride),\n        \"offsetof mismatch for VertexBufferLayout::arrayStride\");\nstatic_assert(offsetof(VertexBufferLayout, stepMode) == offsetof(WGPUVertexBufferLayout, stepMode),\n        \"offsetof mismatch for VertexBufferLayout::stepMode\");\nstatic_assert(offsetof(VertexBufferLayout, attributeCount) == offsetof(WGPUVertexBufferLayout, attributeCount),\n        \"offsetof mismatch for VertexBufferLayout::attributeCount\");\nstatic_assert(offsetof(VertexBufferLayout, attributes) == offsetof(WGPUVertexBufferLayout, attributes),\n        \"offsetof mismatch for VertexBufferLayout::attributes\");\n\n// BindGroupLayoutDescriptor implementation\n\nBindGroupLayoutDescriptor::operator const WGPUBindGroupLayoutDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUBindGroupLayoutDescriptor*>(this);\n}\n\nstatic_assert(sizeof(BindGroupLayoutDescriptor) == sizeof(WGPUBindGroupLayoutDescriptor), \"sizeof mismatch for BindGroupLayoutDescriptor\");\nstatic_assert(alignof(BindGroupLayoutDescriptor) == alignof(WGPUBindGroupLayoutDescriptor), \"alignof mismatch for BindGroupLayoutDescriptor\");\nstatic_assert(offsetof(BindGroupLayoutDescriptor, nextInChain) == offsetof(WGPUBindGroupLayoutDescriptor, nextInChain),\n        \"offsetof mismatch for BindGroupLayoutDescriptor::nextInChain\");\nstatic_assert(offsetof(BindGroupLayoutDescriptor, label) == offsetof(WGPUBindGroupLayoutDescriptor, label),\n        \"offsetof mismatch for BindGroupLayoutDescriptor::label\");\nstatic_assert(offsetof(BindGroupLayoutDescriptor, entryCount) == offsetof(WGPUBindGroupLayoutDescriptor, entryCount),\n        \"offsetof mismatch for BindGroupLayoutDescriptor::entryCount\");\nstatic_assert(offsetof(BindGroupLayoutDescriptor, entries) == offsetof(WGPUBindGroupLayoutDescriptor, entries),\n        \"offsetof mismatch for BindGroupLayoutDescriptor::entries\");\n\n// ColorTargetState implementation\n\nColorTargetState::operator const WGPUColorTargetState&() const noexcept {\n    return *reinterpret_cast<const WGPUColorTargetState*>(this);\n}\n\nstatic_assert(sizeof(ColorTargetState) == sizeof(WGPUColorTargetState), \"sizeof mismatch for ColorTargetState\");\nstatic_assert(alignof(ColorTargetState) == alignof(WGPUColorTargetState), \"alignof mismatch for ColorTargetState\");\nstatic_assert(offsetof(ColorTargetState, nextInChain) == offsetof(WGPUColorTargetState, nextInChain),\n        \"offsetof mismatch for ColorTargetState::nextInChain\");\nstatic_assert(offsetof(ColorTargetState, format) == offsetof(WGPUColorTargetState, format),\n        \"offsetof mismatch for ColorTargetState::format\");\nstatic_assert(offsetof(ColorTargetState, blend) == offsetof(WGPUColorTargetState, blend),\n        \"offsetof mismatch for ColorTargetState::blend\");\nstatic_assert(offsetof(ColorTargetState, writeMask) == offsetof(WGPUColorTargetState, writeMask),\n        \"offsetof mismatch for ColorTargetState::writeMask\");\n\n// CompilationInfo implementation\n\nCompilationInfo::operator const WGPUCompilationInfo&() const noexcept {\n    return *reinterpret_cast<const WGPUCompilationInfo*>(this);\n}\n\nstatic_assert(sizeof(CompilationInfo) == sizeof(WGPUCompilationInfo), \"sizeof mismatch for CompilationInfo\");\nstatic_assert(alignof(CompilationInfo) == alignof(WGPUCompilationInfo), \"alignof mismatch for CompilationInfo\");\nstatic_assert(offsetof(CompilationInfo, nextInChain) == offsetof(WGPUCompilationInfo, nextInChain),\n        \"offsetof mismatch for CompilationInfo::nextInChain\");\nstatic_assert(offsetof(CompilationInfo, messageCount) == offsetof(WGPUCompilationInfo, messageCount),\n        \"offsetof mismatch for CompilationInfo::messageCount\");\nstatic_assert(offsetof(CompilationInfo, messages) == offsetof(WGPUCompilationInfo, messages),\n        \"offsetof mismatch for CompilationInfo::messages\");\n\n// ComputeState implementation\n\nComputeState::operator const WGPUComputeState&() const noexcept {\n    return *reinterpret_cast<const WGPUComputeState*>(this);\n}\n\nstatic_assert(sizeof(ComputeState) == sizeof(WGPUComputeState), \"sizeof mismatch for ComputeState\");\nstatic_assert(alignof(ComputeState) == alignof(WGPUComputeState), \"alignof mismatch for ComputeState\");\nstatic_assert(offsetof(ComputeState, nextInChain) == offsetof(WGPUComputeState, nextInChain),\n        \"offsetof mismatch for ComputeState::nextInChain\");\nstatic_assert(offsetof(ComputeState, module) == offsetof(WGPUComputeState, module),\n        \"offsetof mismatch for ComputeState::module\");\nstatic_assert(offsetof(ComputeState, entryPoint) == offsetof(WGPUComputeState, entryPoint),\n        \"offsetof mismatch for ComputeState::entryPoint\");\nstatic_assert(offsetof(ComputeState, constantCount) == offsetof(WGPUComputeState, constantCount),\n        \"offsetof mismatch for ComputeState::constantCount\");\nstatic_assert(offsetof(ComputeState, constants) == offsetof(WGPUComputeState, constants),\n        \"offsetof mismatch for ComputeState::constants\");\n\n// RenderPassDescriptor implementation\n\nRenderPassDescriptor::operator const WGPURenderPassDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassDescriptor*>(this);\n}\n\nstatic_assert(sizeof(RenderPassDescriptor) == sizeof(WGPURenderPassDescriptor), \"sizeof mismatch for RenderPassDescriptor\");\nstatic_assert(alignof(RenderPassDescriptor) == alignof(WGPURenderPassDescriptor), \"alignof mismatch for RenderPassDescriptor\");\nstatic_assert(offsetof(RenderPassDescriptor, nextInChain) == offsetof(WGPURenderPassDescriptor, nextInChain),\n        \"offsetof mismatch for RenderPassDescriptor::nextInChain\");\nstatic_assert(offsetof(RenderPassDescriptor, label) == offsetof(WGPURenderPassDescriptor, label),\n        \"offsetof mismatch for RenderPassDescriptor::label\");\nstatic_assert(offsetof(RenderPassDescriptor, colorAttachmentCount) == offsetof(WGPURenderPassDescriptor, colorAttachmentCount),\n        \"offsetof mismatch for RenderPassDescriptor::colorAttachmentCount\");\nstatic_assert(offsetof(RenderPassDescriptor, colorAttachments) == offsetof(WGPURenderPassDescriptor, colorAttachments),\n        \"offsetof mismatch for RenderPassDescriptor::colorAttachments\");\nstatic_assert(offsetof(RenderPassDescriptor, depthStencilAttachment) == offsetof(WGPURenderPassDescriptor, depthStencilAttachment),\n        \"offsetof mismatch for RenderPassDescriptor::depthStencilAttachment\");\nstatic_assert(offsetof(RenderPassDescriptor, occlusionQuerySet) == offsetof(WGPURenderPassDescriptor, occlusionQuerySet),\n        \"offsetof mismatch for RenderPassDescriptor::occlusionQuerySet\");\nstatic_assert(offsetof(RenderPassDescriptor, timestampWrites) == offsetof(WGPURenderPassDescriptor, timestampWrites),\n        \"offsetof mismatch for RenderPassDescriptor::timestampWrites\");\n\n// RenderPassPixelLocalStorage implementation\nRenderPassPixelLocalStorage::RenderPassPixelLocalStorage()\n  : ChainedStruct { nullptr, SType::RenderPassPixelLocalStorage } {}\nstruct RenderPassPixelLocalStorage::Init {\n    ChainedStruct * const nextInChain;\n    uint64_t totalPixelLocalStorageSize;\n    size_t storageAttachmentCount = 0;\n    RenderPassStorageAttachment const * storageAttachments;\n};\nRenderPassPixelLocalStorage::RenderPassPixelLocalStorage(RenderPassPixelLocalStorage::Init&& init)\n  : ChainedStruct { init.nextInChain, SType::RenderPassPixelLocalStorage }, \n    totalPixelLocalStorageSize(std::move(init.totalPixelLocalStorageSize)), \n    storageAttachmentCount(std::move(init.storageAttachmentCount)), \n    storageAttachments(std::move(init.storageAttachments)){}\n\nRenderPassPixelLocalStorage::operator const WGPURenderPassPixelLocalStorage&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPassPixelLocalStorage*>(this);\n}\n\nstatic_assert(sizeof(RenderPassPixelLocalStorage) == sizeof(WGPURenderPassPixelLocalStorage), \"sizeof mismatch for RenderPassPixelLocalStorage\");\nstatic_assert(alignof(RenderPassPixelLocalStorage) == alignof(WGPURenderPassPixelLocalStorage), \"alignof mismatch for RenderPassPixelLocalStorage\");\nstatic_assert(offsetof(RenderPassPixelLocalStorage, totalPixelLocalStorageSize) == offsetof(WGPURenderPassPixelLocalStorage, totalPixelLocalStorageSize),\n        \"offsetof mismatch for RenderPassPixelLocalStorage::totalPixelLocalStorageSize\");\nstatic_assert(offsetof(RenderPassPixelLocalStorage, storageAttachmentCount) == offsetof(WGPURenderPassPixelLocalStorage, storageAttachmentCount),\n        \"offsetof mismatch for RenderPassPixelLocalStorage::storageAttachmentCount\");\nstatic_assert(offsetof(RenderPassPixelLocalStorage, storageAttachments) == offsetof(WGPURenderPassPixelLocalStorage, storageAttachments),\n        \"offsetof mismatch for RenderPassPixelLocalStorage::storageAttachments\");\n\n// VertexState implementation\n\nVertexState::operator const WGPUVertexState&() const noexcept {\n    return *reinterpret_cast<const WGPUVertexState*>(this);\n}\n\nstatic_assert(sizeof(VertexState) == sizeof(WGPUVertexState), \"sizeof mismatch for VertexState\");\nstatic_assert(alignof(VertexState) == alignof(WGPUVertexState), \"alignof mismatch for VertexState\");\nstatic_assert(offsetof(VertexState, nextInChain) == offsetof(WGPUVertexState, nextInChain),\n        \"offsetof mismatch for VertexState::nextInChain\");\nstatic_assert(offsetof(VertexState, module) == offsetof(WGPUVertexState, module),\n        \"offsetof mismatch for VertexState::module\");\nstatic_assert(offsetof(VertexState, entryPoint) == offsetof(WGPUVertexState, entryPoint),\n        \"offsetof mismatch for VertexState::entryPoint\");\nstatic_assert(offsetof(VertexState, constantCount) == offsetof(WGPUVertexState, constantCount),\n        \"offsetof mismatch for VertexState::constantCount\");\nstatic_assert(offsetof(VertexState, constants) == offsetof(WGPUVertexState, constants),\n        \"offsetof mismatch for VertexState::constants\");\nstatic_assert(offsetof(VertexState, bufferCount) == offsetof(WGPUVertexState, bufferCount),\n        \"offsetof mismatch for VertexState::bufferCount\");\nstatic_assert(offsetof(VertexState, buffers) == offsetof(WGPUVertexState, buffers),\n        \"offsetof mismatch for VertexState::buffers\");\n\n// ComputePipelineDescriptor implementation\n\nComputePipelineDescriptor::operator const WGPUComputePipelineDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUComputePipelineDescriptor*>(this);\n}\n\nstatic_assert(sizeof(ComputePipelineDescriptor) == sizeof(WGPUComputePipelineDescriptor), \"sizeof mismatch for ComputePipelineDescriptor\");\nstatic_assert(alignof(ComputePipelineDescriptor) == alignof(WGPUComputePipelineDescriptor), \"alignof mismatch for ComputePipelineDescriptor\");\nstatic_assert(offsetof(ComputePipelineDescriptor, nextInChain) == offsetof(WGPUComputePipelineDescriptor, nextInChain),\n        \"offsetof mismatch for ComputePipelineDescriptor::nextInChain\");\nstatic_assert(offsetof(ComputePipelineDescriptor, label) == offsetof(WGPUComputePipelineDescriptor, label),\n        \"offsetof mismatch for ComputePipelineDescriptor::label\");\nstatic_assert(offsetof(ComputePipelineDescriptor, layout) == offsetof(WGPUComputePipelineDescriptor, layout),\n        \"offsetof mismatch for ComputePipelineDescriptor::layout\");\nstatic_assert(offsetof(ComputePipelineDescriptor, compute) == offsetof(WGPUComputePipelineDescriptor, compute),\n        \"offsetof mismatch for ComputePipelineDescriptor::compute\");\n\n// FragmentState implementation\n\nFragmentState::operator const WGPUFragmentState&() const noexcept {\n    return *reinterpret_cast<const WGPUFragmentState*>(this);\n}\n\nstatic_assert(sizeof(FragmentState) == sizeof(WGPUFragmentState), \"sizeof mismatch for FragmentState\");\nstatic_assert(alignof(FragmentState) == alignof(WGPUFragmentState), \"alignof mismatch for FragmentState\");\nstatic_assert(offsetof(FragmentState, nextInChain) == offsetof(WGPUFragmentState, nextInChain),\n        \"offsetof mismatch for FragmentState::nextInChain\");\nstatic_assert(offsetof(FragmentState, module) == offsetof(WGPUFragmentState, module),\n        \"offsetof mismatch for FragmentState::module\");\nstatic_assert(offsetof(FragmentState, entryPoint) == offsetof(WGPUFragmentState, entryPoint),\n        \"offsetof mismatch for FragmentState::entryPoint\");\nstatic_assert(offsetof(FragmentState, constantCount) == offsetof(WGPUFragmentState, constantCount),\n        \"offsetof mismatch for FragmentState::constantCount\");\nstatic_assert(offsetof(FragmentState, constants) == offsetof(WGPUFragmentState, constants),\n        \"offsetof mismatch for FragmentState::constants\");\nstatic_assert(offsetof(FragmentState, targetCount) == offsetof(WGPUFragmentState, targetCount),\n        \"offsetof mismatch for FragmentState::targetCount\");\nstatic_assert(offsetof(FragmentState, targets) == offsetof(WGPUFragmentState, targets),\n        \"offsetof mismatch for FragmentState::targets\");\n\n// RenderPipelineDescriptor implementation\n\nRenderPipelineDescriptor::operator const WGPURenderPipelineDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPURenderPipelineDescriptor*>(this);\n}\n\nstatic_assert(sizeof(RenderPipelineDescriptor) == sizeof(WGPURenderPipelineDescriptor), \"sizeof mismatch for RenderPipelineDescriptor\");\nstatic_assert(alignof(RenderPipelineDescriptor) == alignof(WGPURenderPipelineDescriptor), \"alignof mismatch for RenderPipelineDescriptor\");\nstatic_assert(offsetof(RenderPipelineDescriptor, nextInChain) == offsetof(WGPURenderPipelineDescriptor, nextInChain),\n        \"offsetof mismatch for RenderPipelineDescriptor::nextInChain\");\nstatic_assert(offsetof(RenderPipelineDescriptor, label) == offsetof(WGPURenderPipelineDescriptor, label),\n        \"offsetof mismatch for RenderPipelineDescriptor::label\");\nstatic_assert(offsetof(RenderPipelineDescriptor, layout) == offsetof(WGPURenderPipelineDescriptor, layout),\n        \"offsetof mismatch for RenderPipelineDescriptor::layout\");\nstatic_assert(offsetof(RenderPipelineDescriptor, vertex) == offsetof(WGPURenderPipelineDescriptor, vertex),\n        \"offsetof mismatch for RenderPipelineDescriptor::vertex\");\nstatic_assert(offsetof(RenderPipelineDescriptor, primitive) == offsetof(WGPURenderPipelineDescriptor, primitive),\n        \"offsetof mismatch for RenderPipelineDescriptor::primitive\");\nstatic_assert(offsetof(RenderPipelineDescriptor, depthStencil) == offsetof(WGPURenderPipelineDescriptor, depthStencil),\n        \"offsetof mismatch for RenderPipelineDescriptor::depthStencil\");\nstatic_assert(offsetof(RenderPipelineDescriptor, multisample) == offsetof(WGPURenderPipelineDescriptor, multisample),\n        \"offsetof mismatch for RenderPipelineDescriptor::multisample\");\nstatic_assert(offsetof(RenderPipelineDescriptor, fragment) == offsetof(WGPURenderPipelineDescriptor, fragment),\n        \"offsetof mismatch for RenderPipelineDescriptor::fragment\");\n\n// DeviceDescriptor implementation\n\nDeviceDescriptor::operator const WGPUDeviceDescriptor&() const noexcept {\n    return *reinterpret_cast<const WGPUDeviceDescriptor*>(this);\n}\n\nDeviceDescriptor::DeviceDescriptor() : detail::DeviceDescriptor {} {\n    static_assert(offsetof(DeviceDescriptor, nextInChain) == offsetof(WGPUDeviceDescriptor, nextInChain),\n                \"offsetof mismatch for DeviceDescriptor::nextInChain\");\n    static_assert(offsetof(DeviceDescriptor, label) == offsetof(WGPUDeviceDescriptor, label),\n            \"offsetof mismatch for DeviceDescriptor::label\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeatureCount) == offsetof(WGPUDeviceDescriptor, requiredFeatureCount),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeatureCount\");\n    static_assert(offsetof(DeviceDescriptor, requiredFeatures) == offsetof(WGPUDeviceDescriptor, requiredFeatures),\n            \"offsetof mismatch for DeviceDescriptor::requiredFeatures\");\n    static_assert(offsetof(DeviceDescriptor, requiredLimits) == offsetof(WGPUDeviceDescriptor, requiredLimits),\n            \"offsetof mismatch for DeviceDescriptor::requiredLimits\");\n    static_assert(offsetof(DeviceDescriptor, defaultQueue) == offsetof(WGPUDeviceDescriptor, defaultQueue),\n            \"offsetof mismatch for DeviceDescriptor::defaultQueue\");\n    static_assert(offsetof(DeviceDescriptor, deviceLostCallbackInfo2) == offsetof(WGPUDeviceDescriptor, deviceLostCallbackInfo2),\n            \"offsetof mismatch for DeviceDescriptor::deviceLostCallbackInfo2\");\n    static_assert(offsetof(DeviceDescriptor, uncapturedErrorCallbackInfo2) == offsetof(WGPUDeviceDescriptor, uncapturedErrorCallbackInfo2),\n            \"offsetof mismatch for DeviceDescriptor::uncapturedErrorCallbackInfo2\");\n}\n\nstruct DeviceDescriptor::Init {\n    ChainedStruct const * nextInChain;\n    StringView label = {};\n    size_t requiredFeatureCount = 0;\n    FeatureName const * requiredFeatures = nullptr;\n    RequiredLimits const * requiredLimits = nullptr;\n    QueueDescriptor defaultQueue = {};\n};\n\nDeviceDescriptor::DeviceDescriptor(DeviceDescriptor::Init&& init) : detail::DeviceDescriptor {\n    init.nextInChain, \n    std::move(init.label), \n    std::move(init.requiredFeatureCount), \n    std::move(init.requiredFeatures), \n    std::move(init.requiredLimits), \n    std::move(init.defaultQueue)} {}\n\nstatic_assert(sizeof(DeviceDescriptor) == sizeof(WGPUDeviceDescriptor), \"sizeof mismatch for DeviceDescriptor\");\nstatic_assert(alignof(DeviceDescriptor) == alignof(WGPUDeviceDescriptor), \"alignof mismatch for DeviceDescriptor\");\n\ntemplate <typename F, typename T, typename Cb, typename CbChar, typename>\nvoid DeviceDescriptor::SetDeviceLostCallback(CallbackMode callbackMode, F callback, T userdata) {\n    assert(deviceLostCallbackInfo2.callback == nullptr);\n\n    deviceLostCallbackInfo2.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        deviceLostCallbackInfo2.callback = [](WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<DeviceLostReason>(reason), message, static_cast<T>(userdata_param));\n            apiDevice.MoveToCHandle();\n        };\n    } else {\n        deviceLostCallbackInfo2.callback = [](WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<DeviceLostReason>(reason), detail::StringViewAdapter(message), static_cast<T>(userdata_param));\n            apiDevice.MoveToCHandle();\n        };\n    }\n    deviceLostCallbackInfo2.userdata1 = reinterpret_cast<void*>(+callback);\n    deviceLostCallbackInfo2.userdata2 = reinterpret_cast<void*>(userdata);\n}\n\ntemplate <typename L, typename Cb, typename CbChar, typename>\nvoid DeviceDescriptor::SetDeviceLostCallback(CallbackMode callbackMode, L callback) {\n    assert(deviceLostCallbackInfo2.callback == nullptr);\n    using F = DeviceLostCallback2<void>;\n\n    deviceLostCallbackInfo2.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        deviceLostCallbackInfo2.callback = [](WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<DeviceLostReason>(reason), message);\n            apiDevice.MoveToCHandle();\n        };\n        deviceLostCallbackInfo2.userdata1 = reinterpret_cast<void*>(+callback);\n        deviceLostCallbackInfo2.userdata2 = nullptr;\n    } else {\n        auto* lambda = new L(std::move(callback));\n        deviceLostCallbackInfo2.callback = [](WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*the_lambda)(apiDevice, static_cast<DeviceLostReason>(reason), detail::StringViewAdapter(message));\n            apiDevice.MoveToCHandle();\n        };\n        deviceLostCallbackInfo2.userdata1 = reinterpret_cast<void*>(lambda);\n        deviceLostCallbackInfo2.userdata2 = nullptr;\n    }\n}\n\ntemplate <typename F, typename T, typename Cb, typename CbChar, typename>\nvoid DeviceDescriptor::SetUncapturedErrorCallback(F callback, T userdata) {\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        uncapturedErrorCallbackInfo2.callback = [](WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<ErrorType>(type), message, static_cast<T>(userdata_param));\n            apiDevice.MoveToCHandle();\n        };\n    } else {\n        uncapturedErrorCallbackInfo2.callback = [](WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<ErrorType>(type), detail::StringViewAdapter(message), static_cast<T>(userdata_param));\n            apiDevice.MoveToCHandle();\n        };\n    }\n    uncapturedErrorCallbackInfo2.userdata1 = reinterpret_cast<void*>(+callback);\n    uncapturedErrorCallbackInfo2.userdata2 = reinterpret_cast<void*>(userdata);\n}\n\ntemplate <typename L, typename Cb, typename CbChar, typename>\nvoid DeviceDescriptor::SetUncapturedErrorCallback(L callback) {\n    using F = UncapturedErrorCallback<void>;\n    using FChar = void (const Device& device, ErrorType type, const char* message);\n    static_assert(std::is_convertible_v<L, F*> || std::is_convertible_v<L, FChar*>, \"Uncaptured error callback cannot be a binding lambda\");\n\n    if constexpr (std::is_convertible_v<L, F*>) {\n        uncapturedErrorCallbackInfo2.callback = [](WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<ErrorType>(type), message);\n            apiDevice.MoveToCHandle();\n        };\n    } else {\n        uncapturedErrorCallbackInfo2.callback = [](WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<FChar*>(callback_param);\n            // We manually acquire and release the device to avoid changing any ref counts.\n            auto apiDevice = Device::Acquire(*device);\n            (*cb)(apiDevice, static_cast<ErrorType>(type), detail::StringViewAdapter(message));\n            apiDevice.MoveToCHandle();\n        };\n    }\n    uncapturedErrorCallbackInfo2.userdata1 = reinterpret_cast<void*>(+callback);\n    uncapturedErrorCallbackInfo2.userdata2 = nullptr;\n}\n\n#if defined(__GNUC__) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n// Adapter implementation\n\nDevice Adapter::CreateDevice(DeviceDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientAdapterCreateDevice(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(descriptor));\n    return Device::Acquire(result);\n}\nvoid Adapter::GetFeatures(SupportedFeatures * features) const {\n    *features = SupportedFeatures();\n    wgpuDawnWireClientAdapterGetFeatures(Get(), reinterpret_cast<WGPUSupportedFeatures * >(features));\n}\nConvertibleStatus Adapter::GetFormatCapabilities(TextureFormat format, FormatCapabilities * capabilities) const {\n    auto result = wgpuDawnWireClientAdapterGetFormatCapabilities(Get(), static_cast<WGPUTextureFormat>(format), reinterpret_cast<WGPUFormatCapabilities * >(capabilities));\n    return static_cast<Status>(result);\n}\nConvertibleStatus Adapter::GetInfo(AdapterInfo * info) const {\n    *info = AdapterInfo();\n    auto result = wgpuDawnWireClientAdapterGetInfo(Get(), reinterpret_cast<WGPUAdapterInfo * >(info));\n    return static_cast<Status>(result);\n}\nInstance Adapter::GetInstance() const {\n    auto result = wgpuDawnWireClientAdapterGetInstance(Get());\n    return Instance::Acquire(result);\n}\nConvertibleStatus Adapter::GetLimits(SupportedLimits * limits) const {\n    auto result = wgpuDawnWireClientAdapterGetLimits(Get(), reinterpret_cast<WGPUSupportedLimits * >(limits));\n    return static_cast<Status>(result);\n}\nBool Adapter::HasFeature(FeatureName feature) const {\n    auto result = wgpuDawnWireClientAdapterHasFeature(Get(), static_cast<WGPUFeatureName>(feature));\n    return result;\n}\nvoid Adapter::RequestDevice(DeviceDescriptor const * descriptor, RequestDeviceCallback callback, void * userdata) const {\n    wgpuDawnWireClientAdapterRequestDevice(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(descriptor), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Adapter::RequestDevice(DeviceDescriptor const * options, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPURequestDeviceCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<RequestDeviceStatus>(status), Device::Acquire(device), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<RequestDeviceStatus>(status), Device::Acquire(device), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDawnWireClientAdapterRequestDevice2(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(options), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Adapter::RequestDevice(DeviceDescriptor const * options, CallbackMode callbackMode, L callback) const {\n    using F = RequestDeviceCallback2<void>;\n\n    WGPURequestDeviceCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<RequestDeviceStatus>(status), Device::Acquire(device), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientAdapterRequestDevice2(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(options), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<RequestDeviceStatus>(status), Device::Acquire(device), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientAdapterRequestDevice2(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(options), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Adapter::RequestDevice(DeviceDescriptor const * options, RequestDeviceCallbackInfo callbackInfo) const {\n    auto result = wgpuDawnWireClientAdapterRequestDeviceF(Get(), reinterpret_cast<WGPUDeviceDescriptor const * >(options), *reinterpret_cast<WGPURequestDeviceCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\n\n\nvoid Adapter::WGPUAddRef(WGPUAdapter handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientAdapterAddRef(handle);\n    }\n}\nvoid Adapter::WGPURelease(WGPUAdapter handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientAdapterRelease(handle);\n    }\n}\nstatic_assert(sizeof(Adapter) == sizeof(WGPUAdapter), \"sizeof mismatch for Adapter\");\nstatic_assert(alignof(Adapter) == alignof(WGPUAdapter), \"alignof mismatch for Adapter\");\n\n// BindGroup implementation\n\nvoid BindGroup::SetLabel(StringView label) const {\n    wgpuDawnWireClientBindGroupSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid BindGroup::WGPUAddRef(WGPUBindGroup handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientBindGroupAddRef(handle);\n    }\n}\nvoid BindGroup::WGPURelease(WGPUBindGroup handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientBindGroupRelease(handle);\n    }\n}\nstatic_assert(sizeof(BindGroup) == sizeof(WGPUBindGroup), \"sizeof mismatch for BindGroup\");\nstatic_assert(alignof(BindGroup) == alignof(WGPUBindGroup), \"alignof mismatch for BindGroup\");\n\n// BindGroupLayout implementation\n\nvoid BindGroupLayout::SetLabel(StringView label) const {\n    wgpuDawnWireClientBindGroupLayoutSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid BindGroupLayout::WGPUAddRef(WGPUBindGroupLayout handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientBindGroupLayoutAddRef(handle);\n    }\n}\nvoid BindGroupLayout::WGPURelease(WGPUBindGroupLayout handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientBindGroupLayoutRelease(handle);\n    }\n}\nstatic_assert(sizeof(BindGroupLayout) == sizeof(WGPUBindGroupLayout), \"sizeof mismatch for BindGroupLayout\");\nstatic_assert(alignof(BindGroupLayout) == alignof(WGPUBindGroupLayout), \"alignof mismatch for BindGroupLayout\");\n\n// Buffer implementation\n\nvoid Buffer::Destroy() const {\n    wgpuDawnWireClientBufferDestroy(Get());\n}\nvoid const * Buffer::GetConstMappedRange(size_t offset, size_t size) const {\n    auto result = wgpuDawnWireClientBufferGetConstMappedRange(Get(), offset, size);\n    return result;\n}\nBufferMapState Buffer::GetMapState() const {\n    auto result = wgpuDawnWireClientBufferGetMapState(Get());\n    return static_cast<BufferMapState>(result);\n}\nvoid * Buffer::GetMappedRange(size_t offset, size_t size) const {\n    auto result = wgpuDawnWireClientBufferGetMappedRange(Get(), offset, size);\n    return result;\n}\nuint64_t Buffer::GetSize() const {\n    auto result = wgpuDawnWireClientBufferGetSize(Get());\n    return result;\n}\nBufferUsage Buffer::GetUsage() const {\n    auto result = wgpuDawnWireClientBufferGetUsage(Get());\n    return static_cast<BufferUsage>(result);\n}\nvoid Buffer::MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallback callback, void * userdata) const {\n    wgpuDawnWireClientBufferMapAsync(Get(), static_cast<WGPUMapMode>(mode), offset, size, callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Buffer::MapAsync(MapMode mode, size_t offset, size_t size, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUBufferMapCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUMapAsyncStatus status, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<MapAsyncStatus>(status), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUMapAsyncStatus status, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<MapAsyncStatus>(status), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDawnWireClientBufferMapAsync2(Get(), static_cast<WGPUMapMode>(mode), offset, size, callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Buffer::MapAsync(MapMode mode, size_t offset, size_t size, CallbackMode callbackMode, L callback) const {\n    using F = BufferMapCallback2<void>;\n\n    WGPUBufferMapCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUMapAsyncStatus status, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<MapAsyncStatus>(status), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientBufferMapAsync2(Get(), static_cast<WGPUMapMode>(mode), offset, size, callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUMapAsyncStatus status, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<MapAsyncStatus>(status), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientBufferMapAsync2(Get(), static_cast<WGPUMapMode>(mode), offset, size, callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Buffer::MapAsync(MapMode mode, size_t offset, size_t size, BufferMapCallbackInfo callbackInfo) const {\n    auto result = wgpuDawnWireClientBufferMapAsyncF(Get(), static_cast<WGPUMapMode>(mode), offset, size, *reinterpret_cast<WGPUBufferMapCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nvoid Buffer::SetLabel(StringView label) const {\n    wgpuDawnWireClientBufferSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid Buffer::Unmap() const {\n    wgpuDawnWireClientBufferUnmap(Get());\n}\n\n\nvoid Buffer::WGPUAddRef(WGPUBuffer handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientBufferAddRef(handle);\n    }\n}\nvoid Buffer::WGPURelease(WGPUBuffer handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientBufferRelease(handle);\n    }\n}\nstatic_assert(sizeof(Buffer) == sizeof(WGPUBuffer), \"sizeof mismatch for Buffer\");\nstatic_assert(alignof(Buffer) == alignof(WGPUBuffer), \"alignof mismatch for Buffer\");\n\n// CommandBuffer implementation\n\nvoid CommandBuffer::SetLabel(StringView label) const {\n    wgpuDawnWireClientCommandBufferSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid CommandBuffer::WGPUAddRef(WGPUCommandBuffer handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientCommandBufferAddRef(handle);\n    }\n}\nvoid CommandBuffer::WGPURelease(WGPUCommandBuffer handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientCommandBufferRelease(handle);\n    }\n}\nstatic_assert(sizeof(CommandBuffer) == sizeof(WGPUCommandBuffer), \"sizeof mismatch for CommandBuffer\");\nstatic_assert(alignof(CommandBuffer) == alignof(WGPUCommandBuffer), \"alignof mismatch for CommandBuffer\");\n\n// CommandEncoder implementation\n\nComputePassEncoder CommandEncoder::BeginComputePass(ComputePassDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientCommandEncoderBeginComputePass(Get(), reinterpret_cast<WGPUComputePassDescriptor const * >(descriptor));\n    return ComputePassEncoder::Acquire(result);\n}\nRenderPassEncoder CommandEncoder::BeginRenderPass(RenderPassDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientCommandEncoderBeginRenderPass(Get(), reinterpret_cast<WGPURenderPassDescriptor const * >(descriptor));\n    return RenderPassEncoder::Acquire(result);\n}\nvoid CommandEncoder::ClearBuffer(Buffer const& buffer, uint64_t offset, uint64_t size) const {\n    wgpuDawnWireClientCommandEncoderClearBuffer(Get(), buffer.Get(), offset, size);\n}\nvoid CommandEncoder::CopyBufferToBuffer(Buffer const& source, uint64_t sourceOffset, Buffer const& destination, uint64_t destinationOffset, uint64_t size) const {\n    wgpuDawnWireClientCommandEncoderCopyBufferToBuffer(Get(), source.Get(), sourceOffset, destination.Get(), destinationOffset, size);\n}\nvoid CommandEncoder::CopyBufferToTexture(ImageCopyBuffer const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const {\n    wgpuDawnWireClientCommandEncoderCopyBufferToTexture(Get(), reinterpret_cast<WGPUImageCopyBuffer const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize));\n}\nvoid CommandEncoder::CopyTextureToBuffer(ImageCopyTexture const * source, ImageCopyBuffer const * destination, Extent3D const * copySize) const {\n    wgpuDawnWireClientCommandEncoderCopyTextureToBuffer(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(source), reinterpret_cast<WGPUImageCopyBuffer const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize));\n}\nvoid CommandEncoder::CopyTextureToTexture(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize) const {\n    wgpuDawnWireClientCommandEncoderCopyTextureToTexture(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize));\n}\nCommandBuffer CommandEncoder::Finish(CommandBufferDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientCommandEncoderFinish(Get(), reinterpret_cast<WGPUCommandBufferDescriptor const * >(descriptor));\n    return CommandBuffer::Acquire(result);\n}\nvoid CommandEncoder::InjectValidationError(StringView message) const {\n    wgpuDawnWireClientCommandEncoderInjectValidationError(Get(), *reinterpret_cast<WGPUStringView const*>(&message));\n}\nvoid CommandEncoder::InsertDebugMarker(StringView markerLabel) const {\n    wgpuDawnWireClientCommandEncoderInsertDebugMarker(Get(), *reinterpret_cast<WGPUStringView const*>(&markerLabel));\n}\nvoid CommandEncoder::PopDebugGroup() const {\n    wgpuDawnWireClientCommandEncoderPopDebugGroup(Get());\n}\nvoid CommandEncoder::PushDebugGroup(StringView groupLabel) const {\n    wgpuDawnWireClientCommandEncoderPushDebugGroup(Get(), *reinterpret_cast<WGPUStringView const*>(&groupLabel));\n}\nvoid CommandEncoder::ResolveQuerySet(QuerySet const& querySet, uint32_t firstQuery, uint32_t queryCount, Buffer const& destination, uint64_t destinationOffset) const {\n    wgpuDawnWireClientCommandEncoderResolveQuerySet(Get(), querySet.Get(), firstQuery, queryCount, destination.Get(), destinationOffset);\n}\nvoid CommandEncoder::SetLabel(StringView label) const {\n    wgpuDawnWireClientCommandEncoderSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid CommandEncoder::WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, uint8_t const * data, uint64_t size) const {\n    wgpuDawnWireClientCommandEncoderWriteBuffer(Get(), buffer.Get(), bufferOffset, reinterpret_cast<uint8_t const * >(data), size);\n}\nvoid CommandEncoder::WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const {\n    wgpuDawnWireClientCommandEncoderWriteTimestamp(Get(), querySet.Get(), queryIndex);\n}\n\n\nvoid CommandEncoder::WGPUAddRef(WGPUCommandEncoder handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientCommandEncoderAddRef(handle);\n    }\n}\nvoid CommandEncoder::WGPURelease(WGPUCommandEncoder handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientCommandEncoderRelease(handle);\n    }\n}\nstatic_assert(sizeof(CommandEncoder) == sizeof(WGPUCommandEncoder), \"sizeof mismatch for CommandEncoder\");\nstatic_assert(alignof(CommandEncoder) == alignof(WGPUCommandEncoder), \"alignof mismatch for CommandEncoder\");\n\n// ComputePassEncoder implementation\n\nvoid ComputePassEncoder::DispatchWorkgroups(uint32_t workgroupCountX, uint32_t workgroupCountY, uint32_t workgroupCountZ) const {\n    wgpuDawnWireClientComputePassEncoderDispatchWorkgroups(Get(), workgroupCountX, workgroupCountY, workgroupCountZ);\n}\nvoid ComputePassEncoder::DispatchWorkgroupsIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuDawnWireClientComputePassEncoderDispatchWorkgroupsIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nvoid ComputePassEncoder::End() const {\n    wgpuDawnWireClientComputePassEncoderEnd(Get());\n}\nvoid ComputePassEncoder::InsertDebugMarker(StringView markerLabel) const {\n    wgpuDawnWireClientComputePassEncoderInsertDebugMarker(Get(), *reinterpret_cast<WGPUStringView const*>(&markerLabel));\n}\nvoid ComputePassEncoder::PopDebugGroup() const {\n    wgpuDawnWireClientComputePassEncoderPopDebugGroup(Get());\n}\nvoid ComputePassEncoder::PushDebugGroup(StringView groupLabel) const {\n    wgpuDawnWireClientComputePassEncoderPushDebugGroup(Get(), *reinterpret_cast<WGPUStringView const*>(&groupLabel));\n}\nvoid ComputePassEncoder::SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) const {\n    wgpuDawnWireClientComputePassEncoderSetBindGroup(Get(), groupIndex, group.Get(), dynamicOffsetCount, reinterpret_cast<uint32_t const * >(dynamicOffsets));\n}\nvoid ComputePassEncoder::SetLabel(StringView label) const {\n    wgpuDawnWireClientComputePassEncoderSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid ComputePassEncoder::SetPipeline(ComputePipeline const& pipeline) const {\n    wgpuDawnWireClientComputePassEncoderSetPipeline(Get(), pipeline.Get());\n}\nvoid ComputePassEncoder::WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const {\n    wgpuDawnWireClientComputePassEncoderWriteTimestamp(Get(), querySet.Get(), queryIndex);\n}\n\n\nvoid ComputePassEncoder::WGPUAddRef(WGPUComputePassEncoder handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientComputePassEncoderAddRef(handle);\n    }\n}\nvoid ComputePassEncoder::WGPURelease(WGPUComputePassEncoder handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientComputePassEncoderRelease(handle);\n    }\n}\nstatic_assert(sizeof(ComputePassEncoder) == sizeof(WGPUComputePassEncoder), \"sizeof mismatch for ComputePassEncoder\");\nstatic_assert(alignof(ComputePassEncoder) == alignof(WGPUComputePassEncoder), \"alignof mismatch for ComputePassEncoder\");\n\n// ComputePipeline implementation\n\nBindGroupLayout ComputePipeline::GetBindGroupLayout(uint32_t groupIndex) const {\n    auto result = wgpuDawnWireClientComputePipelineGetBindGroupLayout(Get(), groupIndex);\n    return BindGroupLayout::Acquire(result);\n}\nvoid ComputePipeline::SetLabel(StringView label) const {\n    wgpuDawnWireClientComputePipelineSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid ComputePipeline::WGPUAddRef(WGPUComputePipeline handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientComputePipelineAddRef(handle);\n    }\n}\nvoid ComputePipeline::WGPURelease(WGPUComputePipeline handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientComputePipelineRelease(handle);\n    }\n}\nstatic_assert(sizeof(ComputePipeline) == sizeof(WGPUComputePipeline), \"sizeof mismatch for ComputePipeline\");\nstatic_assert(alignof(ComputePipeline) == alignof(WGPUComputePipeline), \"alignof mismatch for ComputePipeline\");\n\n// Device implementation\n\nBindGroup Device::CreateBindGroup(BindGroupDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateBindGroup(Get(), reinterpret_cast<WGPUBindGroupDescriptor const * >(descriptor));\n    return BindGroup::Acquire(result);\n}\nBindGroupLayout Device::CreateBindGroupLayout(BindGroupLayoutDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateBindGroupLayout(Get(), reinterpret_cast<WGPUBindGroupLayoutDescriptor const * >(descriptor));\n    return BindGroupLayout::Acquire(result);\n}\nBuffer Device::CreateBuffer(BufferDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateBuffer(Get(), reinterpret_cast<WGPUBufferDescriptor const * >(descriptor));\n    return Buffer::Acquire(result);\n}\nCommandEncoder Device::CreateCommandEncoder(CommandEncoderDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateCommandEncoder(Get(), reinterpret_cast<WGPUCommandEncoderDescriptor const * >(descriptor));\n    return CommandEncoder::Acquire(result);\n}\nComputePipeline Device::CreateComputePipeline(ComputePipelineDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateComputePipeline(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor));\n    return ComputePipeline::Acquire(result);\n}\nvoid Device::CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallback callback, void * userdata) const {\n    wgpuDawnWireClientDeviceCreateComputePipelineAsync(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUCreateComputePipelineAsyncCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), ComputePipeline::Acquire(pipeline), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), ComputePipeline::Acquire(pipeline), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDawnWireClientDeviceCreateComputePipelineAsync2(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CallbackMode callbackMode, L callback) const {\n    using F = CreateComputePipelineAsyncCallback2<void>;\n\n    WGPUCreateComputePipelineAsyncCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), ComputePipeline::Acquire(pipeline), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientDeviceCreateComputePipelineAsync2(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<CreatePipelineAsyncStatus>(status), ComputePipeline::Acquire(pipeline), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientDeviceCreateComputePipelineAsync2(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Device::CreateComputePipelineAsync(ComputePipelineDescriptor const * descriptor, CreateComputePipelineAsyncCallbackInfo callbackInfo) const {\n    auto result = wgpuDawnWireClientDeviceCreateComputePipelineAsyncF(Get(), reinterpret_cast<WGPUComputePipelineDescriptor const * >(descriptor), *reinterpret_cast<WGPUCreateComputePipelineAsyncCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nBuffer Device::CreateErrorBuffer(BufferDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateErrorBuffer(Get(), reinterpret_cast<WGPUBufferDescriptor const * >(descriptor));\n    return Buffer::Acquire(result);\n}\nExternalTexture Device::CreateErrorExternalTexture() const {\n    auto result = wgpuDawnWireClientDeviceCreateErrorExternalTexture(Get());\n    return ExternalTexture::Acquire(result);\n}\nShaderModule Device::CreateErrorShaderModule(ShaderModuleDescriptor const * descriptor, StringView errorMessage) const {\n    auto result = wgpuDawnWireClientDeviceCreateErrorShaderModule(Get(), reinterpret_cast<WGPUShaderModuleDescriptor const * >(descriptor), *reinterpret_cast<WGPUStringView const*>(&errorMessage));\n    return ShaderModule::Acquire(result);\n}\nTexture Device::CreateErrorTexture(TextureDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateErrorTexture(Get(), reinterpret_cast<WGPUTextureDescriptor const * >(descriptor));\n    return Texture::Acquire(result);\n}\nExternalTexture Device::CreateExternalTexture(ExternalTextureDescriptor const * externalTextureDescriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateExternalTexture(Get(), reinterpret_cast<WGPUExternalTextureDescriptor const * >(externalTextureDescriptor));\n    return ExternalTexture::Acquire(result);\n}\nPipelineLayout Device::CreatePipelineLayout(PipelineLayoutDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreatePipelineLayout(Get(), reinterpret_cast<WGPUPipelineLayoutDescriptor const * >(descriptor));\n    return PipelineLayout::Acquire(result);\n}\nQuerySet Device::CreateQuerySet(QuerySetDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateQuerySet(Get(), reinterpret_cast<WGPUQuerySetDescriptor const * >(descriptor));\n    return QuerySet::Acquire(result);\n}\nRenderBundleEncoder Device::CreateRenderBundleEncoder(RenderBundleEncoderDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateRenderBundleEncoder(Get(), reinterpret_cast<WGPURenderBundleEncoderDescriptor const * >(descriptor));\n    return RenderBundleEncoder::Acquire(result);\n}\nRenderPipeline Device::CreateRenderPipeline(RenderPipelineDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateRenderPipeline(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor));\n    return RenderPipeline::Acquire(result);\n}\nvoid Device::CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallback callback, void * userdata) const {\n    wgpuDawnWireClientDeviceCreateRenderPipelineAsync(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUCreateRenderPipelineAsyncCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), RenderPipeline::Acquire(pipeline), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), RenderPipeline::Acquire(pipeline), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDawnWireClientDeviceCreateRenderPipelineAsync2(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CallbackMode callbackMode, L callback) const {\n    using F = CreateRenderPipelineAsyncCallback2<void>;\n\n    WGPUCreateRenderPipelineAsyncCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<CreatePipelineAsyncStatus>(status), RenderPipeline::Acquire(pipeline), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientDeviceCreateRenderPipelineAsync2(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<CreatePipelineAsyncStatus>(status), RenderPipeline::Acquire(pipeline), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientDeviceCreateRenderPipelineAsync2(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Device::CreateRenderPipelineAsync(RenderPipelineDescriptor const * descriptor, CreateRenderPipelineAsyncCallbackInfo callbackInfo) const {\n    auto result = wgpuDawnWireClientDeviceCreateRenderPipelineAsyncF(Get(), reinterpret_cast<WGPURenderPipelineDescriptor const * >(descriptor), *reinterpret_cast<WGPUCreateRenderPipelineAsyncCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nSampler Device::CreateSampler(SamplerDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateSampler(Get(), reinterpret_cast<WGPUSamplerDescriptor const * >(descriptor));\n    return Sampler::Acquire(result);\n}\nShaderModule Device::CreateShaderModule(ShaderModuleDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateShaderModule(Get(), reinterpret_cast<WGPUShaderModuleDescriptor const * >(descriptor));\n    return ShaderModule::Acquire(result);\n}\nTexture Device::CreateTexture(TextureDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceCreateTexture(Get(), reinterpret_cast<WGPUTextureDescriptor const * >(descriptor));\n    return Texture::Acquire(result);\n}\nvoid Device::Destroy() const {\n    wgpuDawnWireClientDeviceDestroy(Get());\n}\nvoid Device::ForceLoss(DeviceLostReason type, StringView message) const {\n    wgpuDawnWireClientDeviceForceLoss(Get(), static_cast<WGPUDeviceLostReason>(type), *reinterpret_cast<WGPUStringView const*>(&message));\n}\nConvertibleStatus Device::GetAHardwareBufferProperties(void * handle, AHardwareBufferProperties * properties) const {\n    auto result = wgpuDawnWireClientDeviceGetAHardwareBufferProperties(Get(), handle, reinterpret_cast<WGPUAHardwareBufferProperties * >(properties));\n    return static_cast<Status>(result);\n}\nAdapter Device::GetAdapter() const {\n    auto result = wgpuDawnWireClientDeviceGetAdapter(Get());\n    return Adapter::Acquire(result);\n}\nConvertibleStatus Device::GetAdapterInfo(AdapterInfo * adapterInfo) const {\n    *adapterInfo = AdapterInfo();\n    auto result = wgpuDawnWireClientDeviceGetAdapterInfo(Get(), reinterpret_cast<WGPUAdapterInfo * >(adapterInfo));\n    return static_cast<Status>(result);\n}\nvoid Device::GetFeatures(SupportedFeatures * features) const {\n    *features = SupportedFeatures();\n    wgpuDawnWireClientDeviceGetFeatures(Get(), reinterpret_cast<WGPUSupportedFeatures * >(features));\n}\nConvertibleStatus Device::GetLimits(SupportedLimits * limits) const {\n    auto result = wgpuDawnWireClientDeviceGetLimits(Get(), reinterpret_cast<WGPUSupportedLimits * >(limits));\n    return static_cast<Status>(result);\n}\nFuture Device::GetLostFuture() const {\n    auto result = wgpuDawnWireClientDeviceGetLostFuture(Get());\n    return Future {\n            result.id\n        };\n}\nQueue Device::GetQueue() const {\n    auto result = wgpuDawnWireClientDeviceGetQueue(Get());\n    return Queue::Acquire(result);\n}\nBool Device::HasFeature(FeatureName feature) const {\n    auto result = wgpuDawnWireClientDeviceHasFeature(Get(), static_cast<WGPUFeatureName>(feature));\n    return result;\n}\nSharedBufferMemory Device::ImportSharedBufferMemory(SharedBufferMemoryDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceImportSharedBufferMemory(Get(), reinterpret_cast<WGPUSharedBufferMemoryDescriptor const * >(descriptor));\n    return SharedBufferMemory::Acquire(result);\n}\nSharedFence Device::ImportSharedFence(SharedFenceDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceImportSharedFence(Get(), reinterpret_cast<WGPUSharedFenceDescriptor const * >(descriptor));\n    return SharedFence::Acquire(result);\n}\nSharedTextureMemory Device::ImportSharedTextureMemory(SharedTextureMemoryDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientDeviceImportSharedTextureMemory(Get(), reinterpret_cast<WGPUSharedTextureMemoryDescriptor const * >(descriptor));\n    return SharedTextureMemory::Acquire(result);\n}\nvoid Device::InjectError(ErrorType type, StringView message) const {\n    wgpuDawnWireClientDeviceInjectError(Get(), static_cast<WGPUErrorType>(type), *reinterpret_cast<WGPUStringView const*>(&message));\n}\nvoid Device::PopErrorScope(ErrorCallback oldCallback, void * userdata) const {\n    wgpuDawnWireClientDevicePopErrorScope(Get(), oldCallback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::PopErrorScope(CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUPopErrorScopeCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<PopErrorScopeStatus>(status), static_cast<ErrorType>(type), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<PopErrorScopeStatus>(status), static_cast<ErrorType>(type), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDawnWireClientDevicePopErrorScope2(Get(), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Device::PopErrorScope(CallbackMode callbackMode, L callback) const {\n    using F = PopErrorScopeCallback2<void>;\n\n    WGPUPopErrorScopeCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<PopErrorScopeStatus>(status), static_cast<ErrorType>(type), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientDevicePopErrorScope2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<PopErrorScopeStatus>(status), static_cast<ErrorType>(type), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientDevicePopErrorScope2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Device::PopErrorScope(PopErrorScopeCallbackInfo callbackInfo) const {\n    auto result = wgpuDawnWireClientDevicePopErrorScopeF(Get(), *reinterpret_cast<WGPUPopErrorScopeCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nvoid Device::PushErrorScope(ErrorFilter filter) const {\n    wgpuDawnWireClientDevicePushErrorScope(Get(), static_cast<WGPUErrorFilter>(filter));\n}\nvoid Device::SetLabel(StringView label) const {\n    wgpuDawnWireClientDeviceSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid Device::SetLoggingCallback(LoggingCallback callback, void * userdata) const {\n    wgpuDawnWireClientDeviceSetLoggingCallback(Get(), callback, userdata);\n}\nvoid Device::Tick() const {\n    wgpuDawnWireClientDeviceTick(Get());\n}\nvoid Device::ValidateTextureDescriptor(TextureDescriptor const * descriptor) const {\n    wgpuDawnWireClientDeviceValidateTextureDescriptor(Get(), reinterpret_cast<WGPUTextureDescriptor const * >(descriptor));\n}\n\n\nvoid Device::WGPUAddRef(WGPUDevice handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientDeviceAddRef(handle);\n    }\n}\nvoid Device::WGPURelease(WGPUDevice handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientDeviceRelease(handle);\n    }\n}\nstatic_assert(sizeof(Device) == sizeof(WGPUDevice), \"sizeof mismatch for Device\");\nstatic_assert(alignof(Device) == alignof(WGPUDevice), \"alignof mismatch for Device\");\n\n// ExternalTexture implementation\n\nvoid ExternalTexture::Destroy() const {\n    wgpuDawnWireClientExternalTextureDestroy(Get());\n}\nvoid ExternalTexture::Expire() const {\n    wgpuDawnWireClientExternalTextureExpire(Get());\n}\nvoid ExternalTexture::Refresh() const {\n    wgpuDawnWireClientExternalTextureRefresh(Get());\n}\nvoid ExternalTexture::SetLabel(StringView label) const {\n    wgpuDawnWireClientExternalTextureSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid ExternalTexture::WGPUAddRef(WGPUExternalTexture handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientExternalTextureAddRef(handle);\n    }\n}\nvoid ExternalTexture::WGPURelease(WGPUExternalTexture handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientExternalTextureRelease(handle);\n    }\n}\nstatic_assert(sizeof(ExternalTexture) == sizeof(WGPUExternalTexture), \"sizeof mismatch for ExternalTexture\");\nstatic_assert(alignof(ExternalTexture) == alignof(WGPUExternalTexture), \"alignof mismatch for ExternalTexture\");\n\n// Instance implementation\n\nSurface Instance::CreateSurface(SurfaceDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientInstanceCreateSurface(Get(), reinterpret_cast<WGPUSurfaceDescriptor const * >(descriptor));\n    return Surface::Acquire(result);\n}\nsize_t Instance::EnumerateWGSLLanguageFeatures(WGSLFeatureName * features) const {\n    auto result = wgpuDawnWireClientInstanceEnumerateWGSLLanguageFeatures(Get(), reinterpret_cast<WGPUWGSLFeatureName * >(features));\n    return result;\n}\nBool Instance::HasWGSLLanguageFeature(WGSLFeatureName feature) const {\n    auto result = wgpuDawnWireClientInstanceHasWGSLLanguageFeature(Get(), static_cast<WGPUWGSLFeatureName>(feature));\n    return result;\n}\nvoid Instance::ProcessEvents() const {\n    wgpuDawnWireClientInstanceProcessEvents(Get());\n}\nvoid Instance::RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallback callback, void * userdata) const {\n    wgpuDawnWireClientInstanceRequestAdapter(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Instance::RequestAdapter(RequestAdapterOptions const * options, CallbackMode callbackMode, F callback, T userdata) const {\n    WGPURequestAdapterCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<RequestAdapterStatus>(status), Adapter::Acquire(adapter), StringView {\n    message.data,\n    message.length\n}, static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<RequestAdapterStatus>(status), Adapter::Acquire(adapter), {detail::StringViewAdapter(message)}, static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDawnWireClientInstanceRequestAdapter2(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Instance::RequestAdapter(RequestAdapterOptions const * options, CallbackMode callbackMode, L callback) const {\n    using F = RequestAdapterCallback2<void>;\n\n    WGPURequestAdapterCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<RequestAdapterStatus>(status), Adapter::Acquire(adapter), StringView {\n    message.data,\n    message.length\n});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientInstanceRequestAdapter2(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<RequestAdapterStatus>(status), Adapter::Acquire(adapter), {detail::StringViewAdapter(message)});\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientInstanceRequestAdapter2(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Instance::RequestAdapter(RequestAdapterOptions const * options, RequestAdapterCallbackInfo callbackInfo) const {\n    auto result = wgpuDawnWireClientInstanceRequestAdapterF(Get(), reinterpret_cast<WGPURequestAdapterOptions const * >(options), *reinterpret_cast<WGPURequestAdapterCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nWaitStatus Instance::WaitAny(size_t futureCount, FutureWaitInfo * futures, uint64_t timeoutNS) const {\n    auto result = wgpuDawnWireClientInstanceWaitAny(Get(), futureCount, reinterpret_cast<WGPUFutureWaitInfo * >(futures), timeoutNS);\n    return static_cast<WaitStatus>(result);\n}\n\nWaitStatus Instance::WaitAny(Future f, uint64_t timeout) const {\n    FutureWaitInfo waitInfo { f };\n    return WaitAny(1, &waitInfo, timeout);\n}\n\nvoid Instance::WGPUAddRef(WGPUInstance handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientInstanceAddRef(handle);\n    }\n}\nvoid Instance::WGPURelease(WGPUInstance handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientInstanceRelease(handle);\n    }\n}\nstatic_assert(sizeof(Instance) == sizeof(WGPUInstance), \"sizeof mismatch for Instance\");\nstatic_assert(alignof(Instance) == alignof(WGPUInstance), \"alignof mismatch for Instance\");\n\n// PipelineLayout implementation\n\nvoid PipelineLayout::SetLabel(StringView label) const {\n    wgpuDawnWireClientPipelineLayoutSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid PipelineLayout::WGPUAddRef(WGPUPipelineLayout handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientPipelineLayoutAddRef(handle);\n    }\n}\nvoid PipelineLayout::WGPURelease(WGPUPipelineLayout handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientPipelineLayoutRelease(handle);\n    }\n}\nstatic_assert(sizeof(PipelineLayout) == sizeof(WGPUPipelineLayout), \"sizeof mismatch for PipelineLayout\");\nstatic_assert(alignof(PipelineLayout) == alignof(WGPUPipelineLayout), \"alignof mismatch for PipelineLayout\");\n\n// QuerySet implementation\n\nvoid QuerySet::Destroy() const {\n    wgpuDawnWireClientQuerySetDestroy(Get());\n}\nuint32_t QuerySet::GetCount() const {\n    auto result = wgpuDawnWireClientQuerySetGetCount(Get());\n    return result;\n}\nQueryType QuerySet::GetType() const {\n    auto result = wgpuDawnWireClientQuerySetGetType(Get());\n    return static_cast<QueryType>(result);\n}\nvoid QuerySet::SetLabel(StringView label) const {\n    wgpuDawnWireClientQuerySetSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid QuerySet::WGPUAddRef(WGPUQuerySet handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientQuerySetAddRef(handle);\n    }\n}\nvoid QuerySet::WGPURelease(WGPUQuerySet handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientQuerySetRelease(handle);\n    }\n}\nstatic_assert(sizeof(QuerySet) == sizeof(WGPUQuerySet), \"sizeof mismatch for QuerySet\");\nstatic_assert(alignof(QuerySet) == alignof(WGPUQuerySet), \"alignof mismatch for QuerySet\");\n\n// Queue implementation\n\nvoid Queue::CopyExternalTextureForBrowser(ImageCopyExternalTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const {\n    wgpuDawnWireClientQueueCopyExternalTextureForBrowser(Get(), reinterpret_cast<WGPUImageCopyExternalTexture const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize), reinterpret_cast<WGPUCopyTextureForBrowserOptions const * >(options));\n}\nvoid Queue::CopyTextureForBrowser(ImageCopyTexture const * source, ImageCopyTexture const * destination, Extent3D const * copySize, CopyTextureForBrowserOptions const * options) const {\n    wgpuDawnWireClientQueueCopyTextureForBrowser(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(source), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<WGPUExtent3D const * >(copySize), reinterpret_cast<WGPUCopyTextureForBrowserOptions const * >(options));\n}\nvoid Queue::OnSubmittedWorkDone(QueueWorkDoneCallback callback, void * userdata) const {\n    wgpuDawnWireClientQueueOnSubmittedWorkDone(Get(), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Queue::OnSubmittedWorkDone(CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUQueueWorkDoneCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUQueueWorkDoneStatus status, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<QueueWorkDoneStatus>(status), static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUQueueWorkDoneStatus status, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<QueueWorkDoneStatus>(status), static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDawnWireClientQueueOnSubmittedWorkDone2(Get(), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture Queue::OnSubmittedWorkDone(CallbackMode callbackMode, L callback) const {\n    using F = QueueWorkDoneCallback2<void>;\n\n    WGPUQueueWorkDoneCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUQueueWorkDoneStatus status, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<QueueWorkDoneStatus>(status));\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientQueueOnSubmittedWorkDone2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUQueueWorkDoneStatus status, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<QueueWorkDoneStatus>(status));\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientQueueOnSubmittedWorkDone2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture Queue::OnSubmittedWorkDone(QueueWorkDoneCallbackInfo callbackInfo) const {\n    auto result = wgpuDawnWireClientQueueOnSubmittedWorkDoneF(Get(), *reinterpret_cast<WGPUQueueWorkDoneCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nvoid Queue::SetLabel(StringView label) const {\n    wgpuDawnWireClientQueueSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid Queue::Submit(size_t commandCount, CommandBuffer const * commands) const {\n    wgpuDawnWireClientQueueSubmit(Get(), commandCount, reinterpret_cast<WGPUCommandBuffer const * >(commands));\n}\nvoid Queue::WriteBuffer(Buffer const& buffer, uint64_t bufferOffset, void const * data, size_t size) const {\n    wgpuDawnWireClientQueueWriteBuffer(Get(), buffer.Get(), bufferOffset, reinterpret_cast<void const * >(data), size);\n}\nvoid Queue::WriteTexture(ImageCopyTexture const * destination, void const * data, size_t dataSize, TextureDataLayout const * dataLayout, Extent3D const * writeSize) const {\n    wgpuDawnWireClientQueueWriteTexture(Get(), reinterpret_cast<WGPUImageCopyTexture const * >(destination), reinterpret_cast<void const * >(data), dataSize, reinterpret_cast<WGPUTextureDataLayout const * >(dataLayout), reinterpret_cast<WGPUExtent3D const * >(writeSize));\n}\n\n\nvoid Queue::WGPUAddRef(WGPUQueue handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientQueueAddRef(handle);\n    }\n}\nvoid Queue::WGPURelease(WGPUQueue handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientQueueRelease(handle);\n    }\n}\nstatic_assert(sizeof(Queue) == sizeof(WGPUQueue), \"sizeof mismatch for Queue\");\nstatic_assert(alignof(Queue) == alignof(WGPUQueue), \"alignof mismatch for Queue\");\n\n// RenderBundle implementation\n\nvoid RenderBundle::SetLabel(StringView label) const {\n    wgpuDawnWireClientRenderBundleSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid RenderBundle::WGPUAddRef(WGPURenderBundle handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientRenderBundleAddRef(handle);\n    }\n}\nvoid RenderBundle::WGPURelease(WGPURenderBundle handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientRenderBundleRelease(handle);\n    }\n}\nstatic_assert(sizeof(RenderBundle) == sizeof(WGPURenderBundle), \"sizeof mismatch for RenderBundle\");\nstatic_assert(alignof(RenderBundle) == alignof(WGPURenderBundle), \"alignof mismatch for RenderBundle\");\n\n// RenderBundleEncoder implementation\n\nvoid RenderBundleEncoder::Draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const {\n    wgpuDawnWireClientRenderBundleEncoderDraw(Get(), vertexCount, instanceCount, firstVertex, firstInstance);\n}\nvoid RenderBundleEncoder::DrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) const {\n    wgpuDawnWireClientRenderBundleEncoderDrawIndexed(Get(), indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n}\nvoid RenderBundleEncoder::DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuDawnWireClientRenderBundleEncoderDrawIndexedIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nvoid RenderBundleEncoder::DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuDawnWireClientRenderBundleEncoderDrawIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nRenderBundle RenderBundleEncoder::Finish(RenderBundleDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientRenderBundleEncoderFinish(Get(), reinterpret_cast<WGPURenderBundleDescriptor const * >(descriptor));\n    return RenderBundle::Acquire(result);\n}\nvoid RenderBundleEncoder::InsertDebugMarker(StringView markerLabel) const {\n    wgpuDawnWireClientRenderBundleEncoderInsertDebugMarker(Get(), *reinterpret_cast<WGPUStringView const*>(&markerLabel));\n}\nvoid RenderBundleEncoder::PopDebugGroup() const {\n    wgpuDawnWireClientRenderBundleEncoderPopDebugGroup(Get());\n}\nvoid RenderBundleEncoder::PushDebugGroup(StringView groupLabel) const {\n    wgpuDawnWireClientRenderBundleEncoderPushDebugGroup(Get(), *reinterpret_cast<WGPUStringView const*>(&groupLabel));\n}\nvoid RenderBundleEncoder::SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) const {\n    wgpuDawnWireClientRenderBundleEncoderSetBindGroup(Get(), groupIndex, group.Get(), dynamicOffsetCount, reinterpret_cast<uint32_t const * >(dynamicOffsets));\n}\nvoid RenderBundleEncoder::SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset, uint64_t size) const {\n    wgpuDawnWireClientRenderBundleEncoderSetIndexBuffer(Get(), buffer.Get(), static_cast<WGPUIndexFormat>(format), offset, size);\n}\nvoid RenderBundleEncoder::SetLabel(StringView label) const {\n    wgpuDawnWireClientRenderBundleEncoderSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid RenderBundleEncoder::SetPipeline(RenderPipeline const& pipeline) const {\n    wgpuDawnWireClientRenderBundleEncoderSetPipeline(Get(), pipeline.Get());\n}\nvoid RenderBundleEncoder::SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset, uint64_t size) const {\n    wgpuDawnWireClientRenderBundleEncoderSetVertexBuffer(Get(), slot, buffer.Get(), offset, size);\n}\n\n\nvoid RenderBundleEncoder::WGPUAddRef(WGPURenderBundleEncoder handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientRenderBundleEncoderAddRef(handle);\n    }\n}\nvoid RenderBundleEncoder::WGPURelease(WGPURenderBundleEncoder handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientRenderBundleEncoderRelease(handle);\n    }\n}\nstatic_assert(sizeof(RenderBundleEncoder) == sizeof(WGPURenderBundleEncoder), \"sizeof mismatch for RenderBundleEncoder\");\nstatic_assert(alignof(RenderBundleEncoder) == alignof(WGPURenderBundleEncoder), \"alignof mismatch for RenderBundleEncoder\");\n\n// RenderPassEncoder implementation\n\nvoid RenderPassEncoder::BeginOcclusionQuery(uint32_t queryIndex) const {\n    wgpuDawnWireClientRenderPassEncoderBeginOcclusionQuery(Get(), queryIndex);\n}\nvoid RenderPassEncoder::Draw(uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) const {\n    wgpuDawnWireClientRenderPassEncoderDraw(Get(), vertexCount, instanceCount, firstVertex, firstInstance);\n}\nvoid RenderPassEncoder::DrawIndexed(uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t baseVertex, uint32_t firstInstance) const {\n    wgpuDawnWireClientRenderPassEncoderDrawIndexed(Get(), indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n}\nvoid RenderPassEncoder::DrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuDawnWireClientRenderPassEncoderDrawIndexedIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nvoid RenderPassEncoder::DrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset) const {\n    wgpuDawnWireClientRenderPassEncoderDrawIndirect(Get(), indirectBuffer.Get(), indirectOffset);\n}\nvoid RenderPassEncoder::End() const {\n    wgpuDawnWireClientRenderPassEncoderEnd(Get());\n}\nvoid RenderPassEncoder::EndOcclusionQuery() const {\n    wgpuDawnWireClientRenderPassEncoderEndOcclusionQuery(Get());\n}\nvoid RenderPassEncoder::ExecuteBundles(size_t bundleCount, RenderBundle const * bundles) const {\n    wgpuDawnWireClientRenderPassEncoderExecuteBundles(Get(), bundleCount, reinterpret_cast<WGPURenderBundle const * >(bundles));\n}\nvoid RenderPassEncoder::InsertDebugMarker(StringView markerLabel) const {\n    wgpuDawnWireClientRenderPassEncoderInsertDebugMarker(Get(), *reinterpret_cast<WGPUStringView const*>(&markerLabel));\n}\nvoid RenderPassEncoder::MultiDrawIndexedIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset, uint32_t maxDrawCount, Buffer const& drawCountBuffer, uint64_t drawCountBufferOffset) const {\n    wgpuDawnWireClientRenderPassEncoderMultiDrawIndexedIndirect(Get(), indirectBuffer.Get(), indirectOffset, maxDrawCount, drawCountBuffer.Get(), drawCountBufferOffset);\n}\nvoid RenderPassEncoder::MultiDrawIndirect(Buffer const& indirectBuffer, uint64_t indirectOffset, uint32_t maxDrawCount, Buffer const& drawCountBuffer, uint64_t drawCountBufferOffset) const {\n    wgpuDawnWireClientRenderPassEncoderMultiDrawIndirect(Get(), indirectBuffer.Get(), indirectOffset, maxDrawCount, drawCountBuffer.Get(), drawCountBufferOffset);\n}\nvoid RenderPassEncoder::PixelLocalStorageBarrier() const {\n    wgpuDawnWireClientRenderPassEncoderPixelLocalStorageBarrier(Get());\n}\nvoid RenderPassEncoder::PopDebugGroup() const {\n    wgpuDawnWireClientRenderPassEncoderPopDebugGroup(Get());\n}\nvoid RenderPassEncoder::PushDebugGroup(StringView groupLabel) const {\n    wgpuDawnWireClientRenderPassEncoderPushDebugGroup(Get(), *reinterpret_cast<WGPUStringView const*>(&groupLabel));\n}\nvoid RenderPassEncoder::SetBindGroup(uint32_t groupIndex, BindGroup const& group, size_t dynamicOffsetCount, uint32_t const * dynamicOffsets) const {\n    wgpuDawnWireClientRenderPassEncoderSetBindGroup(Get(), groupIndex, group.Get(), dynamicOffsetCount, reinterpret_cast<uint32_t const * >(dynamicOffsets));\n}\nvoid RenderPassEncoder::SetBlendConstant(Color const * color) const {\n    wgpuDawnWireClientRenderPassEncoderSetBlendConstant(Get(), reinterpret_cast<WGPUColor const * >(color));\n}\nvoid RenderPassEncoder::SetIndexBuffer(Buffer const& buffer, IndexFormat format, uint64_t offset, uint64_t size) const {\n    wgpuDawnWireClientRenderPassEncoderSetIndexBuffer(Get(), buffer.Get(), static_cast<WGPUIndexFormat>(format), offset, size);\n}\nvoid RenderPassEncoder::SetLabel(StringView label) const {\n    wgpuDawnWireClientRenderPassEncoderSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid RenderPassEncoder::SetPipeline(RenderPipeline const& pipeline) const {\n    wgpuDawnWireClientRenderPassEncoderSetPipeline(Get(), pipeline.Get());\n}\nvoid RenderPassEncoder::SetScissorRect(uint32_t x, uint32_t y, uint32_t width, uint32_t height) const {\n    wgpuDawnWireClientRenderPassEncoderSetScissorRect(Get(), x, y, width, height);\n}\nvoid RenderPassEncoder::SetStencilReference(uint32_t reference) const {\n    wgpuDawnWireClientRenderPassEncoderSetStencilReference(Get(), reference);\n}\nvoid RenderPassEncoder::SetVertexBuffer(uint32_t slot, Buffer const& buffer, uint64_t offset, uint64_t size) const {\n    wgpuDawnWireClientRenderPassEncoderSetVertexBuffer(Get(), slot, buffer.Get(), offset, size);\n}\nvoid RenderPassEncoder::SetViewport(float x, float y, float width, float height, float minDepth, float maxDepth) const {\n    wgpuDawnWireClientRenderPassEncoderSetViewport(Get(), x, y, width, height, minDepth, maxDepth);\n}\nvoid RenderPassEncoder::WriteTimestamp(QuerySet const& querySet, uint32_t queryIndex) const {\n    wgpuDawnWireClientRenderPassEncoderWriteTimestamp(Get(), querySet.Get(), queryIndex);\n}\n\n\nvoid RenderPassEncoder::WGPUAddRef(WGPURenderPassEncoder handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientRenderPassEncoderAddRef(handle);\n    }\n}\nvoid RenderPassEncoder::WGPURelease(WGPURenderPassEncoder handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientRenderPassEncoderRelease(handle);\n    }\n}\nstatic_assert(sizeof(RenderPassEncoder) == sizeof(WGPURenderPassEncoder), \"sizeof mismatch for RenderPassEncoder\");\nstatic_assert(alignof(RenderPassEncoder) == alignof(WGPURenderPassEncoder), \"alignof mismatch for RenderPassEncoder\");\n\n// RenderPipeline implementation\n\nBindGroupLayout RenderPipeline::GetBindGroupLayout(uint32_t groupIndex) const {\n    auto result = wgpuDawnWireClientRenderPipelineGetBindGroupLayout(Get(), groupIndex);\n    return BindGroupLayout::Acquire(result);\n}\nvoid RenderPipeline::SetLabel(StringView label) const {\n    wgpuDawnWireClientRenderPipelineSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid RenderPipeline::WGPUAddRef(WGPURenderPipeline handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientRenderPipelineAddRef(handle);\n    }\n}\nvoid RenderPipeline::WGPURelease(WGPURenderPipeline handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientRenderPipelineRelease(handle);\n    }\n}\nstatic_assert(sizeof(RenderPipeline) == sizeof(WGPURenderPipeline), \"sizeof mismatch for RenderPipeline\");\nstatic_assert(alignof(RenderPipeline) == alignof(WGPURenderPipeline), \"alignof mismatch for RenderPipeline\");\n\n// Sampler implementation\n\nvoid Sampler::SetLabel(StringView label) const {\n    wgpuDawnWireClientSamplerSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid Sampler::WGPUAddRef(WGPUSampler handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSamplerAddRef(handle);\n    }\n}\nvoid Sampler::WGPURelease(WGPUSampler handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSamplerRelease(handle);\n    }\n}\nstatic_assert(sizeof(Sampler) == sizeof(WGPUSampler), \"sizeof mismatch for Sampler\");\nstatic_assert(alignof(Sampler) == alignof(WGPUSampler), \"alignof mismatch for Sampler\");\n\n// ShaderModule implementation\n\nvoid ShaderModule::GetCompilationInfo(CompilationInfoCallback callback, void * userdata) const {\n    wgpuDawnWireClientShaderModuleGetCompilationInfo(Get(), callback, userdata);\n}\ntemplate <typename F, typename T,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture ShaderModule::GetCompilationInfo(CallbackMode callbackMode, F callback, T userdata) const {\n    WGPUCompilationInfoCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<F, Cb*>) {\n        callbackInfo.callback = [](WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * compilationInfo, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<Cb*>(callback_param);\n            (*cb)(static_cast<CompilationInfoRequestStatus>(status), reinterpret_cast<CompilationInfo const*>(compilationInfo), static_cast<T>(userdata_param));\n        };\n    } else {\n        callbackInfo.callback = [](WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * compilationInfo, void* callback_param, void* userdata_param) {\n            auto cb = reinterpret_cast<CbChar*>(callback_param);\n            (*cb)(static_cast<CompilationInfoRequestStatus>(status), reinterpret_cast<CompilationInfo const*>(compilationInfo), static_cast<T>(userdata_param));\n        };\n    }\n    callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n    callbackInfo.userdata2 = reinterpret_cast<void*>(userdata);\n    auto result = wgpuDawnWireClientShaderModuleGetCompilationInfo2(Get(), callbackInfo);\n    return Future {\n        result.id\n    };\n}\ntemplate <typename L,\n          typename Cb,\n          typename CbChar,\n          typename>\nFuture ShaderModule::GetCompilationInfo(CallbackMode callbackMode, L callback) const {\n    using F = CompilationInfoCallback2<void>;\n\n    WGPUCompilationInfoCallbackInfo2 callbackInfo = {};\n    callbackInfo.mode = static_cast<WGPUCallbackMode>(callbackMode);\n    if constexpr (std::is_convertible_v<L, F*>) {\n        callbackInfo.callback = [](WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * compilationInfo, void* callback_param, void*) {\n            auto cb = reinterpret_cast<F*>(callback_param);\n            (*cb)(static_cast<CompilationInfoRequestStatus>(status), reinterpret_cast<CompilationInfo const*>(compilationInfo));\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(+callback);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientShaderModuleGetCompilationInfo2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    } else {\n        auto* lambda = new L(std::move(callback));\n        callbackInfo.callback = [](WGPUCompilationInfoRequestStatus status, WGPUCompilationInfo const * compilationInfo, void* callback_param, void*) {\n            std::unique_ptr<L> the_lambda(reinterpret_cast<L*>(callback_param));\n            (*the_lambda)(static_cast<CompilationInfoRequestStatus>(status), reinterpret_cast<CompilationInfo const*>(compilationInfo));\n        };\n        callbackInfo.userdata1 = reinterpret_cast<void*>(lambda);\n        callbackInfo.userdata2 = nullptr;\n        auto result = wgpuDawnWireClientShaderModuleGetCompilationInfo2(Get(), callbackInfo);\n        return Future {\n            result.id\n        };\n    }\n}\nFuture ShaderModule::GetCompilationInfo(CompilationInfoCallbackInfo callbackInfo) const {\n    auto result = wgpuDawnWireClientShaderModuleGetCompilationInfoF(Get(), *reinterpret_cast<WGPUCompilationInfoCallbackInfo const*>(&callbackInfo));\n    return Future {\n            result.id\n        };\n}\nvoid ShaderModule::SetLabel(StringView label) const {\n    wgpuDawnWireClientShaderModuleSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid ShaderModule::WGPUAddRef(WGPUShaderModule handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientShaderModuleAddRef(handle);\n    }\n}\nvoid ShaderModule::WGPURelease(WGPUShaderModule handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientShaderModuleRelease(handle);\n    }\n}\nstatic_assert(sizeof(ShaderModule) == sizeof(WGPUShaderModule), \"sizeof mismatch for ShaderModule\");\nstatic_assert(alignof(ShaderModule) == alignof(WGPUShaderModule), \"alignof mismatch for ShaderModule\");\n\n// SharedBufferMemory implementation\n\nConvertibleStatus SharedBufferMemory::BeginAccess(Buffer const& buffer, SharedBufferMemoryBeginAccessDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientSharedBufferMemoryBeginAccess(Get(), buffer.Get(), reinterpret_cast<WGPUSharedBufferMemoryBeginAccessDescriptor const * >(descriptor));\n    return static_cast<Status>(result);\n}\nBuffer SharedBufferMemory::CreateBuffer(BufferDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientSharedBufferMemoryCreateBuffer(Get(), reinterpret_cast<WGPUBufferDescriptor const * >(descriptor));\n    return Buffer::Acquire(result);\n}\nConvertibleStatus SharedBufferMemory::EndAccess(Buffer const& buffer, SharedBufferMemoryEndAccessState * descriptor) const {\n    *descriptor = SharedBufferMemoryEndAccessState();\n    auto result = wgpuDawnWireClientSharedBufferMemoryEndAccess(Get(), buffer.Get(), reinterpret_cast<WGPUSharedBufferMemoryEndAccessState * >(descriptor));\n    return static_cast<Status>(result);\n}\nConvertibleStatus SharedBufferMemory::GetProperties(SharedBufferMemoryProperties * properties) const {\n    auto result = wgpuDawnWireClientSharedBufferMemoryGetProperties(Get(), reinterpret_cast<WGPUSharedBufferMemoryProperties * >(properties));\n    return static_cast<Status>(result);\n}\nBool SharedBufferMemory::IsDeviceLost() const {\n    auto result = wgpuDawnWireClientSharedBufferMemoryIsDeviceLost(Get());\n    return result;\n}\nvoid SharedBufferMemory::SetLabel(StringView label) const {\n    wgpuDawnWireClientSharedBufferMemorySetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid SharedBufferMemory::WGPUAddRef(WGPUSharedBufferMemory handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSharedBufferMemoryAddRef(handle);\n    }\n}\nvoid SharedBufferMemory::WGPURelease(WGPUSharedBufferMemory handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSharedBufferMemoryRelease(handle);\n    }\n}\nstatic_assert(sizeof(SharedBufferMemory) == sizeof(WGPUSharedBufferMemory), \"sizeof mismatch for SharedBufferMemory\");\nstatic_assert(alignof(SharedBufferMemory) == alignof(WGPUSharedBufferMemory), \"alignof mismatch for SharedBufferMemory\");\n\n// SharedFence implementation\n\nvoid SharedFence::ExportInfo(SharedFenceExportInfo * info) const {\n    wgpuDawnWireClientSharedFenceExportInfo(Get(), reinterpret_cast<WGPUSharedFenceExportInfo * >(info));\n}\n\n\nvoid SharedFence::WGPUAddRef(WGPUSharedFence handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSharedFenceAddRef(handle);\n    }\n}\nvoid SharedFence::WGPURelease(WGPUSharedFence handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSharedFenceRelease(handle);\n    }\n}\nstatic_assert(sizeof(SharedFence) == sizeof(WGPUSharedFence), \"sizeof mismatch for SharedFence\");\nstatic_assert(alignof(SharedFence) == alignof(WGPUSharedFence), \"alignof mismatch for SharedFence\");\n\n// SharedTextureMemory implementation\n\nConvertibleStatus SharedTextureMemory::BeginAccess(Texture const& texture, SharedTextureMemoryBeginAccessDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientSharedTextureMemoryBeginAccess(Get(), texture.Get(), reinterpret_cast<WGPUSharedTextureMemoryBeginAccessDescriptor const * >(descriptor));\n    return static_cast<Status>(result);\n}\nTexture SharedTextureMemory::CreateTexture(TextureDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientSharedTextureMemoryCreateTexture(Get(), reinterpret_cast<WGPUTextureDescriptor const * >(descriptor));\n    return Texture::Acquire(result);\n}\nConvertibleStatus SharedTextureMemory::EndAccess(Texture const& texture, SharedTextureMemoryEndAccessState * descriptor) const {\n    *descriptor = SharedTextureMemoryEndAccessState();\n    auto result = wgpuDawnWireClientSharedTextureMemoryEndAccess(Get(), texture.Get(), reinterpret_cast<WGPUSharedTextureMemoryEndAccessState * >(descriptor));\n    return static_cast<Status>(result);\n}\nConvertibleStatus SharedTextureMemory::GetProperties(SharedTextureMemoryProperties * properties) const {\n    auto result = wgpuDawnWireClientSharedTextureMemoryGetProperties(Get(), reinterpret_cast<WGPUSharedTextureMemoryProperties * >(properties));\n    return static_cast<Status>(result);\n}\nBool SharedTextureMemory::IsDeviceLost() const {\n    auto result = wgpuDawnWireClientSharedTextureMemoryIsDeviceLost(Get());\n    return result;\n}\nvoid SharedTextureMemory::SetLabel(StringView label) const {\n    wgpuDawnWireClientSharedTextureMemorySetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid SharedTextureMemory::WGPUAddRef(WGPUSharedTextureMemory handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSharedTextureMemoryAddRef(handle);\n    }\n}\nvoid SharedTextureMemory::WGPURelease(WGPUSharedTextureMemory handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSharedTextureMemoryRelease(handle);\n    }\n}\nstatic_assert(sizeof(SharedTextureMemory) == sizeof(WGPUSharedTextureMemory), \"sizeof mismatch for SharedTextureMemory\");\nstatic_assert(alignof(SharedTextureMemory) == alignof(WGPUSharedTextureMemory), \"alignof mismatch for SharedTextureMemory\");\n\n// Surface implementation\n\nvoid Surface::Configure(SurfaceConfiguration const * config) const {\n    wgpuDawnWireClientSurfaceConfigure(Get(), reinterpret_cast<WGPUSurfaceConfiguration const * >(config));\n}\nConvertibleStatus Surface::GetCapabilities(Adapter const& adapter, SurfaceCapabilities * capabilities) const {\n    *capabilities = SurfaceCapabilities();\n    auto result = wgpuDawnWireClientSurfaceGetCapabilities(Get(), adapter.Get(), reinterpret_cast<WGPUSurfaceCapabilities * >(capabilities));\n    return static_cast<Status>(result);\n}\nvoid Surface::GetCurrentTexture(SurfaceTexture * surfaceTexture) const {\n    wgpuDawnWireClientSurfaceGetCurrentTexture(Get(), reinterpret_cast<WGPUSurfaceTexture * >(surfaceTexture));\n}\nvoid Surface::Present() const {\n    wgpuDawnWireClientSurfacePresent(Get());\n}\nvoid Surface::SetLabel(StringView label) const {\n    wgpuDawnWireClientSurfaceSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\nvoid Surface::Unconfigure() const {\n    wgpuDawnWireClientSurfaceUnconfigure(Get());\n}\n\n\nvoid Surface::WGPUAddRef(WGPUSurface handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSurfaceAddRef(handle);\n    }\n}\nvoid Surface::WGPURelease(WGPUSurface handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientSurfaceRelease(handle);\n    }\n}\nstatic_assert(sizeof(Surface) == sizeof(WGPUSurface), \"sizeof mismatch for Surface\");\nstatic_assert(alignof(Surface) == alignof(WGPUSurface), \"alignof mismatch for Surface\");\n\n// Texture implementation\n\nTextureView Texture::CreateErrorView(TextureViewDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientTextureCreateErrorView(Get(), reinterpret_cast<WGPUTextureViewDescriptor const * >(descriptor));\n    return TextureView::Acquire(result);\n}\nTextureView Texture::CreateView(TextureViewDescriptor const * descriptor) const {\n    auto result = wgpuDawnWireClientTextureCreateView(Get(), reinterpret_cast<WGPUTextureViewDescriptor const * >(descriptor));\n    return TextureView::Acquire(result);\n}\nvoid Texture::Destroy() const {\n    wgpuDawnWireClientTextureDestroy(Get());\n}\nuint32_t Texture::GetDepthOrArrayLayers() const {\n    auto result = wgpuDawnWireClientTextureGetDepthOrArrayLayers(Get());\n    return result;\n}\nTextureDimension Texture::GetDimension() const {\n    auto result = wgpuDawnWireClientTextureGetDimension(Get());\n    return static_cast<TextureDimension>(result);\n}\nTextureFormat Texture::GetFormat() const {\n    auto result = wgpuDawnWireClientTextureGetFormat(Get());\n    return static_cast<TextureFormat>(result);\n}\nuint32_t Texture::GetHeight() const {\n    auto result = wgpuDawnWireClientTextureGetHeight(Get());\n    return result;\n}\nuint32_t Texture::GetMipLevelCount() const {\n    auto result = wgpuDawnWireClientTextureGetMipLevelCount(Get());\n    return result;\n}\nuint32_t Texture::GetSampleCount() const {\n    auto result = wgpuDawnWireClientTextureGetSampleCount(Get());\n    return result;\n}\nTextureUsage Texture::GetUsage() const {\n    auto result = wgpuDawnWireClientTextureGetUsage(Get());\n    return static_cast<TextureUsage>(result);\n}\nuint32_t Texture::GetWidth() const {\n    auto result = wgpuDawnWireClientTextureGetWidth(Get());\n    return result;\n}\nvoid Texture::SetLabel(StringView label) const {\n    wgpuDawnWireClientTextureSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid Texture::WGPUAddRef(WGPUTexture handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientTextureAddRef(handle);\n    }\n}\nvoid Texture::WGPURelease(WGPUTexture handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientTextureRelease(handle);\n    }\n}\nstatic_assert(sizeof(Texture) == sizeof(WGPUTexture), \"sizeof mismatch for Texture\");\nstatic_assert(alignof(Texture) == alignof(WGPUTexture), \"alignof mismatch for Texture\");\n\n// TextureView implementation\n\nvoid TextureView::SetLabel(StringView label) const {\n    wgpuDawnWireClientTextureViewSetLabel(Get(), *reinterpret_cast<WGPUStringView const*>(&label));\n}\n\n\nvoid TextureView::WGPUAddRef(WGPUTextureView handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientTextureViewAddRef(handle);\n    }\n}\nvoid TextureView::WGPURelease(WGPUTextureView handle) {\n    if (handle != nullptr) {\n        wgpuDawnWireClientTextureViewRelease(handle);\n    }\n}\nstatic_assert(sizeof(TextureView) == sizeof(WGPUTextureView), \"sizeof mismatch for TextureView\");\nstatic_assert(alignof(TextureView) == alignof(WGPUTextureView), \"alignof mismatch for TextureView\");\n\n\n}  // namespace dawn::wire::client\n\nusing Adapter = dawn::wire::client::Adapter;\nusing BindGroup = dawn::wire::client::BindGroup;\nusing BindGroupLayout = dawn::wire::client::BindGroupLayout;\nusing Buffer = dawn::wire::client::Buffer;\nusing CommandBuffer = dawn::wire::client::CommandBuffer;\nusing CommandEncoder = dawn::wire::client::CommandEncoder;\nusing ComputePassEncoder = dawn::wire::client::ComputePassEncoder;\nusing ComputePipeline = dawn::wire::client::ComputePipeline;\nusing Device = dawn::wire::client::Device;\nusing ExternalTexture = dawn::wire::client::ExternalTexture;\nusing Instance = dawn::wire::client::Instance;\nusing PipelineLayout = dawn::wire::client::PipelineLayout;\nusing QuerySet = dawn::wire::client::QuerySet;\nusing Queue = dawn::wire::client::Queue;\nusing RenderBundle = dawn::wire::client::RenderBundle;\nusing RenderBundleEncoder = dawn::wire::client::RenderBundleEncoder;\nusing RenderPassEncoder = dawn::wire::client::RenderPassEncoder;\nusing RenderPipeline = dawn::wire::client::RenderPipeline;\nusing Sampler = dawn::wire::client::Sampler;\nusing ShaderModule = dawn::wire::client::ShaderModule;\nusing SharedBufferMemory = dawn::wire::client::SharedBufferMemory;\nusing SharedFence = dawn::wire::client::SharedFence;\nusing SharedTextureMemory = dawn::wire::client::SharedTextureMemory;\nusing Surface = dawn::wire::client::Surface;\nusing Texture = dawn::wire::client::Texture;\nusing TextureView = dawn::wire::client::TextureView;\n\nusing AdapterPropertiesD3D = dawn::wire::client::AdapterPropertiesD3D;\nusing AdapterPropertiesSubgroups = dawn::wire::client::AdapterPropertiesSubgroups;\nusing AdapterPropertiesVk = dawn::wire::client::AdapterPropertiesVk;\nusing BindGroupEntry = dawn::wire::client::BindGroupEntry;\nusing BlendComponent = dawn::wire::client::BlendComponent;\nusing BufferBindingLayout = dawn::wire::client::BufferBindingLayout;\nusing BufferHostMappedPointer = dawn::wire::client::BufferHostMappedPointer;\nusing BufferMapCallbackInfo = dawn::wire::client::BufferMapCallbackInfo;\nusing Color = dawn::wire::client::Color;\nusing ColorTargetStateExpandResolveTextureDawn = dawn::wire::client::ColorTargetStateExpandResolveTextureDawn;\nusing CompilationInfoCallbackInfo = dawn::wire::client::CompilationInfoCallbackInfo;\nusing ComputePassTimestampWrites = dawn::wire::client::ComputePassTimestampWrites;\nusing CopyTextureForBrowserOptions = dawn::wire::client::CopyTextureForBrowserOptions;\nusing CreateComputePipelineAsyncCallbackInfo = dawn::wire::client::CreateComputePipelineAsyncCallbackInfo;\nusing CreateRenderPipelineAsyncCallbackInfo = dawn::wire::client::CreateRenderPipelineAsyncCallbackInfo;\nusing DawnWGSLBlocklist = dawn::wire::client::DawnWGSLBlocklist;\nusing DawnAdapterPropertiesPowerPreference = dawn::wire::client::DawnAdapterPropertiesPowerPreference;\nusing DawnBufferDescriptorErrorInfoFromWireClient = dawn::wire::client::DawnBufferDescriptorErrorInfoFromWireClient;\nusing DawnEncoderInternalUsageDescriptor = dawn::wire::client::DawnEncoderInternalUsageDescriptor;\nusing DawnExperimentalImmediateDataLimits = dawn::wire::client::DawnExperimentalImmediateDataLimits;\nusing DawnExperimentalSubgroupLimits = dawn::wire::client::DawnExperimentalSubgroupLimits;\nusing DawnRenderPassColorAttachmentRenderToSingleSampled = dawn::wire::client::DawnRenderPassColorAttachmentRenderToSingleSampled;\nusing DawnShaderModuleSPIRVOptionsDescriptor = dawn::wire::client::DawnShaderModuleSPIRVOptionsDescriptor;\nusing DawnTexelCopyBufferRowAlignmentLimits = dawn::wire::client::DawnTexelCopyBufferRowAlignmentLimits;\nusing DawnTextureInternalUsageDescriptor = dawn::wire::client::DawnTextureInternalUsageDescriptor;\nusing DawnTogglesDescriptor = dawn::wire::client::DawnTogglesDescriptor;\nusing DawnWireWGSLControl = dawn::wire::client::DawnWireWGSLControl;\nusing DeviceLostCallbackInfo = dawn::wire::client::DeviceLostCallbackInfo;\nusing DrmFormatProperties = dawn::wire::client::DrmFormatProperties;\nusing Extent2D = dawn::wire::client::Extent2D;\nusing Extent3D = dawn::wire::client::Extent3D;\nusing ExternalTextureBindingEntry = dawn::wire::client::ExternalTextureBindingEntry;\nusing ExternalTextureBindingLayout = dawn::wire::client::ExternalTextureBindingLayout;\nusing FormatCapabilities = dawn::wire::client::FormatCapabilities;\nusing Future = dawn::wire::client::Future;\nusing InstanceFeatures = dawn::wire::client::InstanceFeatures;\nusing Limits = dawn::wire::client::Limits;\nusing MemoryHeapInfo = dawn::wire::client::MemoryHeapInfo;\nusing MultisampleState = dawn::wire::client::MultisampleState;\nusing Origin2D = dawn::wire::client::Origin2D;\nusing Origin3D = dawn::wire::client::Origin3D;\nusing PipelineLayoutStorageAttachment = dawn::wire::client::PipelineLayoutStorageAttachment;\nusing PopErrorScopeCallbackInfo = dawn::wire::client::PopErrorScopeCallbackInfo;\nusing PrimitiveState = dawn::wire::client::PrimitiveState;\nusing QueueWorkDoneCallbackInfo = dawn::wire::client::QueueWorkDoneCallbackInfo;\nusing RenderPassDepthStencilAttachment = dawn::wire::client::RenderPassDepthStencilAttachment;\nusing RenderPassDescriptorExpandResolveRect = dawn::wire::client::RenderPassDescriptorExpandResolveRect;\nusing RenderPassMaxDrawCount = dawn::wire::client::RenderPassMaxDrawCount;\nusing RenderPassTimestampWrites = dawn::wire::client::RenderPassTimestampWrites;\nusing RequestAdapterCallbackInfo = dawn::wire::client::RequestAdapterCallbackInfo;\nusing RequestAdapterOptions = dawn::wire::client::RequestAdapterOptions;\nusing RequestDeviceCallbackInfo = dawn::wire::client::RequestDeviceCallbackInfo;\nusing SamplerBindingLayout = dawn::wire::client::SamplerBindingLayout;\nusing ShaderModuleCompilationOptions = dawn::wire::client::ShaderModuleCompilationOptions;\nusing ShaderSourceSPIRV = dawn::wire::client::ShaderSourceSPIRV;\nusing SharedBufferMemoryBeginAccessDescriptor = dawn::wire::client::SharedBufferMemoryBeginAccessDescriptor;\nusing SharedBufferMemoryEndAccessState = dawn::wire::client::SharedBufferMemoryEndAccessState;\nusing SharedBufferMemoryProperties = dawn::wire::client::SharedBufferMemoryProperties;\nusing SharedFenceDXGISharedHandleDescriptor = dawn::wire::client::SharedFenceDXGISharedHandleDescriptor;\nusing SharedFenceDXGISharedHandleExportInfo = dawn::wire::client::SharedFenceDXGISharedHandleExportInfo;\nusing SharedFenceMTLSharedEventDescriptor = dawn::wire::client::SharedFenceMTLSharedEventDescriptor;\nusing SharedFenceMTLSharedEventExportInfo = dawn::wire::client::SharedFenceMTLSharedEventExportInfo;\nusing SharedFenceExportInfo = dawn::wire::client::SharedFenceExportInfo;\nusing SharedFenceSyncFDDescriptor = dawn::wire::client::SharedFenceSyncFDDescriptor;\nusing SharedFenceSyncFDExportInfo = dawn::wire::client::SharedFenceSyncFDExportInfo;\nusing SharedFenceVkSemaphoreOpaqueFDDescriptor = dawn::wire::client::SharedFenceVkSemaphoreOpaqueFDDescriptor;\nusing SharedFenceVkSemaphoreOpaqueFDExportInfo = dawn::wire::client::SharedFenceVkSemaphoreOpaqueFDExportInfo;\nusing SharedFenceVkSemaphoreZirconHandleDescriptor = dawn::wire::client::SharedFenceVkSemaphoreZirconHandleDescriptor;\nusing SharedFenceVkSemaphoreZirconHandleExportInfo = dawn::wire::client::SharedFenceVkSemaphoreZirconHandleExportInfo;\nusing SharedTextureMemoryD3DSwapchainBeginState = dawn::wire::client::SharedTextureMemoryD3DSwapchainBeginState;\nusing SharedTextureMemoryDXGISharedHandleDescriptor = dawn::wire::client::SharedTextureMemoryDXGISharedHandleDescriptor;\nusing SharedTextureMemoryEGLImageDescriptor = dawn::wire::client::SharedTextureMemoryEGLImageDescriptor;\nusing SharedTextureMemoryIOSurfaceDescriptor = dawn::wire::client::SharedTextureMemoryIOSurfaceDescriptor;\nusing SharedTextureMemoryAHardwareBufferDescriptor = dawn::wire::client::SharedTextureMemoryAHardwareBufferDescriptor;\nusing SharedTextureMemoryBeginAccessDescriptor = dawn::wire::client::SharedTextureMemoryBeginAccessDescriptor;\nusing SharedTextureMemoryDmaBufPlane = dawn::wire::client::SharedTextureMemoryDmaBufPlane;\nusing SharedTextureMemoryEndAccessState = dawn::wire::client::SharedTextureMemoryEndAccessState;\nusing SharedTextureMemoryOpaqueFDDescriptor = dawn::wire::client::SharedTextureMemoryOpaqueFDDescriptor;\nusing SharedTextureMemoryVkDedicatedAllocationDescriptor = dawn::wire::client::SharedTextureMemoryVkDedicatedAllocationDescriptor;\nusing SharedTextureMemoryVkImageLayoutBeginState = dawn::wire::client::SharedTextureMemoryVkImageLayoutBeginState;\nusing SharedTextureMemoryVkImageLayoutEndState = dawn::wire::client::SharedTextureMemoryVkImageLayoutEndState;\nusing SharedTextureMemoryZirconHandleDescriptor = dawn::wire::client::SharedTextureMemoryZirconHandleDescriptor;\nusing StaticSamplerBindingLayout = dawn::wire::client::StaticSamplerBindingLayout;\nusing StencilFaceState = dawn::wire::client::StencilFaceState;\nusing StorageTextureBindingLayout = dawn::wire::client::StorageTextureBindingLayout;\nusing StringView = dawn::wire::client::StringView;\nusing SupportedFeatures = dawn::wire::client::SupportedFeatures;\nusing SurfaceCapabilities = dawn::wire::client::SurfaceCapabilities;\nusing SurfaceConfiguration = dawn::wire::client::SurfaceConfiguration;\nusing SurfaceDescriptorFromWindowsCoreWindow = dawn::wire::client::SurfaceDescriptorFromWindowsCoreWindow;\nusing SurfaceDescriptorFromWindowsSwapChainPanel = dawn::wire::client::SurfaceDescriptorFromWindowsSwapChainPanel;\nusing SurfaceSourceXCBWindow = dawn::wire::client::SurfaceSourceXCBWindow;\nusing SurfaceSourceAndroidNativeWindow = dawn::wire::client::SurfaceSourceAndroidNativeWindow;\nusing SurfaceSourceMetalLayer = dawn::wire::client::SurfaceSourceMetalLayer;\nusing SurfaceSourceWaylandSurface = dawn::wire::client::SurfaceSourceWaylandSurface;\nusing SurfaceSourceWindowsHWND = dawn::wire::client::SurfaceSourceWindowsHWND;\nusing SurfaceSourceXlibWindow = dawn::wire::client::SurfaceSourceXlibWindow;\nusing SurfaceTexture = dawn::wire::client::SurfaceTexture;\nusing TextureBindingLayout = dawn::wire::client::TextureBindingLayout;\nusing TextureBindingViewDimensionDescriptor = dawn::wire::client::TextureBindingViewDimensionDescriptor;\nusing TextureDataLayout = dawn::wire::client::TextureDataLayout;\nusing UncapturedErrorCallbackInfo = dawn::wire::client::UncapturedErrorCallbackInfo;\nusing VertexAttribute = dawn::wire::client::VertexAttribute;\nusing YCbCrVkDescriptor = dawn::wire::client::YCbCrVkDescriptor;\nusing AHardwareBufferProperties = dawn::wire::client::AHardwareBufferProperties;\nusing AdapterInfo = dawn::wire::client::AdapterInfo;\nusing AdapterPropertiesMemoryHeaps = dawn::wire::client::AdapterPropertiesMemoryHeaps;\nusing BindGroupDescriptor = dawn::wire::client::BindGroupDescriptor;\nusing BindGroupLayoutEntry = dawn::wire::client::BindGroupLayoutEntry;\nusing BlendState = dawn::wire::client::BlendState;\nusing BufferDescriptor = dawn::wire::client::BufferDescriptor;\nusing CommandBufferDescriptor = dawn::wire::client::CommandBufferDescriptor;\nusing CommandEncoderDescriptor = dawn::wire::client::CommandEncoderDescriptor;\nusing CompilationMessage = dawn::wire::client::CompilationMessage;\nusing ComputePassDescriptor = dawn::wire::client::ComputePassDescriptor;\nusing ConstantEntry = dawn::wire::client::ConstantEntry;\nusing DawnCacheDeviceDescriptor = dawn::wire::client::DawnCacheDeviceDescriptor;\nusing DepthStencilState = dawn::wire::client::DepthStencilState;\nusing DrmFormatCapabilities = dawn::wire::client::DrmFormatCapabilities;\nusing ExternalTextureDescriptor = dawn::wire::client::ExternalTextureDescriptor;\nusing FutureWaitInfo = dawn::wire::client::FutureWaitInfo;\nusing ImageCopyBuffer = dawn::wire::client::ImageCopyBuffer;\nusing ImageCopyExternalTexture = dawn::wire::client::ImageCopyExternalTexture;\nusing ImageCopyTexture = dawn::wire::client::ImageCopyTexture;\nusing InstanceDescriptor = dawn::wire::client::InstanceDescriptor;\nusing PipelineLayoutDescriptor = dawn::wire::client::PipelineLayoutDescriptor;\nusing PipelineLayoutPixelLocalStorage = dawn::wire::client::PipelineLayoutPixelLocalStorage;\nusing QuerySetDescriptor = dawn::wire::client::QuerySetDescriptor;\nusing QueueDescriptor = dawn::wire::client::QueueDescriptor;\nusing RenderBundleDescriptor = dawn::wire::client::RenderBundleDescriptor;\nusing RenderBundleEncoderDescriptor = dawn::wire::client::RenderBundleEncoderDescriptor;\nusing RenderPassColorAttachment = dawn::wire::client::RenderPassColorAttachment;\nusing RenderPassStorageAttachment = dawn::wire::client::RenderPassStorageAttachment;\nusing RequiredLimits = dawn::wire::client::RequiredLimits;\nusing SamplerDescriptor = dawn::wire::client::SamplerDescriptor;\nusing ShaderModuleDescriptor = dawn::wire::client::ShaderModuleDescriptor;\nusing ShaderSourceWGSL = dawn::wire::client::ShaderSourceWGSL;\nusing SharedBufferMemoryDescriptor = dawn::wire::client::SharedBufferMemoryDescriptor;\nusing SharedFenceDescriptor = dawn::wire::client::SharedFenceDescriptor;\nusing SharedTextureMemoryAHardwareBufferProperties = dawn::wire::client::SharedTextureMemoryAHardwareBufferProperties;\nusing SharedTextureMemoryDescriptor = dawn::wire::client::SharedTextureMemoryDescriptor;\nusing SharedTextureMemoryDmaBufDescriptor = dawn::wire::client::SharedTextureMemoryDmaBufDescriptor;\nusing SharedTextureMemoryProperties = dawn::wire::client::SharedTextureMemoryProperties;\nusing SupportedLimits = dawn::wire::client::SupportedLimits;\nusing SurfaceDescriptor = dawn::wire::client::SurfaceDescriptor;\nusing TextureDescriptor = dawn::wire::client::TextureDescriptor;\nusing TextureViewDescriptor = dawn::wire::client::TextureViewDescriptor;\nusing VertexBufferLayout = dawn::wire::client::VertexBufferLayout;\nusing BindGroupLayoutDescriptor = dawn::wire::client::BindGroupLayoutDescriptor;\nusing ColorTargetState = dawn::wire::client::ColorTargetState;\nusing CompilationInfo = dawn::wire::client::CompilationInfo;\nusing ComputeState = dawn::wire::client::ComputeState;\nusing DeviceDescriptor = dawn::wire::client::DeviceDescriptor;\nusing RenderPassDescriptor = dawn::wire::client::RenderPassDescriptor;\nusing RenderPassPixelLocalStorage = dawn::wire::client::RenderPassPixelLocalStorage;\nusing VertexState = dawn::wire::client::VertexState;\nusing ComputePipelineDescriptor = dawn::wire::client::ComputePipelineDescriptor;\nusing FragmentState = dawn::wire::client::FragmentState;\nusing RenderPipelineDescriptor = dawn::wire::client::RenderPipelineDescriptor;\ntemplate <typename... T>\nusing BufferMapCallback2 = typename dawn::wire::client::BufferMapCallback2<T...>;\ntemplate <typename... T>\nusing CompilationInfoCallback2 = typename dawn::wire::client::CompilationInfoCallback2<T...>;\ntemplate <typename... T>\nusing CreateComputePipelineAsyncCallback2 = typename dawn::wire::client::CreateComputePipelineAsyncCallback2<T...>;\ntemplate <typename... T>\nusing CreateRenderPipelineAsyncCallback2 = typename dawn::wire::client::CreateRenderPipelineAsyncCallback2<T...>;\ntemplate <typename... T>\nusing DeviceLostCallback2 = typename dawn::wire::client::DeviceLostCallback2<T...>;\ntemplate <typename... T>\nusing PopErrorScopeCallback2 = typename dawn::wire::client::PopErrorScopeCallback2<T...>;\ntemplate <typename... T>\nusing QueueWorkDoneCallback2 = typename dawn::wire::client::QueueWorkDoneCallback2<T...>;\ntemplate <typename... T>\nusing RequestAdapterCallback2 = typename dawn::wire::client::RequestAdapterCallback2<T...>;\ntemplate <typename... T>\nusing RequestDeviceCallback2 = typename dawn::wire::client::RequestDeviceCallback2<T...>;\ntemplate <typename... T>\nusing UncapturedErrorCallback = typename dawn::wire::client::UncapturedErrorCallback<T...>;\n\n// ProgrammableStageDescriptor is deprecated.\n// Use ComputeState instead.\nusing ProgrammableStageDescriptor = ComputeState;\n// RenderPassDescriptorMaxDrawCount is deprecated.\n// Use RenderPassMaxDrawCount instead.\nusing RenderPassDescriptorMaxDrawCount = RenderPassMaxDrawCount;\n// ShaderModuleSPIRVDescriptor is deprecated.\n// Use ShaderSourceSPIRV instead.\nusing ShaderModuleSPIRVDescriptor = ShaderSourceSPIRV;\n// ShaderModuleWGSLDescriptor is deprecated.\n// Use ShaderSourceWGSL instead.\nusing ShaderModuleWGSLDescriptor = ShaderSourceWGSL;\n// SurfaceDescriptorFromAndroidNativeWindow is deprecated.\n// Use SurfaceSourceAndroidNativeWindow instead.\nusing SurfaceDescriptorFromAndroidNativeWindow = SurfaceSourceAndroidNativeWindow;\n// SurfaceDescriptorFromMetalLayer is deprecated.\n// Use SurfaceSourceMetalLayer instead.\nusing SurfaceDescriptorFromMetalLayer = SurfaceSourceMetalLayer;\n// SurfaceDescriptorFromWaylandSurface is deprecated.\n// Use SurfaceSourceWaylandSurface instead.\nusing SurfaceDescriptorFromWaylandSurface = SurfaceSourceWaylandSurface;\n// SurfaceDescriptorFromWindowsHWND is deprecated.\n// Use SurfaceSourceWindowsHWND instead.\nusing SurfaceDescriptorFromWindowsHWND = SurfaceSourceWindowsHWND;\n// SurfaceDescriptorFromXcbWindow is deprecated.\n// Use SurfaceSourceXCBWindow instead.\nusing SurfaceDescriptorFromXcbWindow = SurfaceSourceXCBWindow;\n// SurfaceDescriptorFromXlibWindow is deprecated.\n// Use SurfaceSourceXlibWindow instead.\nusing SurfaceDescriptorFromXlibWindow = SurfaceSourceXlibWindow;\n\n// Free Functions\nstatic inline Instance CreateInstance(InstanceDescriptor const * descriptor = nullptr) {\n    auto result = wgpuDawnWireClientCreateInstance(reinterpret_cast<WGPUInstanceDescriptor const * >(descriptor));\n    return Instance::Acquire(result);\n}\nstatic inline Status GetInstanceFeatures(InstanceFeatures * features) {\n    auto result = wgpuDawnWireClientGetInstanceFeatures(reinterpret_cast<WGPUInstanceFeatures * >(features));\n    return static_cast<Status>(result);\n}\nstatic inline Proc GetProcAddress(StringView procName) {\n    auto result = wgpuDawnWireClientGetProcAddress(*reinterpret_cast<WGPUStringView const*>(&procName));\n    return reinterpret_cast<Proc>(result);\n}\n\n}  // namespace wgpu\n\nnamespace wgpu {\ntemplate<>\nstruct IsWGPUBitmask<wgpu::BufferUsage> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::ColorWriteMask> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::HeapProperty> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::MapMode> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::ShaderStage> {\n    static constexpr bool enable = true;\n};\n\ntemplate<>\nstruct IsWGPUBitmask<wgpu::TextureUsage> {\n    static constexpr bool enable = true;\n};\n\n} // namespace wgpu\n\nnamespace std {\n// Custom boolean class needs corresponding hash function so that it appears as a transparent bool.\ntemplate <>\nstruct hash<wgpu::Bool> {\n  public:\n    size_t operator()(const wgpu::Bool &v) const {\n        return hash<bool>()(v);\n    }\n};\ntemplate <>\nstruct hash<wgpu::OptionalBool> {\n  public:\n    size_t operator()(const wgpu::OptionalBool &v) const {\n        return hash<WGPUOptionalBool>()(v.mValue);\n    }\n};\n}  // namespace std\n\n#endif // DAWN_WIRE_CLIENT_WEBGPU_CPP_H_\n", "include/dawn/webgpu_cpp_print.h": "// Copyright 2021 The Dawn & Tint Authors\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#ifndef WEBGPU_CPP_PRINT_H_\n#define WEBGPU_CPP_PRINT_H_\n\n#include \"webgpu/webgpu_cpp.h\"\n\n#include <iomanip>\n#include <ios>\n#include <ostream>\n#include <type_traits>\n\nnamespace wgpu {\n\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, WGSLFeatureName value) {\n      switch (value) {\n      case WGSLFeatureName::ReadonlyAndReadwriteStorageTextures:\n        o << \"WGSLFeatureName::ReadonlyAndReadwriteStorageTextures\";\n        break;\n      case WGSLFeatureName::Packed4x8IntegerDotProduct:\n        o << \"WGSLFeatureName::Packed4x8IntegerDotProduct\";\n        break;\n      case WGSLFeatureName::UnrestrictedPointerParameters:\n        o << \"WGSLFeatureName::UnrestrictedPointerParameters\";\n        break;\n      case WGSLFeatureName::PointerCompositeAccess:\n        o << \"WGSLFeatureName::PointerCompositeAccess\";\n        break;\n      case WGSLFeatureName::ChromiumTestingUnimplemented:\n        o << \"WGSLFeatureName::ChromiumTestingUnimplemented\";\n        break;\n      case WGSLFeatureName::ChromiumTestingUnsafeExperimental:\n        o << \"WGSLFeatureName::ChromiumTestingUnsafeExperimental\";\n        break;\n      case WGSLFeatureName::ChromiumTestingExperimental:\n        o << \"WGSLFeatureName::ChromiumTestingExperimental\";\n        break;\n      case WGSLFeatureName::ChromiumTestingShippedWithKillswitch:\n        o << \"WGSLFeatureName::ChromiumTestingShippedWithKillswitch\";\n        break;\n      case WGSLFeatureName::ChromiumTestingShipped:\n        o << \"WGSLFeatureName::ChromiumTestingShipped\";\n        break;\n          default:\n            o << \"WGSLFeatureName::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<WGSLFeatureName>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AdapterType value) {\n      switch (value) {\n      case AdapterType::DiscreteGPU:\n        o << \"AdapterType::DiscreteGPU\";\n        break;\n      case AdapterType::IntegratedGPU:\n        o << \"AdapterType::IntegratedGPU\";\n        break;\n      case AdapterType::CPU:\n        o << \"AdapterType::CPU\";\n        break;\n      case AdapterType::Unknown:\n        o << \"AdapterType::Unknown\";\n        break;\n          default:\n            o << \"AdapterType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AdapterType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AddressMode value) {\n      switch (value) {\n      case AddressMode::Undefined:\n        o << \"AddressMode::Undefined\";\n        break;\n      case AddressMode::ClampToEdge:\n        o << \"AddressMode::ClampToEdge\";\n        break;\n      case AddressMode::Repeat:\n        o << \"AddressMode::Repeat\";\n        break;\n      case AddressMode::MirrorRepeat:\n        o << \"AddressMode::MirrorRepeat\";\n        break;\n          default:\n            o << \"AddressMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AddressMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, AlphaMode value) {\n      switch (value) {\n      case AlphaMode::Opaque:\n        o << \"AlphaMode::Opaque\";\n        break;\n      case AlphaMode::Premultiplied:\n        o << \"AlphaMode::Premultiplied\";\n        break;\n      case AlphaMode::Unpremultiplied:\n        o << \"AlphaMode::Unpremultiplied\";\n        break;\n          default:\n            o << \"AlphaMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<AlphaMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BackendType value) {\n      switch (value) {\n      case BackendType::Undefined:\n        o << \"BackendType::Undefined\";\n        break;\n      case BackendType::Null:\n        o << \"BackendType::Null\";\n        break;\n      case BackendType::WebGPU:\n        o << \"BackendType::WebGPU\";\n        break;\n      case BackendType::D3D11:\n        o << \"BackendType::D3D11\";\n        break;\n      case BackendType::D3D12:\n        o << \"BackendType::D3D12\";\n        break;\n      case BackendType::Metal:\n        o << \"BackendType::Metal\";\n        break;\n      case BackendType::Vulkan:\n        o << \"BackendType::Vulkan\";\n        break;\n      case BackendType::OpenGL:\n        o << \"BackendType::OpenGL\";\n        break;\n      case BackendType::OpenGLES:\n        o << \"BackendType::OpenGLES\";\n        break;\n          default:\n            o << \"BackendType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BackendType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BlendFactor value) {\n      switch (value) {\n      case BlendFactor::Undefined:\n        o << \"BlendFactor::Undefined\";\n        break;\n      case BlendFactor::Zero:\n        o << \"BlendFactor::Zero\";\n        break;\n      case BlendFactor::One:\n        o << \"BlendFactor::One\";\n        break;\n      case BlendFactor::Src:\n        o << \"BlendFactor::Src\";\n        break;\n      case BlendFactor::OneMinusSrc:\n        o << \"BlendFactor::OneMinusSrc\";\n        break;\n      case BlendFactor::SrcAlpha:\n        o << \"BlendFactor::SrcAlpha\";\n        break;\n      case BlendFactor::OneMinusSrcAlpha:\n        o << \"BlendFactor::OneMinusSrcAlpha\";\n        break;\n      case BlendFactor::Dst:\n        o << \"BlendFactor::Dst\";\n        break;\n      case BlendFactor::OneMinusDst:\n        o << \"BlendFactor::OneMinusDst\";\n        break;\n      case BlendFactor::DstAlpha:\n        o << \"BlendFactor::DstAlpha\";\n        break;\n      case BlendFactor::OneMinusDstAlpha:\n        o << \"BlendFactor::OneMinusDstAlpha\";\n        break;\n      case BlendFactor::SrcAlphaSaturated:\n        o << \"BlendFactor::SrcAlphaSaturated\";\n        break;\n      case BlendFactor::Constant:\n        o << \"BlendFactor::Constant\";\n        break;\n      case BlendFactor::OneMinusConstant:\n        o << \"BlendFactor::OneMinusConstant\";\n        break;\n      case BlendFactor::Src1:\n        o << \"BlendFactor::Src1\";\n        break;\n      case BlendFactor::OneMinusSrc1:\n        o << \"BlendFactor::OneMinusSrc1\";\n        break;\n      case BlendFactor::Src1Alpha:\n        o << \"BlendFactor::Src1Alpha\";\n        break;\n      case BlendFactor::OneMinusSrc1Alpha:\n        o << \"BlendFactor::OneMinusSrc1Alpha\";\n        break;\n          default:\n            o << \"BlendFactor::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BlendFactor>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BlendOperation value) {\n      switch (value) {\n      case BlendOperation::Undefined:\n        o << \"BlendOperation::Undefined\";\n        break;\n      case BlendOperation::Add:\n        o << \"BlendOperation::Add\";\n        break;\n      case BlendOperation::Subtract:\n        o << \"BlendOperation::Subtract\";\n        break;\n      case BlendOperation::ReverseSubtract:\n        o << \"BlendOperation::ReverseSubtract\";\n        break;\n      case BlendOperation::Min:\n        o << \"BlendOperation::Min\";\n        break;\n      case BlendOperation::Max:\n        o << \"BlendOperation::Max\";\n        break;\n          default:\n            o << \"BlendOperation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BlendOperation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferBindingType value) {\n      switch (value) {\n      case BufferBindingType::BindingNotUsed:\n        o << \"BufferBindingType::BindingNotUsed\";\n        break;\n      case BufferBindingType::Uniform:\n        o << \"BufferBindingType::Uniform\";\n        break;\n      case BufferBindingType::Storage:\n        o << \"BufferBindingType::Storage\";\n        break;\n      case BufferBindingType::ReadOnlyStorage:\n        o << \"BufferBindingType::ReadOnlyStorage\";\n        break;\n          default:\n            o << \"BufferBindingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferBindingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferMapAsyncStatus value) {\n      switch (value) {\n      case BufferMapAsyncStatus::Success:\n        o << \"BufferMapAsyncStatus::Success\";\n        break;\n      case BufferMapAsyncStatus::InstanceDropped:\n        o << \"BufferMapAsyncStatus::InstanceDropped\";\n        break;\n      case BufferMapAsyncStatus::ValidationError:\n        o << \"BufferMapAsyncStatus::ValidationError\";\n        break;\n      case BufferMapAsyncStatus::Unknown:\n        o << \"BufferMapAsyncStatus::Unknown\";\n        break;\n      case BufferMapAsyncStatus::DeviceLost:\n        o << \"BufferMapAsyncStatus::DeviceLost\";\n        break;\n      case BufferMapAsyncStatus::DestroyedBeforeCallback:\n        o << \"BufferMapAsyncStatus::DestroyedBeforeCallback\";\n        break;\n      case BufferMapAsyncStatus::UnmappedBeforeCallback:\n        o << \"BufferMapAsyncStatus::UnmappedBeforeCallback\";\n        break;\n      case BufferMapAsyncStatus::MappingAlreadyPending:\n        o << \"BufferMapAsyncStatus::MappingAlreadyPending\";\n        break;\n      case BufferMapAsyncStatus::OffsetOutOfRange:\n        o << \"BufferMapAsyncStatus::OffsetOutOfRange\";\n        break;\n      case BufferMapAsyncStatus::SizeOutOfRange:\n        o << \"BufferMapAsyncStatus::SizeOutOfRange\";\n        break;\n          default:\n            o << \"BufferMapAsyncStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferMapAsyncStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferMapState value) {\n      switch (value) {\n      case BufferMapState::Unmapped:\n        o << \"BufferMapState::Unmapped\";\n        break;\n      case BufferMapState::Pending:\n        o << \"BufferMapState::Pending\";\n        break;\n      case BufferMapState::Mapped:\n        o << \"BufferMapState::Mapped\";\n        break;\n          default:\n            o << \"BufferMapState::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferMapState>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CallbackMode value) {\n      switch (value) {\n      case CallbackMode::WaitAnyOnly:\n        o << \"CallbackMode::WaitAnyOnly\";\n        break;\n      case CallbackMode::AllowProcessEvents:\n        o << \"CallbackMode::AllowProcessEvents\";\n        break;\n      case CallbackMode::AllowSpontaneous:\n        o << \"CallbackMode::AllowSpontaneous\";\n        break;\n          default:\n            o << \"CallbackMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CallbackMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompareFunction value) {\n      switch (value) {\n      case CompareFunction::Undefined:\n        o << \"CompareFunction::Undefined\";\n        break;\n      case CompareFunction::Never:\n        o << \"CompareFunction::Never\";\n        break;\n      case CompareFunction::Less:\n        o << \"CompareFunction::Less\";\n        break;\n      case CompareFunction::Equal:\n        o << \"CompareFunction::Equal\";\n        break;\n      case CompareFunction::LessEqual:\n        o << \"CompareFunction::LessEqual\";\n        break;\n      case CompareFunction::Greater:\n        o << \"CompareFunction::Greater\";\n        break;\n      case CompareFunction::NotEqual:\n        o << \"CompareFunction::NotEqual\";\n        break;\n      case CompareFunction::GreaterEqual:\n        o << \"CompareFunction::GreaterEqual\";\n        break;\n      case CompareFunction::Always:\n        o << \"CompareFunction::Always\";\n        break;\n          default:\n            o << \"CompareFunction::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompareFunction>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompilationInfoRequestStatus value) {\n      switch (value) {\n      case CompilationInfoRequestStatus::Success:\n        o << \"CompilationInfoRequestStatus::Success\";\n        break;\n      case CompilationInfoRequestStatus::InstanceDropped:\n        o << \"CompilationInfoRequestStatus::InstanceDropped\";\n        break;\n      case CompilationInfoRequestStatus::Error:\n        o << \"CompilationInfoRequestStatus::Error\";\n        break;\n      case CompilationInfoRequestStatus::DeviceLost:\n        o << \"CompilationInfoRequestStatus::DeviceLost\";\n        break;\n      case CompilationInfoRequestStatus::Unknown:\n        o << \"CompilationInfoRequestStatus::Unknown\";\n        break;\n          default:\n            o << \"CompilationInfoRequestStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompilationInfoRequestStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompilationMessageType value) {\n      switch (value) {\n      case CompilationMessageType::Error:\n        o << \"CompilationMessageType::Error\";\n        break;\n      case CompilationMessageType::Warning:\n        o << \"CompilationMessageType::Warning\";\n        break;\n      case CompilationMessageType::Info:\n        o << \"CompilationMessageType::Info\";\n        break;\n          default:\n            o << \"CompilationMessageType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompilationMessageType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CompositeAlphaMode value) {\n      switch (value) {\n      case CompositeAlphaMode::Auto:\n        o << \"CompositeAlphaMode::Auto\";\n        break;\n      case CompositeAlphaMode::Opaque:\n        o << \"CompositeAlphaMode::Opaque\";\n        break;\n      case CompositeAlphaMode::Premultiplied:\n        o << \"CompositeAlphaMode::Premultiplied\";\n        break;\n      case CompositeAlphaMode::Unpremultiplied:\n        o << \"CompositeAlphaMode::Unpremultiplied\";\n        break;\n      case CompositeAlphaMode::Inherit:\n        o << \"CompositeAlphaMode::Inherit\";\n        break;\n          default:\n            o << \"CompositeAlphaMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CompositeAlphaMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CreatePipelineAsyncStatus value) {\n      switch (value) {\n      case CreatePipelineAsyncStatus::Success:\n        o << \"CreatePipelineAsyncStatus::Success\";\n        break;\n      case CreatePipelineAsyncStatus::InstanceDropped:\n        o << \"CreatePipelineAsyncStatus::InstanceDropped\";\n        break;\n      case CreatePipelineAsyncStatus::ValidationError:\n        o << \"CreatePipelineAsyncStatus::ValidationError\";\n        break;\n      case CreatePipelineAsyncStatus::InternalError:\n        o << \"CreatePipelineAsyncStatus::InternalError\";\n        break;\n      case CreatePipelineAsyncStatus::DeviceLost:\n        o << \"CreatePipelineAsyncStatus::DeviceLost\";\n        break;\n      case CreatePipelineAsyncStatus::DeviceDestroyed:\n        o << \"CreatePipelineAsyncStatus::DeviceDestroyed\";\n        break;\n      case CreatePipelineAsyncStatus::Unknown:\n        o << \"CreatePipelineAsyncStatus::Unknown\";\n        break;\n          default:\n            o << \"CreatePipelineAsyncStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CreatePipelineAsyncStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, CullMode value) {\n      switch (value) {\n      case CullMode::Undefined:\n        o << \"CullMode::Undefined\";\n        break;\n      case CullMode::None:\n        o << \"CullMode::None\";\n        break;\n      case CullMode::Front:\n        o << \"CullMode::Front\";\n        break;\n      case CullMode::Back:\n        o << \"CullMode::Back\";\n        break;\n          default:\n            o << \"CullMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<CullMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, DeviceLostReason value) {\n      switch (value) {\n      case DeviceLostReason::Unknown:\n        o << \"DeviceLostReason::Unknown\";\n        break;\n      case DeviceLostReason::Destroyed:\n        o << \"DeviceLostReason::Destroyed\";\n        break;\n      case DeviceLostReason::InstanceDropped:\n        o << \"DeviceLostReason::InstanceDropped\";\n        break;\n      case DeviceLostReason::FailedCreation:\n        o << \"DeviceLostReason::FailedCreation\";\n        break;\n          default:\n            o << \"DeviceLostReason::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<DeviceLostReason>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ErrorFilter value) {\n      switch (value) {\n      case ErrorFilter::Validation:\n        o << \"ErrorFilter::Validation\";\n        break;\n      case ErrorFilter::OutOfMemory:\n        o << \"ErrorFilter::OutOfMemory\";\n        break;\n      case ErrorFilter::Internal:\n        o << \"ErrorFilter::Internal\";\n        break;\n          default:\n            o << \"ErrorFilter::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ErrorFilter>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ErrorType value) {\n      switch (value) {\n      case ErrorType::NoError:\n        o << \"ErrorType::NoError\";\n        break;\n      case ErrorType::Validation:\n        o << \"ErrorType::Validation\";\n        break;\n      case ErrorType::OutOfMemory:\n        o << \"ErrorType::OutOfMemory\";\n        break;\n      case ErrorType::Internal:\n        o << \"ErrorType::Internal\";\n        break;\n      case ErrorType::Unknown:\n        o << \"ErrorType::Unknown\";\n        break;\n      case ErrorType::DeviceLost:\n        o << \"ErrorType::DeviceLost\";\n        break;\n          default:\n            o << \"ErrorType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ErrorType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ExternalTextureRotation value) {\n      switch (value) {\n      case ExternalTextureRotation::Rotate0Degrees:\n        o << \"ExternalTextureRotation::Rotate0Degrees\";\n        break;\n      case ExternalTextureRotation::Rotate90Degrees:\n        o << \"ExternalTextureRotation::Rotate90Degrees\";\n        break;\n      case ExternalTextureRotation::Rotate180Degrees:\n        o << \"ExternalTextureRotation::Rotate180Degrees\";\n        break;\n      case ExternalTextureRotation::Rotate270Degrees:\n        o << \"ExternalTextureRotation::Rotate270Degrees\";\n        break;\n          default:\n            o << \"ExternalTextureRotation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ExternalTextureRotation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FeatureName value) {\n      switch (value) {\n      case FeatureName::DepthClipControl:\n        o << \"FeatureName::DepthClipControl\";\n        break;\n      case FeatureName::Depth32FloatStencil8:\n        o << \"FeatureName::Depth32FloatStencil8\";\n        break;\n      case FeatureName::TimestampQuery:\n        o << \"FeatureName::TimestampQuery\";\n        break;\n      case FeatureName::TextureCompressionBC:\n        o << \"FeatureName::TextureCompressionBC\";\n        break;\n      case FeatureName::TextureCompressionETC2:\n        o << \"FeatureName::TextureCompressionETC2\";\n        break;\n      case FeatureName::TextureCompressionASTC:\n        o << \"FeatureName::TextureCompressionASTC\";\n        break;\n      case FeatureName::IndirectFirstInstance:\n        o << \"FeatureName::IndirectFirstInstance\";\n        break;\n      case FeatureName::ShaderF16:\n        o << \"FeatureName::ShaderF16\";\n        break;\n      case FeatureName::RG11B10UfloatRenderable:\n        o << \"FeatureName::RG11B10UfloatRenderable\";\n        break;\n      case FeatureName::BGRA8UnormStorage:\n        o << \"FeatureName::BGRA8UnormStorage\";\n        break;\n      case FeatureName::Float32Filterable:\n        o << \"FeatureName::Float32Filterable\";\n        break;\n      case FeatureName::Float32Blendable:\n        o << \"FeatureName::Float32Blendable\";\n        break;\n      case FeatureName::Subgroups:\n        o << \"FeatureName::Subgroups\";\n        break;\n      case FeatureName::SubgroupsF16:\n        o << \"FeatureName::SubgroupsF16\";\n        break;\n      case FeatureName::DawnInternalUsages:\n        o << \"FeatureName::DawnInternalUsages\";\n        break;\n      case FeatureName::DawnMultiPlanarFormats:\n        o << \"FeatureName::DawnMultiPlanarFormats\";\n        break;\n      case FeatureName::DawnNative:\n        o << \"FeatureName::DawnNative\";\n        break;\n      case FeatureName::ChromiumExperimentalTimestampQueryInsidePasses:\n        o << \"FeatureName::ChromiumExperimentalTimestampQueryInsidePasses\";\n        break;\n      case FeatureName::ImplicitDeviceSynchronization:\n        o << \"FeatureName::ImplicitDeviceSynchronization\";\n        break;\n      case FeatureName::ChromiumExperimentalImmediateData:\n        o << \"FeatureName::ChromiumExperimentalImmediateData\";\n        break;\n      case FeatureName::TransientAttachments:\n        o << \"FeatureName::TransientAttachments\";\n        break;\n      case FeatureName::MSAARenderToSingleSampled:\n        o << \"FeatureName::MSAARenderToSingleSampled\";\n        break;\n      case FeatureName::DualSourceBlending:\n        o << \"FeatureName::DualSourceBlending\";\n        break;\n      case FeatureName::D3D11MultithreadProtected:\n        o << \"FeatureName::D3D11MultithreadProtected\";\n        break;\n      case FeatureName::ANGLETextureSharing:\n        o << \"FeatureName::ANGLETextureSharing\";\n        break;\n      case FeatureName::PixelLocalStorageCoherent:\n        o << \"FeatureName::PixelLocalStorageCoherent\";\n        break;\n      case FeatureName::PixelLocalStorageNonCoherent:\n        o << \"FeatureName::PixelLocalStorageNonCoherent\";\n        break;\n      case FeatureName::Unorm16TextureFormats:\n        o << \"FeatureName::Unorm16TextureFormats\";\n        break;\n      case FeatureName::Snorm16TextureFormats:\n        o << \"FeatureName::Snorm16TextureFormats\";\n        break;\n      case FeatureName::MultiPlanarFormatExtendedUsages:\n        o << \"FeatureName::MultiPlanarFormatExtendedUsages\";\n        break;\n      case FeatureName::MultiPlanarFormatP010:\n        o << \"FeatureName::MultiPlanarFormatP010\";\n        break;\n      case FeatureName::HostMappedPointer:\n        o << \"FeatureName::HostMappedPointer\";\n        break;\n      case FeatureName::MultiPlanarRenderTargets:\n        o << \"FeatureName::MultiPlanarRenderTargets\";\n        break;\n      case FeatureName::MultiPlanarFormatNv12a:\n        o << \"FeatureName::MultiPlanarFormatNv12a\";\n        break;\n      case FeatureName::FramebufferFetch:\n        o << \"FeatureName::FramebufferFetch\";\n        break;\n      case FeatureName::BufferMapExtendedUsages:\n        o << \"FeatureName::BufferMapExtendedUsages\";\n        break;\n      case FeatureName::AdapterPropertiesMemoryHeaps:\n        o << \"FeatureName::AdapterPropertiesMemoryHeaps\";\n        break;\n      case FeatureName::AdapterPropertiesD3D:\n        o << \"FeatureName::AdapterPropertiesD3D\";\n        break;\n      case FeatureName::AdapterPropertiesVk:\n        o << \"FeatureName::AdapterPropertiesVk\";\n        break;\n      case FeatureName::R8UnormStorage:\n        o << \"FeatureName::R8UnormStorage\";\n        break;\n      case FeatureName::FormatCapabilities:\n        o << \"FeatureName::FormatCapabilities\";\n        break;\n      case FeatureName::DrmFormatCapabilities:\n        o << \"FeatureName::DrmFormatCapabilities\";\n        break;\n      case FeatureName::Norm16TextureFormats:\n        o << \"FeatureName::Norm16TextureFormats\";\n        break;\n      case FeatureName::MultiPlanarFormatNv16:\n        o << \"FeatureName::MultiPlanarFormatNv16\";\n        break;\n      case FeatureName::MultiPlanarFormatNv24:\n        o << \"FeatureName::MultiPlanarFormatNv24\";\n        break;\n      case FeatureName::MultiPlanarFormatP210:\n        o << \"FeatureName::MultiPlanarFormatP210\";\n        break;\n      case FeatureName::MultiPlanarFormatP410:\n        o << \"FeatureName::MultiPlanarFormatP410\";\n        break;\n      case FeatureName::SharedTextureMemoryVkDedicatedAllocation:\n        o << \"FeatureName::SharedTextureMemoryVkDedicatedAllocation\";\n        break;\n      case FeatureName::SharedTextureMemoryAHardwareBuffer:\n        o << \"FeatureName::SharedTextureMemoryAHardwareBuffer\";\n        break;\n      case FeatureName::SharedTextureMemoryDmaBuf:\n        o << \"FeatureName::SharedTextureMemoryDmaBuf\";\n        break;\n      case FeatureName::SharedTextureMemoryOpaqueFD:\n        o << \"FeatureName::SharedTextureMemoryOpaqueFD\";\n        break;\n      case FeatureName::SharedTextureMemoryZirconHandle:\n        o << \"FeatureName::SharedTextureMemoryZirconHandle\";\n        break;\n      case FeatureName::SharedTextureMemoryDXGISharedHandle:\n        o << \"FeatureName::SharedTextureMemoryDXGISharedHandle\";\n        break;\n      case FeatureName::SharedTextureMemoryD3D11Texture2D:\n        o << \"FeatureName::SharedTextureMemoryD3D11Texture2D\";\n        break;\n      case FeatureName::SharedTextureMemoryIOSurface:\n        o << \"FeatureName::SharedTextureMemoryIOSurface\";\n        break;\n      case FeatureName::SharedTextureMemoryEGLImage:\n        o << \"FeatureName::SharedTextureMemoryEGLImage\";\n        break;\n      case FeatureName::SharedFenceVkSemaphoreOpaqueFD:\n        o << \"FeatureName::SharedFenceVkSemaphoreOpaqueFD\";\n        break;\n      case FeatureName::SharedFenceSyncFD:\n        o << \"FeatureName::SharedFenceSyncFD\";\n        break;\n      case FeatureName::SharedFenceVkSemaphoreZirconHandle:\n        o << \"FeatureName::SharedFenceVkSemaphoreZirconHandle\";\n        break;\n      case FeatureName::SharedFenceDXGISharedHandle:\n        o << \"FeatureName::SharedFenceDXGISharedHandle\";\n        break;\n      case FeatureName::SharedFenceMTLSharedEvent:\n        o << \"FeatureName::SharedFenceMTLSharedEvent\";\n        break;\n      case FeatureName::SharedBufferMemoryD3D12Resource:\n        o << \"FeatureName::SharedBufferMemoryD3D12Resource\";\n        break;\n      case FeatureName::StaticSamplers:\n        o << \"FeatureName::StaticSamplers\";\n        break;\n      case FeatureName::YCbCrVulkanSamplers:\n        o << \"FeatureName::YCbCrVulkanSamplers\";\n        break;\n      case FeatureName::ShaderModuleCompilationOptions:\n        o << \"FeatureName::ShaderModuleCompilationOptions\";\n        break;\n      case FeatureName::DawnLoadResolveTexture:\n        o << \"FeatureName::DawnLoadResolveTexture\";\n        break;\n      case FeatureName::DawnPartialLoadResolveTexture:\n        o << \"FeatureName::DawnPartialLoadResolveTexture\";\n        break;\n      case FeatureName::MultiDrawIndirect:\n        o << \"FeatureName::MultiDrawIndirect\";\n        break;\n      case FeatureName::ClipDistances:\n        o << \"FeatureName::ClipDistances\";\n        break;\n      case FeatureName::DawnTexelCopyBufferRowAlignment:\n        o << \"FeatureName::DawnTexelCopyBufferRowAlignment\";\n        break;\n          default:\n            o << \"FeatureName::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FeatureName>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FilterMode value) {\n      switch (value) {\n      case FilterMode::Undefined:\n        o << \"FilterMode::Undefined\";\n        break;\n      case FilterMode::Nearest:\n        o << \"FilterMode::Nearest\";\n        break;\n      case FilterMode::Linear:\n        o << \"FilterMode::Linear\";\n        break;\n          default:\n            o << \"FilterMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FilterMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, FrontFace value) {\n      switch (value) {\n      case FrontFace::Undefined:\n        o << \"FrontFace::Undefined\";\n        break;\n      case FrontFace::CCW:\n        o << \"FrontFace::CCW\";\n        break;\n      case FrontFace::CW:\n        o << \"FrontFace::CW\";\n        break;\n          default:\n            o << \"FrontFace::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<FrontFace>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, IndexFormat value) {\n      switch (value) {\n      case IndexFormat::Undefined:\n        o << \"IndexFormat::Undefined\";\n        break;\n      case IndexFormat::Uint16:\n        o << \"IndexFormat::Uint16\";\n        break;\n      case IndexFormat::Uint32:\n        o << \"IndexFormat::Uint32\";\n        break;\n          default:\n            o << \"IndexFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<IndexFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, LoadOp value) {\n      switch (value) {\n      case LoadOp::Undefined:\n        o << \"LoadOp::Undefined\";\n        break;\n      case LoadOp::Load:\n        o << \"LoadOp::Load\";\n        break;\n      case LoadOp::Clear:\n        o << \"LoadOp::Clear\";\n        break;\n      case LoadOp::ExpandResolveTexture:\n        o << \"LoadOp::ExpandResolveTexture\";\n        break;\n          default:\n            o << \"LoadOp::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<LoadOp>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, LoggingType value) {\n      switch (value) {\n      case LoggingType::Verbose:\n        o << \"LoggingType::Verbose\";\n        break;\n      case LoggingType::Info:\n        o << \"LoggingType::Info\";\n        break;\n      case LoggingType::Warning:\n        o << \"LoggingType::Warning\";\n        break;\n      case LoggingType::Error:\n        o << \"LoggingType::Error\";\n        break;\n          default:\n            o << \"LoggingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<LoggingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, MapAsyncStatus value) {\n      switch (value) {\n      case MapAsyncStatus::Success:\n        o << \"MapAsyncStatus::Success\";\n        break;\n      case MapAsyncStatus::InstanceDropped:\n        o << \"MapAsyncStatus::InstanceDropped\";\n        break;\n      case MapAsyncStatus::Error:\n        o << \"MapAsyncStatus::Error\";\n        break;\n      case MapAsyncStatus::Aborted:\n        o << \"MapAsyncStatus::Aborted\";\n        break;\n      case MapAsyncStatus::Unknown:\n        o << \"MapAsyncStatus::Unknown\";\n        break;\n          default:\n            o << \"MapAsyncStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<MapAsyncStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, MipmapFilterMode value) {\n      switch (value) {\n      case MipmapFilterMode::Undefined:\n        o << \"MipmapFilterMode::Undefined\";\n        break;\n      case MipmapFilterMode::Nearest:\n        o << \"MipmapFilterMode::Nearest\";\n        break;\n      case MipmapFilterMode::Linear:\n        o << \"MipmapFilterMode::Linear\";\n        break;\n          default:\n            o << \"MipmapFilterMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<MipmapFilterMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PopErrorScopeStatus value) {\n      switch (value) {\n      case PopErrorScopeStatus::Success:\n        o << \"PopErrorScopeStatus::Success\";\n        break;\n      case PopErrorScopeStatus::InstanceDropped:\n        o << \"PopErrorScopeStatus::InstanceDropped\";\n        break;\n          default:\n            o << \"PopErrorScopeStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PopErrorScopeStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PowerPreference value) {\n      switch (value) {\n      case PowerPreference::Undefined:\n        o << \"PowerPreference::Undefined\";\n        break;\n      case PowerPreference::LowPower:\n        o << \"PowerPreference::LowPower\";\n        break;\n      case PowerPreference::HighPerformance:\n        o << \"PowerPreference::HighPerformance\";\n        break;\n          default:\n            o << \"PowerPreference::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PowerPreference>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PresentMode value) {\n      switch (value) {\n      case PresentMode::Fifo:\n        o << \"PresentMode::Fifo\";\n        break;\n      case PresentMode::FifoRelaxed:\n        o << \"PresentMode::FifoRelaxed\";\n        break;\n      case PresentMode::Immediate:\n        o << \"PresentMode::Immediate\";\n        break;\n      case PresentMode::Mailbox:\n        o << \"PresentMode::Mailbox\";\n        break;\n          default:\n            o << \"PresentMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PresentMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, PrimitiveTopology value) {\n      switch (value) {\n      case PrimitiveTopology::Undefined:\n        o << \"PrimitiveTopology::Undefined\";\n        break;\n      case PrimitiveTopology::PointList:\n        o << \"PrimitiveTopology::PointList\";\n        break;\n      case PrimitiveTopology::LineList:\n        o << \"PrimitiveTopology::LineList\";\n        break;\n      case PrimitiveTopology::LineStrip:\n        o << \"PrimitiveTopology::LineStrip\";\n        break;\n      case PrimitiveTopology::TriangleList:\n        o << \"PrimitiveTopology::TriangleList\";\n        break;\n      case PrimitiveTopology::TriangleStrip:\n        o << \"PrimitiveTopology::TriangleStrip\";\n        break;\n          default:\n            o << \"PrimitiveTopology::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<PrimitiveTopology>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, QueryType value) {\n      switch (value) {\n      case QueryType::Occlusion:\n        o << \"QueryType::Occlusion\";\n        break;\n      case QueryType::Timestamp:\n        o << \"QueryType::Timestamp\";\n        break;\n          default:\n            o << \"QueryType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<QueryType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, QueueWorkDoneStatus value) {\n      switch (value) {\n      case QueueWorkDoneStatus::Success:\n        o << \"QueueWorkDoneStatus::Success\";\n        break;\n      case QueueWorkDoneStatus::InstanceDropped:\n        o << \"QueueWorkDoneStatus::InstanceDropped\";\n        break;\n      case QueueWorkDoneStatus::Error:\n        o << \"QueueWorkDoneStatus::Error\";\n        break;\n      case QueueWorkDoneStatus::Unknown:\n        o << \"QueueWorkDoneStatus::Unknown\";\n        break;\n      case QueueWorkDoneStatus::DeviceLost:\n        o << \"QueueWorkDoneStatus::DeviceLost\";\n        break;\n          default:\n            o << \"QueueWorkDoneStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<QueueWorkDoneStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RequestAdapterStatus value) {\n      switch (value) {\n      case RequestAdapterStatus::Success:\n        o << \"RequestAdapterStatus::Success\";\n        break;\n      case RequestAdapterStatus::InstanceDropped:\n        o << \"RequestAdapterStatus::InstanceDropped\";\n        break;\n      case RequestAdapterStatus::Unavailable:\n        o << \"RequestAdapterStatus::Unavailable\";\n        break;\n      case RequestAdapterStatus::Error:\n        o << \"RequestAdapterStatus::Error\";\n        break;\n      case RequestAdapterStatus::Unknown:\n        o << \"RequestAdapterStatus::Unknown\";\n        break;\n          default:\n            o << \"RequestAdapterStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RequestAdapterStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, RequestDeviceStatus value) {\n      switch (value) {\n      case RequestDeviceStatus::Success:\n        o << \"RequestDeviceStatus::Success\";\n        break;\n      case RequestDeviceStatus::InstanceDropped:\n        o << \"RequestDeviceStatus::InstanceDropped\";\n        break;\n      case RequestDeviceStatus::Error:\n        o << \"RequestDeviceStatus::Error\";\n        break;\n      case RequestDeviceStatus::Unknown:\n        o << \"RequestDeviceStatus::Unknown\";\n        break;\n          default:\n            o << \"RequestDeviceStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<RequestDeviceStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SType value) {\n      switch (value) {\n      case SType::ShaderSourceSPIRV:\n        o << \"SType::ShaderSourceSPIRV\";\n        break;\n      case SType::ShaderSourceWGSL:\n        o << \"SType::ShaderSourceWGSL\";\n        break;\n      case SType::RenderPassMaxDrawCount:\n        o << \"SType::RenderPassMaxDrawCount\";\n        break;\n      case SType::SurfaceSourceMetalLayer:\n        o << \"SType::SurfaceSourceMetalLayer\";\n        break;\n      case SType::SurfaceSourceWindowsHWND:\n        o << \"SType::SurfaceSourceWindowsHWND\";\n        break;\n      case SType::SurfaceSourceXlibWindow:\n        o << \"SType::SurfaceSourceXlibWindow\";\n        break;\n      case SType::SurfaceSourceWaylandSurface:\n        o << \"SType::SurfaceSourceWaylandSurface\";\n        break;\n      case SType::SurfaceSourceAndroidNativeWindow:\n        o << \"SType::SurfaceSourceAndroidNativeWindow\";\n        break;\n      case SType::SurfaceSourceXCBWindow:\n        o << \"SType::SurfaceSourceXCBWindow\";\n        break;\n      case SType::AdapterPropertiesSubgroups:\n        o << \"SType::AdapterPropertiesSubgroups\";\n        break;\n      case SType::TextureBindingViewDimensionDescriptor:\n        o << \"SType::TextureBindingViewDimensionDescriptor\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsCoreWindow:\n        o << \"SType::SurfaceDescriptorFromWindowsCoreWindow\";\n        break;\n      case SType::ExternalTextureBindingEntry:\n        o << \"SType::ExternalTextureBindingEntry\";\n        break;\n      case SType::ExternalTextureBindingLayout:\n        o << \"SType::ExternalTextureBindingLayout\";\n        break;\n      case SType::SurfaceDescriptorFromWindowsSwapChainPanel:\n        o << \"SType::SurfaceDescriptorFromWindowsSwapChainPanel\";\n        break;\n      case SType::DawnTextureInternalUsageDescriptor:\n        o << \"SType::DawnTextureInternalUsageDescriptor\";\n        break;\n      case SType::DawnEncoderInternalUsageDescriptor:\n        o << \"SType::DawnEncoderInternalUsageDescriptor\";\n        break;\n      case SType::DawnInstanceDescriptor:\n        o << \"SType::DawnInstanceDescriptor\";\n        break;\n      case SType::DawnCacheDeviceDescriptor:\n        o << \"SType::DawnCacheDeviceDescriptor\";\n        break;\n      case SType::DawnAdapterPropertiesPowerPreference:\n        o << \"SType::DawnAdapterPropertiesPowerPreference\";\n        break;\n      case SType::DawnBufferDescriptorErrorInfoFromWireClient:\n        o << \"SType::DawnBufferDescriptorErrorInfoFromWireClient\";\n        break;\n      case SType::DawnTogglesDescriptor:\n        o << \"SType::DawnTogglesDescriptor\";\n        break;\n      case SType::DawnShaderModuleSPIRVOptionsDescriptor:\n        o << \"SType::DawnShaderModuleSPIRVOptionsDescriptor\";\n        break;\n      case SType::RequestAdapterOptionsLUID:\n        o << \"SType::RequestAdapterOptionsLUID\";\n        break;\n      case SType::RequestAdapterOptionsGetGLProc:\n        o << \"SType::RequestAdapterOptionsGetGLProc\";\n        break;\n      case SType::RequestAdapterOptionsD3D11Device:\n        o << \"SType::RequestAdapterOptionsD3D11Device\";\n        break;\n      case SType::DawnRenderPassColorAttachmentRenderToSingleSampled:\n        o << \"SType::DawnRenderPassColorAttachmentRenderToSingleSampled\";\n        break;\n      case SType::RenderPassPixelLocalStorage:\n        o << \"SType::RenderPassPixelLocalStorage\";\n        break;\n      case SType::PipelineLayoutPixelLocalStorage:\n        o << \"SType::PipelineLayoutPixelLocalStorage\";\n        break;\n      case SType::BufferHostMappedPointer:\n        o << \"SType::BufferHostMappedPointer\";\n        break;\n      case SType::DawnExperimentalSubgroupLimits:\n        o << \"SType::DawnExperimentalSubgroupLimits\";\n        break;\n      case SType::AdapterPropertiesMemoryHeaps:\n        o << \"SType::AdapterPropertiesMemoryHeaps\";\n        break;\n      case SType::AdapterPropertiesD3D:\n        o << \"SType::AdapterPropertiesD3D\";\n        break;\n      case SType::AdapterPropertiesVk:\n        o << \"SType::AdapterPropertiesVk\";\n        break;\n      case SType::DawnWireWGSLControl:\n        o << \"SType::DawnWireWGSLControl\";\n        break;\n      case SType::DawnWGSLBlocklist:\n        o << \"SType::DawnWGSLBlocklist\";\n        break;\n      case SType::DrmFormatCapabilities:\n        o << \"SType::DrmFormatCapabilities\";\n        break;\n      case SType::ShaderModuleCompilationOptions:\n        o << \"SType::ShaderModuleCompilationOptions\";\n        break;\n      case SType::ColorTargetStateExpandResolveTextureDawn:\n        o << \"SType::ColorTargetStateExpandResolveTextureDawn\";\n        break;\n      case SType::RenderPassDescriptorExpandResolveRect:\n        o << \"SType::RenderPassDescriptorExpandResolveRect\";\n        break;\n      case SType::SharedTextureMemoryVkDedicatedAllocationDescriptor:\n        o << \"SType::SharedTextureMemoryVkDedicatedAllocationDescriptor\";\n        break;\n      case SType::SharedTextureMemoryAHardwareBufferDescriptor:\n        o << \"SType::SharedTextureMemoryAHardwareBufferDescriptor\";\n        break;\n      case SType::SharedTextureMemoryDmaBufDescriptor:\n        o << \"SType::SharedTextureMemoryDmaBufDescriptor\";\n        break;\n      case SType::SharedTextureMemoryOpaqueFDDescriptor:\n        o << \"SType::SharedTextureMemoryOpaqueFDDescriptor\";\n        break;\n      case SType::SharedTextureMemoryZirconHandleDescriptor:\n        o << \"SType::SharedTextureMemoryZirconHandleDescriptor\";\n        break;\n      case SType::SharedTextureMemoryDXGISharedHandleDescriptor:\n        o << \"SType::SharedTextureMemoryDXGISharedHandleDescriptor\";\n        break;\n      case SType::SharedTextureMemoryD3D11Texture2DDescriptor:\n        o << \"SType::SharedTextureMemoryD3D11Texture2DDescriptor\";\n        break;\n      case SType::SharedTextureMemoryIOSurfaceDescriptor:\n        o << \"SType::SharedTextureMemoryIOSurfaceDescriptor\";\n        break;\n      case SType::SharedTextureMemoryEGLImageDescriptor:\n        o << \"SType::SharedTextureMemoryEGLImageDescriptor\";\n        break;\n      case SType::SharedTextureMemoryInitializedBeginState:\n        o << \"SType::SharedTextureMemoryInitializedBeginState\";\n        break;\n      case SType::SharedTextureMemoryInitializedEndState:\n        o << \"SType::SharedTextureMemoryInitializedEndState\";\n        break;\n      case SType::SharedTextureMemoryVkImageLayoutBeginState:\n        o << \"SType::SharedTextureMemoryVkImageLayoutBeginState\";\n        break;\n      case SType::SharedTextureMemoryVkImageLayoutEndState:\n        o << \"SType::SharedTextureMemoryVkImageLayoutEndState\";\n        break;\n      case SType::SharedTextureMemoryD3DSwapchainBeginState:\n        o << \"SType::SharedTextureMemoryD3DSwapchainBeginState\";\n        break;\n      case SType::SharedFenceVkSemaphoreOpaqueFDDescriptor:\n        o << \"SType::SharedFenceVkSemaphoreOpaqueFDDescriptor\";\n        break;\n      case SType::SharedFenceVkSemaphoreOpaqueFDExportInfo:\n        o << \"SType::SharedFenceVkSemaphoreOpaqueFDExportInfo\";\n        break;\n      case SType::SharedFenceSyncFDDescriptor:\n        o << \"SType::SharedFenceSyncFDDescriptor\";\n        break;\n      case SType::SharedFenceSyncFDExportInfo:\n        o << \"SType::SharedFenceSyncFDExportInfo\";\n        break;\n      case SType::SharedFenceVkSemaphoreZirconHandleDescriptor:\n        o << \"SType::SharedFenceVkSemaphoreZirconHandleDescriptor\";\n        break;\n      case SType::SharedFenceVkSemaphoreZirconHandleExportInfo:\n        o << \"SType::SharedFenceVkSemaphoreZirconHandleExportInfo\";\n        break;\n      case SType::SharedFenceDXGISharedHandleDescriptor:\n        o << \"SType::SharedFenceDXGISharedHandleDescriptor\";\n        break;\n      case SType::SharedFenceDXGISharedHandleExportInfo:\n        o << \"SType::SharedFenceDXGISharedHandleExportInfo\";\n        break;\n      case SType::SharedFenceMTLSharedEventDescriptor:\n        o << \"SType::SharedFenceMTLSharedEventDescriptor\";\n        break;\n      case SType::SharedFenceMTLSharedEventExportInfo:\n        o << \"SType::SharedFenceMTLSharedEventExportInfo\";\n        break;\n      case SType::SharedBufferMemoryD3D12ResourceDescriptor:\n        o << \"SType::SharedBufferMemoryD3D12ResourceDescriptor\";\n        break;\n      case SType::StaticSamplerBindingLayout:\n        o << \"SType::StaticSamplerBindingLayout\";\n        break;\n      case SType::YCbCrVkDescriptor:\n        o << \"SType::YCbCrVkDescriptor\";\n        break;\n      case SType::SharedTextureMemoryAHardwareBufferProperties:\n        o << \"SType::SharedTextureMemoryAHardwareBufferProperties\";\n        break;\n      case SType::AHardwareBufferProperties:\n        o << \"SType::AHardwareBufferProperties\";\n        break;\n      case SType::DawnExperimentalImmediateDataLimits:\n        o << \"SType::DawnExperimentalImmediateDataLimits\";\n        break;\n      case SType::DawnTexelCopyBufferRowAlignmentLimits:\n        o << \"SType::DawnTexelCopyBufferRowAlignmentLimits\";\n        break;\n          default:\n            o << \"SType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SamplerBindingType value) {\n      switch (value) {\n      case SamplerBindingType::BindingNotUsed:\n        o << \"SamplerBindingType::BindingNotUsed\";\n        break;\n      case SamplerBindingType::Filtering:\n        o << \"SamplerBindingType::Filtering\";\n        break;\n      case SamplerBindingType::NonFiltering:\n        o << \"SamplerBindingType::NonFiltering\";\n        break;\n      case SamplerBindingType::Comparison:\n        o << \"SamplerBindingType::Comparison\";\n        break;\n          default:\n            o << \"SamplerBindingType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SamplerBindingType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SharedFenceType value) {\n      switch (value) {\n      case SharedFenceType::VkSemaphoreOpaqueFD:\n        o << \"SharedFenceType::VkSemaphoreOpaqueFD\";\n        break;\n      case SharedFenceType::SyncFD:\n        o << \"SharedFenceType::SyncFD\";\n        break;\n      case SharedFenceType::VkSemaphoreZirconHandle:\n        o << \"SharedFenceType::VkSemaphoreZirconHandle\";\n        break;\n      case SharedFenceType::DXGISharedHandle:\n        o << \"SharedFenceType::DXGISharedHandle\";\n        break;\n      case SharedFenceType::MTLSharedEvent:\n        o << \"SharedFenceType::MTLSharedEvent\";\n        break;\n          default:\n            o << \"SharedFenceType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SharedFenceType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, Status value) {\n      switch (value) {\n      case Status::Success:\n        o << \"Status::Success\";\n        break;\n      case Status::Error:\n        o << \"Status::Error\";\n        break;\n          default:\n            o << \"Status::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<Status>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StencilOperation value) {\n      switch (value) {\n      case StencilOperation::Undefined:\n        o << \"StencilOperation::Undefined\";\n        break;\n      case StencilOperation::Keep:\n        o << \"StencilOperation::Keep\";\n        break;\n      case StencilOperation::Zero:\n        o << \"StencilOperation::Zero\";\n        break;\n      case StencilOperation::Replace:\n        o << \"StencilOperation::Replace\";\n        break;\n      case StencilOperation::Invert:\n        o << \"StencilOperation::Invert\";\n        break;\n      case StencilOperation::IncrementClamp:\n        o << \"StencilOperation::IncrementClamp\";\n        break;\n      case StencilOperation::DecrementClamp:\n        o << \"StencilOperation::DecrementClamp\";\n        break;\n      case StencilOperation::IncrementWrap:\n        o << \"StencilOperation::IncrementWrap\";\n        break;\n      case StencilOperation::DecrementWrap:\n        o << \"StencilOperation::DecrementWrap\";\n        break;\n          default:\n            o << \"StencilOperation::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StencilOperation>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StorageTextureAccess value) {\n      switch (value) {\n      case StorageTextureAccess::BindingNotUsed:\n        o << \"StorageTextureAccess::BindingNotUsed\";\n        break;\n      case StorageTextureAccess::WriteOnly:\n        o << \"StorageTextureAccess::WriteOnly\";\n        break;\n      case StorageTextureAccess::ReadOnly:\n        o << \"StorageTextureAccess::ReadOnly\";\n        break;\n      case StorageTextureAccess::ReadWrite:\n        o << \"StorageTextureAccess::ReadWrite\";\n        break;\n          default:\n            o << \"StorageTextureAccess::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StorageTextureAccess>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StoreOp value) {\n      switch (value) {\n      case StoreOp::Undefined:\n        o << \"StoreOp::Undefined\";\n        break;\n      case StoreOp::Store:\n        o << \"StoreOp::Store\";\n        break;\n      case StoreOp::Discard:\n        o << \"StoreOp::Discard\";\n        break;\n          default:\n            o << \"StoreOp::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<StoreOp>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, SurfaceGetCurrentTextureStatus value) {\n      switch (value) {\n      case SurfaceGetCurrentTextureStatus::Success:\n        o << \"SurfaceGetCurrentTextureStatus::Success\";\n        break;\n      case SurfaceGetCurrentTextureStatus::Timeout:\n        o << \"SurfaceGetCurrentTextureStatus::Timeout\";\n        break;\n      case SurfaceGetCurrentTextureStatus::Outdated:\n        o << \"SurfaceGetCurrentTextureStatus::Outdated\";\n        break;\n      case SurfaceGetCurrentTextureStatus::Lost:\n        o << \"SurfaceGetCurrentTextureStatus::Lost\";\n        break;\n      case SurfaceGetCurrentTextureStatus::OutOfMemory:\n        o << \"SurfaceGetCurrentTextureStatus::OutOfMemory\";\n        break;\n      case SurfaceGetCurrentTextureStatus::DeviceLost:\n        o << \"SurfaceGetCurrentTextureStatus::DeviceLost\";\n        break;\n      case SurfaceGetCurrentTextureStatus::Error:\n        o << \"SurfaceGetCurrentTextureStatus::Error\";\n        break;\n          default:\n            o << \"SurfaceGetCurrentTextureStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<SurfaceGetCurrentTextureStatus>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureAspect value) {\n      switch (value) {\n      case TextureAspect::Undefined:\n        o << \"TextureAspect::Undefined\";\n        break;\n      case TextureAspect::All:\n        o << \"TextureAspect::All\";\n        break;\n      case TextureAspect::StencilOnly:\n        o << \"TextureAspect::StencilOnly\";\n        break;\n      case TextureAspect::DepthOnly:\n        o << \"TextureAspect::DepthOnly\";\n        break;\n      case TextureAspect::Plane0Only:\n        o << \"TextureAspect::Plane0Only\";\n        break;\n      case TextureAspect::Plane1Only:\n        o << \"TextureAspect::Plane1Only\";\n        break;\n      case TextureAspect::Plane2Only:\n        o << \"TextureAspect::Plane2Only\";\n        break;\n          default:\n            o << \"TextureAspect::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureAspect>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureDimension value) {\n      switch (value) {\n      case TextureDimension::Undefined:\n        o << \"TextureDimension::Undefined\";\n        break;\n      case TextureDimension::e1D:\n        o << \"TextureDimension::e1D\";\n        break;\n      case TextureDimension::e2D:\n        o << \"TextureDimension::e2D\";\n        break;\n      case TextureDimension::e3D:\n        o << \"TextureDimension::e3D\";\n        break;\n          default:\n            o << \"TextureDimension::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureDimension>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureFormat value) {\n      switch (value) {\n      case TextureFormat::Undefined:\n        o << \"TextureFormat::Undefined\";\n        break;\n      case TextureFormat::R8Unorm:\n        o << \"TextureFormat::R8Unorm\";\n        break;\n      case TextureFormat::R8Snorm:\n        o << \"TextureFormat::R8Snorm\";\n        break;\n      case TextureFormat::R8Uint:\n        o << \"TextureFormat::R8Uint\";\n        break;\n      case TextureFormat::R8Sint:\n        o << \"TextureFormat::R8Sint\";\n        break;\n      case TextureFormat::R16Uint:\n        o << \"TextureFormat::R16Uint\";\n        break;\n      case TextureFormat::R16Sint:\n        o << \"TextureFormat::R16Sint\";\n        break;\n      case TextureFormat::R16Float:\n        o << \"TextureFormat::R16Float\";\n        break;\n      case TextureFormat::RG8Unorm:\n        o << \"TextureFormat::RG8Unorm\";\n        break;\n      case TextureFormat::RG8Snorm:\n        o << \"TextureFormat::RG8Snorm\";\n        break;\n      case TextureFormat::RG8Uint:\n        o << \"TextureFormat::RG8Uint\";\n        break;\n      case TextureFormat::RG8Sint:\n        o << \"TextureFormat::RG8Sint\";\n        break;\n      case TextureFormat::R32Float:\n        o << \"TextureFormat::R32Float\";\n        break;\n      case TextureFormat::R32Uint:\n        o << \"TextureFormat::R32Uint\";\n        break;\n      case TextureFormat::R32Sint:\n        o << \"TextureFormat::R32Sint\";\n        break;\n      case TextureFormat::RG16Uint:\n        o << \"TextureFormat::RG16Uint\";\n        break;\n      case TextureFormat::RG16Sint:\n        o << \"TextureFormat::RG16Sint\";\n        break;\n      case TextureFormat::RG16Float:\n        o << \"TextureFormat::RG16Float\";\n        break;\n      case TextureFormat::RGBA8Unorm:\n        o << \"TextureFormat::RGBA8Unorm\";\n        break;\n      case TextureFormat::RGBA8UnormSrgb:\n        o << \"TextureFormat::RGBA8UnormSrgb\";\n        break;\n      case TextureFormat::RGBA8Snorm:\n        o << \"TextureFormat::RGBA8Snorm\";\n        break;\n      case TextureFormat::RGBA8Uint:\n        o << \"TextureFormat::RGBA8Uint\";\n        break;\n      case TextureFormat::RGBA8Sint:\n        o << \"TextureFormat::RGBA8Sint\";\n        break;\n      case TextureFormat::BGRA8Unorm:\n        o << \"TextureFormat::BGRA8Unorm\";\n        break;\n      case TextureFormat::BGRA8UnormSrgb:\n        o << \"TextureFormat::BGRA8UnormSrgb\";\n        break;\n      case TextureFormat::RGB10A2Uint:\n        o << \"TextureFormat::RGB10A2Uint\";\n        break;\n      case TextureFormat::RGB10A2Unorm:\n        o << \"TextureFormat::RGB10A2Unorm\";\n        break;\n      case TextureFormat::RG11B10Ufloat:\n        o << \"TextureFormat::RG11B10Ufloat\";\n        break;\n      case TextureFormat::RGB9E5Ufloat:\n        o << \"TextureFormat::RGB9E5Ufloat\";\n        break;\n      case TextureFormat::RG32Float:\n        o << \"TextureFormat::RG32Float\";\n        break;\n      case TextureFormat::RG32Uint:\n        o << \"TextureFormat::RG32Uint\";\n        break;\n      case TextureFormat::RG32Sint:\n        o << \"TextureFormat::RG32Sint\";\n        break;\n      case TextureFormat::RGBA16Uint:\n        o << \"TextureFormat::RGBA16Uint\";\n        break;\n      case TextureFormat::RGBA16Sint:\n        o << \"TextureFormat::RGBA16Sint\";\n        break;\n      case TextureFormat::RGBA16Float:\n        o << \"TextureFormat::RGBA16Float\";\n        break;\n      case TextureFormat::RGBA32Float:\n        o << \"TextureFormat::RGBA32Float\";\n        break;\n      case TextureFormat::RGBA32Uint:\n        o << \"TextureFormat::RGBA32Uint\";\n        break;\n      case TextureFormat::RGBA32Sint:\n        o << \"TextureFormat::RGBA32Sint\";\n        break;\n      case TextureFormat::Stencil8:\n        o << \"TextureFormat::Stencil8\";\n        break;\n      case TextureFormat::Depth16Unorm:\n        o << \"TextureFormat::Depth16Unorm\";\n        break;\n      case TextureFormat::Depth24Plus:\n        o << \"TextureFormat::Depth24Plus\";\n        break;\n      case TextureFormat::Depth24PlusStencil8:\n        o << \"TextureFormat::Depth24PlusStencil8\";\n        break;\n      case TextureFormat::Depth32Float:\n        o << \"TextureFormat::Depth32Float\";\n        break;\n      case TextureFormat::Depth32FloatStencil8:\n        o << \"TextureFormat::Depth32FloatStencil8\";\n        break;\n      case TextureFormat::BC1RGBAUnorm:\n        o << \"TextureFormat::BC1RGBAUnorm\";\n        break;\n      case TextureFormat::BC1RGBAUnormSrgb:\n        o << \"TextureFormat::BC1RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC2RGBAUnorm:\n        o << \"TextureFormat::BC2RGBAUnorm\";\n        break;\n      case TextureFormat::BC2RGBAUnormSrgb:\n        o << \"TextureFormat::BC2RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC3RGBAUnorm:\n        o << \"TextureFormat::BC3RGBAUnorm\";\n        break;\n      case TextureFormat::BC3RGBAUnormSrgb:\n        o << \"TextureFormat::BC3RGBAUnormSrgb\";\n        break;\n      case TextureFormat::BC4RUnorm:\n        o << \"TextureFormat::BC4RUnorm\";\n        break;\n      case TextureFormat::BC4RSnorm:\n        o << \"TextureFormat::BC4RSnorm\";\n        break;\n      case TextureFormat::BC5RGUnorm:\n        o << \"TextureFormat::BC5RGUnorm\";\n        break;\n      case TextureFormat::BC5RGSnorm:\n        o << \"TextureFormat::BC5RGSnorm\";\n        break;\n      case TextureFormat::BC6HRGBUfloat:\n        o << \"TextureFormat::BC6HRGBUfloat\";\n        break;\n      case TextureFormat::BC6HRGBFloat:\n        o << \"TextureFormat::BC6HRGBFloat\";\n        break;\n      case TextureFormat::BC7RGBAUnorm:\n        o << \"TextureFormat::BC7RGBAUnorm\";\n        break;\n      case TextureFormat::BC7RGBAUnormSrgb:\n        o << \"TextureFormat::BC7RGBAUnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGB8Unorm:\n        o << \"TextureFormat::ETC2RGB8Unorm\";\n        break;\n      case TextureFormat::ETC2RGB8UnormSrgb:\n        o << \"TextureFormat::ETC2RGB8UnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGB8A1Unorm:\n        o << \"TextureFormat::ETC2RGB8A1Unorm\";\n        break;\n      case TextureFormat::ETC2RGB8A1UnormSrgb:\n        o << \"TextureFormat::ETC2RGB8A1UnormSrgb\";\n        break;\n      case TextureFormat::ETC2RGBA8Unorm:\n        o << \"TextureFormat::ETC2RGBA8Unorm\";\n        break;\n      case TextureFormat::ETC2RGBA8UnormSrgb:\n        o << \"TextureFormat::ETC2RGBA8UnormSrgb\";\n        break;\n      case TextureFormat::EACR11Unorm:\n        o << \"TextureFormat::EACR11Unorm\";\n        break;\n      case TextureFormat::EACR11Snorm:\n        o << \"TextureFormat::EACR11Snorm\";\n        break;\n      case TextureFormat::EACRG11Unorm:\n        o << \"TextureFormat::EACRG11Unorm\";\n        break;\n      case TextureFormat::EACRG11Snorm:\n        o << \"TextureFormat::EACRG11Snorm\";\n        break;\n      case TextureFormat::ASTC4x4Unorm:\n        o << \"TextureFormat::ASTC4x4Unorm\";\n        break;\n      case TextureFormat::ASTC4x4UnormSrgb:\n        o << \"TextureFormat::ASTC4x4UnormSrgb\";\n        break;\n      case TextureFormat::ASTC5x4Unorm:\n        o << \"TextureFormat::ASTC5x4Unorm\";\n        break;\n      case TextureFormat::ASTC5x4UnormSrgb:\n        o << \"TextureFormat::ASTC5x4UnormSrgb\";\n        break;\n      case TextureFormat::ASTC5x5Unorm:\n        o << \"TextureFormat::ASTC5x5Unorm\";\n        break;\n      case TextureFormat::ASTC5x5UnormSrgb:\n        o << \"TextureFormat::ASTC5x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC6x5Unorm:\n        o << \"TextureFormat::ASTC6x5Unorm\";\n        break;\n      case TextureFormat::ASTC6x5UnormSrgb:\n        o << \"TextureFormat::ASTC6x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC6x6Unorm:\n        o << \"TextureFormat::ASTC6x6Unorm\";\n        break;\n      case TextureFormat::ASTC6x6UnormSrgb:\n        o << \"TextureFormat::ASTC6x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x5Unorm:\n        o << \"TextureFormat::ASTC8x5Unorm\";\n        break;\n      case TextureFormat::ASTC8x5UnormSrgb:\n        o << \"TextureFormat::ASTC8x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x6Unorm:\n        o << \"TextureFormat::ASTC8x6Unorm\";\n        break;\n      case TextureFormat::ASTC8x6UnormSrgb:\n        o << \"TextureFormat::ASTC8x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC8x8Unorm:\n        o << \"TextureFormat::ASTC8x8Unorm\";\n        break;\n      case TextureFormat::ASTC8x8UnormSrgb:\n        o << \"TextureFormat::ASTC8x8UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x5Unorm:\n        o << \"TextureFormat::ASTC10x5Unorm\";\n        break;\n      case TextureFormat::ASTC10x5UnormSrgb:\n        o << \"TextureFormat::ASTC10x5UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x6Unorm:\n        o << \"TextureFormat::ASTC10x6Unorm\";\n        break;\n      case TextureFormat::ASTC10x6UnormSrgb:\n        o << \"TextureFormat::ASTC10x6UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x8Unorm:\n        o << \"TextureFormat::ASTC10x8Unorm\";\n        break;\n      case TextureFormat::ASTC10x8UnormSrgb:\n        o << \"TextureFormat::ASTC10x8UnormSrgb\";\n        break;\n      case TextureFormat::ASTC10x10Unorm:\n        o << \"TextureFormat::ASTC10x10Unorm\";\n        break;\n      case TextureFormat::ASTC10x10UnormSrgb:\n        o << \"TextureFormat::ASTC10x10UnormSrgb\";\n        break;\n      case TextureFormat::ASTC12x10Unorm:\n        o << \"TextureFormat::ASTC12x10Unorm\";\n        break;\n      case TextureFormat::ASTC12x10UnormSrgb:\n        o << \"TextureFormat::ASTC12x10UnormSrgb\";\n        break;\n      case TextureFormat::ASTC12x12Unorm:\n        o << \"TextureFormat::ASTC12x12Unorm\";\n        break;\n      case TextureFormat::ASTC12x12UnormSrgb:\n        o << \"TextureFormat::ASTC12x12UnormSrgb\";\n        break;\n      case TextureFormat::R16Unorm:\n        o << \"TextureFormat::R16Unorm\";\n        break;\n      case TextureFormat::RG16Unorm:\n        o << \"TextureFormat::RG16Unorm\";\n        break;\n      case TextureFormat::RGBA16Unorm:\n        o << \"TextureFormat::RGBA16Unorm\";\n        break;\n      case TextureFormat::R16Snorm:\n        o << \"TextureFormat::R16Snorm\";\n        break;\n      case TextureFormat::RG16Snorm:\n        o << \"TextureFormat::RG16Snorm\";\n        break;\n      case TextureFormat::RGBA16Snorm:\n        o << \"TextureFormat::RGBA16Snorm\";\n        break;\n      case TextureFormat::R8BG8Biplanar420Unorm:\n        o << \"TextureFormat::R8BG8Biplanar420Unorm\";\n        break;\n      case TextureFormat::R10X6BG10X6Biplanar420Unorm:\n        o << \"TextureFormat::R10X6BG10X6Biplanar420Unorm\";\n        break;\n      case TextureFormat::R8BG8A8Triplanar420Unorm:\n        o << \"TextureFormat::R8BG8A8Triplanar420Unorm\";\n        break;\n      case TextureFormat::R8BG8Biplanar422Unorm:\n        o << \"TextureFormat::R8BG8Biplanar422Unorm\";\n        break;\n      case TextureFormat::R8BG8Biplanar444Unorm:\n        o << \"TextureFormat::R8BG8Biplanar444Unorm\";\n        break;\n      case TextureFormat::R10X6BG10X6Biplanar422Unorm:\n        o << \"TextureFormat::R10X6BG10X6Biplanar422Unorm\";\n        break;\n      case TextureFormat::R10X6BG10X6Biplanar444Unorm:\n        o << \"TextureFormat::R10X6BG10X6Biplanar444Unorm\";\n        break;\n      case TextureFormat::External:\n        o << \"TextureFormat::External\";\n        break;\n          default:\n            o << \"TextureFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureSampleType value) {\n      switch (value) {\n      case TextureSampleType::BindingNotUsed:\n        o << \"TextureSampleType::BindingNotUsed\";\n        break;\n      case TextureSampleType::Float:\n        o << \"TextureSampleType::Float\";\n        break;\n      case TextureSampleType::UnfilterableFloat:\n        o << \"TextureSampleType::UnfilterableFloat\";\n        break;\n      case TextureSampleType::Depth:\n        o << \"TextureSampleType::Depth\";\n        break;\n      case TextureSampleType::Sint:\n        o << \"TextureSampleType::Sint\";\n        break;\n      case TextureSampleType::Uint:\n        o << \"TextureSampleType::Uint\";\n        break;\n          default:\n            o << \"TextureSampleType::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureSampleType>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureViewDimension value) {\n      switch (value) {\n      case TextureViewDimension::Undefined:\n        o << \"TextureViewDimension::Undefined\";\n        break;\n      case TextureViewDimension::e1D:\n        o << \"TextureViewDimension::e1D\";\n        break;\n      case TextureViewDimension::e2D:\n        o << \"TextureViewDimension::e2D\";\n        break;\n      case TextureViewDimension::e2DArray:\n        o << \"TextureViewDimension::e2DArray\";\n        break;\n      case TextureViewDimension::Cube:\n        o << \"TextureViewDimension::Cube\";\n        break;\n      case TextureViewDimension::CubeArray:\n        o << \"TextureViewDimension::CubeArray\";\n        break;\n      case TextureViewDimension::e3D:\n        o << \"TextureViewDimension::e3D\";\n        break;\n          default:\n            o << \"TextureViewDimension::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureViewDimension>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, VertexFormat value) {\n      switch (value) {\n      case VertexFormat::Uint8:\n        o << \"VertexFormat::Uint8\";\n        break;\n      case VertexFormat::Uint8x2:\n        o << \"VertexFormat::Uint8x2\";\n        break;\n      case VertexFormat::Uint8x4:\n        o << \"VertexFormat::Uint8x4\";\n        break;\n      case VertexFormat::Sint8:\n        o << \"VertexFormat::Sint8\";\n        break;\n      case VertexFormat::Sint8x2:\n        o << \"VertexFormat::Sint8x2\";\n        break;\n      case VertexFormat::Sint8x4:\n        o << \"VertexFormat::Sint8x4\";\n        break;\n      case VertexFormat::Unorm8:\n        o << \"VertexFormat::Unorm8\";\n        break;\n      case VertexFormat::Unorm8x2:\n        o << \"VertexFormat::Unorm8x2\";\n        break;\n      case VertexFormat::Unorm8x4:\n        o << \"VertexFormat::Unorm8x4\";\n        break;\n      case VertexFormat::Snorm8:\n        o << \"VertexFormat::Snorm8\";\n        break;\n      case VertexFormat::Snorm8x2:\n        o << \"VertexFormat::Snorm8x2\";\n        break;\n      case VertexFormat::Snorm8x4:\n        o << \"VertexFormat::Snorm8x4\";\n        break;\n      case VertexFormat::Uint16:\n        o << \"VertexFormat::Uint16\";\n        break;\n      case VertexFormat::Uint16x2:\n        o << \"VertexFormat::Uint16x2\";\n        break;\n      case VertexFormat::Uint16x4:\n        o << \"VertexFormat::Uint16x4\";\n        break;\n      case VertexFormat::Sint16:\n        o << \"VertexFormat::Sint16\";\n        break;\n      case VertexFormat::Sint16x2:\n        o << \"VertexFormat::Sint16x2\";\n        break;\n      case VertexFormat::Sint16x4:\n        o << \"VertexFormat::Sint16x4\";\n        break;\n      case VertexFormat::Unorm16:\n        o << \"VertexFormat::Unorm16\";\n        break;\n      case VertexFormat::Unorm16x2:\n        o << \"VertexFormat::Unorm16x2\";\n        break;\n      case VertexFormat::Unorm16x4:\n        o << \"VertexFormat::Unorm16x4\";\n        break;\n      case VertexFormat::Snorm16:\n        o << \"VertexFormat::Snorm16\";\n        break;\n      case VertexFormat::Snorm16x2:\n        o << \"VertexFormat::Snorm16x2\";\n        break;\n      case VertexFormat::Snorm16x4:\n        o << \"VertexFormat::Snorm16x4\";\n        break;\n      case VertexFormat::Float16:\n        o << \"VertexFormat::Float16\";\n        break;\n      case VertexFormat::Float16x2:\n        o << \"VertexFormat::Float16x2\";\n        break;\n      case VertexFormat::Float16x4:\n        o << \"VertexFormat::Float16x4\";\n        break;\n      case VertexFormat::Float32:\n        o << \"VertexFormat::Float32\";\n        break;\n      case VertexFormat::Float32x2:\n        o << \"VertexFormat::Float32x2\";\n        break;\n      case VertexFormat::Float32x3:\n        o << \"VertexFormat::Float32x3\";\n        break;\n      case VertexFormat::Float32x4:\n        o << \"VertexFormat::Float32x4\";\n        break;\n      case VertexFormat::Uint32:\n        o << \"VertexFormat::Uint32\";\n        break;\n      case VertexFormat::Uint32x2:\n        o << \"VertexFormat::Uint32x2\";\n        break;\n      case VertexFormat::Uint32x3:\n        o << \"VertexFormat::Uint32x3\";\n        break;\n      case VertexFormat::Uint32x4:\n        o << \"VertexFormat::Uint32x4\";\n        break;\n      case VertexFormat::Sint32:\n        o << \"VertexFormat::Sint32\";\n        break;\n      case VertexFormat::Sint32x2:\n        o << \"VertexFormat::Sint32x2\";\n        break;\n      case VertexFormat::Sint32x3:\n        o << \"VertexFormat::Sint32x3\";\n        break;\n      case VertexFormat::Sint32x4:\n        o << \"VertexFormat::Sint32x4\";\n        break;\n      case VertexFormat::Unorm10_10_10_2:\n        o << \"VertexFormat::Unorm10_10_10_2\";\n        break;\n      case VertexFormat::Unorm8x4BGRA:\n        o << \"VertexFormat::Unorm8x4BGRA\";\n        break;\n          default:\n            o << \"VertexFormat::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<VertexFormat>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, VertexStepMode value) {\n      switch (value) {\n      case VertexStepMode::VertexBufferNotUsed:\n        o << \"VertexStepMode::VertexBufferNotUsed\";\n        break;\n      case VertexStepMode::Undefined:\n        o << \"VertexStepMode::Undefined\";\n        break;\n      case VertexStepMode::Vertex:\n        o << \"VertexStepMode::Vertex\";\n        break;\n      case VertexStepMode::Instance:\n        o << \"VertexStepMode::Instance\";\n        break;\n          default:\n            o << \"VertexStepMode::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<VertexStepMode>::type>(value);\n      }\n      return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, WaitStatus value) {\n      switch (value) {\n      case WaitStatus::Success:\n        o << \"WaitStatus::Success\";\n        break;\n      case WaitStatus::TimedOut:\n        o << \"WaitStatus::TimedOut\";\n        break;\n      case WaitStatus::UnsupportedTimeout:\n        o << \"WaitStatus::UnsupportedTimeout\";\n        break;\n      case WaitStatus::UnsupportedCount:\n        o << \"WaitStatus::UnsupportedCount\";\n        break;\n      case WaitStatus::UnsupportedMixedSources:\n        o << \"WaitStatus::UnsupportedMixedSources\";\n        break;\n      case WaitStatus::Unknown:\n        o << \"WaitStatus::Unknown\";\n        break;\n          default:\n            o << \"WaitStatus::\" << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<WaitStatus>::type>(value);\n      }\n      return o;\n  }\n\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, BufferUsage value) {\n    o << \"BufferUsage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & BufferUsage::MapRead) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"MapRead\";\n    value &= ~BufferUsage::MapRead;\n  }\n  if (value & BufferUsage::MapWrite) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"MapWrite\";\n    value &= ~BufferUsage::MapWrite;\n  }\n  if (value & BufferUsage::CopySrc) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopySrc\";\n    value &= ~BufferUsage::CopySrc;\n  }\n  if (value & BufferUsage::CopyDst) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopyDst\";\n    value &= ~BufferUsage::CopyDst;\n  }\n  if (value & BufferUsage::Index) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Index\";\n    value &= ~BufferUsage::Index;\n  }\n  if (value & BufferUsage::Vertex) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Vertex\";\n    value &= ~BufferUsage::Vertex;\n  }\n  if (value & BufferUsage::Uniform) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Uniform\";\n    value &= ~BufferUsage::Uniform;\n  }\n  if (value & BufferUsage::Storage) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Storage\";\n    value &= ~BufferUsage::Storage;\n  }\n  if (value & BufferUsage::Indirect) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Indirect\";\n    value &= ~BufferUsage::Indirect;\n  }\n  if (value & BufferUsage::QueryResolve) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"QueryResolve\";\n    value &= ~BufferUsage::QueryResolve;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<BufferUsage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ColorWriteMask value) {\n    o << \"ColorWriteMask::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & ColorWriteMask::Red) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Red\";\n    value &= ~ColorWriteMask::Red;\n  }\n  if (value & ColorWriteMask::Green) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Green\";\n    value &= ~ColorWriteMask::Green;\n  }\n  if (value & ColorWriteMask::Blue) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Blue\";\n    value &= ~ColorWriteMask::Blue;\n  }\n  if (value & ColorWriteMask::Alpha) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Alpha\";\n    value &= ~ColorWriteMask::Alpha;\n  }\n  if (value & ColorWriteMask::All) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"All\";\n    value &= ~ColorWriteMask::All;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ColorWriteMask>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, HeapProperty value) {\n    o << \"HeapProperty::\";\n    if (!static_cast<bool>(value)) {\n    o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << 0;\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & HeapProperty::DeviceLocal) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"DeviceLocal\";\n    value &= ~HeapProperty::DeviceLocal;\n  }\n  if (value & HeapProperty::HostVisible) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"HostVisible\";\n    value &= ~HeapProperty::HostVisible;\n  }\n  if (value & HeapProperty::HostCoherent) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"HostCoherent\";\n    value &= ~HeapProperty::HostCoherent;\n  }\n  if (value & HeapProperty::HostUncached) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"HostUncached\";\n    value &= ~HeapProperty::HostUncached;\n  }\n  if (value & HeapProperty::HostCached) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"HostCached\";\n    value &= ~HeapProperty::HostCached;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<HeapProperty>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, MapMode value) {\n    o << \"MapMode::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & MapMode::Read) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Read\";\n    value &= ~MapMode::Read;\n  }\n  if (value & MapMode::Write) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Write\";\n    value &= ~MapMode::Write;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<MapMode>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, ShaderStage value) {\n    o << \"ShaderStage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & ShaderStage::Vertex) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Vertex\";\n    value &= ~ShaderStage::Vertex;\n  }\n  if (value & ShaderStage::Fragment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Fragment\";\n    value &= ~ShaderStage::Fragment;\n  }\n  if (value & ShaderStage::Compute) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"Compute\";\n    value &= ~ShaderStage::Compute;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<ShaderStage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, TextureUsage value) {\n    o << \"TextureUsage::\";\n    if (!static_cast<bool>(value)) {\n    // 0 is often explicitly declared as None.\n    o << \"None\";\n      return o;\n    }\n\n    bool moreThanOneBit = !HasZeroOrOneBits(value);\n    if (moreThanOneBit) {\n      o << \"(\";\n    }\n\n    bool first = true;\n  if (value & TextureUsage::CopySrc) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopySrc\";\n    value &= ~TextureUsage::CopySrc;\n  }\n  if (value & TextureUsage::CopyDst) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"CopyDst\";\n    value &= ~TextureUsage::CopyDst;\n  }\n  if (value & TextureUsage::TextureBinding) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"TextureBinding\";\n    value &= ~TextureUsage::TextureBinding;\n  }\n  if (value & TextureUsage::StorageBinding) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"StorageBinding\";\n    value &= ~TextureUsage::StorageBinding;\n  }\n  if (value & TextureUsage::RenderAttachment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"RenderAttachment\";\n    value &= ~TextureUsage::RenderAttachment;\n  }\n  if (value & TextureUsage::TransientAttachment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"TransientAttachment\";\n    value &= ~TextureUsage::TransientAttachment;\n  }\n  if (value & TextureUsage::StorageAttachment) {\n    if (!first) {\n      o << \"|\";\n    }\n    first = false;\n    o << \"StorageAttachment\";\n    value &= ~TextureUsage::StorageAttachment;\n  }\n\n    if (static_cast<bool>(value)) {\n      if (!first) {\n        o << \"|\";\n      }\n      o << std::showbase << std::hex << std::setfill('0') << std::setw(4) << static_cast<typename std::underlying_type<TextureUsage>::type>(value);\n    }\n\n    if (moreThanOneBit) {\n      o << \")\";\n    }\n    return o;\n  }\n\n  template <typename CharT, typename Traits>\n  std::basic_ostream<CharT, Traits>& operator<<(std::basic_ostream<CharT, Traits>& o, StringView value) {\n      o << std::string_view(value);\n      return o;\n  }\n\n}  // namespace wgpu\n\n#endif // WEBGPU_CPP_PRINT_H_\n", "include/webgpu/webgpu_cpp_chained_struct.h": "// Copyright 2023 The Dawn & Tint Authors\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#ifdef __EMSCRIPTEN__\n#error \"Do not include this header. Emscripten already provides headers needed for WebGPU.\"\n#endif\n\n#ifndef WEBGPU_CPP_CHAINED_STRUCT_H_\n#define WEBGPU_CPP_CHAINED_STRUCT_H_\n\n#include <cstddef>\n#include <cstdint>\n\n// This header file declares the ChainedStruct structures separately from the WebGPU\n// headers so that dependencies can directly extend structures without including the larger header\n// which exposes capabilities that may require correctly set proc tables.\nnamespace wgpu {\n\n    enum class SType : uint32_t;\n\n    struct ChainedStruct {\n        ChainedStruct const * nextInChain = nullptr;\n        SType sType = SType(0u);\n    };\n\n    struct ChainedStructOut {\n        ChainedStructOut * nextInChain = nullptr;\n        SType sType = SType(0u);\n    };\n\n}  // namespace wgpu}\n\n#endif // WEBGPU_CPP_CHAINED_STRUCT_H_\n"}